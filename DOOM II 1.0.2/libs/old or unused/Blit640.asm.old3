;-----------------------------------------------------------------------------;	Blit640;;	Assembly function that blits "screen[0]" to 640 x 400.;-----------------------------------------------------------------------------	CASE ONBlit640Byte PROC EXPORT;;	void Blit640Byte (void *src, void *dst, long rowBytes, void *remapper);;	link			A6,#0		movem.l			A0-A3/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		A2 = 2ndDstPtr	;		A3 = remap array	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register		move.l		8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3	movea.l		20(A6),A3	move.l		A1,A2	add.l		D3,A2	sub.l		#640,D3		move.l		#199,D0				; 200 rows@RowLoop	move.l		#39,D1				; 40 * 16 = 640	moveq.l		#0,D2@ColLoop	; 8 output bytes per row		move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,(A1)+	move.b		D2,(A1)+	move.b		D2,(A2)+	move.b		D2,(A2)+		move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,(A1)+	move.b		D2,(A1)+	move.b		D2,(A2)+	move.b		D2,(A2)+	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,(A1)+	move.b		D2,(A1)+	move.b		D2,(A2)+	move.b		D2,(A2)+	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,(A1)+	move.b		D2,(A1)+	move.b		D2,(A2)+	move.b		D2,(A2)+		; 8 output bytes per row		move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,(A1)+	move.b		D2,(A1)+	move.b		D2,(A2)+	move.b		D2,(A2)+		move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,(A1)+	move.b		D2,(A1)+	move.b		D2,(A2)+	move.b		D2,(A2)+	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,(A1)+	move.b		D2,(A1)+	move.b		D2,(A2)+	move.b		D2,(A2)+	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,(A1)+	move.b		D2,(A1)+	move.b		D2,(A2)+	move.b		D2,(A2)+		dbra		D1,@ColLoop		add.l		D3,A1	add.l		D3,A1	add.l		#640,A1	add.l		D3,A2	add.l		D3,A2	add.l		#640,A2		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A3/D0-D7	unlk		A6	rtsBlit640 PROC EXPORT;;	void Blit640 (void *src, void *dst, long rowBytes, void *remapper);;	link			A6,#0		movem.l			A0-A3/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		A2 = 2ndDstPtr	;		A3 = remap array	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register		move.l		8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3	movea.l		20(A6),A3	move.l		A1,A2	add.l		D3,A2	sub.l		#640,D3		move.l		#199,D0				; 200 rows@RowLoop	move.l		#39,D1				; 40 * 16 = 640@ColLoop	; 8 output bytes		move.l		(A0)+,D5	rol.l		#8,D5		moveq.l		#0,D2			; 4	move.b		D5,D2	rol.l		#8,D5	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	rol.l		#8,D4	move.b		D5,D2	rol.l		#8,D5	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	move.l		D4,(A1)+	move.l		D4,(A2)+		moveq.l		#0,D2			; 4	move.b		D5,D2	rol.l		#8,D5	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	rol.l		#8,D4	move.b		D5,D2	rol.l		#8,D5	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	move.l		D4,(A1)+	move.l		D4,(A2)+		; 8 output bytes		move.l		(A0)+,D5	rol.l		#8,D5	moveq.l		#0,D2			; 4	move.b		D5,D2	rol.l		#8,D5	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	rol.l		#8,D4	move.b		D5,D2	rol.l		#8,D5	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	move.l		D4,(A1)+	move.l		D4,(A2)+	moveq.l		#0,D2			; 4	move.b		D5,D2	rol.l		#8,D5	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	rol.l		#8,D4	move.b		D5,D2	rol.l		#8,D5	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	move.l		D4,(A1)+	move.l		D4,(A2)+		dbra		D1,@ColLoop		add.l		D3,A1	add.l		D3,A1	add.l		#640,A1	add.l		D3,A2	add.l		D3,A2	add.l		#640,A2		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A3/D0-D7	unlk		A6	rtsBlit640Skip PROC EXPORT;;	void Blit640Skip (void *src, void *dst, long rowBytes, void *remapper);;	link			A6,#0		movem.l			A0-A3/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count		move.l		8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3	move.l		20(A6),A3	sub.l		#640,D3		move.l		#199,D0				; 200 rows@RowLoop	move.l		#39,D1				; 40 * 16 = 640@ColLoop	; 8 output bytes		moveq.l		#0,D2			; 4	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	rol.l		#8,D4	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	move.l		D4,(A1)+		moveq.l		#0,D2			; 4	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	rol.l		#8,D4	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	move.l		D4,(A1)+		; 8 output bytes		moveq.l		#0,D2			; 4	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	rol.l		#8,D4	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	move.l		D4,(A1)+		moveq.l		#0,D2			; 4	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	rol.l		#8,D4	move.b		(A0)+,D2	move.b		(A3,D2.w),D2	move.b		D2,D4	rol.l		#8,D4	move.b		D2,D4	move.l		D4,(A1)+		dbra		D1,@ColLoop		add.l		D3,A1	add.l		D3,A1	add.l		#640,A1		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A3/D0-D7	unlk		A6	rts		end