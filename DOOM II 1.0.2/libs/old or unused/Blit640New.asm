	CASE ON	MACHINE MC68020;-----------------------------------------------AsmSwapLong PROC EXPORT	move.b			7(A7),D0	lsl.l			#8,D0	move.b			6(A7),D0	lsl.l			#8,D0	move.b			5(A7),D0	lsl.l			#8,D0	move.b			4(A7),D0	rts;-----------------------------------------------AsmSwapShort PROC EXPORT	move.b			5(A7),D0	lsl.l			#8,D0	move.b			4(A7),D0	rts;-----------------------------------------------Blit640SkipWidth PROC EXPORT;;	void Blit640SkipWidth (void *src, void *dst, long rowBytes, long rows, long width,;		long sourceSkip);;	link			A6,#0	movem.l			A0-A1/D0-D6,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register	;		D5 = Copy of long word column count		move.l		 8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3			; Row bytes	move.l		24(A6),D1			; columns wide		asl.l		#1,D3				; 2 rowbytes each pointer		asr.l		#2,D1				; convert "columns wide" to long words	move.l		D1,D6				; store a copy	subq.l		#1,D1				; minus one.	move.l		D1,D5				; store a copy		asl.l		#3,D6				; convert back to bytes * 2 (pixel-doubling)	sub.l		D6,D3				; 2 rowbytes - 1 byte-based column count		move.l		28(A6),D6			; sourceSkip		move.l		20(A6),D0			; Number of rows to do	subq.l		#1,D0				; minus one for "dbra"@RowLoop	move.l		D5,D1				; number of long words (source)@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		dbra		D1,@ColLoop		add.l		D3,A1			; Dest += Offset bytes	add.l		D6,A0			; src += sourceSkip		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A1/D0-D6	unlk		A6	rts;-----------------------------------------------BlitTable PROC EXPORT	dc.w		$0000,$0101,$0202,$0303,$0404,$0505,$0606,$0707	dc.w		$0808,$0909,$0A0A,$0B0B,$0C0C,$0D0D,$0E0E,$0F0F	dc.w		$1010,$1111,$1212,$1313,$1414,$1515,$1616,$1717	dc.w		$1818,$1919,$1A1A,$1B1B,$1C1C,$1D1D,$1E1E,$1F1F	dc.w		$2020,$2121,$2222,$2323,$2424,$2525,$2626,$2727	dc.w		$2828,$2929,$2A2A,$2B2B,$2C2C,$2D2D,$2E2E,$2F2F	dc.w		$3030,$3131,$3232,$3333,$3434,$3535,$3636,$3737	dc.w		$3838,$3939,$3A3A,$3B3B,$3C3C,$3D3D,$3E3E,$3F3F	dc.w		$4040,$4141,$4242,$4343,$4444,$4545,$4646,$4747	dc.w		$4848,$4949,$4A4A,$4B4B,$4C4C,$4D4D,$4E4E,$4F4F	dc.w		$5050,$5151,$5252,$5353,$5454,$5555,$5656,$5757	dc.w		$5858,$5959,$5A5A,$5B5B,$5C5C,$5D5D,$5E5E,$5F5F	dc.w		$6060,$6161,$6262,$6363,$6464,$6565,$6666,$6767	dc.w		$6868,$6969,$6A6A,$6B6B,$6C6C,$6D6D,$6E6E,$6F6F	dc.w		$7070,$7171,$7272,$7373,$7474,$7575,$7676,$7777	dc.w		$7878,$7979,$7A7A,$7B7B,$7C7C,$7D7D,$7E7E,$7F7F	dc.w		$8080,$8181,$8282,$8383,$8484,$8585,$8686,$8787	dc.w		$8888,$8989,$8A8A,$8B8B,$8C8C,$8D8D,$8E8E,$8F8F	dc.w		$9090,$9191,$9292,$9393,$9494,$9595,$9696,$9797	dc.w		$9898,$9999,$9A9A,$9B9B,$9C9C,$9D9D,$9E9E,$9F9F	dc.w		$A0A0,$A1A1,$A2A2,$A3A3,$A4A4,$A5A5,$A6A6,$A7A7	dc.w		$A8A8,$A9A9,$AAAA,$ABAB,$ACAC,$ADAD,$AEAE,$AFAF	dc.w		$B0B0,$B1B1,$B2B2,$B3B3,$B4B4,$B5B5,$B6B6,$B7B7	dc.w		$B8B8,$B9B9,$BABA,$BBBB,$BCBC,$BDBD,$BEBE,$BFBF	dc.w		$C0C0,$C1C1,$C2C2,$C3C3,$C4C4,$C5C5,$C6C6,$C7C7	dc.w		$C8C8,$C9C9,$CACA,$CBCB,$CCCC,$CDCD,$CECE,$CFCF	dc.w		$D0D0,$D1D1,$D2D2,$D3D3,$D4D4,$D5D5,$D6D6,$D7D7	dc.w		$D8D8,$D9D9,$DADA,$DBDB,$DCDC,$DDDD,$DEDE,$DFDF	dc.w		$E0E0,$E1E1,$E2E2,$E3E3,$E4E4,$E5E5,$E6E6,$E7E7	dc.w		$E8E8,$E9E9,$EAEA,$EBEB,$ECEC,$EDED,$EEEE,$EFEF	dc.w		$F0F0,$F1F1,$F2F2,$F3F3,$F4F4,$F5F5,$F6F6,$F7F7	dc.w		$F8F8,$F9F9,$FAFA,$FBFB,$FCFC,$FDFD,$FEFE,$FFFF	Blit640Width PROC EXPORT;;	void Blit640Width (void *src, void *dst, long rowBytes, long rows, long width,;		long sourceSkip);;	link			A6,#0	movem.l			A0-A2/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		A2 = 2ndDstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register	;		D5 = Copy of long word column count		move.l		 8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3			; Row bytes	move.l		24(A6),D1			; columns wide	move.l		A1,A2	adda.l		D3,A2				; add 1 full "rowbytes"		asl.l		#1,D3				; 2 rowbytes each pointer		asr.l		#2,D1				; convert "columns wide" to long words	move.l		D1,D6				; store a copy	subq.l		#1,D1				; minus one.	move.l		D1,D5				; store a copy		asl.l		#3,D6				; convert back to bytes * 2 (pixel-doubling)	sub.l		D6,D3				; 2 rowbytes - 1 byte-based column count		move.l		28(A6),D6			; sourceSkip		move.l		20(A6),D0			; Number of rows to do	subq.l		#1,D0				; minus one for "dbra"@RowLoop	move.l		D5,D1				; number of long words (source)@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+	move.l		D2,(A2)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+	move.l		D2,(A2)+		dbra		D1,@ColLoop		add.l		D3,A1			; Dest += Offset bytes	add.l		D3,A2	add.l		D6,A0			; src += sourceSkip		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A2/D0-D7	unlk		A6	rts;-----------------------------------------------Blit320Width PROC EXPORT;;	void Blit320Width (void *src, void *dst, long rowBytes, long rows, long width,;		long sourceSkip);;	; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col repeat count	;		D2 = row bytes	;		D3 = rows	;		D4 = source skip		link			A6,#0	movem.l			A0-A1/D0-D5,-(SP)		movea.l			8(A6),A0	movea.l			12(A6),A1	move.l			16(A6),D2			; row bytes	move.l			24(A6),D1			; columns wide	move.l			28(A6),D4			; source skip	sub.l			D1,D2				; row bytes - columns wide	asr.l			#2,D1	subq.l			#1,D1	move.l			D1,D5		move.l			20(A6),D0			; rows	subq.l			#1,D0@RowLoop	move.l			D5,D1	ble.s			@Done@ColLoop	move.l			(A0)+,(A1)+	dbra			D1,@ColLoop	adda.l			D4,A0			; source += sourceSkip	adda.l			D2,A1			; Point to next dest row	dbra			D0,@RowLoop@Done	movem.l			(SP)+,A0-A1/D0-D5	unlk			A6	rts;-----------------------------------------------Blit320 PROC EXPORT;;	void Blit320 (void *src, void *dst, long rowBytes, long rows);;	; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col repeat count	;		D2 = row bytes	;		D3-D6 = temp registers		link			A6,#0	movem.l			A0-A1/D0-D7,-(SP)		movea.l			8(A6),A0	movea.l			12(A6),A1		move.l			16(A6),D1	sub.l			#320,D1		move.l			20(A6),D0			; rows	subq.l			#1,D0@RowLoop	movem.l			D0-D1,-(SP)		movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(SP)+,D0-D1	adda.l			D1,A1			; Point to next dest row	dbra			D0,@RowLoop	movem.l			(SP)+,A0-A1/D0-D7	unlk			A6	rtsBlit640 PROC EXPORT;;	void Blit640 (void *src, void *dst, long rowBytes, long rows);;	link			A6,#0	movem.l			A0-A3/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		A2 = 2ndDstPtr	;		A3 = pointer to table	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register		move.l		8(A6),A0	move.l		12(A6),A1	lea			BlitTable,A3	move.l		16(A6),D3	move.l		A1,A2	add.l		D3,A2	asl.l		#1,D3	sub.l		#640,D3		move.l		20(A6),D0	subq.l		#1,D0@RowLoop	move.l		#39,D1				; 40 * 16 = 640@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+	move.l		D2,(A2)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+	move.l		D2,(A2)+		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+	move.l		D2,(A2)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+	move.l		D2,(A2)+		dbra		D1,@ColLoop		add.l		D3,A1	add.l		D3,A2		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A3/D0-D7	unlk		A6	rtsBlit640Skip PROC EXPORT;;	void Blit640Skip (void *src, void *dst, long rowBytes, long rows);;	link			A6,#0	movem.l			A0-A3/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register		move.l		8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3	sub.l		#640,D3		move.l		20(A6),D0	subq.l		#1,D0@RowLoop	move.l		#39,D1				; 40 * 16 = 640@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		dbra		D1,@ColLoop		add.l		D3,A1	add.l		D3,A1	add.l		#640,A1		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A3/D0-D7	unlk		A6	rts		end