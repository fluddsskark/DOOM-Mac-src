;-----------------------------------------------------------------------------;	Blit640;;	Assembly function that blits "screen[0]" to 640 x 400.;-----------------------------------------------------------------------------	CASE ON;-----------------------------------------------AsmSwapLong PROC EXPORT	move.b			7(A7),D0	lsl.l			#8,D0	move.b			6(A7),D0	lsl.l			#8,D0	move.b			5(A7),D0	lsl.l			#8,D0	move.b			4(A7),D0	rts;-----------------------------------------------AsmSwapShort PROC EXPORT	move.b			5(A7),D0	lsl.l			#8,D0	move.b			4(A7),D0	rts;-----------------------------------------------Blit640SkipWidth PROC EXPORT;;	void Blit640SkipWidth (void *src, void *dst, long rowBytes, long rows, long width,;		long sourceSkip);;	link			A6,#0	movem.l			A0-A1/D0-D6,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register	;		D5 = Copy of long word column count		move.l		 8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3			; Row bytes	move.l		24(A6),D1			; columns wide		asl.l		#1,D3				; 2 rowbytes each pointer		asr.l		#2,D1				; convert "columns wide" to long words	move.l		D1,D6				; store a copy	subq.l		#1,D1				; minus one.	move.l		D1,D5				; store a copy		asl.l		#3,D6				; convert back to bytes * 2 (pixel-doubling)	sub.l		D6,D3				; 2 rowbytes - 1 byte-based column count		move.l		28(A6),D6			; sourceSkip		move.l		20(A6),D0			; Number of rows to do	subq.l		#1,D0				; minus one for "dbra"@RowLoop	move.l		D5,D1				; number of long words (source)@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		dbra		D1,@ColLoop		add.l		D3,A1			; Dest += Offset bytes	add.l		D6,A0			; src += sourceSkip		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A1/D0-D6	unlk		A6	rts;-----------------------------------------------Blit640Width PROC EXPORT;;	void Blit640Width (void *src, void *dst, long rowBytes, long rows, long width,;		long sourceSkip);;	link			A6,#0	movem.l			A0-A3/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		A2 = 2ndDstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register	;		D5 = Copy of long word column count		move.l		 8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3			; Row bytes	move.l		24(A6),D1			; columns wide	move.l		A1,A2	adda.l		D3,A2				; add 1 full "rowbytes"		asl.l		#1,D3				; 2 rowbytes each pointer		asr.l		#2,D1				; convert "columns wide" to long words	move.l		D1,D6				; store a copy	subq.l		#1,D1				; minus one.	move.l		D1,D5				; store a copy		asl.l		#3,D6				; convert back to bytes * 2 (pixel-doubling)	sub.l		D6,D3				; 2 rowbytes - 1 byte-based column count		move.l		28(A6),D6			; sourceSkip		move.l		20(A6),D0			; Number of rows to do	subq.l		#1,D0				; minus one for "dbra"@RowLoop	move.l		D5,D1				; number of long words (source)@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+	move.l		D2,(A2)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+	move.l		D2,(A2)+		dbra		D1,@ColLoop		add.l		D3,A1			; Dest += Offset bytes	add.l		D3,A2	add.l		D6,A0			; src += sourceSkip		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A3/D0-D7	unlk		A6	rts;-----------------------------------------------Blit320Width PROC EXPORT;;	void Blit320Width (void *src, void *dst, long rowBytes, long rows, long width,;		long sourceSkip);;	; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col repeat count	;		D2 = row bytes	;		D3 = rows	;		D4 = source skip		link			A6,#0	movem.l			A0-A1/D0-D5,-(SP)		movea.l			8(A6),A0	movea.l			12(A6),A1	move.l			16(A6),D2			; row bytes	move.l			24(A6),D1			; columns wide	move.l			28(A6),D4			; source skip	sub.l			D1,D2				; row bytes - columns wide	asr.l			#2,D1	subq.l			#1,D1	move.l			D1,D5		move.l			20(A6),D0			; rows	subq.l			#1,D0@RowLoop	move.l			D5,D1	ble.s			@Done@ColLoop	move.l			(A0)+,(A1)+	dbra			D1,@ColLoop	adda.l			D4,A0			; source += sourceSkip	adda.l			D2,A1			; Point to next dest row	dbra			D0,@RowLoop@Done	movem.l			(SP)+,A0-A1/D0-D5	unlk			A6	rts;-----------------------------------------------Blit320 PROC EXPORT;;	void Blit320 (void *src, void *dst, long rowBytes, long rows);;	; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col repeat count	;		D2 = row bytes	;		D3-D6 = temp registers		link			A6,#0	movem.l			A0-A1/D0-D6,-(SP)		movea.l			8(A6),A0	movea.l			12(A6),A1		move.l			16(A6),D1	sub.l			#320,D1		move.l			20(A6),D0			; rows	subq.l			#1,D0@RowLoop	movem.l			D0-D1,-(SP)		movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(SP)+,D0-D1	adda.l			D1,A1			; Point to next dest row	dbra			D0,@RowLoop	movem.l			(SP)+,A0-A1/D0-D6	unlk			A6	rtsBlit640 PROC EXPORT;;	void Blit640 (void *src, void *dst, long rowBytes, long rows);;	link			A6,#0	movem.l			A0-A3/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		A2 = 2ndDstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register		move.l		8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3	move.l		A1,A2	add.l		D3,A2	sub.l		#640,D3		move.l		20(A6),D0	subq.l		#1,D0@RowLoop	move.l		#39,D1				; 40 * 16 = 640@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,(A1)	move.b		D4,(A2)	move.b		D4,1(A1)	move.b		D4,1(A2)	rol.l		#8,D4	move.b		D4,2(A1)	move.b		D4,2(A2)	move.b		D4,3(A1)	move.b		D4,3(A2)	rol.l		#8,D4	move.b		D4,4(A1)	move.b		D4,4(A2)	move.b		D4,5(A1)	move.b		D4,5(A2)	rol.l		#8,D4	move.b		D4,6(A1)	move.b		D4,6(A2)	move.b		D4,7(A1)	move.b		D4,7(A2)	adda.l		#8,A1	adda.l		#8,A2		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,(A1)	move.b		D4,(A2)	move.b		D4,1(A1)	move.b		D4,1(A2)	rol.l		#8,D4	move.b		D4,2(A1)	move.b		D4,2(A2)	move.b		D4,3(A1)	move.b		D4,3(A2)	rol.l		#8,D4	move.b		D4,4(A1)	move.b		D4,4(A2)	move.b		D4,5(A1)	move.b		D4,5(A2)	rol.l		#8,D4	move.b		D4,6(A1)	move.b		D4,6(A2)	move.b		D4,7(A1)	move.b		D4,7(A2)	adda.l		#8,A1	adda.l		#8,A2		dbra		D1,@ColLoop		add.l		D3,A1	add.l		D3,A1	add.l		#640,A1	add.l		D3,A2	add.l		D3,A2	add.l		#640,A2		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A3/D0-D7	unlk		A6	rtsBlit640Skip PROC EXPORT;;	void Blit640Skip (void *src, void *dst, long rowBytes, long rows);;	link			A6,#0	movem.l			A0-A3/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register		move.l		8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3	sub.l		#640,D3		move.l		20(A6),D0	subq.l		#1,D0@RowLoop	move.l		#39,D1				; 40 * 16 = 640@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		dbra		D1,@ColLoop		add.l		D3,A1	add.l		D3,A1	add.l		#640,A1		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A3/D0-D7	unlk		A6	rts		end