	CASE ON	MACHINE MC68040	;-----------------------------------------------BlitSingle PROC EXPORT;;	void BlitSingle (void *src, void *dst, long rowBytes, long rows, long width,;		long sourceSkip);;	; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col repeat count	;		D2 = row bytes	;		D3 = rows	;		D4 = source skip		link			A6,#0	movem.l			A0-A1/D0-D6,-(SP)		movea.l			 8(A6),A0		; src pointer	movea.l			12(A6),A1		; dst pointer	move.l			16(A6),D2		; row bytes	move.l			24(A6),D1		; columns wide (width)	move.l			28(A6),D4		; source skip		lsr.l			#3,D1	lsl.l			#3,D1	sub.l			D1,D2			; row bytes - columns wide	asr.l			#2,D1			; / 4 = long words to move		move.l			D1,D6			; store in D6	andi.l			#7,D6			; "singles" 0-7 long words	subq.l			#1,D6			; for dbra instruction		lsr.l			#3,D1			; / 8 = 32-byte packets to move	subq.l			#1,D1			; minus 1 for dbra	move.l			D1,D5			; copy into D5: (longWords2Move - 1)		move.l			20(A6),D0		; rows	subq.l			#1,D0			; minus 1 for dbra@RowLoop	move.l			D5,D1			; 32-byte packets to move - 1	ble.s			@Singles		; if <= 0, do singles@Col16Loop	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	dbra			D1,@Col16Loop@Singles	move.l			D6,D1	ble.s			@NextRow@ColLoop	move.l			(A0)+,(A1)+	dbra			D1,@ColLoop@NextRow	adda.l			D4,A0			; source += sourceSkip	adda.l			D2,A1			; Point to next dest row	dbra			D0,@RowLoop@Done	movem.l			(SP)+,A0-A1/D0-D6	unlk			A6	rts;-----------------------------------------------Blit320non040 PROC EXPORT;;	void Blit320non040 (void *src, void *dst, long rowBytes, long rows);	// Blits 320 to 320;	; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col repeat count	;		D2 = row bytes	;		D3-D6 = temp registers		link			A6,#0	movem.l			A0-A1/D0-D7,-(SP)		movea.l			8(A6),A0	movea.l			12(A6),A1		move.l			16(A6),D1			; row bytes	sub.l			#320,D1				; minus 320		move.l			20(A6),D0			; rows	subq.l			#1,D0@RowLoop	movem.l			D0-D1,-(SP)		movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(SP)+,D0-D1	adda.l			D1,A1					; Point to next dest row	dbra			D0,@RowLoop	movem.l			(SP)+,A0-A1/D0-D7	unlk			A6	rtsBlitDoubled PROC EXPORT;;	void BlitDoubled (void *src, void *dst, long rowBytes, long rows);	// Blits a 320 wide source to a 640 wide dest.  ;	link			A6,#0	movem.l			A0-A2/D0-D5,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		A2 = 2ndDstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register	;		D5 = 3rd work register		move.l		8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3	move.l		A1,A2	add.l		D3,A2	asl.l		#1,D3	sub.l		#640,D3		move.l		20(A6),D0	subq.l		#1,D0@RowLoop	move.l		#39,D1				; 40 * 16 = 640@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4	;---------;	DH: replaced these basic blocks with a more convoluted form  7/24/95;		d4 = 4,3,2,1	move.l		D4, D5			;	d5 = 4,3,2,1	move.l		D4, D2			;	d2 = 4,3,2,1	swap		D5				;	d5 = 2,1,4,3	move.w		D5, D2			;	d2 = 4,3,4,3	move.w		D4, D5			;	d5 = 2,1,2,1	rol.w		#8, D2			;	d2 = 4,3,3,4	rol.w		#8, D5			;	d5 = 2,1,1,2	ror.l		#8, D2			;	d2 = 4,4,3,3	ror.l		#8, D5			;	d5 = 2,2,1,1;---Should I alternate these or interleave with the above code?	move.l		D2, (A1)+		;	Write out 4433,4433	move.l		D2, (A2)+	move.l		D5, (A1)+		;	Write out 2211,2211	move.l		D5, (A2)+	;---------OLD--------;	rol.l		#8,D4			; Get byte 1;	move.b		D4,D2;	rol.l		#8,D2;	move.b		D4,D2;	rol.l		#8,D2;	rol.l		#8,D4			; Get byte 2;	move.b		D4,D2;	rol.l		#8,D2;	move.b		D4,D2;	move.l		D2,(A1)+;	move.l		D2,(A2)+	;	rol.l		#8,D4			; Get byte 3;	move.b		D4,D2;	rol.l		#8,D2;	move.b		D4,D2;	rol.l		#8,D2;	rol.l		#8,D4			; Get byte 4;	move.b		D4,D2;	rol.l		#8,D2;	move.b		D4,D2;	move.l		D2,(A1)+;	move.l		D2,(A2)+		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4	;---------;	DH: replaced these basic blocks with a more convoluted form  7/24/95;		d4 = 4,3,2,1	move.l		D4, D5			;	d5 = 4,3,2,1	move.l		D4, D2			;	d2 = 4,3,2,1	swap		D5				;	d5 = 2,1,4,3	move.w		D5, D2			;	d2 = 4,3,4,3	move.w		D4, D5			;	d5 = 2,1,2,1	rol.w		#8, D2			;	d2 = 4,3,3,4	rol.w		#8, D5			;	d5 = 2,1,1,2	ror.l		#8, D2			;	d2 = 4,4,3,3	ror.l		#8, D5			;	d5 = 2,2,1,1;---Should I alternate these or interleave with the above code?	move.l		D2, (A1)+		;	Write out 4433,4433	move.l		D2, (A2)+	move.l		D5, (A1)+		;	Write out 2211,2211	move.l		D5, (A2)+;---------OLD--------;	rol.l		#8,D4			; Get byte 1;	move.b		D4,D2;	rol.l		#8,D2;	move.b		D4,D2;	rol.l		#8,D2;	rol.l		#8,D4			; Get byte 2;	move.b		D4,D2;	rol.l		#8,D2;	move.b		D4,D2;	move.l		D2,(A1)+;	move.l		D2,(A2)+	;	rol.l		#8,D4			; Get byte 3;	move.b		D4,D2;	rol.l		#8,D2;	move.b		D4,D2;	rol.l		#8,D2;	rol.l		#8,D4			; Get byte 4;	move.b		D4,D2;	rol.l		#8,D2;	move.b		D4,D2;	move.l		D2,(A1)+;	move.l		D2,(A2)+		dbra		D1,@ColLoop		add.l		D3,A1	add.l		D3,A2		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A2/D0-D5	unlk		A6	rts;-----------------------------------------------Blit320 PROC EXPORT;;	void asm Blit320 (void *src, void *dst, long rowBytes, long rows);	// Blits 320 to 320;		MACHINE MC68040	; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col repeat count		link			A6,#0		movem.l			A0-A1/D0-D1,-(SP)		movea.l			8(A6),A0	movea.l			12(A6),A1		move.l			16(A6),D1			; row bytes	sub.l			#320,D1				; minus 320		move.l			20(A6),D0			; rows	subq.l			#1,D0@RowLoop		;	movem.l			D0-D1,-(SP)		move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	move16			(A0)+, (A1)+	adda.l			D1,A1					; Point to next dest row	dbra			D0,@RowLoop	movem.l			(SP)+,A0-A1/D0-D1		unlk			A6	rts		end