// From dmz.h/*  *	This is the structure that defines the "look" of our lists.  It includes *	the object name, type, net, node & socket */#ifndef __APPLETALKNET__#define __APPLETALKNET__#include <Devices.h>#include <AppleTalk.h>#include <Memory.h>#include <Stdio.h>#include <GestaltEqu.h>#include <Types.h>#include <OSUtils.h>#include <TextUtils.h>#include <Errors.h>// #include "GeneralStuff.h"/* * Version numbers */#define	kEarliestPhase2Vers		53					// AppleTalk Phase 2 started with this version#define	kPGetAppleTalkInfoVers	1					// The version of PGetAppleTalkInfo call (= 1 for .MPP driver 53 and later)#define kFreeEntityType			"\pMacDoom20Free"	// The type of entity for a player looking for a game#define kRecruitingEntityType	"\pMacDoom20Rec"	// The type of entity for a player recruiting#define kReservedEntityType		"\pMacDoom20Res"	// The type of entity for a player reserved in a game#define kMaxNetPlayers			4					// The maximum number of players to search for on net#define	kDDPWDSSize				14					// DDP write data structure size#define	kDDPPacketType			4				// ее Should be > 15 DDP protocol type#define kNameTupleSize			104				// The size of a net entity tuple#define	kDDPWDSSize				14				// DDP write data structure size#define	kDDPHeaderSize			17				// DDP header packet size/* * Error Codes */enum {	kDMNoATalkActive = 1,						// AppleTalk is not turned on	kDMOldATalkVers								// AppleTalk version is too old};#if powerc#pragma options align=mac68k#endiftypedef struct NetEntityAddress {				// Address of a	char object[33];		char type[33];		char net[6];	char node[4];	char socket[4];} NetEntityAddress;#if powerc#pragma options align=reset#endif /*   *	various stuff needed for AppleTalk bridging   */#define sysABridge 			0x19#define ABusVars 			0x000002D8#define kBridgeSocket 		0x6#define systemNetwork 		0x1A /*   *	other defines   */#define kMachineNameResourceID	-16096#define kFlagshipNameResourceID	-16413#define ddpMyDataSize			200#define	ddpMaxData				586#define kNumBuffers				100 /*   * defines to indicate a change of status in AppleTalk  */#define	ATalkStatusChanged	1#define	ATalkActivated		2/*   *	offsets for packet buffers to be used by socket listener */#if powerc#pragma options align=mac68k#endiftypedef struct {		QElemPtr	qLink;		short		qType;		short		buffer_type;			/* DDP Type */		short		buffer_NodeID;			/* Destination Node */		AddrBlock	buffer_Address;			/* Source Address in AddrBlock format */		short		buffer_Hops;			/* Hop count */		short		buffer_ActCount;		/* length of DDP datagram */		OSErr		buffer_CheckSum;		/* Checksum returned here */		long		buffer_Ticks;			/* Timestamp of processing by socket listener */		char		buffer_Data[ddpMyDataSize]; /* the DDP datagram */} PacketBuffer;typedef PacketBuffer *PacketPtr;#if powerc#pragma options align=reset#endif/*----------------------------------------------------------------------		NBP Name Change Info record----------------------------------------------------------------------*/#if powerc#pragma options align=mac68k#endiftypedef struct NameChangeInfo {	Str32 	newObjStr;	/* new NBP name */	Ptr	name;			/* Ptr to location to place a pointer to Pascal string of */							/* name of process that NAK'd the event */}	NameChangeInfo, *NameChangePtr, **NameChangeHdl;#if powerc#pragma options align=reset#endif//--------------------------------------------------------------------// Global variables//--------------------------------------------------------------------extern short				gNumPlayersOnNet;					// Current numbr of players on the networkextern short				gMPPRefNum;							// Reference number for .MPP driverextern NamesTableEntry 		gNamesTableEntry;					// Names table entryextern char					gSocketNum;							// Number of the socket														// Should be initialized to 0extern Ptr					gEntityInfoPtr;						// Pointer to entity info from PLookupName callextern Ptr					gDDPWDSPtr;							// DDP write data structureextern Ptr					gDDPHeaderPtr;						// DDP header packet pointerextern Ptr					gSendDataPtr;						// Pointer to data to be sentextern MPPParamBlock		gMPPSendBlock;						// Parameter block for MPPextern EntityName			gEntityNameArr[kMaxNetPlayers];		// Array of network entity namesextern AddrBlock			gAddressNameArr[kMaxNetPlayers];	// Array of entity address blocks/*  * 	gFreeQ and gUsedQ,are used to track whether gBuffers packet record buffers are  *  available for use or have been filled in by the socket listener and are available *  for processing. */extern  QHdr		gFreeQ, gUsedQ;					// Set up by InitSocketListenerextern Handle 	gSockCodeHndl; 			// Handle to socket listener code resource/*  * 	The socket listener uses the gBuffers buffers to save received packets *	until they can be processed. */extern PacketBuffer	gBuffers[kNumBuffers];			// Set up by InitSocketListenerextern Boolean		gVirtualMem;					// State of virtual memory (true == on)/*----------------------------------------------------------------------	 	ProcPtr defines for PowerPC----------------------------------------------------------------------*/enum {	uppInitListenerProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(QHdrPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(QHdrPtr)))};typedef pascal OSErr (*InitSktListenerProcPtr)(QHdr *freeQ, QHdr *usedQ);#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr	InitSktListenerUPP;#define CallInitSktListenerProc(userRoutine, freeQ, usedQ)	\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppInitListenerProcInfo, (freeQ), (usedQ))#define NewInitSktListenerProc(userRoutine)		\		(InitSktListenerUPP) NewRoutineDescriptor((ProcPtr)userRoutine, uppInitListenerProcInfo, kM68kISA)#elsetypedef InitSktListenerProcPtr	InitSktListenerUPP;#define CallInitSktListenerProc(userRoutine, freeQ, usedQ)	\		(userRoutine)(freeQ, usedQ)#define NewInitSktListenerProc(userRoutine)		\		(InitSktListenerUPP)(userRoutine)	// add definition for accessing A5 which is in LowMem.h that doesn't get included when we	// compile for 68K#define LMGetCurrentA5() (* (Ptr *) 0x0904)#endif// Globalsextern Boolean			gVirtualMem;					// State of virtual memory (true == on)// Function PrototypesBoolean IsVMOn(void);OSErr 	CheckAppleTalkState(void);OSErr 	InitSocketListener(void);OSErr	InitializeNet();OSErr 	TerminateSocketListener(void);OSErr 	TerminateNet();OSErr 	SendDDPPacket(UInt16 sendTo, Ptr data, Size length);Boolean ReceiveDDPPacket(Ptr data, Size *length, short *remoteNode);void	AppleTalkConnect();void Wait();#endif //__APPLETALKNET__