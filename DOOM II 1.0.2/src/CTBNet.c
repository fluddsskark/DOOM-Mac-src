#include <CTBUtilities.h>#include <CommResources.h>#include <Connections.h>#include <Stdio.h>#include <Traps.h>#include <Lion.h>#include "CTBNet.h"#include "CTBBuffer.h"#include "LionDoom.h"#include "doomdef.h"#include "MacPCSwitches.h"#include "DebugSwitches.h"#include "PCMacNet.h"extern WindowPtr			gDoomWindow;#define kBufferSize				(1024 *  16)			// Data Storage Sizeextern void SpinCursor (void);const 	Str32	kDefaultConnTool	= "\pApple Modem Tool";#define	kConnectionWaitTicks	-1 				//Time to wait when listening for connection request#define	kReadWaitTicks			(60 * 10)		//Time to wait when reading#define	kConnectionFlags		(cmData +cmDataClean)	// Use reliable data channel#define 	_CommToolboxTrap		0x8B#define 	_UnimplementedOSTrap	0x9F#define kHeaderSize (sizeof(doomdata_t) - (sizeof(ticcmd_t) * BACKUPTICS))extern BlackScreen();extern RedrawScreen();	extern void DrawStatusDialog (Boolean forUpdate);extern void StatusParamText(char *one, char *two, char *three, char *four);ConnHandle		gConn;CTBReadBufArr	*gCTBRead;CTBWriteBufArr	*gCTBWrite;ConnectionCompletionUPP gCTBPCReadCompletionProc;//_____________________________________________________________________//// ConfigConnection//// Configure Connection tool.//_____________________________________________________________________OSErr ConfigConnection(void){	short			procID;		// tool's ref number					Point			where;	CMBufferSizes	sizes;		// requested size of the buffers		Str255			toolName;	// tool file name			OSErr			status;		//	// Get ProcID	//			procID = -1;				// Unknown tool					// If it can't get the default, get the 1st		BlockMove(kDefaultConnTool, toolName, kDefaultConnTool[0] + 1);	procID = CMGetProcID(toolName);		if(procID == -1)	{		status = CRMGetIndToolName(classCM,1,toolName);		if (status == noErr)		{			procID = CMGetProcID(toolName);		}	}		if (procID == -1)	{		I_Error("No connection tools found");		status = cmNoTools;		goto ErrorDone;	}		//	// Create connection record - refCon and UserData are 0. 	//	sizes[cmDataIn] = 0;	sizes[cmDataOut] = 0;	sizes[cmCntlIn] = 0;	sizes[cmCntlOut] = 0;	sizes[cmAttnIn] = 0;	sizes[cmAttnOut] = 0;	gConn = CMNew(procID, cmData | cmDataClean, sizes, 0, 0);	if (gConn == NULL)	{		I_Error("Can't create a connection tool\n");		goto ErrorDone;	}#if __CTB_DEBUG__	fprintf(debugfile,"cmDataIn %d cmDataOut %d\n",(**gConn).bufSizes[cmDataIn],(**gConn).bufSizes[cmDataOut]);#endif		//	MoveHHi((Handle) gConn);//	HLock((Handle) gConn);		// Allocate space for the read/writes using the number		// returned by the connection tool						//본JDM if using an alternate buffer	gBuffer = NewPtr((*gConn)->bufSizes[cmDataIn]);	if ((status = MemError()) != noErr)	{		I_Error("Out of memory");		goto ErrorDone;	}	//	// Allow user to configure the tool using dialog box	//	if (gConn != NULL) 	{		RGBColor		rgb;		//		HUnlock((Handle) gConn);				SetPt(&where,30,40);				status = CMChoose(&gConn, where, NULL);		BlackScreen();		RedrawScreen();				switch (status) 		{			case chooseDisaster:			case chooseFailed:				I_Exit();				goto ErrorDone;			break;			case chooseOKMinor: 			case chooseOKMajor:				 status = noErr;			break;			case chooseCancel:				I_Exit("");			break;		}		StatusParamText("\pInitializing Connection...", "\p", "\p", "\p");		DrawStatusDialog(TRUE);				//		HLock((Handle) gConn);	} 	ErrorDone:	return(status);}//_____________________________________________________________________//// InitializeComManagers//// Initialize the Communication Toolbox managers.////_____________________________________________________________________static OSErr InitializeComManagers(){	OSErr	status;		// Load up the Communications Toolbox			// Must Initialize CRM && CTBUtilities first		status = 	InitCRM();	if (status != cmNoErr)	{		I_Error("Error in calling InitCRM\n");		goto	ErrorDone;	}		status = 	InitCTBUtilities();	if (status != cmNoErr)	{		I_Error("Error in calling InitCTBUtilities\n");		goto	ErrorDone;	}	// initializes the Connection Manager 	status = 	InitCM();	if (status != cmNoErr)	{		if (status == cmNoTools)		{			I_Error("No Connection Manager tools were found\n");			goto	ErrorDone;		}		else		{			I_Error("Error in initializing Connection Manager\n");			goto	ErrorDone;		}	}	ErrorDone:		return(status);}//_____________________________________________________________________//	CTBOpenConnection	- Initiates a connection////_____________________________________________________________________Boolean CTBOpenConnection() {	CMBufferSizes	sizes;		// Connection Tool data			CMStatFlags		statusFlags;	CMErr			status;		if (gConn != NULL) 	{		// Get connection info				status = CMStatus(gConn, sizes, &statusFlags);				if (status == cmNoErr) 		{			// If it isn't already open, then open it				if ((statusFlags & (cmStatusOpen + cmStatusOpening)) == 0)			{				status = CMOpen(gConn, false, NULL, 0);			}			if (status != cmNoErr)			{				BlackScreen();				RedrawScreen();					//I_Error("Did not complete attempt to contact other player");				return(false);			}		}	 	else	// CMStatus call failed	 	{			BlackScreen();			RedrawScreen();				//I_Error("Error calling CMStatus %hd, status %ld\n",status, statusFlags );			return(false);		}			}	return(true);}//_____________________________________________________________________////	CTBCloseConnection	- Kills a connection////_____________________________________________________________________void CTBCloseConnection(void) {	CMBufferSizes	sizes;		// Connection Tool data			CMStatFlags		statFlags;	OSErr			status;	// Kill the current connection		if (gConn != NULL) 	{		status = CMStatus(gConn, sizes, &statFlags);				// If it's open, then close it			if (status == noErr)		{			if ((statFlags & (cmStatusOpen + cmStatusOpening)) != 0)			{				status = CMClose(gConn, false, NULL, 0, true);			}		}		else		{			I_Error("Error in closing connection");		}					if (status != noErr)			;		// Conn tool will alert user on an error			}	}//_____________________________________________________________________//	CTBCloseAndDispose//// Closes connection and disposes of data structures////_____________________________________________________________________static void CloseAndDispose(void){		// Clear all local read and write buffers	CMReset(gConn);		//본 JDM may want to kill io if asynch	CTBCloseConnection();			// Dispose of all the tools		if (gConn != NULL) 	{		HUnlock((Handle) gConn);		CMDispose(gConn);	}			//본JDM if using an alternate buffer/*	if (gBuffer != NULL)	// Clean up our buffer			{		DisposPtr(gBuffer);	}*/}pascal void CTBPCReadCompletion(ConnHandle hConn){		// Set user data for read complete flag	CMSetUserData(hConn, 1);	}	//_____________________________________________________________________////	CTBInitializeNet	- Initiates a connection////_____________________________________________________________________OSErr	CTBInitializeNet(){	int		i;	OSErr	status;		gConn = NULL;	// Does CommToolbox Exist?		if (NGetTrapAddress(_CommToolboxTrap,OSTrap) == NGetTrapAddress(_UnimplementedOSTrap, OSTrap))	{		I_Error("You must install Communications Toolbox in your system to use this feature.");		status = -1;		goto ErrorDone;	}		// Initialize CTB managers	if ((status = InitializeComManagers()) != noErr)	{		I_Error("Error in initializing communication managers");	}		//	// Initialize the connection manager	//	if ((status = ConfigConnection()) != noErr)	{		I_Error("Error in configuring the connection");	}	// Initialize write buffer	gCTBWrite = (CTBWriteBufArr *) NewPtrClear(sizeof(CTBWriteBufArr));	if (gCTBWrite == NULL)	{		I_Error("Memory error");	}	gCTBWrite->ctbWriteReady = 0;	// Initialize completion routine	gCTBPCReadCompletionProc = NewConnectionCompletionProc((ProcPtr) CTBPCReadCompletion);	if (gCTBPCReadCompletionProc == NULL)	{		I_Error("Error in allocating Read completion routine");	}	// Set user data for read complete flag	CMSetUserData(gConn, 0);		// Initialize read buffer	gCTBRead = (CTBReadBufArr *) NewPtrClear(sizeof(CTBReadBufArr));	if (gCTBRead == NULL)	{		I_Error("Memory error");	}	gCTBRead->bufPend 	= -1;	gCTBRead->currHdr 	= 0;	gCTBRead->currData 	= 0;	gCTBRead->lastEOM	= 0;	for(i = 0; i<kNumCTBReadBuffers; i++)	{		gCTBRead->buf[i].end = -1;	}ErrorDone:	return(status);}//_____________________________________________________________________////	CTBKillIO	- Kills all asynchronous I/O requests////_____________________________________________________________________OSErr CTBKillIO(){	OSErr			status = noErr;	if (gConn)	{		CMIOKill(gConn, cmDataIn);		CMIOKill(gConn, cmDataOut);	}	return (status);}//_____________________________________________________________________////	CTBTerminateNet	- Terminates the connection and cleans up////_____________________________________________________________________OSErr CTBTerminateNet(){	CMBufferSizes	sizes;	CMStatFlags		statusFlags;	OSErr			status;	if (gConn)	{		CMIOKill(gConn, cmDataIn);		status = CMStatus(gConn, sizes, &statusFlags);		while(statusFlags & cmStatusDRPend)		{			status = CMStatus(gConn, sizes, &statusFlags);			}			CloseAndDispose();				// Dispose Write buffer		if (gCTBWrite != NULL)		{			DisposePtr((Ptr) gCTBWrite);		}		// Dispose read buffer		if (gCTBRead != NULL)		{			DisposePtr((Ptr) gCTBRead);		}	}		//본 JDM WARNING dispose of completion routine UPPs?	return(true);}OSErr CTBWaitForConnection(){	CMBufferSizes	sizes;		// Connection tool data			CMStatFlags		statFlags;	OSErr			status = noErr;		if (gConn == NULL)	{		BlackScreen();		RedrawScreen();			I_Error("Cannot wait for connection because no tool has been initialized\n");		status = cmNoTools;		goto ErrorDone;	}		status = CMListen(gConn, false, NULL, kConnectionWaitTicks);	BlackScreen();	RedrawScreen();		if (status != cmNoErr)	{//		I_Error("Error in calling CMListen %hd\n",status);		goto ErrorDone;	}		status = 	CMStatus(gConn, sizes, &statFlags);	if (status != cmNoErr)	{		I_Error("Error in calling CMStatus %hd\n",status);		status = 1;		goto ErrorDone;	}		// Check if incoming call was received	if (!(statFlags & cmStatusIncomingCallPresent))	{		I_Error("No attempt to connect has been received\n");		status = 1;		goto ErrorDone;	}		//본퇽DM Should probably decide whether to accept instead of accepting blindly		// Connection request has been received, accept it#if __CTB_DEBUG__	fprintf(debugfile,"Attempt to connect has been received\n");#endif		status = CMAccept(gConn, true);	BlackScreen();	RedrawScreen();		if (status != cmNoErr)	{		I_Error("Error in calling CMAccept %hd\n",status);		status = 1;		goto ErrorDone;	}ErrorDone:	return(status);	}/*_______________________________________________________________________________	CTBSendString	Sends a string of characters to Comm Toolbox - synchronous.	Used in initial arbitration.   _______________________________________________________________________________*/OSErr CTBSendString(UInt16 sendTo, Ptr data, Size length){	CMFlags			cmFlags = 0;	long			bytesToWrite;	OSErr			status;		if (gConn == NULL)	{		I_Error("Cannot send data because no tool has been initialized");		status = cmNoTools;		return(-1);	}		bytesToWrite = length;		status = CMWrite(gConn, data, &bytesToWrite, cmData, false, NULL, -1, cmFlags);	if (status != cmNoErr)	{		I_Error("Error in calling CMWrite %hd", status);		return(status);	}		return(noErr);}/*_______________________________________________________________________________	CTBSendPacketFilter	Sends a packet of data with all EOM characters doubled and EOM at end of packet.	Searches through data and if any of the data is equivalent to the EOM char, 	appends another EOM char after that char in the data.		Terminates data with EOM followed by NULL._______________________________________________________________________________*/OSErr CTBSendPacketFilter(UInt16 sendTo, Ptr data, Size length){	Bytes8 			*dataDst;	Bytes8 			*dataSrc;	int				copySize		= 0;	int				srcInd 			= 0;	int				dstInd 			= 0;	int				lastSrcStart	= 0;	int				lastDstStart 	= 0;	char			*dst;	CMStatFlags		statFlags;	CMFlags			cmFlags = 0;	CMBufferSizes	sizes;		int 			i;	OSErr			status;		#if __FILTER_DEBUG__	int			count;		fprintf(debugfile,"$Sending %d chars to Send Filter ");	for (count = 0; count < length; count++)		fprintf(debugfile,"%x ",data[count]);	fprintf(debugfile,"\n");		#endif#if __FILTER_DEBUG__	int			count;#endif		dst = gCTBWrite->buf[gCTBWrite->ctbWriteReady].data;	while(srcInd < length)	{		// Does this chacter need to be doubled?		if (data[srcInd] == FRAMECHAR1)		{						// Copy through EOM			copySize = srcInd - lastSrcStart + 1;						// 본JDM WARNING use something faster than BlockMove			BlockMoveData(&data[lastSrcStart], &dst[lastDstStart], copySize);			// Add another EOM			lastDstStart += copySize;			dst[lastDstStart] = FRAMECHAR1;						// Update pointers to next character			lastDstStart++;			lastSrcStart += copySize;		}				srcInd++;	}	// If any EOMs had to be inserted, lastDstStart > 0 and is number of bytes to send	// Otherwise, length is num to send and none were copied		if (lastDstStart > 0)	{		// Copy remaining data if not all copied		if ((copySize = srcInd - lastSrcStart) > 0)		{							// 본JDM WARNING use something faster than BlockMove			BlockMoveData(&data[lastSrcStart], &dst[lastDstStart], copySize);				} 		// Add EOM and NULL chars		lastDstStart += copySize;			dst[lastDstStart++] = FRAMECHAR1;		dst[lastDstStart++] = FRAMECHAR2;				gCTBWrite->buf[gCTBWrite->ctbWriteReady].length = lastDstStart;#if __FILTER_DEBUG__		fprintf(debugfile,"$$Sending %d chars ",gCTBWrite->buf[gCTBWrite->ctbWriteReady].length);		for (count = 0; count < gCTBWrite->buf[gCTBWrite->ctbWriteReady].length; count++)			fprintf(debugfile,"%x ",gCTBWrite->buf[gCTBWrite->ctbWriteReady].data[count]);		fprintf(debugfile,"\n");		#endif		// Make sure write is not pending (CTB only)		status = CMStatus(gConn, &sizes, &statFlags);		while(statFlags & cmStatusDWPend)	// Check if read is pending		{#if __FILTER_DEBUG__			fprintf(debugfile,"**Write pending\n");#endif			status = CMStatus(gConn, &sizes, &statFlags);		}				status = CMWrite(gConn, gCTBWrite->buf[gCTBWrite->ctbWriteReady].data,							 	&gCTBWrite->buf[gCTBWrite->ctbWriteReady].length,							 	cmData, true, NULL, -1, cmFlags);						 		if (status != cmNoErr)		{			I_Error("Error in writing to Communications Toolbox %hd", status);		}	}	else	//	// No EOM characters in message	{			// We are copying a message with no EOMs so will be exactly divisible by 8		// Write EOM		dataSrc = (Bytes8 *) data;		dataDst = (Bytes8 *) dst;				for (i = length; i > 0; i -= 8)		{			*dataDst++ = *dataSrc++;		}		dst[length++] = FRAMECHAR1;		dst[length++] = FRAMECHAR2;		gCTBWrite->buf[gCTBWrite->ctbWriteReady].length = length;		#if __FILTER_DEBUG__		fprintf(debugfile,"$$Sending %d chars ",gCTBWrite->buf[gCTBWrite->ctbWriteReady].length);		for (count = 0; count < gCTBWrite->buf[gCTBWrite->ctbWriteReady].length; count++)			fprintf(debugfile,"%x ",gCTBWrite->buf[gCTBWrite->ctbWriteReady].data[count]);		fprintf(debugfile,"\n");		#endif		// Make sure write is not pending (CTB only)		status = CMStatus(gConn, &sizes, &statFlags);		while(statFlags & cmStatusDWPend)	// Check if read is pending		{#if __FILTER_DEBUG__			fprintf(debugfile,"**Write pending\n");#endif			status = CMStatus(gConn, &sizes, &statFlags);		}		status = CMWrite(gConn, gCTBWrite->buf[gCTBWrite->ctbWriteReady].data,							 	&gCTBWrite->buf[gCTBWrite->ctbWriteReady].length,							 	cmData, true, NULL, -1, cmFlags);						 		if (status != cmNoErr)		{			I_Error("Error in calling CMWrite %hd", status);		}		}		// Increment next ready buffer	gCTBWrite->ctbWriteReady = (gCTBWrite->ctbWriteReady + 1) % kNumCTBWriteBuffers;}/*_______________________________________________________________________________	CTBReadString	Reads available data up to requested amount synchronously.	Returns true if any data was read.   _______________________________________________________________________________*/Boolean CTBReadString(Ptr data, Size *length){	CMFlags			cmFlags;	long			bytesToRead;	OSErr			status;		if (gConn == NULL)	{		I_Error("Cannot receive data because no tool has been initialized\n");		return(false);	}		// Read a byte	bytesToRead	= *length;	status = CMRead(gConn, data, &bytesToRead, cmData, false, NULL, 0, &cmFlags);	if (bytesToRead > 0)	{		*length = bytesToRead;		return (true);	}	else	{		*length = 0;		return(false);	}}//______________________________________________________________________________//// Return up to requested number of bytes in the designated place.// If all requested bytes are available, returns all bytes, num copied and true,// otherwise, return bytes available, number of bytes copied and false.//// Returns all bytes from input stream unless they are the second of two consecutive// EOM chars, or they are a non EOM char following an EOM char.// // kNumCTBReadBuffers must be at least 2 for this algorithm to work correctly.//______________________________________________________________________________long	GetGoodBytes(){		int				bytesCopied = 0;	int				thisBuf;	int				sendIndex;	CTBReadBuf		*thisBufPtr;	CMFlags			cmFlags;	CMStatFlags		statFlags;	CMBufferSizes	sizes;	int				tryRead;	Boolean			didLastBuf;	Boolean			done = false;	long			bytesRead;	OSErr			status;		// Update if an asynchronous read has completed	if (gCTBRead->bufPend != -1)	{#if __FILTER_DEBUG__		fprintf(debugfile,"\t\t--Buffer %d was pending\n",gCTBRead->bufPend);#endif		// Check if read is pending		if(CMGetUserData(gConn) != 0)			{			// Reset to false			CMSetUserData(gConn, 0);			#if __FILTER_DEBUG__			fprintf(debugfile,"\t\t--Asynch read has completed\n");#endif			gCTBRead->buf[gCTBRead->bufPend].end = (**gConn).asyncCount[cmDataIn] - 1;	// 본JDM Protocol dependent			if ((**gConn).asyncCount[cmDataIn] > 0)			{#if __FILTER_DEBUG__				fprintf(debugfile,"\t\t--Asynch read of %d bytes\n",(**gConn).asyncCount[cmDataIn]);#endif			}			gCTBRead->endBuf = gCTBRead->bufPend;			gCTBRead->bufPend = -1;		}	}	sendIndex 	= gCTBRead->currData;#if __FILTER_DEBUG__	fprintf(debugfile,"\t\t--sendIndex = %d\n",sendIndex);#endif	thisBuf		= gCTBRead->startBuf;	// Process each buffer until all are processed or all requested data is read	didLastBuf = false;	while (!done && !didLastBuf)	{				thisBufPtr	= &(gCTBRead->buf[thisBuf]);#if __FILTER_DEBUG__		fprintf(debugfile,"\t\t--Processing buffer %d start %d end %d\n",thisBuf,thisBufPtr->start, thisBufPtr->end);#endif		// Get all the bytes needed from this buffer		while (!done && (thisBufPtr->start <= thisBufPtr->end) 					&& (sendIndex < sizeof(doomdata_t))) 		{			// If last char was not FRAMECHAR1			if(gCTBRead->lastEOM == 0)			{				// Not this, nor last char was FRAMECHAR1				if (thisBufPtr->data[thisBufPtr->start] != FRAMECHAR1)				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t--Read char %x \n",thisBufPtr->data[thisBufPtr->start]);#endif					gCTBRead->sendBuf[sendIndex] = thisBufPtr->data[thisBufPtr->start];					sendIndex++;					bytesCopied++;				}				// This char is FRAMECHAR1, last was not				else				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t--Read first EOM\n");#endif					gCTBRead->lastEOM = 1;				}							}			// Last char was FRAMECHAR1			else if (gCTBRead->lastEOM == 1)			{				// Last was FRAMECHAR1, this is also				if (thisBufPtr->data[thisBufPtr->start] == FRAMECHAR1)				{	#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t--Read second EOM\n");	#endif					gCTBRead->sendBuf[sendIndex] = thisBufPtr->data[thisBufPtr->start];					sendIndex++;								bytesCopied++;								gCTBRead->lastEOM = 0;				}				// Last char was FRAMECHAR1, this is FRAMECHAR2				else if (thisBufPtr->data[thisBufPtr->start] == FRAMECHAR2)				{	#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t--dropped FRAMECHAR2\n");	#endif					gCTBRead->lastEOM = 0;					done = true;				}				// There is a problem, FRAMECHAR1 followed by random char				else				{	#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--*Error, entering state 2 read %x\n",												thisBufPtr->data[thisBufPtr->start]);	#endif					gCTBRead->lastEOM = 2;				}			}			// We are in the process of flushing a bad packet and waiting for FRAMECHAR1			else if (gCTBRead->lastEOM == 2)			{				if(thisBufPtr->data[thisBufPtr->start] == FRAMECHAR1)				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--*Error, entering state 3 read %x\n",												thisBufPtr->data[thisBufPtr->start]);#endif					gCTBRead->lastEOM = 3;				}				else				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--*Error, still in state 3 read %x\n",												thisBufPtr->data[thisBufPtr->start]);#endif				}			}			// We are in the process of flushing a bad packet and waiting for FRAMECHAR2			else if (gCTBRead->lastEOM == 3)			{				if(thisBufPtr->data[thisBufPtr->start] == FRAMECHAR2)				{	#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t--*Error, Entering state 4\n");	#endif					gCTBRead->lastEOM = 4;					done = true;				}				else				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--*Error, state 3 to 2 read %x\n",												thisBufPtr->data[thisBufPtr->start]);#endif					gCTBRead->lastEOM = 2;				}			}						thisBufPtr->start++;					}				// If we exhausted this buffer, reset it		if(thisBufPtr->start > thisBufPtr->end)		{			thisBufPtr->start 	= 0;			thisBufPtr->end 	= -1;						// advance to next buffer			if (thisBuf	!= gCTBRead->endBuf)			{				thisBuf = (thisBuf + 1) % kNumCTBReadBuffers;			}			else			{				didLastBuf = true;			}								gCTBRead->startBuf = thisBuf;		}					}	// If we have read a complete packet		if(done)	{#if __FILTER_DEBUG__		fprintf(debugfile,"\t\t--Clearing currData\n");#endif		gCTBRead->currData = 0;	}	// If have read incomplete packet	else if (bytesCopied)	{#if __FILTER_DEBUG__		fprintf(debugfile,"\t\t-Setting currData to %d + %d\n",gCTBRead->currData,bytesCopied);#endif		gCTBRead->currData 	+= bytesCopied;	}	// We are reading more than sizeof(doomdata_t) data	if(sendIndex > sizeof(doomdata_t))	{		// We need to flush all this data		if (gCTBRead->lastEOM == 0)		{			gCTBRead->lastEOM = 2;		}	}		// Initiate read for next buffer if the next buffer is not used and not pending	if (gCTBRead->bufPend == -1)	{		// endBuf is empty, so don't go to next one		if (gCTBRead->buf[gCTBRead->endBuf].end == -1)		{			tryRead = gCTBRead->endBuf;		}		else		{			tryRead = (gCTBRead->endBuf + 1) % kNumCTBReadBuffers;		}		#if __FILTER_DEBUG__		fprintf(debugfile,"\t\t--About to read to %d\n",tryRead);#endif		//본 JDM Warning first part of this check is not needed		if ((tryRead != gCTBRead->bufPend) && (gCTBRead->buf[tryRead].end == -1))		{			status = CMStatus(gConn, &sizes, &statFlags);			if ((bytesRead = sizes[cmDataIn]) > 0)			{				gCTBRead->bufPend = tryRead;#if __FILTER_DEBUG__				fprintf(debugfile,"\t\t--%d bytes available, read to %d\n",bytesRead,tryRead);#endif				if (bytesRead > kCTBReadBufSize)				{					bytesRead = kCTBReadBufSize;#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t--Too many bytes available %d read only %d\n",bytesRead,kCTBReadBufSize);#endif				}				status = CMRead(gConn, gCTBRead->buf[tryRead].data, &bytesRead, cmData, true,								 gCTBPCReadCompletionProc, -1, &cmFlags);				if (status != noErr)				{					I_Error("Error in reading from serial data port %d\n",status);				}	#if __FILTER_DEBUG__				fprintf(debugfile,"\t\t--Read to %d\n",tryRead);	#endif			}			else			{#if __FILTER_DEBUG__				fprintf(debugfile,"\t\t\t--No bytes available\n");#endif				}		}	}#if __FILTER_DEBUG__	fprintf(debugfile,"\t\t--LastEOM = %d\n",gCTBRead->lastEOM);#endif		// Got a complete, well formed packet	if (done && gCTBRead->lastEOM == 0)	{		return(true);	}		else	{		if (gCTBRead->lastEOM == 4)		{			gCTBRead->lastEOM = 0;		}		return(false);	}}Boolean CTBReceivePacketFilter(Ptr data, Size *length){		Bytes8 		*dataDst;	Bytes8 		*dataSrc;	int 		i;	CMIdle(gConn);	if (GetGoodBytes())	{		*length = kHeaderSize + ((doomdata_t *)(gCTBRead->sendBuf))->numtics * sizeof(ticcmd_t);		if(*length <= sizeof(doomdata_t))		{			dataSrc = (Bytes8 *) gCTBRead->sendBuf;			dataDst = (Bytes8 *) data;						for (i = *length; i > 0; i -= 8)			{				*dataDst++ = *dataSrc++;			}//			BlockMove(gCTBRead->sendBuf, data, *length);			return(true);		}		else		{#if __SYSBEEPS__			SysBeep(5);#endif#if __FILTER_DEBUG__			fprintf(debugfile,"\t--*Error Trying to get a bad data packet\n");#endif			*length = 0;			return(false);		}	}	else	{		*length = 0;		return(false);	}}void CTBFlushData (void){ 	CMStatFlags		statusFlags;	CMBufferSizes	sizes;	CMFlags			cmFlags;	char			flushBuf[256];	long			length;	long			myWaitTicks;	OSErr			status;		SpinCursor ();		status = CMStatus(gConn, sizes, &statusFlags);	if (statusFlags & cmStatusDataAvail)	{		while ((length = sizes[cmDataIn]) != 0)		{			SpinCursor ();						status = CMRead(gConn, flushBuf, &length, cmData, false, NULL, -1, &cmFlags);			status = CMStatus(gConn, sizes, &statusFlags);		}	}		myWaitTicks = TickCount() + (60 * 5);	while(myWaitTicks > TickCount())	{		SpinCursor ();	}	status = CMStatus(gConn, sizes, &statusFlags);	while ((length = sizes[cmDataIn]) != 0)	{		if (length > 256)		{			length = 256;		}			SpinCursor ();		status = CMRead(gConn, flushBuf, &length, cmData, false, NULL, -1, &cmFlags);		SpinCursor ();		status = CMStatus(gConn, sizes, &statusFlags);		SpinCursor ();	}}