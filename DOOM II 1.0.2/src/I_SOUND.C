#include "LionDoom.h"#include <stdio.h>#include "doomdef.h"#include "sounds.h"#include "i_sound.h"#include "I_SOUND.PROTO.H"#include "MacSound.h"#include <Memory.h>#include <Resources.h>#include <Sound.h>#include <Timer.h>#include <Movies.h>#define rate11025khz				0x2B110000#define kMaxMacChannels			4void I_PlaySoundResource (int mchan, int id);int												gMinSep = 0, gMaxSep = 0;SndChannelPtr							gMacSndChannels[kMaxMacChannels] = { NULL, NULL, NULL, NULL };tStdSndResourceHdrHndl		gMacSndHandles[kMaxMacChannels] = { NULL, NULL, NULL, NULL };int												gMacRsrcSnd[kMaxMacChannels] = { NULL, NULL, NULL, NULL };//extern int								gNumChannels;						// number of channels availableextern int             		ticcount;extern boolean						gMusicPaused;						// whether songs are pausedextern Boolean						gQuickTimeInstalled;extern Boolean						gQuickTimeLoaded;extern musicinfo_t				*gCurrSongPlaying;	// music currently being playedtypedef struct {		TMTask		task;	long		tmWakeUp;	long		tmReserved;	long		tmRefCon;} TMInfo, *TMInfoPtr;TMInfo		tm;#if __profile__#pragma profile off#endif/****************************************************** *	ServiceTimer.																			* *																										* *	This is the interrupt timer routine. The function	* *	is called differently, depending upon whether			* *	or not we are running on a PowerPC.								* ******************************************************/#define TRUE_TIMER#if defined(powerc) || defined (__powerc)	// For PowerPC		pascal void ServiceTimer (TMTaskPtr tmTaskPtr);	pascal void ServiceTimer (TMTaskPtr tmTaskPtr)	{		TMInfoPtr		tmRecPtr;		int				v35hzDelay = -28571L;				tmRecPtr = (TMInfoPtr) tmTaskPtr;#ifdef TRUE_TIMER		ticcount++;#endif		PrimeTime((QElemPtr)&tm, v35hzDelay);	}	#else	// For 68K		extern pascal TMInfoPtr GetTMInfo (void)	 ONEWORDINLINE(0x2E89);	 	pascal void ServiceTimer (void);		pascal void ServiceTimer (void)	{		TMInfoPtr		tmRecPtr;		long			oldA5;		int				v35hzDelay = -28571L;				tmRecPtr = GetTMInfo();		oldA5 = SetA5( tmRecPtr->tmRefCon );		#ifdef TRUE_TIMER		ticcount++;#endif		PrimeTime((QElemPtr)&tm, v35hzDelay);				oldA5 = SetA5( oldA5 );	}#endif#if __profile__#pragma profile on#endif/****************************************************** *	I_StartupTimer.																		* *																										* *	Called from the initialization functions, this		* *	function starts the 35hz timer.										* ******************************************************/void I_StartupTimer (void){	int			v35hzDelay;		v35hzDelay = -28571L;	tm.task.tmAddr = NewTimerProc(ServiceTimer);	tm.tmWakeUp = 0L;	tm.tmReserved = 0;	tm.tmRefCon = SetCurrentA5();	InsXTime((QElemPtr)&tm);	PrimeTime((QElemPtr)&tm, v35hzDelay);}/****************************************************** *	I_ShutdownTimer.																	* *																										* *	Removes the timer interrupt from the queue.				* ******************************************************/void I_ShutdownTimer (void){	RmvTime((QElemPtr)&tm);}/* * *                           SOUND HEADER & DATA * * */int							gSndSfxVolume,      // maximum volume for sound								gSndMusicVolume;    // maximum volume for musicextern boolean	snd_MusicAvail,			// whether music is available								snd_SfxAvail;				// whether sfx are available/****************************************************** *	I_PauseSong.																			* *																										* *	Pauses the song currently being played.						* ******************************************************/void I_PauseSong (void *midiMovie2Pause){	Movie		aMovie;		if (!gQuickTimeInstalled || !gQuickTimeLoaded)		return;	  aMovie = (Movie) midiMovie2Pause;  if (aMovie == NULL)  	return;    if (!gMusicPaused)		StopMovie(aMovie);}/****************************************************** *	I_ResumeSong.																			* *																										* *	Resumes the song currently being played.					* ******************************************************/void I_ResumeSong (void *midiMovie2Resume){	Movie		aMovie;	OSErr		err;		if (!gQuickTimeInstalled || !gQuickTimeLoaded)		return;	  aMovie = (Movie) midiMovie2Resume;  if (aMovie == NULL)  	return;    StartMovie(aMovie);	if ((err = GetMoviesError()) != noErr)		return;		MoviesTask(aMovie, 4L);}/****************************************************** *	I_SetMusicVolume.																	* *																										* *	Sets the volume for the music currently playing		* *	as well as the "master" volume for Doom.					* ******************************************************/void I_SetMusicVolume (int volume){	Movie		aMovie;	  gSndMusicVolume = volume;    if (gCurrSongPlaying == NULL)  	return;    if (gCurrSongPlaying->data == NULL)  	return;  	if (!gQuickTimeInstalled || !gQuickTimeLoaded)		return;		if (gMusicPaused)		return;	  aMovie = (Movie) gCurrSongPlaying->data;  SetMovieVolume(aMovie, (gSndMusicVolume + 1) * 2);}/****************************************************** *	I_SetSfxVolume.																		* *																										* *	Sets the volume for the sound currently playing		* *	as well as the "master" volume for Doom.					* ******************************************************/void I_SetSfxVolume (int volume){  gSndSfxVolume = volume; // THROW AWAY?}/* * *                              SONG API * *//****************************************************** *	I_QrySongPlaying.																	* *																										* *	Returns 1 if the specified music is playing, or		* *	0 otherwise.																			* ******************************************************/int I_QrySongPlaying (musicinfo_t *song2Check){	Movie		aMovie;		if (!gQuickTimeInstalled || !gQuickTimeLoaded)		return 0;		aMovie = (Movie) song2Check->data;	if (aMovie == NULL)		return 0;		if (gMusicPaused)		return 0;		if (IsMovieDone(aMovie))		return 0;	else		return 1;}/****************************************************** *	I_StopSong.																				* *																										* *	Stops the song currently playing.									* ******************************************************/void I_StopSong (void *midiMovieHandle){	Movie		musicMovie;	long		dummy;		if (!gQuickTimeInstalled || !gQuickTimeLoaded)		return;		if (midiMovieHandle == NULL)		return;		musicMovie = (Movie) midiMovieHandle;		if (IsMovieDone(musicMovie) == FALSE)	{		long		startVol, i;				startVol = gSndMusicVolume + 1;				for (i = 0; i < 16; i++)		{	  	SetMovieVolume(musicMovie, ((startVol * (15 - i)) / 15) * 2);	  	Delay(2,  &dummy);	  }	}		if (!gMusicPaused)		StopMovie(musicMovie);		DisposeMovie(musicMovie);}/* * *                                 SOUND FX API * *//****************************************************** *	I_GetSfxLumpNum.																	* *																										* *	Gets lump nums of the named sound. Returns				* *	pointer which will be passed to I_StartSound()		* *	when you want to start an SFX. Must be sure to		* *	pass this to UngetSoundEffect() so that they can	* *	be freed!																					* ******************************************************/int I_GetSfxLumpNum (sfxinfo_t *sound){	char namebuf[9];	if (sound->link)		sound = sound->link;	sprintf(namebuf, "d%c%s", 'S' /* snd_prefixen[snd_SfxDevice] */, sound->name);	return W_GetNumForName(namebuf);}void I_PlaySoundResource (int mchan, int id){	Handle				sHndl;	void					*data;	OSErr					err; 	SndCommand		sCmd; 	 	if (gSndSfxVolume == 0) 		return;		sHndl = GetResource('idXX', id);	if (sHndl == NULL)		return;	else	{		MoveHHi((Handle)sHndl);		HLock((Handle)sHndl);		data = (void *)*sHndl;				if (I_SoundIsPlaying((int)gMacSndHandles[mchan]))			I_StopSound((int)gMacSndHandles[mchan]);				(**gMacSndHandles[mchan]).numFrames = GetHandleSize(sHndl) - 8;		(**gMacSndHandles[mchan]).samplePtr = (Ptr)&((byte *)data)[8];				gMacRsrcSnd[mchan] = (int) sHndl;				// Play the sound				sCmd.cmd = bufferCmd;		sCmd.param2 = (long) &(**gMacSndHandles[mchan]).samplePtr;		err = SndDoImmediate(gMacSndChannels[mchan], &sCmd);			// After playing, set the amplitude for the channel to 0.		sCmd.cmd = ampCmd;	sCmd.param1 = (255L * (long)gSndSfxVolume) / 127L;		err = SndDoImmediate(gMacSndChannels[mchan], &sCmd);	}}/****************************************************** *	I_StartSound.																			* *																										* *	Starts a sound effect, unless volume is 0.				* ******************************************************/int I_StartSound (int id, void *data, int vol, int sep, int pitch, int priority, int size){ 	short					err; 	SndCommand		sCmd; 	int						left, right; 	 	if (gSndSfxVolume == 0) 		return -1; 		(**gMacSndHandles[id]).numFrames = size - 8;	(**gMacSndHandles[id]).samplePtr = (Ptr)&((byte *)data)[8];		// Play the sound		sCmd.cmd = bufferCmd;	sCmd.param2 = (long) &(**gMacSndHandles[id]).samplePtr;	err = SndDoImmediate(gMacSndChannels[id], &sCmd);		// Set the amplitude		sCmd.cmd = ampCmd;//	sCmd.param1 = (255L * (long)gSndSfxVolume) / 127L;	sCmd.param1 = (255L * (long)vol) / 127L;	err = SndDoImmediate(gMacSndChannels[id], &sCmd);		// Set the volume based on separation/volume		sCmd.cmd = volumeCmd;		left = 0x100;	right = 0x100;		if (sep > 0)		left = 256 - sep;	else if (sep < 0)		right = 256 + sep;		sCmd.param2 = (left << 16) + right;	err = SndDoImmediate(gMacSndChannels[id], &sCmd);		return (int) gMacSndChannels[id];}/****************************************************** *	I_StopSound.																			* *																										* *	Stops a sound effect.															* ******************************************************/void I_StopSound (int handle){	SndChannelPtr		sndChannel;	SndCommand			sCmd;	short						err, i, j;		sndChannel = (SndChannelPtr) handle;		sCmd.cmd = quietCmd;	err = SndDoImmediate(sndChannel, &sCmd);	if (err != noErr)		return;		sCmd.cmd = reInitCmd;	err = SndDoImmediate(sndChannel, &sCmd);		for (i = 0; i < kMaxMacChannels; i++)	{		if (sndChannel == gMacSndChannels[i])		{			if (gMacRsrcSnd[i])			{				for (j = 0; j < kMaxMacChannels; j++)				{					if ((i != j) && (gMacRsrcSnd[i] == gMacRsrcSnd[j]))					{					// Used by another channel! don't unlock it!						gMacRsrcSnd[i] = NULL;						return;					}				}								HUnlock((Handle)gMacRsrcSnd[i]);				HPurge((Handle)gMacRsrcSnd[i]);				gMacRsrcSnd[i] = NULL;			}			break;		}	}}/****************************************************** *	I_SoundIsPlaying.																	* *																										* *	Returns 1 if the specified channel is currently		* *	playing a sound, or 0 if not.											* ******************************************************/int I_SoundIsPlaying (int handle){	SCStatus				sndStatus;	SndChannelPtr		sndChannel;	short						err;		sndChannel = (SndChannelPtr) handle;		err = SndChannelStatus(sndChannel, sizeof(SCStatus), &sndStatus);	if (err)		return 1;		if (sndStatus.scChannelBusy == FALSE)		return 0;	else		return 1;}/****************************************************** *	I_UpdateSoundParams.															* *																										* *	Updates the sound parameters for the specified		* *	channel.																					* ******************************************************/void I_UpdateSoundParams (int handle, int vol, int sep, int pitch){	SndChannelPtr		sndChannel;	int							left, right;	OSErr						err; 	SndCommand			sCmd;		sndChannel = (SndChannelPtr) handle;	// Set the amplitude		sCmd.cmd = ampCmd;//	sCmd.param1 = (255L * (long)gSndSfxVolume) / 127L;	sCmd.param1 = (255L * (long)vol) / 127L;	err = SndDoImmediate(sndChannel, &sCmd);		// Set the volume based on separation/volume		sCmd.cmd = volumeCmd;		left = 0x100;	right = 0x100;		if (sep > 0)		left = 256 - sep;	else if (sep < 0)		right = 256 + sep;		sCmd.param2 = (left << 16) + right;	err = SndDoImmediate(sndChannel, &sCmd);	 // SFX_SetOrigin(handle, pitch, sep, vol);}/* * *                                                      SOUND STARTUP STUFF * * *//****************************************************** *	I_StartupSound.																		* *																										* *	Inits all sound stuff, including allocating				* *	sound channels, setting up "fake" sound handles,	* *	and so forth.																			* ******************************************************/void I_StartupSound (void){	short										i, err;	tStdSndResourceHdrHndl	sHdr;		for (i = 0; i < kMaxMacChannels; i++)	{		gMacSndChannels[i] = NULL;		err = SndNewChannel(&gMacSndChannels[i], sampledSynth, 0 /* initMono */, NULL);		if (err != noErr)			I_Error("Error starting up sound channel #%d (Error #%d).", i, err);	}		for (i = 0; i < kMaxMacChannels; i++)	{ 		gMacSndHandles[i] = (tStdSndResourceHdrHndl) NewHandle(sizeof(tStdSndResourceHdr)); 		if (gMacSndHandles[i] == NULL) 			I_Error("Error allocating sound handle #%d.", i);				MoveHHi((Handle) gMacSndHandles[i]);		HLock((Handle) gMacSndHandles[i]);			 	sHdr = (tStdSndResourceHdrHndl) gMacSndHandles[i];				(**sHdr).format = 1;		(**sHdr).numModifiers = 1;		(**sHdr).modNumber = sampledSynth;		(**sHdr).modInit = initMono;		(**sHdr).numCommands = 1;		(**sHdr).cmd = 0x8051;		(**sHdr).param1 = 0;		(**sHdr).param2 = 0x00000014;		(**sHdr).samplePtr = 0L;		(**sHdr).numFrames = 0L;		(**sHdr).sampleRate = rate11025khz;	// 11 khz		(**sHdr).loopStart = 0L;		(**sHdr).loopEnd = 0L;		(**sHdr).encode = 0;		(**sHdr).baseFrequency = 0x3C;	}		// gNumChannels = kMaxMacChannels;}/****************************************************** *	I_ShutdownSound.																	* *																										* *	Shuts down the sound functions.										* ******************************************************/void I_ShutdownSound (void){	int		i;		S_PauseSound();		for (i = 0; i < kMaxMacChannels; i++)	{		if (gMacSndChannels[i] != NULL)		{			SndDisposeChannel(gMacSndChannels[i], TRUE);			gMacSndChannels[i] = NULL;		}				if (gMacSndHandles[i] != NULL)		{			DisposeHandle((Handle)gMacSndHandles[i]);			gMacSndHandles[i] = NULL;		}	}		if (gQuickTimeInstalled)	{		S_StopMusic();		if (gQuickTimeLoaded)			ExitMovies();	}		// quiet and dispose of movie,	// etc.}