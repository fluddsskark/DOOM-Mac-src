#ifndef __MPW_VERSION__	#if defined(powerc) || defined (__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#endif#if defined(__powerc) && defined(__MPW_VERSION__)	#define	CursorDeviceMoveTo(a,b,c)		CrsrDevMoveTo(a,b,c)	#define CursorDeviceNextDevice(a)		CrsrDevNextDevice(a)#elif defined(__powerc)	extern pascal OSErr CrsrDevMoveTo(CursorDevicePtr ourDevice, long absX, long absY)	 TWOWORDINLINE(0x7001, 0xAADB);	extern pascal OSErr CrsrDevNextDevice(CursorDevicePtr *ourDevice)	 TWOWORDINLINE(0x700B, 0xAADB);	#define	CursorDeviceMoveTo(a,b,c)		CrsrDevMoveTo(a,b,c)	#define CursorDeviceNextDevice(a)		CrsrDevNextDevice(a)#endif#include "LionDoom.h"#include <Lion.h>#include "DoomResources.h"#define	kWNETrap							0xA860#define	kUnimplementedTrap		0xA89F#define kCursorManagerTrap		0xAADBPoint	*LMMouse = (Point *) 		0x830;Point	*LMRawMouse = (Point *) 0x82C;#include <AppleEvents.h>#include <CursorDevices.h>#include <Files.h>#include <LowMem.h>#include <Memory.h>#include <Movies.h>#include <OSUtils.h>#include <Palettes.h>#include <Processes.h>#include <SegLoad.h>#include <Strings.h>#include <ToolUtils.h>#include <ctype.h>#include <stdlib.h>#include <stdarg.h>#include "I_MAIN.PROTO.H"#include "D_NET.PROTO.H"#include "DoomDef.h"#include "R_local.h"#include "sounds.h"#include "i_sound.h"#include "I_SOUND.PROTO.H"#include "AppleTalkNet.h"#include "SerialNet.h"#include "soundst.h"#undef __LION_SHOWFRAMERATE#define __LION_SHOWFRAMERATE 0void I_ReinitMouse (void); extern musicinfo_t				*gCurrSongPlaying;		// music currently being played int											gPrevSndSfxVolume; extern int								gSndSfxVolume;			// maximum volume of a sound effect extern int								gLastSongStarted; extern int								gLastSongLooping; extern Boolean						gQuickTimeLoaded; extern short							gCursID; extern int								turboparm; extern boolean						chat_on; extern boolean						sendsave;  extern Rect							gMainDeviceRect; extern Boolean						gHasHelpManager;  extern Boolean AmIFrontProcess (void); extern void G_DoLoadGame (FSSpec *fSpec); extern void G_DoSaveGame (FSSpec *fSpec); extern void NetUpdateNoStartTic (void); extern void M_QuitDOOM (int choice); extern void M_NewGame(int choice); extern void M_DrawNewGame (void); extern void S_ChangeMusic (int musicnum, int looping); extern void KeyboardPrefsDialog (Boolean inInitial); extern void EditChatMacros (Boolean inInitial); extern void ReadActionKeys (void); extern void AboutBox (void); extern void RestoreScreenDepth ( void ); extern void D_Display (void); extern void UpdateDoomWindow (void); extern void StatusParamText(char *one, char *two, char *three, char *four);extern void W_CloseWadFiles();/* * *	For Macintosh. * */  #define NUMKEYS	256  extern boolean				message_on; extern boolean				setsizeneeded; extern int						gMacStartTicks; extern WindowPtr			gDoomWindow; extern CGrafPtr			gOffPort; extern CGrafPtr			gOffSmallPort; extern GDHandle			gOffDevice; extern GDHandle			gMainDevice; extern Rect					gDrawRect; extern int						usejoystick; extern char					gammamsg[5][26]; extern int						viewwindowx, viewwindowy, viewheight; extern boolean				usergame; extern boolean				gamekeydown[NUMKEYS]; extern int						saveStringEnter; extern int						detailLevel;			// has default, 1 = high, 0 = normal  extern int						screenblocks; extern lighttable_t	*colormaps; extern int						colormapslength; extern boolean				st_statusbaron;				// Status bar active? extern boolean				menuactive; extern int						forwardmove[2]; extern int						sidemove[2]; extern int						gTurboScale;  boolean							gGameLoaded = false; FSSpec								gQuickSave; Boolean							gNeedsUpdate = TRUE; Boolean							gPCCommunication = false;  byte									remapMac[256]; byte									rgb16[256]; int									skipLines = 0; int									gOneTimeFullUpdate = 0; int									useCopybits = FALSE; int									useMouse = 0; CursorDevicePtr			gInputDevPtr = NULL; Point								gCenterPoint; Boolean							gPlayNetGame	= false; Boolean							gKeyPlayer		= false; Boolean							gMusicOff		= false; Boolean							gFrameRateOn	= true; Boolean							gMenuHidden = 0; RgnHandle						gOldeGrayRgn = NULL; short								gOldeMBarHeight = 0; Boolean							gInForeground = TRUE; Boolean							gHiRes = FALSE; Boolean							gLargeGraphics = TRUE;  Boolean							gCmdKeyDown; Boolean							gOptKeyDown; Boolean							gShftKeyDown; Boolean							gCntlKeyDown; Boolean							gSignalError = true; // gScanCode remaps the Macintosh key codes (virtual key codes) to Doom-compatible// values. unsigned char gScanCode[256] = {//         0       1       2       3       4       5       6       7       8       9       A       B       C       D       E       F/* 0 */  'a',    's',    'd',    'f',    'h',    'g',    'z',    'x',    'c',    'v',      0,    'b',    'q',    'w',    'e',    'r',/* 1 */  'y',    't',    '1',    '2',    '3',    '4',    '6',    '5',    '=',    '9',    '7',    '-',    '8',    '0',      0,    'o',/* 2 */  'u',      0,    'i',    'p',   0x0D,    'l',    'j',   0x27,    'k',    ';',      0,    ',',    '/',    'n',    'm',    '.',/* 3 */ '\t',    ' ',      0,KEY_BACKSPACE,0,   0x1B,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,/* 4 */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,   0x0D,      0,      0,      0,/* 5 */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,/* 6 */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,/* 7 */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,KEY_LEFTARROW,KEY_RIGHTARROW,KEY_DOWNARROW,KEY_UPARROW,0,/* 8 */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,/* 9 */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,/* A */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,/* B */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,/* C */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,/* D */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,/* E */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,/* F */    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0};/* * *	Blitters. * */#undef __NO_USE_ASM#if !defined(powerc) && !defined (__powerc) && !defined __NO_USE_ASM	// #define	Blit640		BlitDoubled	// #define Blit640Width BlitDoubledWidth		extern void Blit320 (void *src, void *dst, long rowBytes, long rows);	extern void Blit320Small (void *src, void *dst, long rowBytes, long rows);	extern void Blit640 (void *src, void *dst, long rowBytes, long rows);	extern void Blit640Skip (void *src, void *dst, long rowBytes, long rows);	extern void Blit320WidthMed (void *src, void *dst, long rowBytes, long rows, long width,		long sourceSkip);	extern void Blit320Width (void *src, void *dst, long rowBytes, long rows, long width,		long sourceSkip);	extern void Blit640Width (void *src, void *dst, long rowBytes, long rows, long width,		long sourceSkip);	extern void Blit640SkipWidth (void *src, void *dst, long rowBytes, long rows, long width,		long sourceSkip);#else	#define Blit320(a,b,c,d)				PPCBlit320(a,b,c,d)	#define Blit320Small(a,b,c,d)			PPCBlit320Small(a,b,c,d)	#define Blit640(a,b,c,d)				PPCBlit640(a,b,c,d)	#define Blit640Skip(a,b,c,d)			PPCBlit640Skip(a,b,c,d)	#define Blit320Width(a,b,c,d,e,f)		PPCBlit320Width(a,b,c,d,e,f)	#define Blit320WidthMed(a,b,c,d,e,f)	PPCBlit320WidthMed(a,b,c,d,e,f)	#define Blit640Width(a,b,c,d,e,f)		PPCBlit640Width(a,b,c,d,e,f)	#define Blit640SkipWidth(a,b,c,d,e,f)	PPCBlit640SkipWidth(a,b,c,d,e,f)		extern void PPCBlit320 (void *srcPtr, void *dstPtr, int rowBytes, int height);	extern void PPCBlit320Small (void *srcPtr, void *dstPtr, int rowBytes, int height);	extern void PPCBlit320Width (void *src, void *dst, long rowBytes, long rows, long width,		long sourceSkip);	extern void PPCBlit320WidthMed (void *src, void *dst, long rowBytes, long rows, long width,		long sourceSkip);	extern void PPCBlit640 (void *srcPtr, void *dstPtr, int rowBytes, int height);	extern void PPCBlit640Skip (void *srcPtr, void *dstPtr, int rowBytes, int height);	extern void PPCBlit640Width (void *src, void *dst, long rowBytes, long rows, long width,		long sourceSkip);	extern void PPCBlit640SkipWidth (void *src, void *dst, long rowBytes, long rows, long width,		long sourceSkip);#endif/* * *	Frame Rate stuff. * */#if __LION_SHOWFRAMERATE	int			blitTime[64];	int			blitIndex = 0;#endif/*=============================================================================							CONSTANTS=============================================================================*///#define SC_INDEX				0x3C4#define SC_RESET                0#define SC_CLOCK                1//#define SC_MAPMASK			2#define SC_CHARMAP              3#define SC_MEMMODE				4#define CRTC_INDEX			 0x3D4#define CRTC_H_TOTAL				 0#define CRTC_H_DISPEND			 1#define CRTC_H_BLANK				 2#define CRTC_H_ENDBLANK			 3#define CRTC_H_RETRACE			 4#define CRTC_H_ENDRETRACE		 5#define CRTC_V_TOTAL				 6#define CRTC_OVERFLOW				 7#define CRTC_ROWSCAN				 8#define CRTC_MAXSCANLINE		 9#define CRTC_CURSORSTART		10#define CRTC_CURSOREND			11#define CRTC_STARTHIGH			12#define CRTC_STARTLOW				13#define CRTC_CURSORHIGH			14#define CRTC_CURSORLOW			15#define CRTC_V_RETRACE			16#define CRTC_V_ENDRETRACE		17#define CRTC_V_DISPEND			18#define CRTC_OFFSET					19#define CRTC_UNDERLINE			20#define CRTC_V_BLANK				21#define CRTC_V_ENDBLANK			22#define CRTC_MODE						23#define CRTC_LINECOMPARE		24//#define GC_INDEX				0x3CE#define GC_SETRESET					0#define GC_ENABLESETRESET		1#define GC_COLORCOMPARE			2#define GC_DATAROTATE				3//#define GC_READMAP				4//#define GC_MODE						5#define GC_MISCELLANEOUS		6#define GC_COLORDONTCARE		7#define GC_BITMASK          8#define ATR_INDEX          0x3c0#define ATR_MODE							16#define ATR_OVERSCAN					17#define ATR_COLORPLANEENABLE	18#define ATR_PELPAN						19#define ATR_COLORSELECT				20//===============================#define MAXBLITCOUNT		5int             ticcount = 0L;int							blitCount = 0;boolean         novideo = 0;                // if true, stay in text mode for debugging#define KBDQUESIZE              32byte    keyboardque[KBDQUESIZE];int     kbdtail, kbdhead;#define KEY_LSHIFT      0xFE#define KEY_INS         (0x80+0x52)#define KEY_DEL         (0x80+0x53)#define KEY_PGUP        (0x80+0x49)#define KEY_PGDN        (0x80+0x51)#define KEY_HOME        (0x80+0x47)#define KEY_END         (0x80+0x4F)#define SC_RSHIFT       0x36#define SC_LSHIFT       0x2A#include "I_IBM.PROTO.H"/*byte        scantokey[128] =					{//  0           1       2       3       4       5       6       7//  8           9       A       B       C       D       E       F	0  ,    27,     '1',    '2',    '3',    '4',    '5',    '6',	'7',    '8',    '9',    '0',    '-',    '=',    KEY_BACKSPACE, 9, // 0	'q',    'w',    'e',    'r',    't',    'y',    'u',    'i',	'o',    'p',    '[',    ']',    13 ,    KEY_RCTRL,'a',  's',      // 1	'd',    'f',    'g',    'h',    'j',    'k',    'l',    ';',	39 ,    '`',    KEY_LSHIFT,92,  'z',    'x',    'c',    'v',      // 2	'b',    'n',    'm',    ',',    '.',    '/',    KEY_RSHIFT,'*',	KEY_RALT,' ',   0  ,    KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5,   // 3	KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_F10,0  ,    0  , KEY_HOME,	KEY_UPARROW,KEY_PGUP,'-',KEY_LEFTARROW,'5',KEY_RIGHTARROW,'+',KEY_END, //4	KEY_DOWNARROW,KEY_PGDN,KEY_INS,KEY_DEL,0,0,             0,              KEY_F11,	KEY_F12,0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,        // 5	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,        // 6	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0         // 7					};*///===========================================================================//// control api//typedef struct{	int				intnum;			// doom will call this interrupt	ticcmd_t		ticcmd;			// then the driver will fill in this structure} doomcontrol_t;ticcmd_t		emptycmd;doomcontrol_t	*doomcon = NULL;/******************************************************** *	I_BaseTiccmd.																				* *																											* *	No comment.																					* ********************************************************/ticcmd_t *I_BaseTiccmd (void){	if (!doomcon)		return &emptycmd;		return &doomcon->ticcmd;}//==================================================	#if defined(powerc) || defined (__powerc)	// PowerPC version	/********************************************************	 *	FixedDiv.																						*	 *																											*	 *	Calls an assembly function.													*	 ********************************************************/	 	extern fixed_t AsmFixedDiv (fixed_t d1, fixed_t d2);		fixed_t FixedDiv (fixed_t d1, fixed_t d2)	{		fixed_t temp;				if ( (abs(d1) >> 14) >= abs(d2))			temp = (d1 ^ d2) < 0 ? MININT : MAXINT;		else			return AsmFixedDiv(d1, d2);		return (temp);	}#else	// 68K Version		fixed_t FixedDiv ( fixed_t d1, fixed_t d2)		{			if ( (abs(d1) >> 14) >= abs(d2))				return (d1 ^ d2) < 0 ? MININT : MAXINT;							return DoFixedDiv(d1, d2);		}#endif // __MAC_VERSION__//===========================================================================/******************************************************** *	I_GetTime.											* *														* *	Returns the time in 1/35th second tics. See			* *	I_Sound.c for timer routines (which must be in the	* *	main segment to work correctly).					* ********************************************************/#define TRUE_TIMERint I_GetTime (void){#ifdef TRUE_TIMER	return ticcount;#else	return ++ticcount;#endif}/*===============================================================================						USER INPUT===============================================================================*//*=================== I_SetPalette== takes full 8 bit values=================*/short		remapped = 0;void I_SetPalette (byte *palette){	RGBColor		rgb;	PaletteHandle	pal;	short			i, pixelSize;	CTabHandle		ctab;	ColorSpec		*specPtr;	long			value, minValue, maxValue;	short			minIndex, maxIndex;		if ( palette == NULL )		return;		if (gMainDevice)		pixelSize = (**(**gMainDevice).gdPMap).pixelSize;	else		pixelSize = 0;		if ( gDoomWindow != NULL )	{		if (pixelSize == 8)			pal = GetPalette( gDoomWindow );		else			pal = NULL;					ctab = (**(*gOffPort).portPixMap).pmTable;		specPtr = &(**ctab).ctTable[0];				maxValue = 0;		minValue = 0x7FFFFFFF;				for (i = 0; i < 256; i++)		{			// Get red, green, blue components of color						rgb.red = (gammatable[usegamma][*palette++]);			rgb.green = (gammatable[usegamma][*palette++]);			rgb.blue = (gammatable[usegamma][*palette++]);						// Convert 8-bit color to 16-bit						rgb.red = (rgb.red << 8) - (rgb.red << 6);			rgb.green = (rgb.green << 8) - (rgb.green << 6);			rgb.blue = (rgb.blue << 8) - (rgb.blue << 6);						value = ((long)rgb.red) + ((long)rgb.green) + ((long)rgb.blue);						if (value > maxValue)			{				maxValue = value;				maxIndex = i;			}						if (value < minValue)			{				minValue = value;				minIndex = i;			}						remapMac[i] = i;			if (ctab)			{				specPtr[i].value = i;				specPtr[i].rgb = rgb;			}		}				// Swap black with "minimum" value, white with "maximum" value.				if (TRUE)		{			(**ctab).ctTable[minIndex].rgb = (**ctab).ctTable[255].rgb;			(**ctab).ctTable[255].rgb.red =			(**ctab).ctTable[255].rgb.green =			(**ctab).ctTable[255].rgb.blue = 0;						remapMac[255] = minIndex;			remapMac[minIndex] = 255;						(**ctab).ctTable[maxIndex].rgb = (**ctab).ctTable[0].rgb;			(**ctab).ctTable[0].rgb.red =			(**ctab).ctTable[0].rgb.green =			(**ctab).ctTable[0].rgb.blue = 65535;						remapMac[0] = maxIndex;			remapMac[maxIndex] = 0;						if (minIndex == 0)			{				remapMac[0] = 255;				remapMac[255] = maxIndex;			}		}				maxValue = 0;		minValue = 0x7FFFFFFF;		specPtr = &(**ctab).ctTable[0];				for (i = 1; i < 255; i++)		{			value = ((long)specPtr[i].rgb.red) + ((long)specPtr[i].rgb.green) + ((long)specPtr[i].rgb.blue);			if (value < minValue)			{				minIndex = i;				minValue = value;			}		}				// NO true black!				for (i = 0; i < 256; i++)			if (remapMac[i] == 255)				remapMac[i] = minIndex;				// Only do this once.		if (!remapped)		{			for (i = 0; i < colormapslength; i++)				colormaps[i] = remapMac[ colormaps[i]];			remapped = TRUE;						// Set up 16-color remap values.			for (i = 0; i < 256; i++)			{				rgb = (**ctab).ctTable[ remapMac[ i ] ].rgb;				minValue = ((long)rgb.red + (long)rgb.green + (long)rgb.blue) / 3L;				minValue = (minValue >> 12) & 0x0F;				rgb16[i] = 15 - minValue;			}		}				if (pixelSize == 8)			SetEntries(0, 255, (**ctab).ctTable);	}}/*=============================================================================						GRAPHICS MODE=============================================================================*/byte            *destscreen, *destview;#define PLANEWIDTH      80#if defined(powerc) || defined (__powerc) || defined __NO_USE_ASMtypedef struct {		int		eightLongs[8];} tEightLongs, *tEightLongsPtr;tUWord gDoubledValue[256] ={	0x0000, 0x0101, 0x0202, 0x0303, 0x0404, 0x0505, 0x0606, 0x0707,	0x0808, 0x0909, 0x0A0A, 0x0B0B, 0x0C0C, 0x0D0D, 0x0E0E, 0x0F0F,	0x1010, 0x1111, 0x1212, 0x1313, 0x1414, 0x1515, 0x1616, 0x1717,	0x1818, 0x1919, 0x1A1A, 0x1B1B, 0x1C1C, 0x1D1D, 0x1E1E, 0x1F1F,	0x2020, 0x2121, 0x2222, 0x2323, 0x2424, 0x2525, 0x2626, 0x2727,	0x2828, 0x2929, 0x2A2A, 0x2B2B, 0x2C2C, 0x2D2D, 0x2E2E, 0x2F2F,	0x3030, 0x3131, 0x3232, 0x3333, 0x3434, 0x3535, 0x3636, 0x3737,	0x3838, 0x3939, 0x3A3A, 0x3B3B, 0x3C3C, 0x3D3D, 0x3E3E, 0x3F3F,	0x4040, 0x4141, 0x4242, 0x4343, 0x4444, 0x4545, 0x4646, 0x4747,	0x4848, 0x4949, 0x4A4A, 0x4B4B, 0x4C4C, 0x4D4D, 0x4E4E, 0x4F4F,	0x5050, 0x5151, 0x5252, 0x5353, 0x5454, 0x5555, 0x5656, 0x5757,	0x5858, 0x5959, 0x5A5A, 0x5B5B, 0x5C5C, 0x5D5D, 0x5E5E, 0x5F5F,	0x6060, 0x6161, 0x6262, 0x6363, 0x6464, 0x6565, 0x6666, 0x6767,	0x6868, 0x6969, 0x6A6A, 0x6B6B, 0x6C6C, 0x6D6D, 0x6E6E, 0x6F6F,	0x7070, 0x7171, 0x7272, 0x7373, 0x7474, 0x7575, 0x7676, 0x7777,	0x7878, 0x7979, 0x7A7A, 0x7B7B, 0x7C7C, 0x7D7D, 0x7E7E, 0x7F7F,	0x8080, 0x8181, 0x8282, 0x8383, 0x8484, 0x8585, 0x8686, 0x8787,	0x8888, 0x8989, 0x8A8A, 0x8B8B, 0x8C8C, 0x8D8D, 0x8E8E, 0x8F8F,	0x9090, 0x9191, 0x9292, 0x9393, 0x9494, 0x9595, 0x9696, 0x9797,	0x9898, 0x9999, 0x9A9A, 0x9B9B, 0x9C9C, 0x9D9D, 0x9E9E, 0x9F9F,	0xA0A0, 0xA1A1, 0xA2A2, 0xA3A3, 0xA4A4, 0xA5A5, 0xA6A6, 0xA7A7,	0xA8A8, 0xA9A9, 0xAAAA, 0xABAB, 0xACAC, 0xADAD, 0xAEAE, 0xAFAF,	0xB0B0, 0xB1B1, 0xB2B2, 0xB3B3, 0xB4B4, 0xB5B5, 0xB6B6, 0xB7B7,	0xB8B8, 0xB9B9, 0xBABA, 0xBBBB, 0xBCBC, 0xBDBD, 0xBEBE, 0xBFBF,	0xC0C0, 0xC1C1, 0xC2C2, 0xC3C3, 0xC4C4, 0xC5C5, 0xC6C6, 0xC7C7,	0xC8C8, 0xC9C9, 0xCACA, 0xCBCB, 0xCCCC, 0xCDCD, 0xCECE, 0xCFCF,	0xD0D0, 0xD1D1, 0xD2D2, 0xD3D3, 0xD4D4, 0xD5D5, 0xD6D6, 0xD7D7,	0xD8D8, 0xD9D9, 0xDADA, 0xDBDB, 0xDCDC, 0xDDDD, 0xDEDE, 0xDFDF,	0xE0E0, 0xE1E1, 0xE2E2, 0xE3E3, 0xE4E4, 0xE5E5, 0xE6E6, 0xE7E7,	0xE8E8, 0xE9E9, 0xEAEA, 0xEBEB, 0xECEC, 0xEDED, 0xEEEE, 0xEFEF,	0xF0F0, 0xF1F1, 0xF2F2, 0xF3F3, 0xF4F4, 0xF5F5, 0xF6F6, 0xF7F7,	0xF8F8, 0xF9F9, 0xFAFA, 0xFBFB, 0xFCFC, 0xFDFD, 0xFEFE, 0xFFFF};void PPCBlit320 (void *srcPtr, void *dstPtr, int rowBytes, int height){	register tEightLongsPtr		sPtr, dPtr;	register int				amt, j;		sPtr = (tEightLongsPtr)srcPtr;	dPtr = (tEightLongsPtr)dstPtr;		amt = (rowBytes >> 2) - (320 / 4);	j = height;		while (j--)	{			*dPtr++ = *sPtr++;			*dPtr++ = *sPtr++;			*dPtr++ = *sPtr++;			*dPtr++ = *sPtr++;			*dPtr++ = *sPtr++;			*dPtr++ = *sPtr++;			*dPtr++ = *sPtr++;			*dPtr++ = *sPtr++;		*dPtr++ = *sPtr++;		*dPtr++ = *sPtr++;				dPtr = (tEightLongsPtr) ((int *)dPtr + amt);	}}void PPCBlit320Small (void *srcPtr, void *dstPtr, int rowBytes, int height){	PPCBlit320Width(srcPtr, dstPtr, rowBytes, height, 320, 0);}typedef struct {	long		myLong[8];} tMy32ByteStruct;void PPCBlit320Width (void *src, void *dst, long rowBytes, long rows, long width, long sourceSkip){	register double				*sDPtr, *dDPtr;	register int				amt, i;		amt = rowBytes - width;		sDPtr = (double*)src;	dDPtr = (double*)dst;			while (rows--)	{		i = width >> 4;					// calculate number of 16-byte chunks we can transfer		do			 					// transfer 16 bytes, 8 bytes at a time		{			double		tempDouble1, tempDouble2;						tempDouble1 = sDPtr[0];			tempDouble2 = sDPtr[1];			dDPtr[0] = tempDouble1;			sDPtr += 2;			dDPtr[1] = tempDouble2;			dDPtr += 2;		}		while (--i);				i = ((width >> 2) & 0x3);			if (i) 	// calculate number of longs left to transfer		{			register long	*a, *b;						a = (long *)dDPtr;			b = (long *)sDPtr;			dDPtr = (double *)((byte *)dDPtr + (i << 2));			sDPtr = (double *)((byte *)sDPtr + (i << 2));			while (i--)				*a++ = *b++;		}				dDPtr = (double *) (((byte *)dDPtr) + amt);		sDPtr = (double *) (((byte *)sDPtr) + sourceSkip);	}}void PPCBlit320WidthMed (void *src, void *dst, long rowBytes, long rows, long width, long sourceSkip){	register double				*sDPtr, *dDPtr, *dDPtr2;	register int				amt, i;		amt = (rowBytes - width) + rowBytes;		sDPtr = (double *)src;	dDPtr = (double *)dst;	dDPtr2 = (double *)((byte *)dDPtr + rowBytes);		while (rows--)	{		i = width >> 4;					// calculate number of 16-byte chunks we can transfer		do			 					// transfer 16 bytes, 8 bytes at a time		{			double		tempDouble1, tempDouble2;						tempDouble1 = sDPtr[0];			tempDouble2 = sDPtr[1];			dDPtr[0] = tempDouble1;			sDPtr += 2;			dDPtr2[0] = tempDouble1;			dDPtr[1] = tempDouble2;			dDPtr += 2;			dDPtr2[1] = tempDouble2;			dDPtr2 += 2;		}		while (--i);				i = ((width >> 2) & 0x3);			if (i) 	// calculate number of longs left to transfer		{			register long	*a, *b, *c;						a = (long *)dDPtr;			b = (long *)sDPtr;			c = (long *)((byte *)a + rowBytes);						dDPtr = (double *)((byte *)dDPtr + (i << 2));			sDPtr = (double *)((byte *)sDPtr + (i << 2));			while (i--)				*a++ = *c++ = *b++;		}				dDPtr = (double *) (((byte *)dDPtr) + amt);		dDPtr2 = (double *) (((byte *)dDPtr2) + amt);		sDPtr = (double *) (((byte *)sDPtr) + sourceSkip);	}}// PowerPC Assembly function#define __C_PPC_BLITTER__		1extern void BlitLargeAlign (void *draw_buffer, int rowbytes, void *destPtr, short w, short h, short modulus);/* UNUSEDvoid PPCBlit640Skip (void *srcPtr, void *dstPtr, int rowBytes, int height){	register long		*dPtr;	register byte		*sbPtr;	register int		amt, j, i;	register tUWord		*regDblValue;		amt = (rowBytes * 2) - 640;	amt >>= 2;		dPtr = (long *) dstPtr;	sbPtr = (byte *) srcPtr;		j = height;		regDblValue = (tUWord *) gDoubledValue;		while (j--)	{		// i = output byte count.		i = 640 / 16;		while (i--)		{			dPtr[0] = ((long)regDblValue[sbPtr[0]] << 16) | (regDblValue[sbPtr[1]]);			dPtr[1] = ((long)regDblValue[sbPtr[2]] << 16) | (regDblValue[sbPtr[3]]);			dPtr[2] = ((long)regDblValue[sbPtr[4]] << 16) | (regDblValue[sbPtr[5]]);			dPtr[3] = ((long)regDblValue[sbPtr[6]] << 16) | (regDblValue[sbPtr[7]]);			sbPtr += 8;			dPtr += 4;		}				dPtr += amt;	}}*/void PPCBlit640 (void *srcPtr, void *dstPtr, int rowBytes, int height){#ifdef __C_PPC_BLITTER__	PPCBlit640Width(srcPtr, dstPtr, rowBytes, height, 320, 0);#else	BlitLargeAlign(srcPtr, rowBytes, dstPtr, 640, height + 1, 320);#endif}void PPCBlit640Width (void *srcPtr, void *dstPtr, long rowBytes, long rows, long width,	long sourceSkip){#ifdef __C_PPC_BLITTER__	register double		*dPtr, *dPtr2, *save1;	register byte		*sbPtr;	register int		i, j;	register tUWord		*regDblValue;	register double		*localSpace;	tUWord				temp[8];		dPtr = (double *) dstPtr;	sbPtr = (byte *) srcPtr;		localSpace = (double *)temp;	// Point at local space on stack (cacheable)		j = rows;	rowBytes >>= 3;		dPtr2 = dPtr + rowBytes;				// Point at next scan line	save1 = dPtr2 + rowBytes;		regDblValue = (tUWord *) gDoubledValue;		// Pointer to table		while (j--)	{		i = (width << 1);				while (i >= 16)		{			register tUWord	templocal;						templocal = sbPtr[0];			temp[0] = templocal | (templocal << 8);			templocal = sbPtr[1];			temp[1] = templocal | (templocal << 8);			templocal = sbPtr[2];			temp[2] = templocal | (templocal << 8);			templocal = sbPtr[3];			temp[3] = templocal | (templocal << 8);						i -= 16;			*dPtr++ = *dPtr2++ = localSpace[0];		// 8 dest bytes						templocal = sbPtr[4];			temp[4] = templocal | (templocal << 8);			templocal = sbPtr[5];			temp[5] = templocal | (templocal << 8);			templocal = sbPtr[6];			temp[6] = templocal | (templocal << 8);			templocal = sbPtr[7];			temp[7] = templocal | (templocal << 8);						*dPtr++ = *dPtr2++ = localSpace[1];		// 8 dest bytes			sbPtr += 8;		}				i = (width >> 1) & 0x03;		while (i--)		{			*dPtr2++ = *dPtr++ = ((long)regDblValue[sbPtr[0]] << 16) | (regDblValue[sbPtr[1]]);			sbPtr += 2;		}				dPtr = save1;		sbPtr += sourceSkip;		save1 += rowBytes << 1;			// skip 2 lines		dPtr2 = dPtr + rowBytes;	}#else	BlitLargeAlign(srcPtr, rowBytes, dstPtr, width, rows + 1, 320);#endif}/* UNUSEDvoid PPCBlit640SkipWidth (void *src, void *dst, long rowBytes, long rows, long width,		long sourceSkip){	register long		*dPtr;	register byte		*sbPtr;	register int		amt, i, j;	register tUWord		*regDblValue;		dPtr = (long *) dst;	sbPtr = (byte *) src;		j = rows;		regDblValue = (tUWord *) gDoubledValue;		while (j--)	{		i = width >> 4;		// width / 16				while (i--)		{			dPtr[0] = ((long)regDblValue[sbPtr[0]] << 16) | (regDblValue[sbPtr[1]]);			dPtr[1] = ((long)regDblValue[sbPtr[2]] << 16) | (regDblValue[sbPtr[3]]);			dPtr[2] = ((long)regDblValue[sbPtr[4]] << 16) | (regDblValue[sbPtr[5]]);			dPtr[3] = ((long)regDblValue[sbPtr[6]] << 16) | (regDblValue[sbPtr[7]]);			sbPtr += 8;		// Offset by  8			dPtr += 4;		// Offset by 16		}				i = (width >> 2) & 0x03;		while (i--)		{			*dPtr++ = (regDblValue[sbPtr[0]] << 16) | (regDblValue[sbPtr[1]]);			sbPtr += 2;		}				sbPtr += sourceSkip;		dPtr += amt;	}}*/#endif // defined(powerc) || defined (__powerc)/*================ I_FinishUpdate===============*/int		gWasChatOn = 0;void I_FinishUpdate (void){	register byte		*sPtr;	register byte		*dPtr;	Rect						r;	int							rb;	Point						pt;	Boolean					windowNotFront;	Boolean					usingBalloons = false;	short						menuHeight;	#if !defined(powerc) && !defined (__powerc)	char						mmuMode;#endif	WindowPeek			doomPeek;	// Draw the frame rate into the offscreen buffer (screens[0]).	#if __LION_SHOWFRAMERATE		if (gFrameRateOn)	{		long			tc, diff;		Str255			str;		long double		fps;				tc = TickCount();				if (blitIndex == 63)			diff = (tc - blitTime[ 0 ]);		else			diff = (tc - blitTime[ blitIndex + 1 ]);				blitTime[ blitIndex ] = tc;				blitIndex++;		if (blitIndex >= 64)			blitIndex = 0;				if (diff == 0)			fps = 0.0;		else			fps = (long double)(64L * 60L) / ((long double)diff);				SetPort((GrafPtr)gOffPort);		SetGDevice(gOffDevice);			sprintf((char *)str, "%3.1Lf", fps);				if (gHiRes)			(void) M_DrawText (viewwindowx / 2 + 3, viewwindowy / 2 + 3, false, (char *)str);		else			(void) M_DrawText (viewwindowx + 3, viewwindowy + 3, false, (char *)str);				SetPort((GrafPtr)gDoomWindow);		SetGDevice(gMainDevice);	}	#endif// end FRAME RATE printing.	// Check if monitor resolution has changed		r = (**gMainDevice).gdRect; // current rectangle		// Does it match rectangle we got before?	if (gMainDeviceRect.bottom != r.bottom || gMainDeviceRect.right != r.right)	{		SizeWindow(gDoomWindow, r.right - r.left, r.bottom -r.top, true);		gMainDeviceRect = r;				if (gLargeGraphics)			SetRect(&gDrawRect, 0, 0, 640, 400);		else			SetRect(&gDrawRect, 0, 0, 320, 200);				CenterRect(&gDrawRect, &gDoomWindow->portRect);		if (gDrawRect.left & 0x03)			OffsetRect(&gDrawRect, -(4 - (gDrawRect.left & 0x03)), 0);		SetPort( gDoomWindow );			BackPat( &qd.black );				ClipRect(&gDoomWindow->portRect);		PaintRect(&gDoomWindow->portRect);	}			// Macintosh menu showing or hidden?		if (gMenuHidden)		menuHeight = 0;	else		menuHeight = LMGetMBarHeight();		doomPeek = (WindowPeek) gDoomWindow;	if ( (doomPeek->visible == FALSE) )		return;		if ( EmptyRect(&(**(doomPeek->port.visRgn)).rgnBBox) )		return;		// blitCount is for only drawing the status bar every 5th frame.		if (++blitCount > MAXBLITCOUNT)		blitCount = 0;		rb = (**(**gMainDevice).gdPMap).rowBytes & 0x3FFF;		windowNotFront = (FrontWindow() != gDoomWindow);		if ((gamestate != GS_LEVEL) || windowNotFront || chat_on || gWasChatOn || menuactive || automapactive)		gOneTimeFullUpdate = 1;		gWasChatOn = chat_on;	// Copybits start	if ( gHasHelpManager )				// Is the Help Manager present?	{		if ( HMGetBalloons() )			// Is Balloon Help turned on?		{			usingBalloons = true;		}	}		if (	((**(**gMainDevice).gdPMap).pixelSize != 8) || 				!gInForeground	 														||				windowNotFront															||				usingBalloons																||				(((**gMainDevice).gdRect.right - (**gMainDevice).gdRect.left ) < 640)	||				(((( (**gMainDevice).gdRect.bottom - (**gMainDevice).gdRect.top ) - menuHeight < 400)))			 )	{		CGrafPtr		srcPort;		GrafPtr			oldPort;		GDHandle		oldDevice;				GetPort(&oldPort);		oldDevice = GetGDevice();		SetPort(gDoomWindow);		SetGDevice(gMainDevice);				if (gHiRes)			srcPort = gOffPort;		else			srcPort = gOffSmallPort;				if (!gOneTimeFullUpdate)		{			if (blitCount)	// 1, 2, 3, 4			{				Rect		dr;								if (message_on)				{				// Message bar.					r.left = 0;					r.top = 0;										dr.left = 0;					dr.top = 0;					switch (gHiRes)					{						case 2 : // Hi							r.right = 640;							r.bottom = 16;							dr.right = 640;							dr.bottom = 16;							break;						case 1 : // Med							r.right = 640;							r.bottom = 8;							dr.right = 640;							dr.bottom = 16;							break;						case 0 : // Low							r.right = 320;							r.bottom = 8;							if (gLargeGraphics)							{								dr.right = 640;								dr.bottom = 16;							}							else							{								dr.right = 320;								dr.bottom = 8;							}							break;					}										dr.left += gDrawRect.left;					dr.right += gDrawRect.left;					dr.top += gDrawRect.top;					dr.bottom += gDrawRect.top;										CopyBits(&((GrafPtr)srcPort)->portBits, &((GrafPtr)gDoomWindow)->portBits, &r, 						&dr, srcCopy, NULL);				}								if (st_statusbaron)				{				// Status bar.					r.left = 0;										switch (gHiRes)					{						case 2 :							r.right = 640;							r.top = 168 * 2;							r.bottom = 400;							dr = r;							break;						case 1 :							r.right = 640;							r.top = 168;							r.bottom = 200;							dr = r;							dr.top <<= 1;							dr.bottom <<= 1;							break;						case 0 :							r.right = 320;							r.top = 168;							r.bottom = 200;							dr = r;							if (gLargeGraphics)							{								dr.left <<= 1;								dr.top <<= 1;								dr.right <<= 1;								dr.bottom <<= 1;							}							break;					}										dr.left += gDrawRect.left;					dr.right += gDrawRect.left;					dr.top += gDrawRect.top;					dr.bottom += gDrawRect.top;										CopyBits(&((GrafPtr)srcPort)->portBits, &((GrafPtr)gDoomWindow)->portBits, &r, 						&dr, srcCopy, NULL);				}				r.left = viewwindowx;				r.right = viewwindowx + viewwidth;				r.top = viewwindowy;				r.bottom = viewwindowy + viewheight;								switch (gHiRes)				{					case 2 :						dr = r;						break;					case 1 :						dr = r;						dr.top <<= 1;						dr.bottom <<= 1;						break;					case 0 :						dr = r;						if (gLargeGraphics)						{							dr.left <<= 1;							dr.top <<= 1;							dr.right <<= 1;							dr.bottom <<= 1;						}						break;				}								dr.left += gDrawRect.left;				dr.right += gDrawRect.left;				dr.top += gDrawRect.top;				dr.bottom += gDrawRect.top;								CopyBits(&((GrafPtr)srcPort)->portBits, &((GrafPtr)gDoomWindow)->portBits, &r, 					&dr, srcCopy, NULL);			}			else			// 0				goto BlitFullScreen;		}		else		{		BlitFullScreen :					r.left = 0;			r.top = 0;						if (gHiRes == 2)			{				r.right = 640;				r.bottom = 400;			}			else if (gHiRes == 1)			{				r.right = 640;				r.bottom = 200;			}			else			{				r.right = 320;				r.bottom = 200;			}						CopyBits(&((GrafPtr)srcPort)->portBits, &((GrafPtr)gDoomWindow)->portBits, &r, 				&gDrawRect, srcCopy, NULL);		}		SetPort(oldPort);		SetGDevice(oldDevice);		gOneTimeFullUpdate = 0;		return;	}	// Copybits end		r = gDrawRect;	pt.h = r.left;	pt.v = r.top;		// LocalToGlobal	#if !defined(powerc) && !defined (__powerc)	LocalToGlobal(&pt);	if ((mmuMode = GetMMUMode()) == false32b)		SwapMMUMode(&mmuMode);#else	pt.h -= (**gMainDevice).gdRect.left;	pt.v -= (**gMainDevice).gdRect.top;#endif	ShieldCursor(&r, pt);		// see "rb" assignment above.		if (gLargeGraphics == FALSE)	{		dPtr = (byte *)(**(* ((CGrafPtr)gDoomWindow) ).portPixMap).baseAddr			+ (pt.h + (rb * pt.v));		sPtr = (byte *)screens[0];				if (!gOneTimeFullUpdate)		{			if (blitCount)	// 1, 2, 3, 4			{				sPtr += viewwindowx + viewwindowy * kScreenWidth;				dPtr += viewwindowx + (viewwindowy * rb);								Blit320Width (sPtr, dPtr, rb, viewheight, viewwidth, kScreenWidth -					viewwidth);			}			else			// 0				Blit320Small (sPtr, dPtr, rb, 200);		}		else			Blit320Small (sPtr, dPtr, rb, 200);	}	else	{		dPtr = (byte *)(**(* ((CGrafPtr)gDoomWindow) ).portPixMap).baseAddr			+ (pt.h + (rb * pt.v));		sPtr = (byte *)screens[0];				if (!gOneTimeFullUpdate)		{			if (blitCount)	// 1, 2, 3, 4			{			Blit3DView :				// Just the 3D view area.								if (gHiRes == 2)				{					sPtr += viewwindowx + viewwindowy * kHiResRowBytes;					dPtr += viewwindowx + (viewwindowy * rb);					Blit320Width (sPtr, dPtr, rb, viewheight, viewwidth,						kHiResRowBytes - viewwidth);				}				else if (gHiRes == 1)				{					sPtr += viewwindowx + (viewwindowy >> 1) * kHiResRowBytes;					dPtr += viewwindowx + (viewwindowy * rb);										Blit320WidthMed (sPtr, dPtr, rb, viewheight >> 1, viewwidth,						kHiResRowBytes - viewwidth);				}				else				{					sPtr += viewwindowx + viewwindowy * kScreenWidth;					dPtr += (viewwindowx << 1) + ((viewwindowy * rb) << 1);										Blit640Width (sPtr, dPtr, rb, viewheight, viewwidth, kScreenWidth -						viewwidth);				}			}			else 			// 0			{				if (message_on)				{				// Message bar.					if (gHiRes == 2)					{						Blit320Width (sPtr, dPtr, rb, 14, kHiResScreenWidth,							kHiResRowBytes - kHiResScreenWidth);					}					else if (gHiRes == 1)					{						Blit320WidthMed (sPtr, dPtr, rb, 7, kHiResScreenWidth,							kHiResRowBytes - kHiResScreenWidth);					}					else					{						Blit640 (sPtr, dPtr, rb, 7);					}				}								if (st_statusbaron)				{				// Status bar.					if (gHiRes == 2)					{						Blit320Width (sPtr + ((168 * 2) * kHiResRowBytes), dPtr + ((168 * 2) * rb), rb, 							64, kHiResScreenWidth, kHiResRowBytes - kHiResScreenWidth);					}					else if (gHiRes == 1)					{						Blit320WidthMed (sPtr + (168 * kHiResRowBytes), dPtr + ((168 * 2) * rb), rb, 							32, kHiResScreenWidth, kHiResRowBytes - kHiResScreenWidth);					}					else					{						Blit640 (sPtr + (168 * kScreenWidth), dPtr + ((168 * 2) * rb), rb, 32);					}				}							// Main Scene.				goto Blit3DView;			}		}		else		{			if (gHiRes == 2)				Blit320Width (sPtr, dPtr, rb, 400, kHiResScreenWidth, kHiResRowBytes - kHiResScreenWidth);			else if (gHiRes == 1)				Blit320WidthMed (sPtr, dPtr, rb, 200, kHiResScreenWidth, kHiResRowBytes - kHiResScreenWidth);			else				Blit640 (sPtr, dPtr, rb, 200);		}	}	#if !defined(powerc) && !defined (__powerc)	if (mmuMode == false32b)		SwapMMUMode(&mmuMode);#endif	gOneTimeFullUpdate = 0;	ShowCursor();}/*================= I_InitGraphics================*/void I_InitGraphics (void){#if __LION_SHOWFRAMERATE	short		i;		for (i = 0; i < 64; i++)		blitTime[i] = 0L;#endif	I_SetPalette (W_CacheLumpName ("PLAYPAL", PU_CACHE));	I_InitDiskFlash ();}/*================ HandleMenu===============*/void HandleMenu (short menuId, short menuItem){	MenuHandle		theMenu;	event_t				ev;	short					drvrRefNum;	Str255				daName;		theMenu = GetMHandle(menuId);		switch (menuId)	{		case mAppleMenu :	// Apple Menu			if (menuItem == 1)				AboutBox();			else			{				GetItem(theMenu, menuItem, daName);				drvrRefNum = OpenDeskAcc(daName);			}			break;					case mFileMenu :	// File Menu			switch (menuItem)			{				case iFileStart :					M_StartControlPanel();					M_NewGame(0);					S_StartSound(NULL, sfx_swtchn);					break;									case iFileOpen :	// Open					gameaction = ga_loadgame;					gGameLoaded = false;			// Prompt User					break;									case iFileQuickLoad : // QuickLoad : F9					ev.type = ev_keydown;					ev.data1 = KEY_F9;					D_PostEvent(&ev);					break;									case iFileClose :	// Close					ev.type = ev_keydown;					ev.data1 = KEY_F7;					D_PostEvent(&ev);					break;									case iFileSave :	// Save//					gameaction = ga_savegame;					sendsave = true;					break;									case iFileSaveAs :	// Save As//					gameaction = ga_savegame;					gGameLoaded = false;			// Prompt user					sendsave = true;					break;									case iFileQuit :	// Quit					S_StartSound(NULL,sfx_swtchn);					M_QuitDOOM(0);					break;			}			break;					case mEditMenu :	// Edit Menu			break;					case mOptionsMenu :	// Options Menu			switch (menuItem)			{				case 1 :	// Keyboard					useMouse = 0;					usejoystick = 0;					SetItemMark(theMenu, 1, checkMark);					SetItemMark(theMenu, 2, noMark);					SetItemMark(theMenu, 3, noMark);					ShowCursor();					break;									case 2 :	// Mouse/Joystick					if (!useMouse || (useMouse && usejoystick))					{						SetItemMark(theMenu, 1, noMark);						SetItemMark(theMenu, 2, checkMark);						SetItemMark(theMenu, 3, noMark);						if (!usejoystick)							HideCursor();						useMouse = 1;						usejoystick = 0;						I_ReinitMouse();					}					break;									case 3 :					if (!usejoystick)					{						SetItemMark(theMenu, 1, noMark);						SetItemMark(theMenu, 2, noMark);						SetItemMark(theMenu, 3, checkMark);						if (!useMouse)							HideCursor();						useMouse = 1;						usejoystick = 1;					}					break;									case 5 :	// Large Graphics					gLargeGraphics = TRUE;					SetPort(gDoomWindow);					PaintRect(&gDoomWindow->portRect);					SetRect(&gDrawRect, 0, 0, 640, 400);					CenterRect(&gDrawRect, &gDoomWindow->portRect);					if (gDrawRect.left & 0x03)						OffsetRect(&gDrawRect, -(4 - (gDrawRect.left & 0x03)), 0);					SetItemMark(theMenu, 5, checkMark);					SetItemMark(theMenu, 6, noMark);					gOneTimeFullUpdate = 1;					I_FinishUpdate();					break;									case 6 :	// Small Graphics					gLargeGraphics = FALSE;					SetPort(gDoomWindow);					PaintRect(&gDoomWindow->portRect);					SetRect(&gDrawRect, 0, 0, 320, 200);					CenterRect(&gDrawRect, &gDoomWindow->portRect);					if (gDrawRect.left & 0x03)						OffsetRect(&gDrawRect, -(4 - (gDrawRect.left & 0x03)), 0);					SetItemMark(theMenu, 5, noMark);					SetItemMark(theMenu, 6, checkMark);					gOneTimeFullUpdate = 1;					I_FinishUpdate();					break;								case 8 :	// Turbo					turboparm ^= 0x01;										if (turboparm)						SetItemMark(theMenu, 8, checkMark);					else						SetItemMark(theMenu, 8, noMark);										if (turboparm)					{						forwardmove[0] = 0x19 * gTurboScale / 100;						forwardmove[1] = 0x32 * gTurboScale / 100;						sidemove[0] = 0x18 * gTurboScale / 100;						sidemove[1] = 0x28 * gTurboScale / 100;					}					else					{						forwardmove[0] = 0x19;						forwardmove[1] = 0x32;						sidemove[0] = 0x18;						sidemove[1] = 0x28;					}					break;								case 10 :	// Sound On/Off					if (gSndSfxVolume == 0)					{						gSndSfxVolume = gPrevSndSfxVolume;						SetItemMark(theMenu, 10, checkMark);						S_SetSfxVolume(gSndSfxVolume);					}					else					{						gPrevSndSfxVolume = gSndSfxVolume;						SetItemMark(theMenu, 10, noMark);						S_SetSfxVolume(0);					}					break;								case 11 :	// Music On/Off					if (gMusicOff)					{						// Turn it on												SetItemMark(theMenu, 11, checkMark);												gMusicOff = FALSE;												if (!gQuickTimeLoaded)						{							EnterMovies();							gQuickTimeLoaded = TRUE;						}												S_ChangeMusic(gLastSongStarted, gLastSongLooping);					}					else					{						SetItemMark(theMenu, 11, noMark);						gMusicOff = TRUE;						S_StopMusic();												if (gQuickTimeLoaded)						{							gQuickTimeLoaded = FALSE;							ExitMovies();						}					}					break;			}		break;			case mControlMenu : // Control menu			switch (menuItem)			{				case iControlSet : // Set Controls					KeyboardPrefsDialog(false);				break;				case iControlChat : // Set Controls					EditChatMacros(false);				break;				case iControlHelp : // Help : F1					ev.type = ev_keydown;					ev.data1 = KEY_F1;					D_PostEvent(&ev);					break;									case iControlSound : // Sound Volume : F4					ev.type = ev_keydown;					ev.data1 = KEY_F4;					D_PostEvent(&ev);					break;									case iControlGraphic : // Graphic Detail : F5					ev.type = ev_keydown;					ev.data1 = KEY_F5;					D_PostEvent(&ev);					break;				case iControlMessages : // Toggle Messages : F8					ev.type = ev_keydown;					ev.data1 = KEY_F8;					D_PostEvent(&ev);					break;									case iControlGamma : // Gamma Toggle : F11					ev.type = ev_keydown;					ev.data1 = KEY_F11;					D_PostEvent(&ev);					break;								case iControlView :					ev.type = ev_keydown;					ev.data1 = KEY_F12;					D_PostEvent(&ev);					break;									case iControlPause : // Pause					if (gamekeydown[KEY_PAUSE])						ev.type = ev_keyup;					else						ev.type = ev_keydown;					ev.data1 = KEY_PAUSE;					D_PostEvent(&ev);					break;			}			break;	}		HiliteMenu(0);}//===========================================================================/******************************************************** *	SetToMenuRect.										* *														* *	Helper function for Hide/Show menu bar.				* ********************************************************/void SetToMenuRect( RgnHandle rgn ){	Rect	menuRect;		menuRect = (**gMainDevice).gdRect; // qd.screenBits.bounds;	menuRect.bottom = gOldeMBarHeight;	RectRgn( rgn, &menuRect );}/******************************************************** *	HideMenuBar.										* *														* *	Hide the menu bar.									* ********************************************************/void HideMenuBar ( void ){	GrafPtr		oldPort;	RgnHandle	menuRgn, testRgn;		if ( !gMenuHidden )	{		GetPort( &oldPort );				// ¥ JDM this may fix the problem where the menubar gets painted over		testRgn = LMGetGrayRgn();		if ((**testRgn).rgnBBox.top == 0)		{			(**testRgn).rgnBBox.top = LMGetMBarHeight();			LMSetGrayRgn(testRgn);		}				gOldeMBarHeight = LMGetMBarHeight();		LMSetMBarHeight(0);				if ( gOldeGrayRgn == NULL )			gOldeGrayRgn = NewRgn();		CopyRgn( LMGetGrayRgn(), gOldeGrayRgn );				menuRgn = NewRgn();		SetToMenuRect( menuRgn );		UnionRgn( LMGetGrayRgn(), menuRgn, LMGetGrayRgn() );		PaintBehind( ( WindowRef )FrontWindow(), menuRgn );		CalcVisBehind( (WindowRef )FrontWindow(), menuRgn );		DisposeRgn( menuRgn );				gMenuHidden = TRUE;				SetPort( oldPort );	}}	// HideMenuBar/******************************************************** *	ShowMenuBar.										* *														* *	Make the menu bar visible.							* ********************************************************/void ShowMenuBar ( void ){	GrafPtr			oldPort;		if ( gMenuHidden ) 	{		GetPort( &oldPort );				LMSetMBarHeight(gOldeMBarHeight);		CopyRgn( gOldeGrayRgn, GetGrayRgn() );		SetToMenuRect( gOldeGrayRgn );				PaintBehind( ( WindowRef )FrontWindow(), gOldeGrayRgn );		CalcVisBehind( ( WindowRef )FrontWindow(), gOldeGrayRgn );				DrawMenuBar();		gMenuHidden = FALSE;				SetEmptyRgn( gOldeGrayRgn );				SetPort( oldPort );/*		pal = GetPalette( gDoomWindow );				for (i = 0; i < 256; i++)			SetEntryUsage(pal, i, pmCourteous, 0);				ActivatePalette( gDoomWindow ); */	}}	// ShowMenuBarvoid CheckCursor( Point mouseLocation ){	Rect				menuRect;		if (gInForeground == FALSE)		return;		if (useMouse)	{		if (!gMenuHidden)	{		HideMenuBar();		return;	}		else			return;	}		/*	if (gCmdKeyDown)	{		if (gMenuHidden)			ShowMenuBar();		return;	}	*/		menuRect = (**gMainDevice).gdRect;		if (gMenuHidden)		menuRect.bottom = gOldeMBarHeight;	else		menuRect.bottom = LMGetMBarHeight();		if ( PtInRect( mouseLocation, &menuRect ) )		ShowMenuBar();	else if (!gMenuHidden)		HideMenuBar();	}	// CheckCursor/*===================== AmIFrontProcess==	Returns TRUE if the application is the front process, FALSE= if not (or if an error occurs).====================*//*Boolean AmIFrontProcess (void){	ProcessSerialNumber		myProc, frontProc;	OSErr									err;	Boolean								ourFlag;	err = GetCurrentProcess(&myProc);	if (err != noErr)		return FALSE;			err = GetFrontProcess(&frontProc);	if (err != noErr)		return FALSE;	err = SameProcess(&myProc, &frontProc, &ourFlag);	if (err != noErr)		return FALSE;		return ourFlag;}*/unsigned char 		gKeyState[16];#define IsKeyPressed(a) ((gKeyState[ a >> 3 ] >> (a & 0x07)) & 0x01);/*===================== I_StartTic=// called by D_DoomLoop// called before processing each tic in a frame// can call D_PostEvent// asyncronous interrupt functions should maintain private ques that are// read by the syncronous functions to be converted into events===================*/#define SC_UPARROW				0x48#define SC_DOWNARROW			0x50#define SC_LEFTARROW			0x4B#define SC_RIGHTARROW			0x4D#define NUMKEYS 256extern int				key_speed, key_fire, key_strafe;extern boolean		gamekeydown[NUMKEYS];int		gFireMouseButton = 0L;int		checkWNE = 0L;Boolean gWrote = false;void I_StartTic (void){	event_t				ev;	EventRecord		macEvent;	char					c;	OSErr					err;	WindowPtr			wind;	short					part;	long					tempL;	Point					mLoc;			ReadActionKeys();	SetPort(gDoomWindow);	GetMouse(&mLoc);		if (useMouse || usejoystick)		I_ReadMouse(&mLoc);	else if (gInForeground)		ObscureCursor();		mLoc.h -= (**gMainDevice).gdRect.left;	mLoc.v -= (**gMainDevice).gdRect.top;		CheckCursor(mLoc);		if (gInForeground)	{		checkWNE++;		if (checkWNE < 4 && !chat_on)			return;		checkWNE = 0;	}	CallWNEAgain :	SetEventMask(everyEvent);		if (WaitNextEvent(everyEvent | osEvt, &macEvent, 0L, NULL))	{		switch (macEvent.what)		{			case osEvt :				switch( (macEvent.message >> 24) & 0xFF )				{					case mouseMovedMessage:						break;											case suspendResumeMessage:						if ( macEvent.message & resumeFlag )						{								gInForeground = TRUE;								HideMenuBar();								novideo = 0;								S_ResumeSound();							}							else							{								gInForeground = FALSE;								ShowMenuBar();								novideo = 1;								S_PauseSound();							}						break;				}				break;							case mouseDown :				part = FindWindow(macEvent.where, &wind);								if (part == inMenuBar)				{					gFireMouseButton = 0;										EnableItem(GetMHandle(mFileMenu), iFileOpen);					if (usergame)					{						EnableItem(GetMHandle(mFileMenu), iFileStart);						EnableItem(GetMHandle(mFileMenu), iFileClose);						EnableItem(GetMHandle(mFileMenu), iFileSave);						EnableItem(GetMHandle(mFileMenu), iFileSaveAs);					}					else					{						DisableItem(GetMHandle(mFileMenu), iFileClose);						DisableItem(GetMHandle(mFileMenu), iFileSave);						DisableItem(GetMHandle(mFileMenu), iFileSaveAs);					}										if (gamestate != GS_LEVEL)					{						DisableItem(GetMHandle(mFileMenu), iFileSave);						DisableItem(GetMHandle(mFileMenu), iFileSaveAs);					}					else					{						EnableItem(GetMHandle(mFileMenu), iFileSave);						EnableItem(GetMHandle(mFileMenu), iFileSaveAs);					}					tempL = MenuSelect(macEvent.where);										HandleMenu(HiWord(tempL), LoWord(tempL));				}				else					gFireMouseButton = 1;				break;							case kHighLevelEvent :				err = AEProcessAppleEvent(&macEvent);				break;						case mouseUp :				gFireMouseButton = 0;				break;						case keyDown :				if (macEvent.modifiers & cmdKey)				{					EnableItem(GetMHandle(mFileMenu), iFileOpen);					if (usergame)					{						EnableItem(GetMHandle(mFileMenu), iFileStart);						EnableItem(GetMHandle(mFileMenu), iFileClose);						EnableItem(GetMHandle(mFileMenu), iFileSave);						EnableItem(GetMHandle(mFileMenu), iFileSaveAs);					}					else					{						DisableItem(GetMHandle(mFileMenu), iFileClose);						DisableItem(GetMHandle(mFileMenu), iFileSave);						DisableItem(GetMHandle(mFileMenu), iFileSaveAs);					}										if (gamestate != GS_LEVEL)					{						DisableItem(GetMHandle(mFileMenu), iFileSave);						DisableItem(GetMHandle(mFileMenu), iFileSaveAs);					}					else					{						EnableItem(GetMHandle(mFileMenu), iFileSave);						EnableItem(GetMHandle(mFileMenu), iFileSaveAs);					}					// Macintosh menu.					tempL = MenuKey( macEvent.message & charCodeMask );										HandleMenu( HiWord(tempL), LoWord(tempL) );				}				else if (macEvent.modifiers & optionKey)				{					c = tolower(macEvent.message & charCodeMask);					ev.type = ev_keydown;							D_PostEvent (&ev);										switch (c)					{						case 'i' :							ev.data1 = HUSTR_KEYINDIGO;							D_PostEvent(&ev);							break;													case 'g' :							ev.data1 = HUSTR_KEYGREEN;							D_PostEvent(&ev);							break;												case 'b' :							ev.data1 = HUSTR_KEYBROWN;							D_PostEvent(&ev);							break;												case 'r' :							ev.data1 = HUSTR_KEYRED;							D_PostEvent(&ev);							break;												default :							ev.data1 = gScanCode[ (macEvent.message >> 8) & 0xFF ];							gOptKeyDown = TRUE;							D_PostEvent(&ev);							break;					}				}				else				{					gOptKeyDown = FALSE;					c = tolower(macEvent.message & charCodeMask);											// Function key?										if (c == 0x10)					{						ev.type = ev_keydown;												// Function key						switch ( macEvent.message & 0xFF00 )						{							case 0x7A00 :								ev.data1 = KEY_F1;								break;							case 0x7800 :								ev.data1 = KEY_F2;								break;							case 0x6300 :								ev.data1 = KEY_F3;								break;							case 0x7600 :								ev.data1 = KEY_F4;								break;							case 0x6000 :								ev.data1 = KEY_F5;								break;							case 0x6100 :								ev.data1 = KEY_F6;								break;							case 0x6200 :								ev.data1 = KEY_F7;								break;							case 0x6400 :								ev.data1 = KEY_F8;								break;							case 0x6500 :								ev.data1 = KEY_F9;								break;							case 0x6D00 :								ev.data1 = KEY_F10;								break;							case 0x6700 :								ev.data1 = KEY_F11;								break;							case 0x6F00 :								ev.data1 = KEY_F12;								break;							default :								goto NoKeyEvent;								break;						}												D_PostEvent(&ev);										NoKeyEvent :						;					}					else					{						// ¥¥ Debugging hack to toggle frame rate counter.						if ((c == 'Q') || (c == 'q'))							gFrameRateOn = !gFrameRateOn;												ev.type = ev_keydown;						ev.data1 = gScanCode[ (macEvent.message >> 8) & 0xFF ];						if (ev.data1)							D_PostEvent (&ev);					}				}				break;							case keyUp :				if (macEvent.modifiers & cmdKey)				{					// Macintosh menu.				}				else				{					ev.type = ev_keyup;					ev.data1 = gScanCode[ (macEvent.message >> 8) & charCodeMask ];					if (ev.data1)						D_PostEvent (&ev);				}				break;						case updateEvt :				if (gDoomWindow == (WindowPtr)macEvent.message)				{						if (gInForeground == FALSE)							UpdateDoomWindow();						else							gNeedsUpdate = TRUE;				}				break;		}	}		gamekeydown[key_fire] |= gFireMouseButton;	#if __USE_BALLOONS__	// Do we need to show a balloon?	// Test in terms of upper, left of gDrawRect		// Yes, add gDrawRect.left, top	// then LocalToGlobal(&point)	// ¥¥		// Do we need to hide a balloon?	// ¥¥// Showing balloons	// Make sure port == gDoomWindow#define kControlBarBalloons 13#define kMainMenuHelpStResID	300	if ( gHasHelpManager)		// Is the Help Manager present?	{		if ( HMGetBalloons() )	// Is Balloon Help turned on?		{			Rect						globalRect;			Rect 						pBalloonRects[kControlBarBalloons] =										 { 										 	{336, 0, 398, 91,},	 // Ammo										 	{336, 97, 398, 208}, // Health								 			{377, 214, 398, 283},// Arms								 			{341, 214, 356,  233},// Fist/Chainsaw								 			{341, 239, 356, 258},// ShotGuns/Combat Shotguns								 			{341, 263, 356, 281},// Chainguns								 			{361, 214, 376, 233},// Rocket Launchers								 			{361, 239, 376, 258},// Plasma Rifles								 			{361, 263, 376, 281},// BFG 9000										  {337, 285, 398, 356},// Mug										  {337, 359, 398, 472},// Armor										  {340, 474, 398, 494},// Keys										  {340, 502, 398, 639} // Total Ammo										  };			int							pLastBalloon = -1;			Point						globalTip;			HMMessageRecord	aHelpMsg;			Boolean					inRect;			int							index;						// mLoc (Point), in local coordinates			GetMouse(&mLoc);			mLoc.h -= gDrawRect.left;			mLoc.v -= gDrawRect.top;						aHelpMsg.hmmHelpType = khmmStringRes;						inRect = FALSE;			for ( index = 0; index < kControlBarBalloons; index++ )			{				if ( PtInRect( mLoc, &pBalloonRects[ index ] ) )				{					if ( pLastBalloon != index )					{						globalRect = pBalloonRects[ index ];						LocalToGlobal( &( botRight( globalRect ) ) );						LocalToGlobal( &( topLeft( globalRect ) ) );																		globalTip.h = gDrawRect.left + globalRect.left + (globalRect.right - globalRect.left)/2;						globalTip.v = gDrawRect.top + globalRect.top;												// STR# resource id & index												aHelpMsg.u.hmmStringRes.hmmResID = kMainMenuHelpStResID;						aHelpMsg.u.hmmStringRes.hmmIndex = index + 1;												err = HMShowBalloon( &aHelpMsg, globalTip, NULL, //&globalRect,															nil, 0, 3, kHMRegularWindow );						gWrote = true;						if ( err == hmBalloonAborted )							err = noErr;												pLastBalloon = index;					}					inRect = TRUE;					break;				}			}			if ( !inRect | !HMIsBalloon() )				pLastBalloon = -1;		}	}#endif //__USE_BALLOONS__}/**************************************************** *	NumToolboxTraps.																* *																									* *	Returns the total number of toolbox traps.			* ****************************************************/short NumToolboxTraps (void){	if (NGetTrapAddress(0xA86E, ToolTrap) == NGetTrapAddress(0xAA6E, ToolTrap))		return(0x200);	else		return(0x400);} /**************************************************** *	GetTrapType.																		* *																									* *	Returns what type of trap "theTrap" really is.	* ****************************************************/TrapType GetTrapType (short theTrap){	if (theTrap & 0x0800)		return(ToolTrap);	else		return(OSTrap);}/**************************************************** *	TrapAvailable.																	* *																									* *	Returns TRUE if the specified system trap is		* *	available.																			* ****************************************************/Boolean TrapAvailable (short trapNum){	TrapType	tType;		tType = GetTrapType(trapNum);	if (tType == ToolTrap)	{		trapNum &= 0x07FF;		if (trapNum >= NumToolboxTraps())			trapNum = kUnimplementedTrap;	}	return (NGetTrapAddress(trapNum, tType) != NGetTrapAddress(kUnimplementedTrap, ToolTrap));}/*================== StartupMouse=================*/void I_ReinitMouse (void){	Rect		r;		r = gDrawRect;		gCenterPoint.h = r.left + ((r.right - r.left) >> 1);	gCenterPoint.v = r.top + ((r.bottom - r.top) >> 1);		gInputDevPtr = NULL;		if (TrapAvailable(kCursorManagerTrap))	{		if ((CursorDeviceNextDevice(&gInputDevPtr) != noErr) || (gInputDevPtr == NULL))			gInputDevPtr = NULL; 				if (gInputDevPtr != NULL)			if (CursorDeviceMoveTo(gInputDevPtr, gCenterPoint.h, gCenterPoint.v) != noErr)				gInputDevPtr = NULL;	}	else	{		*LMMouse = gCenterPoint;		*LMRawMouse = gCenterPoint;	}}void I_StartupMouse (void){	Rect		r;		r = gDrawRect;		gCenterPoint.h = r.left + ((r.right - r.left) >> 1);	gCenterPoint.v = r.top + ((r.bottom - r.top) >> 1);		gInputDevPtr = NULL;		if (TrapAvailable(kCursorManagerTrap))	{		if ((CursorDeviceNextDevice(&gInputDevPtr) != noErr) || (gInputDevPtr == NULL))			gInputDevPtr = NULL; 				/*		if (gInputDevPtr != NULL)			if (CrsrDevMoveTo(gInputDevPtr, gCenterPoint.h, gCenterPoint.v) != noErr)				gInputDevPtr = NULL;		*/	}	else	{		/*		*LMMouse = gCenterPoint;		*LMRawMouse = gCenterPoint;		*/	}}/*================== I_ReadMouse=================*/long		lastMouseTic = 0;void I_ReadMouse (Point *currMLoc){	event_t			ev;	Point				pt;	Rect				r;	long				w, h;		if (lastMouseTic == ticcount)		return;		lastMouseTic = ticcount;//// mouse events//	if (!useMouse && !usejoystick)	{		// exception: Button works even if in keyboard mode.		return;	}	r = (**gMainDevice).gdRect;		// Center of main monitor, local coordinates.	gCenterPoint.h = ((r.right - r.left) >> 1);	gCenterPoint.v = ((r.bottom - r.top) >> 1);		// Get local coordinates (main monitor/window coordinates)	pt = *currMLoc;		// Convert to -? to ? in local coordinates.	pt.h = pt.h - gCenterPoint.h;	pt.v = pt.v - gCenterPoint.v;		if (!usejoystick)	{		pt.h <<= 2;		pt.v <<= 3;	}		pt.h = (pt.h < -319) ? -319 : pt.h;	pt.v = (pt.v < -199) ? -199 : pt.v;	pt.h = (pt.h > 319) ? 319 : pt.h;	pt.v = (pt.v > 199) ? 199 : pt.v;		ev.type = ev_mouse;	ev.data1 = Button();		// 1 = button down	ev.data2 = pt.h;	ev.data3 = -pt.v;		// Again, in local/monitor coordinates.	pt = *currMLoc;		// Move horiz. to center	pt.h = gCenterPoint.h;		// Move vert. halfway to center.	pt.v = gCenterPoint.v + ((pt.v - gCenterPoint.v) / 2);		if (usejoystick == FALSE)	{		if (gInputDevPtr != NULL)		{			// Convert to global.			pt.h += r.left;			pt.v += r.top;						if (CursorDeviceMoveTo(gInputDevPtr, pt.h, pt.v) == noErr)				;		}		else		{			*LMMouse = pt;			// Convert to global.			pt.h += r.left;			pt.v += r.top;			*LMRawMouse = pt;		}	}		D_PostEvent (&ev);}/*================= IO_ColorBlack================*//*void IO_ColorBlack (int r, int g, int b){	PaletteHandle		pal;	RGBColor			rgb;	CTabHandle			ctab;		return;		if (gOffPort != NULL)		ctab = (**(*gOffPort).portPixMap).pmTable;		if ( gDoomWindow != NULL )	{		pal = GetPalette( gDoomWindow );				if ( pal != NULL )		{			rgb.red = r;			rgb.green = g;			rgb.blue = b;						rgb.red <<= 8;			rgb.green <<= 8;			rgb.blue <<= 8;						SetEntryColor( pal, 254, &rgb );			if (ctab)				(**ctab).ctTable[0].rgb = rgb;			ActivatePalette( gDoomWindow );		}	}}*//*================= I_Init== hook interrupts and set graphics mode================*/void I_Init (void){	extern void I_StartupTimer(void);		I_StartupMouse ();	I_StartupTimer ();		HideMenuBar();}/*================= I_Shutdown== return to default system state================*/void I_Shutdown (void){	// Deallocate doomcom structure	if (doomcom != nil)		DisposePtr((Ptr) doomcom);	I_ShutdownSound ();	I_ShutdownTimer ();		W_CloseWadFiles();	ShowMenuBar();	#if __DO_DEBUG__	if (debugfile)		fclose(debugfile);#endif}/*================== I_Error=================*/boolean G_CheckDemoStatus (void);extern int gMinSep, gMaxSep;void I_Exit (void){	DisposePtr( (Ptr)screens[0] );	// Tons o memory freed up!	screens[0] = screens[1] = screens[2] = screens[3] = screens[4] = NULL;		D_QuitNetGame ();#if (1)	gCursID = 0;	InitCursor();#endif	I_Shutdown ();	ExitToShell();}void I_Error (char *error, ...){	va_list		argptr;	char		errStr[300];		va_start (argptr,error);	vsprintf (errStr, error, argptr);	c2pstr(errStr);	if (gSignalError)	{		gCursID = 0;		InitCursor();		ParamText("\pAn error has occurred:\n", (unsigned char *)errStr, "\p", "\p");		(void) Alert(rAlertErrGeneral, NULL);	}	gSignalError = false;		DisposePtr( (Ptr)screens[0] );	// Tons o memory freed up!		screens[0] = screens[1] = screens[2] = screens[3] = NULL;	D_QuitNetGame ();			va_end (argptr);	I_Shutdown ();	// ExitToShell();}/*================== I_Quit=================*/void I_Quit (void){	HideWindow(gDoomWindow);		if (gMinSep > 0)		;	if (gMaxSep < 0)		;		if (demorecording)		G_CheckDemoStatus ();	else		D_QuitNetGame ();		M_SaveDefaults ();	// scr = (byte *)W_CacheLumpName ("ENDOOM", PU_CACHE);	I_Shutdown ();	#if __profile__	ProfilerDump("\pDoomII.prof");	ProfilerTerm();#endif		RestoreScreenDepth();	ExitToShell();}/*================== CheckForTermination Check if user has pressed Command-period=================*/int CheckForTermination (void){	EventRecord		event;		if (WaitNextEvent(everyEvent, &event, 2L, (RgnHandle)0))	{		if ((event.modifiers & cmdKey) && ((char)event.message == '.'))		{			return (1);		}	}	return (0);}long GetHeapSize (void);long GetHeapSize (void){	THz		pZone;		pZone = GetZone();	return ((long)pZone->bkLim - (long)pZone);}#define		kOffscreenSize		((kHiResRowBytes * kHiResScreenHeight) + ((kScreenWidth * kScreenHeight) * 3))#define		kFreeAmount			(1024L * 300L)#define		kMusicAmount		(1024L * 100L)#define		kWADBuffer			(1024L * (80L + 15L))/*================= I_ZoneBase================*/byte *I_ZoneBase (int *size){	void	*ptr;	int		heap;		heap = FreeMem();	heap -= (kMusicAmount + kWADBuffer + kOffscreenSize + kFreeAmount);		if (heap > 0x800000L)		heap = 0x800000L;		ptr = (void *) NewPtrClear(heap);		if ((heap < 0x180000L) || (ptr == NULL))	{		DisposePtr(ptr);		I_Error("Insufficient memory to run Doom! You should have about 4MB free for Doom to run.");	}		if (size != NULL)		*size = heap;		return ptr;}/*=============================================================================					DISK ICON FLASHING=============================================================================*/void I_InitDiskFlash (void){/* ¥¥	void    *pic;	byte    *temp;	if (M_CheckParm("-cdrom"))	    pic = W_CacheLumpName ("STCDROM",PU_CACHE);	else	    pic = W_CacheLumpName ("STDISK",PU_CACHE);	temp = destscreen;	destscreen = (byte *)0xac000;	V_DrawPatchDirect (SCREENWIDTH-16,SCREENHEIGHT-16,0,pic);	destscreen = temp;	*/}// draw disk iconvoid I_BeginRead (void){/*	byte    *src,*dest;	int             y;	if (!grmode)		return;// write through all planes	outp (SC_INDEX,SC_MAPMASK);	outp (SC_INDEX+1,15);// set write mode 1	outp (GC_INDEX,GC_MODE);	outp (GC_INDEX+1,inp(GC_INDEX+1)|1);// copy to backup	src = currentscreen + 184*80 + 304/4;	dest = (byte *)0xac000 + 184*80 + 288/4;	for (y=0 ; y<16 ; y++)	{		dest[0] = src[0];		dest[1] = src[1];		dest[2] = src[2];		dest[3] = src[3];		src += 80;		dest += 80;	}// copy disk over	dest = currentscreen + 184*80 + 304/4;	src = (byte *)0xac000 + 184*80 + 304/4;	for (y=0 ; y<16 ; y++)	{		dest[0] = src[0];		dest[1] = src[1];		dest[2] = src[2];		dest[3] = src[3];		src += 80;		dest += 80;	}// set write mode 0	outp (GC_INDEX,GC_MODE);	outp (GC_INDEX+1,inp(GC_INDEX+1)&~1);	*/}// erase disk iconvoid I_EndRead (void){/* ¥¥	byte    *src,*dest;	int             y;	if (!grmode)		return;// write through all planes	outp (SC_INDEX,SC_MAPMASK);	outp (SC_INDEX+1,15);// set write mode 1	outp (GC_INDEX,GC_MODE);	outp (GC_INDEX+1,inp(GC_INDEX+1)|1);// copy disk over	dest = currentscreen + 184*80 + 304/4;	src = (byte *)0xac000 + 184*80 + 288/4;	for (y=0 ; y<16 ; y++)	{		dest[0] = src[0];		dest[1] = src[1];		dest[2] = src[2];		dest[3] = src[3];		src += 80;		dest += 80;	}// set write mode 0	outp (GC_INDEX,GC_MODE);	outp (GC_INDEX+1,inp(GC_INDEX+1)&~1);	*/}/*=============== I_AllocLow==============*/byte *I_AllocLow (int length){	void	*memPtr;		memPtr = (void *) NewPtr(length);	if ((memPtr == NULL) || (MemError()))		I_Error("I_AllocLow: couldn't allocate pointer of length %ld.", length);		return memPtr;}