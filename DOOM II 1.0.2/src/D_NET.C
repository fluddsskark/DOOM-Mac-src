#define __MAC_VERSION__#include <Lion.h>#include "LionDoom.h"#include "AppleTalkNet.h"#include "SerialNet.h"#include "CTBNet.h"#include "doomdef.h"#include "MacPCSwitches.h"#include "DebugSwitches.h"#include "NetDialogs.h"// I_pcnet.m#include "DoomResources.h"#define	NCMD_EXIT		0x80000000#define	NCMD_RETRANSMIT	0x40000000#define	NCMD_SETUP		0x20000000#define	NCMD_KILL		0x10000000		// kill game#define	NCMD_CHECKSUM	0x0fffffff#define kWaitUntilTicks	(60 * 45)		// Wait 45 seconds if no other players are around#if __DEBUG_FILE__	#include <stdio.h>#endif// IPX Routinesextern void SendPacket (int destination);extern Boolean GetPacket (long *size);extern void IPXTerminateNet (void);extern void SpinCursor (void);extern void StatusParamText(char *one, char *two, char *three, char *four);extern short gCursID;extern void BlackScreen(void);extern RedrawScreen();NetType 		gNetType; doomcom_t		*doomcom = 0;	doomdata_t		*netbuffer;		// points inside doomcomlong			tryRunCount	= 0;/*==============================================================================							NETWORKINGgametic is the tic about to (or currently being) runmaketic is the tick that hasn't had control made for it yetnettics[] has the maketics for all players a gametic cannot be run until nettics[] > gametic for all players==============================================================================*/#define	RESENDCOUNT	10#define	PL_DRONE	0x80				// bit flag in doomdata->player#include "D_NET.PROTO.H"ticcmd_t		localcmds[BACKUPTICS];ticcmd_t        netcmds[MAXPLAYERS][BACKUPTICS];int         	nettics[MAXNETNODES];boolean			nodeingame[MAXNETNODES];	// set false as nodes leave gameboolean			remoteresend[MAXNETNODES];	// set when local needs ticsint				resendto[MAXNETNODES];			// set when remote needs ticsint				resendcount[MAXNETNODES];int				nodeforplayer[MAXPLAYERS];int             maketic;int				lastnettic, skiptics;int				ticdup;		int				maxsend;	// BACKUPTICS/(2*ticdup)-1void D_ProcessEvents (void); void G_BuildTiccmd (ticcmd_t *cmd); void D_DoAdvanceDemo (void); boolean			reboundpacket;doomdata_t		reboundstore;extern void CloseStatusDialog (void);extern void StatusDialog (tLong total, tLong current);extern void DrawStatusDialog (Boolean forUpdate);extern short InitialDialog (void);/*====================== I_InitNetwork=====================*/void I_InitNetwork (void){		usergame = true;		// Allocate doomcom structure	if (!doomcom)	{		doomcom = (doomcom_t *) NewPtrClear(sizeof (doomcom_t));		if (!doomcom) 		{			I_Error("Allocation of doomcom failed");		}	}		if (!gPlayNetGame)	{	//	// single player game	//		netgame 				= false;		doomcom->id 			= DOOMCOM_ID;		gNumPlayersOnNet = doomcom->numplayers = doomcom->numnodes = 1;		doomcom->deathmatch 	= false;		doomcom->consoleplayer	= 0;		doomcom->ticdup 		= 1;		doomcom->extratics		= 0;		return;	}	else	{		netgame = true;			doomcom->skill 		= startskill;		doomcom->episode 	= startepisode;		doomcom->map 		= startmap;				doomcom->deathmatch = deathmatch;		doomcom->id 		= DOOMCOM_ID;		doomcom->ticdup 	= 1;		doomcom->extratics 	= 0;				}}int	NetbufferSize (void){	int	size;		size =(sizeof(doomdata_t) - (sizeof(ticcmd_t) * (BACKUPTICS - netbuffer->numtics)));	return (size);//	return (((doomdata_t *)0)->cmds[netbuffer->numtics]); }unsigned NetbufferChecksum (void){	unsigned	c;	unsigned	add;	int			i;	int			l;	c = 0x1234567;	l = (NetbufferSize () - (sizeof (unsigned) ))/4;	for (i=0 ; i<l ; i++)	{		if(gPCCommunication)		{			add = LONG(((unsigned *)&netbuffer->retransmitfrom)[i]) * (i+1);		}		else		{			add = ((unsigned *)&netbuffer->retransmitfrom)[i] * (i+1);		}		c += add;	}	return c & NCMD_CHECKSUM;}int ExpandTics (int low){	int	delta;		delta = low - (maketic&0xff);		if (delta >= -64 && delta <= 64)		return (maketic&~0xff) + low;	if (delta > 64)		return (maketic&~0xff) - 256 + low;	if (delta < -64)		return (maketic&~0xff) + 256 + low;			I_Error ("ExpandTics: strange value %i at maketic %i",low,maketic);	return 0;}//============================================================================void PrintDoomData(){	#if __DATA_DEBUG__		if (netbuffer->checksum & NCMD_RETRANSMIT)		realretrans = ExpandTics (netbuffer->retransmitfrom);	else		realretrans = -1;	fprintf (debugfile," (%i + %i, R %i) [%i] "	,ExpandTics(netbuffer->starttic),netbuffer->numtics, realretrans, doomcom->datalength);	// Print doomdata in case where there is not a full ticcmd ERROR	if ((doomcom->datalength - 8) % sizeof(ticcmd_t))	{		fprintf (debugfile,"ERROR in doomdata (partial ticcmd)");				for (i=0 ; i<doomcom->datalength ; i++)			fprintf (debugfile,"0x%x ",((byte *)netbuffer)[i]);		fprintf (debugfile,"\n");	}		else	// Print valid doomdata	{		i = 0;		if (doomcom->datalength > 0)		{			// Print data up to ticcmd						fprintf (debugfile,"chk 0x%X ",netbuffer->checksum);			fprintf (debugfile,"0x%x 0x%x 0x%x 0x%x ",netbuffer->retransmitfrom,											netbuffer->starttic,											netbuffer->player,											netbuffer->numtics);			// Print the ticcmd data						for (i= 0; i< netbuffer->numtics; i++)			{				fprintf (debugfile," | ");				// print first two bytes				fprintf (debugfile,"0x%x 0x%x ",netbuffer->cmds[i].forwardmove,												netbuffer->cmds[i].sidemove);												// print angle				fprintf (debugfile,"ang 0x%x ",netbuffer->cmds[i].angleturn);				// print consist				fprintf (debugfile,"cons 0x%x ",netbuffer->cmds[i].consistancy);												// print last two bytes				fprintf (debugfile,"0x%x 0x%x ",netbuffer->cmds[i].chatchar,												netbuffer->cmds[i].buttons);			}		}		fprintf (debugfile,"\n ");	}	fflush(debugfile);#endif //__DATA_DEBUG__}/*================ HSendPacket===============*/void HSendPacket (int node, int flags){	short temp;	unsigned short flip;		if (!node)	{		netbuffer->checksum = NetbufferChecksum () | flags;		reboundstore = *netbuffer;		reboundpacket = true;		return;	}	doomcom->remotenode = node;	doomcom->datalength = NetbufferSize ();	if(gPCCommunication)	{// Flip Bytes so that we are sending info in little endian format#if __DATA_DEBUG__		fprintf(debugfile,"Send Before");		PrintDoomData();#endif //__DATA_DEBUG__		//¥¥JDM Can I do this in G_BuildTiccmd		for (temp = netbuffer->numtics; temp >0; temp--)		{			flip = netbuffer->cmds[temp-1].angleturn;			netbuffer->cmds[temp-1].angleturn = SHORT(flip);						flip = netbuffer->cmds[temp-1].consistancy;			 netbuffer->cmds[temp-1].consistancy = SHORT(flip);		}			netbuffer->checksum = LONG(NetbufferChecksum () | flags);	#if __DATA_DEBUG__		fprintf(debugfile,"Send After ");		PrintDoomData();#endif //__DATA_DEBUG__	}	// Not PC Communication	else	{#if __DATA_DEBUG__		fprintf(debugfile,"Send ");		PrintDoomData();#endif //__DATA_DEBUG__		netbuffer->checksum = NetbufferChecksum () | flags;	}	if (demoplayback)		return;	if (!netgame)		I_Error ("Tried to transmit to another node");			switch (gNetType)	{				case kAppleTalkNet:			SendDDPPacket(node, (Ptr) netbuffer, doomcom->datalength);		break;		case kSerialNet:				SerSendPacketFilter(node, (Ptr) netbuffer, doomcom->datalength);		break;		case kCTBNet:				CTBSendPacketFilter(node, (Ptr) netbuffer, doomcom->datalength);		break;		case kIPXNet:			SendPacket(node);		break;	}	}/*================ HGetPacket== Returns false if no packet is waiting===============*/boolean HGetPacket (void){		Boolean	gotPacket;	long		size;	short		temp;	unsigned 	temp2;	short		flip;	short		remoteNode;		if (reboundpacket)	{		*netbuffer = reboundstore;		doomcom->remotenode = 0;		reboundpacket = false;		return true;	}	if (!netgame)		return false;	if (demoplayback)		return false;			size =  sizeof(doomdata_t);		// ¥¥JDM Check for a packet	switch (gNetType)	{		case kAppleTalkNet:			gotPacket = ReceiveDDPPacket((Ptr) netbuffer, &size, &remoteNode);			doomcom->remotenode = remoteNode; //netbuffer->player & ~PL_DRONE;		break;		case kSerialNet:				gotPacket = SerReceivePacketFilter((Ptr) netbuffer, &size);				doomcom->remotenode = 1;		break;		case kCTBNet:				gotPacket = CTBReceivePacketFilter((Ptr) netbuffer, &size);				doomcom->remotenode = 1;;		break;		case kIPXNet:			gotPacket = GetPacket(&size);		break;	}	if (!gotPacket)	{		doomcom->remotenode = -1;		return(false);	}		// Assign size of data read	doomcom->datalength = size;			if(gPCCommunication)	{// Flip Bytes to big endian format#if __DATA_DEBUG__		fprintf(debugfile,"Get Before ");		PrintDoomData();#endif // __DATA_DEBUG__		temp2 = LONG(netbuffer->checksum);		netbuffer->checksum = temp2;	}	// Not PC Communication	else	{#if __DATA_DEBUG__		fprintf(debugfile,"Get ");		PrintDoomData();#endif // __DATA_DEBUG__	}	if (doomcom->datalength != NetbufferSize ())	{//		I_Error("bad packet length  -got 0x%x -expect 0x%x\n",size,NetbufferSize() );#if __DATA_DEBUG__		fprintf(debugfile,"bad packet length  -got 0x%x -expect 0x%x\n",size,NetbufferSize() );#endif		return true;	}		if (NetbufferChecksum () != (netbuffer->checksum&NCMD_CHECKSUM) )	{#if __SYSBEEPS__		SysBeep(10);//I_Error("bad packet checksum -got 0x%x -expect 0x%x",netbuffer->checksum&NCMD_CHECKSUM, NetbufferChecksum ());#endif#if __DATA_DEBUG__		fprintf (debugfile,"bad packet checksum -got 0x%x -expect 0x%x\n",netbuffer->checksum&NCMD_CHECKSUM, NetbufferChecksum ());#endif		return false;	}	if(gPCCommunication)	{// Flip Bytes to big endian format		for (temp = netbuffer->numtics; temp > 0; temp--)		{			flip = netbuffer->cmds[temp-1].angleturn;			netbuffer->cmds[temp-1].angleturn = SHORT(flip);						flip = netbuffer->cmds[temp-1].consistancy;			 netbuffer->cmds[temp-1].consistancy = SHORT(flip);		}	#if __DATA_DEBUG__		fprintf(debugfile,"Get After  ");		PrintDoomData();#endif //__DATA_DEBUG__	}	return true;	}/*===================== GetPackets====================*/char    exitmsg[80];void GetPackets (void){	int		netconsole;	int		netnode;	ticcmd_t	*src, *dest;	int		realend;	int		realstart;				 	while (HGetPacket ())	{		if (netbuffer->checksum & NCMD_SETUP)			continue;		// extra setup packet					netconsole = netbuffer->player & ~PL_DRONE;		netnode = doomcom->remotenode;		//		// to save bytes, only the low byte of tic numbers are sent		// Figure out what the rest of the bytes are		//		realstart = ExpandTics (netbuffer->starttic);				realend = (realstart+netbuffer->numtics);				//		// check for exiting the game		//		if (netbuffer->checksum & NCMD_EXIT)		{			if (!nodeingame[netnode])				continue;			nodeingame[netnode] = false;			playeringame[netconsole] = false;			strcpy (exitmsg, "Player 1 left the game");			exitmsg[7] += netconsole;			players[consoleplayer].message = exitmsg;						// Cancel all communication with quitting player			if (gNetType == kCTBNet)			{				CTBKillIO();				CMClose(gConn, false, NULL, 0, true);	//			netgame = false;				break;			}			else if (gNetType == kSerialNet)			{				D_QuitNetGame();				netgame = false;				break;			}						if (demorecording)				G_CheckDemoStatus ();			continue;		}		//		// check for a remote game kill		//		if (netbuffer->checksum & NCMD_KILL)			I_Error ("Killed by network driver");		nodeforplayer[netconsole] = netnode;				//		// check for retransmit request		//		if ( resendcount[netnode] <= 0 && (netbuffer->checksum & NCMD_RETRANSMIT) )		{			resendto[netnode] = ExpandTics(netbuffer->retransmitfrom);		#if __DATA_DEBUG__			if (debugfile)				fprintf (debugfile,"retransmit from %i\n", resendto[netnode]);#endif	// __DATA_DEBUG__			resendcount[netnode] = RESENDCOUNT;		}		else			resendcount[netnode]--;		//		// check for out of order / duplicated packet		//				if (realend == nettics[netnode])			continue;			#if __DATA_DEBUG__		if (realend < nettics[netnode])		{			if (debugfile)				fprintf (debugfile,"*out of order packet (%i + %i)\n" ,realstart,netbuffer->numtics);			continue;		}#endif // __DATA_DEBUG__		//		// check for a missed packet		//		if (realstart > nettics[netnode])		{		// stop processing until the other system resends the missed tics#if __DATA_DEBUG__			if (debugfile)				fprintf (debugfile,"*missed tics from %i (%i - %i)\n", netnode, realstart, nettics[netnode]);#endif // __DATA_DEBUG__			remoteresend[netnode] = true;			continue;		}	//// update command store from the packet//{	int		start;		remoteresend[netnode] = false;				start = nettics[netnode] - realstart;				src = &netbuffer->cmds[start];		while (nettics[netnode] < realend)		{			dest = &netcmds[netconsole][nettics[netnode]%BACKUPTICS];			nettics[netnode]++;			*dest = *src;			src++;		}	}}}/*=============== NetUpdate== Builds ticcmds for console player= sends out a packet=============*/int      gametime;void NetUpdate (void){	int             nowtime;	int             newtics;	int				i,j;	int				realstart;	int				gameticdiv;			//// check time//  	nowtime = I_GetTime ()/ticdup;	newtics = nowtime - gametime;	gametime = nowtime;		if (newtics <= 0)                       // nothing new to update		goto listen; 	if (skiptics <= newtics)	{		newtics -= skiptics;		skiptics = 0;	}	else	{		skiptics -= newtics;		newtics = 0;	}				netbuffer->player = consoleplayer;		//// build new ticcmds for console player//	gameticdiv = gametic/ticdup;	for (i=0 ; i<newtics ; i++)	{		I_StartTic ();		D_ProcessEvents ();		if (maketic - gameticdiv >= BACKUPTICS/2-1)			break;          // can't hold any more//printf ("mk:%i ",maketic);		G_BuildTiccmd (&localcmds[maketic%BACKUPTICS]);		maketic++;	}	if (singletics)		return;         // singletic update is syncronous		//// send the packet to the other nodes//	for (i=0 ; i<doomcom->numnodes ; i++)		if (nodeingame[i])		{			netbuffer->starttic = realstart = resendto[i];			netbuffer->numtics = maketic - realstart;			if (netbuffer->numtics > BACKUPTICS)				I_Error ("NetUpdate: netbuffer->numtics > BACKUPTICS");			resendto[i] = maketic - doomcom->extratics;				for (j=0 ; j< netbuffer->numtics ; j++)				netbuffer->cmds[j] = localcmds[(realstart+j)%BACKUPTICS];								if (remoteresend[i])			{				netbuffer->retransmitfrom = nettics[i];				HSendPacket (i, NCMD_RETRANSMIT);			}			else			{				netbuffer->retransmitfrom = 0;				HSendPacket (i, 0);			}		}//// listen for other packets//		listen:	GetPackets ();}/*======================= CheckAbort======================*/void CheckAbort (void){	event_t *ev;	int		stoptic;		stoptic = I_GetTime () + 2; 	while (I_GetTime() < stoptic) 		I_StartTic (); 		I_StartTic ();	for ( ; eventtail != eventhead; eventtail = (++eventtail)&(MAXEVENTS-1) ) 	{ 		ev = &events[eventtail]; 		if (ev->type == ev_keydown && ev->data1 == KEY_ESCAPE)		;// ¥¥JDM Warning	I_Error ("Network game synchronization aborted.");	} }/*======================= D_ArbitrateNetStart======================*/void D_ArbitrateNetStart (void){	int		i;	boolean	gotinfo[MAXNETNODES];	short 	waitAgain = kYesButton;	long	netWait;	autostart 			= true;	 	memset (gotinfo,0,sizeof(gotinfo));		// See who else is on the net	switch (gNetType)	{		case kAppleTalkNet:		break;		case kSerialNet:			gNumPlayersOnNet = 1;		break;		case kCTBNet:			gNumPlayersOnNet = 1; 		break;	}	// Assign number of players	doomcom->numplayers = doomcom->numnodes = gNumPlayersOnNet + 1;	if (doomcom->consoleplayer)	{	// listen for setup info from key player			StatusParamText("\pListening for network start info...", "\p", "\p", "\p");		DrawStatusDialog(TRUE);		netWait = TickCount();				// mprintf ("listening for network start info...\n");		while (1)		{			//¥¥ JDM Warning CheckAbort ();			if (!HGetPacket ())			{				SpinCursor();				if (TickCount() < netWait + kWaitUntilTicks)				{					continue;				}				else				{					InitCursor();					gCursID = -2;										ParamText("\pStill listening for network start info.  Would you like to continue to wait?", "\p", "\p", "\p");					waitAgain = Alert(rAlertGeneralYN, NULL);											BlackScreen();					RedrawScreen();										if (waitAgain == kYesButton)					{												StatusParamText("\pListening for network start info...", "\p", "\p", "\p");						DrawStatusDialog(TRUE);						SpinCursor();						netWait = TickCount();						continue;					}					else					{						I_Exit();					}				}			}						StatusParamText("\pGot start packet...", "\p", "\p", "\p");			DrawStatusDialog(TRUE);						if (netbuffer->checksum & NCMD_SETUP)			{				if (netbuffer->player != VERSION)					I_Error ("Different DOOM versions cannot play a net game - %d!",netbuffer->player );				startskill = netbuffer->retransmitfrom & 15;				deathmatch = (netbuffer->retransmitfrom & 0xc0) >> 6;				nomonsters = (netbuffer->retransmitfrom & 0x20) > 0;				respawnparm = (netbuffer->retransmitfrom & 0x10) > 0;				startmap = netbuffer->starttic & 0x3f;				startepisode = netbuffer->starttic >> 6;// ¥¥ JDM I Added next 2 lines because key player is waiting for packet#if __MAC_ACK__				netbuffer->player = doomcom->consoleplayer;				HSendPacket (1, NCMD_SETUP);	// ¥¥WARNING this works only for 2 players#endif //__MAC_ACK__								return;			}		}		StatusDialog(80, 36);	}	else	{	// key player, send the setup info		//mprintf ("sending network start info...\n");		StatusParamText("\pSending network start info...", "\p", "\p", "\p");		DrawStatusDialog(TRUE);		netWait = TickCount();						//¥¥ JDM Warning CheckAbort ();//¥¥JDM Warning - The do loop below used to start here#if __PC_D0__		do		{#endif		for (i=0 ; i<doomcom->numnodes ; i++)		{			SpinCursor();			netbuffer->retransmitfrom = startskill;			if (deathmatch)				netbuffer->retransmitfrom |= (deathmatch<<6);			if (nomonsters)				netbuffer->retransmitfrom |= 0x20;			if (respawnparm)				netbuffer->retransmitfrom |= 0x10;			netbuffer->starttic = startepisode * 64 + startmap;			netbuffer->player = VERSION;			netbuffer->numtics = 0;			HSendPacket (i, NCMD_SETUP);StatusParamText("\pSent start packet...", "\p", "\p", "\p");DrawStatusDialog(TRUE);		}#if !__PC_D0__		do		{#endif			// Check if we have been waiting for a long time			if (TickCount() > netWait + kWaitUntilTicks)			{				InitCursor();				gCursID = -2;								ParamText("\pStill waiting for a response.  Would you like to continue to wait?", "\p", "\p", "\p");				waitAgain = Alert(rAlertGeneralYN, NULL);										BlackScreen();				RedrawScreen();									if (waitAgain == kYesButton)				{					StatusParamText("\pSent start packet...", "\p", "\p", "\p");					DrawStatusDialog(TRUE);										SpinCursor();					netWait = TickCount();				}				else				{					I_Exit();				}			}#if 1 			for(i = 10 ; i  &&  HGetPacket(); --i) 			{				SpinCursor(); 				if((netbuffer->player&0x7f) < MAXNETNODES) 					gotinfo[netbuffer->player&0x7f] = true; 			}#else			while (HGetPacket ())			{				gotinfo[netbuffer->player&0x7f] = true;			}#endif			for (i=1 ; i<doomcom->numnodes ; i++)			{				if (!gotinfo[i])				{					break;				}			}						SpinCursor();					} while (i < doomcom->numnodes);	}	StatusDialog(80, 36);}/*===================== D_CheckNetGame== Works out player numbers among the net participants===================*/extern	int			viewangleoffset;void D_CheckNetGame (void){	int             i;		for (i=0 ; i<MAXNETNODES ; i++)	{		nodeingame[i] = false;       	nettics[i] = 0;		remoteresend[i] = false;	// set when local needs tics		resendto[i] = 0;			// which tic to start sending	}		netbuffer = &doomcom->data;	consoleplayer = displayplayer = doomcom->consoleplayer;		if (doomcom->id != DOOMCOM_ID)	{		D_QuitNetGame();		I_Error ("Doomcom buffer %d invalid!",doomcom->id);	}			if (gPlayNetGame)	{		D_ArbitrateNetStart ();	}// printf ("startskill %i  deathmatch: %i  startmap: %i  startepisode: %i\n", startskill, deathmatch, startmap, startepisode);	// read values out of doomcom	ticdup = doomcom->ticdup;	maxsend = BACKUPTICS/(2*ticdup)-1;	if (maxsend<1)		maxsend = 1;				for (i=0 ; i<doomcom->numplayers ; i++)		playeringame[i] = true;	for (i=0 ; i<doomcom->numnodes ; i++)		nodeingame[i] = true;	// printf ("player %i of %i (%i nodes)\n", consoleplayer+1, doomcom->numplayers, doomcom->numnodes);}/*==================== D_QuitNetGame== Called before quitting to leave a net game without hanging the= other players===================*/void D_QuitNetGame (void){	int             i, j;	long			tempL;		if (!netgame || !usergame || consoleplayer == -1 || demoplayback)		return;			usergame = false;	// send a bunch of packets for security	netbuffer->player = consoleplayer;	netbuffer->numtics = 0;	for (i = 0; i < 2; i++)	{		for (j = 1; j < doomcom->numnodes; j++)		{			if (nodeingame[j])			{				HSendPacket (j, NCMD_EXIT);			}		}		// I_WaitVBL (1);		Delay(2, &tempL);	}			switch (gNetType)	{		case kAppleTalkNet:			// Unregister and close socket listener			TerminateNet();		break;		case kSerialNet:			SerTerminateNet();		break;		case kCTBNet:			CTBTerminateNet();		break;		case kIPXNet:			IPXTerminateNet ();		break;	}#if __DO_DEBUG__		if (debugfile)		fclose (debugfile);#endif}/*================= TryRunTics================*/int	frametics[4], frameon;int	frameskip[4];int		oldnettics;extern	boolean	advancedemo;int		notFirstTime = 0;void TryRunTics (void){	int             i;	int             lowtic;	int             entertic;	static int		oldentertics;	int				realtics, availabletics;	int				counts;	int				numplaying;//// get real tics//				entertic = I_GetTime() / ticdup;	realtics = entertic - oldentertics;	oldentertics = entertic;//// get available tics//	NetUpdate();	lowtic = MAXINT;	numplaying = 0;	for (i = 0; i < doomcom->numnodes ; i++)	{		if (nodeingame[i])		{			numplaying++;			if (nettics[i] < lowtic)				lowtic = nettics[i];		}	}		availabletics = lowtic - (gametic / ticdup);//// decide how many tics to run//	if (realtics < availabletics - 1)		counts = realtics + 1;	else if (realtics < availabletics)		counts = realtics;	else		counts = availabletics;	if (counts < 1)		counts = 1;			frameon++;#if __DO_DEBUG__	if (debugfile)	{		tryRunCount++;		fprintf (debugfile,"count %d =======real: %i  avail: %i  game: %i\n",tryRunCount, realtics, availabletics,counts);	}#endif // __DO_DEBUG__		if (!demoplayback)	{		//=============================================================================	//	//	ideally nettics[0] should be 1 - 3 tics above lowtic	//	if we are consistantly slower, speed up time	//		for (i = 0; i < MAXPLAYERS; i++)			if (playeringame[i])				break;				if (consoleplayer == i)		{	// the key player does not adapt		}		else		{			if (nettics[0] <= nettics[nodeforplayer[i]])			{				gametime--;	//			printf ("-");			}						frameskip[frameon&3] = (oldnettics > nettics[nodeforplayer[i]]);			oldnettics = nettics[0];			if (frameskip[0] && frameskip[1] && frameskip[2] && frameskip[3])			{				skiptics = 1;	//			printf ("+");			}		}			//=============================================================================		}	// demoplayback				//	// wait for new tics if needed	//		while (lowtic < ((gametic / ticdup) + counts))			{			NetUpdate ();			lowtic = MAXINT;						for (i = 0; i < doomcom->numnodes; i++)			{				if (nodeingame[i] && nettics[i] < lowtic)					lowtic = nettics[i];			}				if (lowtic < gametic/ticdup)				I_Error ("TryRunTics: lowtic < gametic");						// don't stay in here forever -- give the menu a chance to work			if ( ((I_GetTime() / ticdup) - entertic) >= 20)			{				M_Ticker();					if (notFirstTime)					return;			}		}		notFirstTime = 1;//// run the count * ticdup dics//	while (counts--)	{		for (i = 0; i < ticdup; i++)		{			if (gametic/ticdup > lowtic)				I_Error ("gametic>lowtic");			if (advancedemo)			{				D_DoAdvanceDemo();				}			M_Ticker();			G_Ticker();			gametic++;						//			// modify command for duplicated tics			//			if (i != ticdup-1)			{				ticcmd_t	*cmd;				int			buf;				int			j;								buf = (gametic / ticdup) % BACKUPTICS; 								for (j = 0; j < MAXPLAYERS; j++)				{					cmd = &netcmds[j][buf];					cmd->chatchar = 0;					if (cmd->buttons & BT_SPECIAL)						cmd->buttons = 0;				}			}		}				NetUpdate ();					// check for new console commands	}}