	CASE ON	MACHINE MC68040	kHiResPadBytes		EQU			32;-----------------------------------------------;;	void Blit320WidthMed (void *src, void *dst, long rowBytes, ;		long rows, long width, long sourceSkip);;;	Blits "width" pixels into "dst" buffer, then blasts the same;	row into the following destination row.Blit320WidthMed PROC EXPORT		; Register usage:	;	A0			source pointer	;	A1			dest pointer #1	;	A2			dest pointer #2	;	D0			row count (-1 for dbra)	;	D1			column counter	;	D2			column counter raw (width)	;	D3			sourceSkip	;	D4			destination width (rowBytes)	;	D5			temporary values	;	D6			offset to beginning of next destination for A1 & A2		link		A6,#0	movem.l		A0-A2/D0-D6,-(SP)		movea.l		 8(A6),A0				; get source pointer	movea.l		12(A6),A1				; get destination pointer	move.l		16(A6),D4				; get rowBytes	move.l		20(A6),D0				; get rows to do	ble.s		@AbsolutelyFinished		; No rows to do!	move.l		24(A6),D2				; get width	ble.s		@AbsolutelyFinished		; No columns to do!	move.l		28(A6),D3				; get sourceSkip	subq.l		#1,D0					; for "dbra" (rows)		move.l		D4,D6					; rowBytes	asl.l		#1,D6					; * 2	sub.l		D2,D6					; minus width		movea.l		A1,A2					; copy dest pointer	add.l		D4,A2					; point to next row@RowLoop	move.l		D2,D1					; column count	lsr.l		#4,D1					; / 16	subq.l		#1,D1					; -1 for "dbra"	ble.s		@Singles@Move16Bytes	move.l		(A0)+,D5				; Move 16 bytes into destinations	move.l		D5,(A1)+	move.l		D5,(A2)+	move.l		(A0)+,D5	move.l		D5,(A1)+	move.l		D5,(A2)+	move.l		(A0)+,D5	move.l		D5,(A1)+	move.l		D5,(A2)+	move.l		(A0)+,D5	move.l		D5,(A1)+	move.l		D5,(A2)+		dbra		D1,@Move16Bytes@Singles	move.l		D2,D1					; column count	beq.s		@NoSingles	andi.l		#$F,D1					; mod 16	subq.l		#1,D1					; -1 for "dbra"	ble.s		@NoSingles@Move1Byte	move.b		(A0)+,D5	move.b		D5,(A1)+	move.b		D5,(A2)+		dbra		D1,@Move1Byte@NoSingles	add.l		D3,A0	add.l		D6,A1	add.l		D6,A2	dbra		D0,@RowLoop@AbsolutelyFinished	movem.l		(SP)+,A0-A2/D0-D6	unlk		A6	rts		endp;-----------------------------------------------;;	unsigned long AsmSwapLong (unsigned long long2flip);;;	Flips the bytes from Intel format to 68000 format in a long word,;	or vice versa.AsmSwapLong PROC EXPORT	move.b			7(A7),D0	lsl.l			#8,D0	move.b			6(A7),D0	lsl.l			#8,D0	move.b			5(A7),D0	lsl.l			#8,D0	move.b			4(A7),D0	rts		endp;-----------------------------------------------;;	unsigned word AsmSwapShort (unsigned word word2flip);;;	Flips the bytes from Intel format to 68000 format in a ;	two-byte word, or vice versa.AsmSwapShort PROC EXPORT	move.b			5(A7),D0	lsl.l			#8,D0	move.b			4(A7),D0	rts		endp;-----------------------------------------------Blit640SkipWidth PROC EXPORT;;	void Blit640SkipWidth (void *src, void *dst, long rowBytes, long rows, long width,;		long sourceSkip);;	link			A6,#0	movem.l			A0-A1/D0-D6,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register	;		D5 = Copy of long word column count		move.l		 8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3			; Row bytes	move.l		24(A6),D1			; columns wide		asl.l		#1,D3				; 2 rowbytes each pointer		asr.l		#2,D1				; convert "columns wide" to long words	move.l		D1,D6				; store a copy	subq.l		#1,D1				; minus one.	move.l		D1,D5				; store a copy		asl.l		#3,D6				; convert back to bytes * 2 (pixel-doubling)	sub.l		D6,D3				; 2 rowbytes - 1 byte-based column count		move.l		28(A6),D6			; sourceSkip		move.l		20(A6),D0			; Number of rows to do	subq.l		#1,D0				; minus one for "dbra"@RowLoop	move.l		D5,D1				; number of long words (source)@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		dbra		D1,@ColLoop		add.l		D3,A1			; Dest += Offset bytes	add.l		D6,A0			; src += sourceSkip		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A1/D0-D6	unlk		A6	rts	endp	;-----------------------------------------------	Blit640Width PROC EXPORT;;	void Blit640Width (void *src, void *dst, long rowBytes, long rows, long width,;		long sourceSkip);;	link			A6,#0	movem.l			A0-A2/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		A2 = 2ndDstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register	;		D5 = 3rd work register	;		D6 = source skip	;		D7 = Copy of long word column count		move.l		 8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3			; Row bytes	move.l		24(A6),D1			; columns wide	move.l		A1,A2	adda.l		D3,A2				; add 1 full "rowbytes"		asl.l		#1,D3				; 2 rowbytes each pointer		asr.l		#2,D1				; convert "columns wide" to long words	move.l		D1,D6				; store a copy	subq.l		#1,D1				; minus one.	move.l		D1,D7				; store a copy		asl.l		#3,D6				; convert back to bytes * 2 (pixel-doubling)	sub.l		D6,D3				; 2 rowbytes - 1 byte-based column count		move.l		28(A6),D6			; sourceSkip		move.l		20(A6),D0			; Number of rows to do	subq.l		#1,D0				; minus one for "dbra"@RowLoop	move.l		D7,D1				; number of long words (source)@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		move.l		D4, D5			;	d5 = 4,3,2,1	move.l		D4, D2			;	d2 = 4,3,2,1	swap		D5				;	d5 = 2,1,4,3	move.w		D5, D2			;	d2 = 4,3,4,3	move.w		D4, D5			;	d5 = 2,1,2,1	rol.w		#8, D2			;	d2 = 4,3,3,4	rol.w		#8, D5			;	d5 = 2,1,1,2	ror.l		#8, D2			;	d2 = 4,4,3,3	ror.l		#8, D5			;	d5 = 2,2,1,1	move.l		D2, (A1)+		;	Write out 4433,4433	move.l		D2, (A2)+	move.l		D5, (A1)+		;	Write out 2211,2211	move.l		D5, (A2)+		dbra		D1,@ColLoop		add.l		D3,A1			; Dest += Offset bytes	add.l		D3,A2	add.l		D6,A0			; src += sourceSkip		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A2/D0-D7	unlk		A6	rts		endp;-----------------------------------------------Blit320Width PROC EXPORT;;	void Blit320Width (void *src, void *dst, long rowBytes, long rows, long width,;		long sourceSkip);;	; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col repeat count	;		D2 = row bytes	;		D3 = rows	;		D4 = source skip		link			A6,#0	movem.l			A0-A1/D0-D6,-(SP)		movea.l			 8(A6),A0		; src pointer	movea.l			12(A6),A1		; dst pointer	move.l			16(A6),D2		; row bytes	move.l			24(A6),D1		; columns wide (width)	move.l			28(A6),D4		; source skip		lsr.l			#3,D1	lsl.l			#3,D1	sub.l			D1,D2			; row bytes - columns wide	asr.l			#2,D1			; / 4 = long words to move		move.l			D1,D6			; store in D6	andi.l			#7,D6			; "singles" 0-7 long words	subq.l			#1,D6			; for dbra instruction		lsr.l			#3,D1			; / 8 = 32-byte packets to move	subq.l			#1,D1			; minus 1 for dbra	move.l			D1,D5			; copy into D5: (longWords2Move - 1)		move.l			20(A6),D0		; rows	subq.l			#1,D0			; minus 1 for dbra@RowLoop	move.l			D5,D1			; 32-byte packets to move - 1	ble.s			@Singles		; if <= 0, do singles@Col16Loop	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	move.l			(A0)+,(A1)+	dbra			D1,@Col16Loop@Singles	move.l			D6,D1	ble.s			@NextRow@ColLoop	move.l			(A0)+,(A1)+	dbra			D1,@ColLoop@NextRow	adda.l			D4,A0			; source += sourceSkip	adda.l			D2,A1			; Point to next dest row	dbra			D0,@RowLoop@Done	movem.l			(SP)+,A0-A1/D0-D6	unlk			A6	rts		endp;-----------------------------------------------Blit320Small PROC EXPORT;;	void Blit320Small (void *src, void *dst, long rowBytes, long rows);;	; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col repeat count	;		D2 = row bytes	;		D3-D6 = temp registers		link			A6,#0	movem.l			A0-A1/D0-D7,-(SP)		movea.l			8(A6),A0	movea.l			12(A6),A1		move.l			16(A6),D1			; row bytes	sub.l			#320,D1				; minus 320		move.l			20(A6),D0			; rows	subq.l			#1,D0@RowLoop	movem.l			D0-D1,-(SP)		movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(SP)+,D0-D1	adda.l			D1,A1					; Point to next dest row	dbra			D0,@RowLoop	movem.l			(SP)+,A0-A1/D0-D7	unlk			A6	rts		endp;-----------------------------------------------Blit320 PROC EXPORT;;	void Blit320 (void *src, void *dst, long rowBytes, long rows);;	; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col repeat count	;		D2 = row bytes	;		D3-D6 = temp registers		link			A6,#0	movem.l			A0-A1/D0-D7,-(SP)		movea.l			8(A6),A0	movea.l			12(A6),A1		move.l			16(A6),D1			; row bytes	sub.l			#320,D1				; minus 320		move.l			20(A6),D0			; rows	subq.l			#1,D0@RowLoop	movem.l			D0-D1,-(SP)		movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(A0)+,D0-D7		; 32 bytes	movem.l			D0-D7,(A1)	adda.l			#32,A1	movem.l			(SP)+,D0-D1	adda.l			#kHiResPadBytes,A0		; Pad bytes	adda.l			D1,A1					; Point to next dest row	dbra			D0,@RowLoop	movem.l			(SP)+,A0-A1/D0-D7	unlk			A6	rts		endp;-----------------------------------------------Blit640 PROC EXPORT;;	void Blit640 (void *src, void *dst, long rowBytes, long rows);;	link			A6,#0	movem.l			A0-A2/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		A2 = 2ndDstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register		move.l		8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3	move.l		A1,A2	add.l		D3,A2	asl.l		#1,D3	sub.l		#640,D3		move.l		20(A6),D0	subq.l		#1,D0@RowLoop	move.l		#39,D1				; 40 * 16 = 640@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		move.l		D4, D5			;	d5 = 4,3,2,1	move.l		D4, D2			;	d2 = 4,3,2,1	swap		D5				;	d5 = 2,1,4,3	move.w		D5, D2			;	d2 = 4,3,4,3	move.w		D4, D5			;	d5 = 2,1,2,1	rol.w		#8, D2			;	d2 = 4,3,3,4	rol.w		#8, D5			;	d5 = 2,1,1,2	ror.l		#8, D2			;	d2 = 4,4,3,3	ror.l		#8, D5			;	d5 = 2,2,1,1	move.l		D2, (A1)+		;	Write out 4433,4433	move.l		D2, (A2)+	move.l		D5, (A1)+		;	Write out 2211,2211	move.l		D5, (A2)+		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		move.l		D4, D5			;	d5 = 4,3,2,1	move.l		D4, D2			;	d2 = 4,3,2,1	swap		D5				;	d5 = 2,1,4,3	move.w		D5, D2			;	d2 = 4,3,4,3	move.w		D4, D5			;	d5 = 2,1,2,1	rol.w		#8, D2			;	d2 = 4,3,3,4	rol.w		#8, D5			;	d5 = 2,1,1,2	ror.l		#8, D2			;	d2 = 4,4,3,3	ror.l		#8, D5			;	d5 = 2,2,1,1	move.l		D2, (A1)+		;	Write out 4433,4433	move.l		D2, (A2)+	move.l		D5, (A1)+		;	Write out 2211,2211	move.l		D5, (A2)+		dbra		D1,@ColLoop		add.l		D3,A1	add.l		D3,A2		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A2/D0-D7	unlk		A6	rts	endp;-----------------------------------------------Blit640Skip PROC EXPORT;;	void Blit640Skip (void *src, void *dst, long rowBytes, long rows);;	link			A6,#0	movem.l			A0-A3/D0-D7,-(SP)		; Register Usage:	;	;		A0 = srcPtr	;		A1 = dstPtr	;		D0 = row count	;		D1 = col count	;		D2 = work register	;		D3 = row bytes	;		D4 = 2nd work register		move.l		8(A6),A0	move.l		12(A6),A1	move.l		16(A6),D3	sub.l		#640,D3		move.l		20(A6),D0	subq.l		#1,D0@RowLoop	move.l		#39,D1				; 40 * 16 = 640@ColLoop		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		; 8 output bytes, 4 source bytes		move.l		(A0)+,D4		rol.l		#8,D4			; Get byte 1	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 2	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		rol.l		#8,D4			; Get byte 3	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	rol.l		#8,D2	rol.l		#8,D4			; Get byte 4	move.b		D4,D2	rol.l		#8,D2	move.b		D4,D2	move.l		D2,(A1)+		dbra		D1,@ColLoop		add.l		D3,A1	add.l		D3,A1	add.l		#640,A1		dbra		D0,@RowLoop		movem.l		(SP)+,A0-A3/D0-D7	unlk		A6	rts		endp		end