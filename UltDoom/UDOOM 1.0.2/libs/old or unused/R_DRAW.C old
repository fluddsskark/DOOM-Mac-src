#define __MAC_VERSION__#include "LionDoom.h"// R_draw.c#include "doomdef.h"#include "r_local.h"extern byte				remapMac[256];/*All drawing to the view buffer is accomplished in this file.  The other refreshfiles only know about ccordinates, not the architecture of the frame buffer.*/byte	*viewimage;int		viewwidth, scaledviewwidth, viewheight, viewwindowx, viewwindowy;byte	*ylookup[MAXHEIGHT];int		columnofs[MAXWIDTH];byte	translations[3][256];	// color tables for different playersvoid R_VideoErase (unsigned ofs, int count);/*==================== R_DrawColumn== Source is the top of the column to scale===================*//*extern void Asm_R_DrawColum (void *srcPtr, void *clrPtr, void *dest, int frac, 	int fracstep, int count);*/lighttable_t	*dc_colormap;int				dc_x;int				dc_yl;int				dc_yh;fixed_t			dc_iscale;fixed_t			dc_texturemid;byte			*dc_source;		// first pixel in a column (possibly virtual)int				dccount;		// just for profiling/*#if defined(NORMALUNIX) || (!defined(__WATCOMC__) && !defined(__i386) && !defined(__m68k))#include "R_DRAW.PROTO.H"void R_DrawColumn (void){	register int		count;	register byte		*dest, *regDCMap, *regDCSrc;	register fixed_t	frac, fracstep;		count = dc_yh - dc_yl;	if (count < 0)		return;				#ifdef RANGECHECK	if ((unsigned)dc_x >= SCREENWIDTH || dc_yl < 0 || dc_yh >= SCREENHEIGHT)		I_Error ("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);#endif		dest = ylookup[dc_yl] + columnofs[dc_x];		fracstep = dc_iscale;	frac = dc_texturemid + (dc_yl - centery) * fracstep;	regDCMap = dc_colormap;	regDCSrc = dc_source;	do	{		*dest = regDCMap[ regDCSrc[ (short)((frac >> FRACBITS) & 127) ] ];		dest += SCREENWIDTH;		frac += fracstep;	} while (count--);/*	#if defined(powerc) || defined (__powerc)	do	{		*dest = regDCMap[ regDCSrc[ (short)((frac >> FRACBITS) & 127) ] ];		dest += SCREENWIDTH;		frac += fracstep;	} while (count--);#else	Asm_R_DrawColum(dc_source, dc_colormap, dest, frac, fracstep, count);#endif}*/void R_DrawColumn (void){	register byte			*source, *dest, *colormap;	register unsigned int	frac, fracstep, fracstep2, fracstep3, fracstep4;		register int			count;	count = dc_yh - dc_yl + 1;	source = dc_source;	colormap = dc_colormap;	dest = ylookup[dc_yl] + columnofs[dc_x];		fracstep = dc_iscale << 9;	frac = (dc_texturemid + (dc_yl - centery) * dc_iscale) << 9;		fracstep2 = fracstep + fracstep;	fracstep3 = fracstep2 + fracstep;	fracstep4 = fracstep3 + fracstep;		while (count >= 8)	{		dest[0] = colormap[source[ (short)(frac>>25) ]];		dest[SCREENWIDTH] = colormap[source[ (short) ((frac+fracstep)>>25) ]];		dest[SCREENWIDTH*2] = colormap[source[ (short)((frac+fracstep2)>>25) ]];		dest[SCREENWIDTH*3] = colormap[source[ (short)((frac+fracstep3)>>25) ]];		frac += fracstep4;		dest[SCREENWIDTH*4] = colormap[source[ (short) (frac>>25) ]];		dest[SCREENWIDTH*5] = colormap[source[ (short) ((frac+fracstep)>>25) ]];		dest[SCREENWIDTH*6] = colormap[source[ (short) ((frac+fracstep2)>>25) ]];		dest[SCREENWIDTH*7] = colormap[source[ (short) ((frac+fracstep3)>>25) ]];		frac += fracstep4;		dest += SCREENWIDTH * 8;		count -= 8;	}		while (count > 0)	{		*dest = colormap[source[ (short) (frac>>25) ]];		dest += SCREENWIDTH;		frac += fracstep;		count--;	}}void R_DrawColumnLow (void){	register int		count;	register byte		*dest;	register byte		*remapArray, *regDCMap, *regDCSrc;	register fixed_t	frac, fracstep;		count = dc_yh - dc_yl;	if (count < 0)		return;	#ifdef RANGECHECK	if ((unsigned)dc_x >= SCREENWIDTH || dc_yl < 0 || dc_yh >= SCREENHEIGHT)		I_Error ("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);//	dccount++;#endif	dest = ylookup[dc_yl] + columnofs[dc_x];		fracstep = dc_iscale;	frac = dc_texturemid + (dc_yl-centery)*fracstep;	remapArray = remapMac;	regDCMap = dc_colormap;	regDCSrc = dc_source;		do	{		// *dest = remapArray[ regDCMap[ regDCSrc[(frac >> FRACBITS) & 127]]];		*dest = regDCMap[ regDCSrc[(frac >> FRACBITS) & 127]];		dest += SCREENWIDTH;		frac += fracstep;	} while (count--);}// #endif#define FUZZTABLE	50#ifdef __WATCOMC__	#define FUZZOFF	(SCREENWIDTH/4)#else	#define FUZZOFF	(SCREENWIDTH)#endifint		fuzzoffset[FUZZTABLE] = {FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF};int		fuzzpos = 0;void R_DrawFuzzColumn (void){	register int		count, regFuzzPos;	register byte		*dest, *remapArray, *regCMaps;	register int		*regFuzzOff;	// fixed_t				frac, fracstep;		if (!dc_yl)		dc_yl = 1;	if (dc_yh == viewheight-1)		dc_yh = viewheight - 2;		count = dc_yh - dc_yl;	if (count < 0)		return;	#ifdef RANGECHECK	if ((unsigned)dc_x >= SCREENWIDTH || dc_yl < 0 || dc_yh >= SCREENHEIGHT)		I_Error ("R_DrawFuzzColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);#endif		dest = ylookup[dc_yl] + columnofs[dc_x];		// fracstep = dc_iscale;	// frac = dc_texturemid + (dc_yl-centery) * fracstep;	remapArray = remapMac;	regCMaps = &colormaps[6 * 256];	regFuzzOff = fuzzoffset;	regFuzzPos = fuzzpos;		do	{		// *dest = colormaps[ 6*256 + dest[fuzzoffset[fuzzpos]] ];		// *dest = remapArray[ regCMaps[ dest[fuzzoffset[fuzzpos]] ]];		*dest = regCMaps[ dest[ regFuzzOff[ regFuzzPos ] ] ];		if (++regFuzzPos == FUZZTABLE)			regFuzzPos = 0;		dest += SCREENWIDTH;		// frac += fracstep;	// ¥DG¥ What does this affect?	} while (count--);		fuzzpos = regFuzzPos;}/*========================== R_DrawTranslatedColumn=========================*/byte	*dc_translation;byte	*translationtables;void R_DrawTranslatedColumn (void){	register byte			*dest;	register byte			*remapArray;	register byte			*regDCCMap;	register byte			*regDCTrans;	register byte			*regDCSrc;	register int			count;	register fixed_t		frac, fracstep;	count = dc_yh - dc_yl;	if (count < 0)		return;				#ifdef RANGECHECK	if ((unsigned)dc_x >= SCREENWIDTH || dc_yl < 0 || dc_yh >= SCREENHEIGHT)		I_Error ("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);#endif	dest = ylookup[dc_yl] + columnofs[dc_x];	fracstep = dc_iscale;	frac = dc_texturemid + (dc_yl - centery) * fracstep;	remapArray = remapMac;	regDCCMap = dc_colormap;	regDCTrans = dc_translation;	regDCSrc = dc_source;	do	{		// *dest = remapArray[ regDCCMap[ regDCTrans[ regDCSrc[ frac >> FRACBITS ]]]];		*dest = regDCCMap[ regDCTrans[ regDCSrc[ (byte) (frac >> FRACBITS) ]]];		dest += SCREENWIDTH;		frac += fracstep;	} while (count--);}/*====================== R_InitTranslationTables=====================*/void R_InitTranslationTables (void){	int		i;		translationtables = Z_Malloc (256*3+255, PU_STATIC, 0);	translationtables = (byte *)(( (int)translationtables + 255 )& ~255);	//// translate just the 16 green colors//	for (i=0 ; i<256 ; i++)	{		if (i >= 0x70 && i<= 0x7f)		{	// green, gray, brown, red			translationtables[i] = 0x60 + (i&0xf);			translationtables [i+256] = 0x40 + (i&0xf);			translationtables [i+512] = 0x20 + (i&0xf);		}		else			translationtables[i] = translationtables[i+256]			= translationtables[i+512] = i;	}}/*================== R_DrawSpan=================*/int				ds_y;int				ds_x1;int				ds_x2;lighttable_t	*ds_colormap;fixed_t			ds_xfrac;fixed_t			ds_yfrac;fixed_t			ds_xstep;fixed_t			ds_ystep;byte			*ds_source;		// start of a 64*64 tile imageint				dscount;		// just for profiling#if defined(NORMALUNIX) || (!defined(__WATCOMC__) && !defined(__i386) && !defined(__m68k))void R_DrawSpan (void){	register fixed_t	xfrac, yfrac;	register byte		*dest;	register int		count, spot;	register byte		*remapArray;	register byte		*regDSColor;	register byte		*regDSSrc;	#ifdef RANGECHECK	if (ds_x2 < ds_x1 || ds_x1<0 || ds_x2>=SCREENWIDTH	|| (unsigned)ds_y>SCREENHEIGHT)		I_Error ("R_DrawSpan: %i to %i at %i",ds_x1,ds_x2,ds_y);//	dscount++;#endif		xfrac = ds_xfrac;	yfrac = ds_yfrac;		dest = ylookup[ds_y] + columnofs[ds_x1];		count = ds_x2 - ds_x1;	remapArray = remapMac;	regDSColor = ds_colormap;	regDSSrc = ds_source;		do	{		spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		// *dest++ = remapArray[ regDSColor[ regDSSrc[spot]]];		*dest++ = regDSColor[ regDSSrc[spot]];		xfrac += ds_xstep;		yfrac += ds_ystep;	} while (count--);}/*void R_DrawSpan (void){	unsigned	position, step;	byte		*source,*colormap,*dest;	unsigned	count, spot;	unsigned	value, temp;	unsigned	xtemp, ytemp;			position = ((ds_xfrac<<10)&0xffff0000) | ((ds_yfrac>>6)&0xffff);	step = ((ds_xstep<<10)&0xffff0000) | ((ds_ystep>>6)&0xffff);			source = ds_source;	colormap = ds_colormap;	dest = ylookup[ds_y] + columnofs[ds_x1];		count = ds_x2 - ds_x1 + 1;		while (count >= 4)	{		ytemp = position>>4;		ytemp = ytemp & 4032;		xtemp = position>>26;		spot = xtemp | ytemp;		position += step;		dest[0] = colormap[source[spot]];		ytemp = position>>4;		ytemp = ytemp & 4032;		xtemp = position>>26;		spot = xtemp | ytemp;		position += step;		dest[1] = colormap[source[spot]];		ytemp = position>>4;		ytemp = ytemp & 4032;		xtemp = position>>26;		spot = xtemp | ytemp;		position += step;		dest[2] = colormap[source[spot]];		ytemp = position>>4;		ytemp = ytemp & 4032;		xtemp = position>>26;		spot = xtemp | ytemp;		position += step;		dest[3] = colormap[source[spot]];				count -= 4;		dest += 4;	}	while (count > 0)	{		ytemp = position>>4;		ytemp = ytemp & 4032;		xtemp = position>>26;		spot = xtemp | ytemp;		position += step;		*dest++ = colormap[source[spot]];		count--;	}}*/void R_DrawSpanLow (void){	register byte			*dest;	register byte			*remapArray;	register byte			*regDSCMap;	register byte			*regDSSrc;	register int			count, spot;	register fixed_t		xfrac, yfrac;	#ifdef RANGECHECK	if (ds_x2 < ds_x1 || ds_x1<0 || ds_x2>=SCREENWIDTH	|| (unsigned)ds_y>SCREENHEIGHT)		I_Error ("R_DrawSpan: %i to %i at %i",ds_x1,ds_x2,ds_y);//	dscount++;#endif		xfrac = ds_xfrac;	yfrac = ds_yfrac;		dest = ylookup[ds_y] + columnofs[ds_x1];	count = ds_x2 - ds_x1;	remapArray = remapMac;	regDSCMap = ds_colormap;	regDSSrc = ds_source;		do	{		spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		// *dest++ = remapArray[ regDSCMap[ regDSSrc[spot]]];		*dest++ = regDSCMap[ regDSSrc[spot]];		xfrac += ds_xstep;		yfrac += ds_ystep;	} while (count--);}#endif/*================== R_InitBuffer==================*/void R_InitBuffer (int width, int height){	register int	i;		viewwindowx = (SCREENWIDTH - width) >> 1;	for (i = 0; i < width; i++)		columnofs[i] = viewwindowx + i;	if (width == SCREENWIDTH)		viewwindowy = 0;	else		viewwindowy = (SCREENHEIGHT - SBARHEIGHT - height) >> 1;		for (i = 0; i < height; i++)		ylookup[i] = screens[0] + (i + viewwindowy) * SCREENWIDTH;}/*==================== R_FillBackScreen== Fills the back screen with a pattern for variable screen sizes= Also draws a beveled edge==================*/void R_FillBackScreen (void){	register byte		*src, *dest, *remapArray;	register short		x, y;	register short		i, temp;	patch_t				*patch;	char				name1[] = "FLOOR7_2";	// DOOM	char				name2[] = "GRNROCK";	// DOOM II	char				*name;		if (scaledviewwidth == 320)		return;		if (commercial)		name = name2;	else		name = name1;		src = W_CacheLumpName (name, PU_CACHE);	dest = screens[1];	remapArray = remapMac;		for (y = 0; y < SCREENHEIGHT - SBARHEIGHT; y++)	{		for (x = 0; x < SCREENWIDTH / 64; x++)		{			// memcpy (dest, src + ((y & 63) << 6), 64);						temp = ((y & 63) << 6);			for (i = 0; i < 64; i++)				dest[i] = remapArray[ src[ temp++ ]];						dest += 64;		}				/*		if (SCREENWIDTH & 63)		{			// memcpy (dest, src + ((y & 63) << 6), SCREENWIDTH & 63);			temp = ((y & 63) << 6);			for (i = 0; i < (SCREENWIDTH & 63); i++)				dest[i] = remapArray[ src[ temp++ ]];						dest += (SCREENWIDTH & 63);		}		*/	}		patch = W_CacheLumpName ("brdr_t",PU_CACHE);	for (x=0 ; x<scaledviewwidth ; x+=8)		V_DrawPatch (viewwindowx+x,viewwindowy-8,1,patch);		patch = W_CacheLumpName ("brdr_b",PU_CACHE);	for (x=0 ; x<scaledviewwidth ; x+=8)		V_DrawPatch (viewwindowx+x,viewwindowy+viewheight,1,patch);		patch = W_CacheLumpName ("brdr_l",PU_CACHE);	for (y=0 ; y<viewheight ; y+=8)		V_DrawPatch (viewwindowx-8,viewwindowy+y,1,patch);		patch = W_CacheLumpName ("brdr_r",PU_CACHE);	for (y=0 ; y<viewheight ; y+=8)		V_DrawPatch (viewwindowx+scaledviewwidth,viewwindowy+y,1,patch);	V_DrawPatch (viewwindowx-8,viewwindowy-8,1		, W_CacheLumpName ("brdr_tl",PU_CACHE));	V_DrawPatch (viewwindowx+scaledviewwidth,viewwindowy-8,1		, W_CacheLumpName ("brdr_tr",PU_CACHE));	V_DrawPatch (viewwindowx-8,viewwindowy+viewheight,1		, W_CacheLumpName ("brdr_bl",PU_CACHE));	V_DrawPatch (viewwindowx+scaledviewwidth,viewwindowy+viewheight,1		, W_CacheLumpName ("brdr_br",PU_CACHE));}void R_VideoErase (unsigned ofs, int count){	memcpy (screens[0] + ofs, screens[1] + ofs, count);}/*==================== R_DrawViewBorder== Draws the border around the view for different size windows==================*/void V_MarkRect (int x, int y, int width, int height);void R_DrawViewBorder (void){	int			top, top2, side, ofs, i;	if (scaledviewwidth == SCREENWIDTH)		return; 		top = ((SCREENHEIGHT - SBARHEIGHT) - viewheight) >> 1;	side = (SCREENWIDTH - scaledviewwidth) >> 1;		top2 = ((top << 8) + (top << 6));	// copy top and one line of left side	R_VideoErase (0, top2 + side);	// copy one line of right side and bottom	ofs = (viewheight + top) * SCREENWIDTH - side;	R_VideoErase (ofs, top2 + side);		// copy sides using wraparound	ofs = top2 + SCREENWIDTH - side;	side <<= 1;		for (i = 1; i < viewheight; i++)	{		R_VideoErase (ofs, side);		ofs += SCREENWIDTH;	}	V_MarkRect (0, 0, SCREENWIDTH, SCREENHEIGHT - SBARHEIGHT);}