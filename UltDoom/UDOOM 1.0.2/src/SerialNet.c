#ifndef __MPW_VERSION__	#if defined(powerc) || defined (__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif	#include <Serial.h>#else	// #include "GeneralStuff.h"	#include <Devices.h>	#include <Serial.h>	#include <Memory.h>	#include <Types.h>	#include <Stdio.h>#endif#include "LionDoom.h"#include <Lion.h>#include "SerialNet.h"#include "doomdef.h"#include "MacPCSwitches.h"#include "NetBuffer.h"#include "DebugSwitches.h"#include "PCMacNet.h"short	gOutputRefNum;			// Output driver reference numbershort	gInputRefNum;			// Input driver reference numberPtr		gInputBufPtr;			// Pointer to extended input bufferParamBlockRec	*gWParamBlock;	// Pointer to write parameter block recordParamBlockRec	*gRParamBlock;	// Pointer to read parameter block recorddoomdata_t		gWriteBuf;		// Buffer used for asynchronous writesCTBReadBufArr	*gSerRead;CTBWriteBufArr	*gSerWrite;int gSerialPort = kModemPort;IOCompletionUPP	gReadSerCompletionProc;pascal void ReadSerCompletion(ParmBlkPtr paramBlock);extern void SpinCursor (void);#define	kInputBufSize	2048	// Size of extended input buffer#define kConfigParam	baud57600 + data8 + noParity + stop10#define kHeaderSize (sizeof(doomdata_t) - (sizeof(ticcmd_t) * BACKUPTICS))static tMessageBufArr	*gMsgBufPtr;					// Global pointer to message bufferstatic long 						gSizeToWrite;/*___________________________________________________________________________________	SerInitializeNet		Initializes the serial driver.	___________________________________________________________________________________*/OSErr	SerInitializeNet(){	SerShk		serShake;	int			i;	OSErr		status;	Str255		outString = "\p.AOut";	Str255		inString = "\p.AIn";		if(gSerialPort == kPrinterPort)	{		outString[2] = 'B';		inString[2] = 'B';	}		// Open Input and output drivers	status = OpenDriver(outString, &gOutputRefNum);	if (status != noErr)	{//		fprintf(tempFile,"Error in opening driver AOut %d\n",status);		goto ErrorDone;	}		status = OpenDriver(inString, &gInputRefNum);	if (status != noErr)	{//		fprintf(tempFile,"Error in opening driver AIn %d\n",status);		goto ErrorDone;	}	// Change input buffer	gInputBufPtr = NewPtrClear((Size) kInputBufSize);	if (gInputBufPtr == NULL)	{//		fprintf(tempFile,"Error in Allocating serial input buffer\n");		goto ErrorDone;	}	status = SerSetBuf(gInputRefNum, gInputBufPtr, kInputBufSize);	if (status != noErr)	{//		fprintf(tempFile,"Error in Changing input buffer %d\n",status);		goto ErrorDone;	}		// Set handshake options	serShake.fXOn	= 0;	// Turn off XON/XOFF output flow control	serShake.fCTS	= 0;	// Turn off CTS/DTR flow control	serShake.errs	= 0;	// Clear error mask	serShake.evts	= 0;	// Clear event mask	serShake.fInX	= 0;	// Turn off XON/XOFF input flow control	serShake.fDTR	= 0;	// Turn off DTR input flow control		status = Control(gOutputRefNum, 14, &serShake);	if (status != noErr)	{//		fprintf(tempFile,"Error in Setting handshake options %d\n",status);		goto ErrorDone;	}		// Configure port	status = SerReset(gOutputRefNum,kConfigParam);	if (status != noErr)	{//		fprintf(tempFile,"Error in Configuring port %d\n",status);		goto ErrorDone;	}		// Allocate  param block for data to write asynchronously	gWParamBlock = (ParamBlockRec *) NewPtrClear(sizeof(ParamBlockRec));	if (gWParamBlock == NULL)	{		I_Error("Need more memory");	}		// Allocate param block for data to read asynchronously	gRParamBlock = (ParamBlockRec *) NewPtrClear(sizeof(ParamBlockRec));	if (gRParamBlock == NULL)	{		I_Error("Need more memory");	}			// Initialize write buffer	gSerWrite = (CTBWriteBufArr *) NewPtrClear(sizeof(CTBWriteBufArr));	if (gSerWrite == NULL)	{		I_Error("Memory error");	}	gSerWrite->ctbWriteReady = 0;	// Initialize read buffer	gSerRead = (CTBReadBufArr *) NewPtrClear(sizeof(CTBReadBufArr));	if (gSerRead == NULL)	{		I_Error("Memory error");	}	gSerRead->bufPend 	= -1;	gSerRead->currHdr 	= 0;	gSerRead->currData 	= 0;	gSerRead->lastEOM	= 0;	for(i = 0; i<kNumCTBReadBuffers; i++)	{		gSerRead->buf[i].end = -1;	}ErrorDone:	return(status);}/*___________________________________________________________________________________	SerTerminateNet		Terminates the message buffer.	___________________________________________________________________________________*/OSErr 	SerTerminateNet(){	SerStaRec	serStat;	OSErr		status;		// Restore default input buffer	if (gInputBufPtr)	{		// Wait until all pending writes are complete		status = SerStatus(gOutputRefNum, &serStat);		while(serStat.wrPend)		{			status = SerStatus(gOutputRefNum, &serStat);		}				status = SerStatus(gOutputRefNum, &serStat);		SerSetBuf(gInputRefNum, gInputBufPtr, 0);		DisposePtr((Ptr)gInputBufPtr);		gInputBufPtr = 0;			// Terminate all pending I/O		status = KillIO(gOutputRefNum);		if (status != noErr)		{			goto ErrorDone;		}		// Close serial driver		status = CloseDriver(gInputRefNum);		if (status != noErr)		{			goto ErrorDone;		}				status = CloseDriver(gOutputRefNum);		if (status != noErr)		{			goto ErrorDone;		}	}				if (gWParamBlock != NULL)	{		DisposePtr((Ptr)gWParamBlock);	}	if (gRParamBlock != NULL)	{		DisposePtr((Ptr)gRParamBlock);	}	// Dispose Write buffer	if (gSerWrite != NULL)	{		DisposePtr((Ptr) gSerWrite);	}	// Dispose read buffer	if (gSerRead != NULL)	{		DisposePtr((Ptr) gSerRead);	}	ErrorDone:	return(status);}//______________________________________________________________________________//// Return up to requested number of bytes in the designated place.// If all requested bytes are available, returns all bytes, num copied and true,// otherwise, return bytes available, number of bytes copied and false.//// Returns all bytes from input stream unless they are the second of two consecutive// EOM chars, or they are a non EOM char following an EOM char.// // kNumCTBReadBuffers must be at least 2 for this algorithm to work correctly.//______________________________________________________________________________long	SerGetGoodBytes(){		int				bytesCopied = 0;	int				thisBuf;	int				sendIndex;	CTBReadBuf		*thisBufPtr;	int				tryRead;	long			bytesRead;	Boolean			didLastBuf;	Boolean			done = false;	SerStaRec		serialStatus;	OSErr			status;		// Update if an asynchronous read has completed	if (gSerRead->bufPend != -1)	{#if __FILTER_DEBUG__		fprintf(debugfile,"\t\t--Buffer %d was pending\n",gSerRead->bufPend);#endif		// Find out if read is pending		status = SerStatus(gInputRefNum, &serialStatus);		if(!(serialStatus.rdPend)) 		{#if __FILTER_DEBUG__			fprintf(debugfile,"\t\t--Asynch read has completed\n");#endif			// If a read completes in Serial Driver, the data has been read			gSerRead->buf[gSerRead->bufPend].end = gRParamBlock->ioParam.ioActCount - 1;#if __FILTER_DEBUG__			fprintf(debugfile,"\t\t\t--Asynch read of %d bytes\n",gRParamBlock->ioParam.ioActCount);#endif			gSerRead->endBuf = gSerRead->bufPend;			gSerRead->bufPend = -1;		}	}	sendIndex 	= gSerRead->currData;#if __FILTER_DEBUG__	fprintf(debugfile,"\t\t--sendIndex = %d\n",sendIndex);#endif	thisBuf		= gSerRead->startBuf;	// Process each buffer until all are processed or all requested data is read	didLastBuf = false;	while (!done && !didLastBuf)	{				thisBufPtr	= &(gSerRead->buf[thisBuf]);#if __FILTER_DEBUG__		fprintf(debugfile,"\t\t--Processing buffer %d start %d end %d\n",thisBuf,thisBufPtr->start, thisBufPtr->end);#endif		// Get all the bytes needed from this buffer		while (!done && (thisBufPtr->start <= thisBufPtr->end) 					&& (sendIndex < sizeof(doomdata_t))) 		{			// If last char was not FRAMECHAR1			if(gSerRead->lastEOM == 0)			{				// Not this, nor last char was FRAMECHAR1				if (thisBufPtr->data[thisBufPtr->start] != FRAMECHAR1)				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--Read char %x \n",thisBufPtr->data[thisBufPtr->start]);#endif					gSerRead->sendBuf[sendIndex] = thisBufPtr->data[thisBufPtr->start];					sendIndex++;					bytesCopied++;				}				// This char is FRAMECHAR1, last was not				else				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--Read first EOM\n");#endif					gSerRead->lastEOM = 1;				}							}			// Last char was FRAMECHAR1			else if (gSerRead->lastEOM == 1)			{				// Last was FRAMECHAR1, this is also				if (thisBufPtr->data[thisBufPtr->start] == FRAMECHAR1)				{	#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--Read second EOM\n");	#endif					gSerRead->sendBuf[sendIndex] = thisBufPtr->data[thisBufPtr->start];					sendIndex++;								bytesCopied++;								gSerRead->lastEOM = 0;				}				// Last char was FRAMECHAR1, this is FRAMECHAR2				else if (thisBufPtr->data[thisBufPtr->start] == FRAMECHAR2)				{	#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--dropped FRAMECHAR2\n");	#endif					gSerRead->lastEOM = 0;					done = true;				}				// There is a problem, FRAMECHAR1 followed by random char				else				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--*Error, entering state 2 read %x\n",												thisBufPtr->data[thisBufPtr->start]);#endif#if __SYSBEEPS__					SysBeep(5);#endif					gSerRead->lastEOM = 2;				}			}			// We are in the process of flushing a bad packet and waiting for FRAMECHAR1			else if (gSerRead->lastEOM == 2)			{				if(thisBufPtr->data[thisBufPtr->start] == FRAMECHAR1)				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--*Error, entering state 3 read %x\n",												thisBufPtr->data[thisBufPtr->start]);#endif#if __SYSBEEPS__					SysBeep(5);#endif					gSerRead->lastEOM = 3;				}				else				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--*Error, still in state 3 read %x\n",												thisBufPtr->data[thisBufPtr->start]);#endif#if __SYSBEEPS__					SysBeep(5);#endif				}			}			// We are in the process of flushing a bad packet and waiting for FRAMECHAR2			else if (gSerRead->lastEOM == 3)			{				if(thisBufPtr->data[thisBufPtr->start] == FRAMECHAR2)				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--*Error, Entering state 4\n");#endif#if __SYSBEEPS__					SysBeep(5);#endif					gSerRead->lastEOM = 4;					done = true;				}				else				{#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t\t--*Error, state 3 to 2 read %x\n",												thisBufPtr->data[thisBufPtr->start]);#endif					gSerRead->lastEOM = 2;				}			}						thisBufPtr->start++;					}				// If we exhausted this buffer, reset it		if(thisBufPtr->start > thisBufPtr->end)		{			thisBufPtr->start 	= 0;			thisBufPtr->end 	= -1;						// advance to next buffer			if (thisBuf	!= gSerRead->endBuf)			{				thisBuf = (thisBuf + 1) % kNumCTBReadBuffers;			}			else			{				didLastBuf = true;			}								gSerRead->startBuf = thisBuf;		}			}			// If we have read a complete packet		if(done)		{#if __FILTER_DEBUG__			fprintf(debugfile,"\t\t--Clearing currData\n");#endif			gSerRead->currData = 0;		}		// If have read incomplete packet		else if (bytesCopied)		{#if __FILTER_DEBUG__			fprintf(debugfile,"\t\t-Setting currData to %d + %d\n",gSerRead->currData,bytesCopied);#endif			gSerRead->currData 	+= bytesCopied;		}				// We are reading more than sizeof(doomdata_t) data		if(sendIndex > sizeof(doomdata_t))		{#if __SYSBEEPS__			SysBeep(5);#endif			// We need to flush all this data			if (gSerRead->lastEOM == 0)			{				gSerRead->lastEOM = 2;			}		}	// Initiate read for next buffer if the next buffer is not used and not pending	if (gSerRead->bufPend == -1)	{		// endBuf is empty, so don't go to next one		if (gSerRead->buf[gSerRead->endBuf].end == -1)		{			tryRead = gSerRead->endBuf;		}		else		{			tryRead = (gSerRead->endBuf + 1) % kNumCTBReadBuffers;		}		#if __FILTER_DEBUG__		fprintf(debugfile,"\t\t--tryRead = %d\n",tryRead);#endif		if ((tryRead != gSerRead->bufPend) && (gSerRead->buf[tryRead].end == -1))		{						// Only read if there are bytes available			SerGetBuf(gInputRefNum,  &bytesRead);			if (bytesRead > 0)			{				gSerRead->bufPend = tryRead;#if __FILTER_DEBUG__				fprintf(debugfile,"\t\t--%d bytes available, read to %d\n",bytesRead,tryRead);#endif				if (bytesRead > kCTBReadBufSize)				{					bytesRead = kCTBReadBufSize;#if __FILTER_DEBUG__					fprintf(debugfile,"\t\t--Too many bytes available %d read only %d\n",bytesRead,kCTBReadBufSize);#endif				}								gRParamBlock->ioParam.ioCompletion 	= NULL;				gRParamBlock->ioParam.ioRefNum 		= gInputRefNum;							gRParamBlock->ioParam.ioBuffer 		= (Ptr) gSerRead->buf[tryRead].data;				gRParamBlock->ioParam.ioReqCount 	= bytesRead;				gRParamBlock->ioParam.ioVRefNum 	= 0;				gRParamBlock->ioParam.ioPosMode 	= 0;				gRParamBlock->ioParam.ioPosOffset 	= 0;								status = PBRead(gRParamBlock, true);								if (status != noErr)				{					I_Error("Error in reading from serial data port %d\n",status);				}			}			else			{#if __FILTER_DEBUG__				fprintf(debugfile,"\t\t\t--No bytes available\n");#endif				}		}	}		#if __FILTER_DEBUG__	fprintf(debugfile,"\t\t--LastEOM = %d\n",gSerRead->lastEOM);#endif		// Got a complete, well formed packet	if (done && gSerRead->lastEOM == 0)	{		return(true);	}		else	{		// Got a complete, bad packet		if (gSerRead->lastEOM == 4)		{#if __SYSBEEPS__					SysBeep(5);#endif			gSerRead->lastEOM = 0;		}		return(false);	}}Boolean SerReceivePacketFilter(Ptr data, Size *length){		Bytes8 *dataSrc;	Bytes8 *dataDst;	int 	i;		if (SerGetGoodBytes())	{		*length = kHeaderSize + ((doomdata_t *)(gSerRead->sendBuf))->numtics * sizeof(ticcmd_t);		if(*length <= sizeof(doomdata_t))		{			dataSrc = (Bytes8 *) gSerRead->sendBuf;			dataDst = (Bytes8 *) data;						for (i = *length; i > 0; i -= 8)			{				*dataDst++ = *dataSrc++;			}//			BlockMove(gSerRead->sendBuf, data, *length);	//¥¥ JDM Warning accelerate this line			return(true);		}		else		{#if __FILTER_DEBUG__			fprintf(debugfile,"\t--*Error Trying to get a bad data packet\n");#endif#if __SYSBEEPS__			SysBeep(5);#endif			*length = 0;			return(false);		}	}	else	{		*length = 0;		return(false);	}}/*_______________________________________________________________________________	SerSendPacketFilter	Sends a packet of data with all EOM characters doubled and EOM at end of packet.	Searches through data and if any of the data is equivalent to the EOM char, 	appends another EOM char after that char in the data.		Terminates data with EOM followed by NULL.   _______________________________________________________________________________*/OSErr SerSendPacketFilter(UInt16 sendTo, Ptr data, Size length){	Bytes8 			*dataDst;	Bytes8 			*dataSrc;	int				copySize		= 0;	int				srcInd 			= 0;	int				dstInd 			= 0;	int				lastSrcStart	= 0;	int				lastDstStart 	= 0;	char			*dst;	SerStaRec		serStat;	int 			i;	OSErr			status;#if __FILTER_DEBUG__	int			count;		fprintf(debugfile,"$Sending %d chars to Send Filter ");	for (count = 0; count < length; count++)		fprintf(debugfile,"%x ",data[count]);	fprintf(debugfile,"\n");		#endif	dst = gSerWrite->buf[gSerWrite->ctbWriteReady].data;	while(srcInd < length)	{		// Does this chacter need to be doubled?		if (data[srcInd] == FRAMECHAR1)		{						// Copy through EOM			copySize = srcInd - lastSrcStart + 1;						// ¥¥JDM WARNING use something faster than BlockMove			BlockMoveData(&data[lastSrcStart], &dst[lastDstStart], copySize);			// Add another EOM			lastDstStart += copySize;			dst[lastDstStart] = FRAMECHAR1;						// Update pointers to next character			lastDstStart++;			lastSrcStart += copySize;		}				srcInd++;	}	// If any EOMs had to be inserted, lastDstStart > 0 and is number of bytes to send	// Otherwise, length is num to send and none were copied		if (lastDstStart > 0)	{		// Copy remaining data if not all copied		if ((copySize = srcInd - lastSrcStart) > 0)		{							// ¥¥JDM WARNING use something faster than BlockMove			BlockMoveData(&data[lastSrcStart], &dst[lastDstStart], copySize);				} 		// Add EOM and NULL chars		lastDstStart += copySize;			dst[lastDstStart++] = FRAMECHAR1;		dst[lastDstStart++] = FRAMECHAR2;				gSerWrite->buf[gSerWrite->ctbWriteReady].length = lastDstStart;#if __FILTER_DEBUG__		fprintf(debugfile,"$$Sending %d chars ",gSerWrite->buf[gSerWrite->ctbWriteReady].length);		for (count = 0; count < gSerWrite->buf[gSerWrite->ctbWriteReady].length; count++)			fprintf(debugfile,"%x ",gSerWrite->buf[gSerWrite->ctbWriteReady].data[count]);		fprintf(debugfile,"\n");		#endif		gWParamBlock->ioParam.ioCompletion	= NULL;				// No completion routine		gWParamBlock->ioParam.ioRefNum 		= gOutputRefNum;	// Write to output driver		gWParamBlock->ioParam.ioBuffer 		= gSerWrite->buf[gSerWrite->ctbWriteReady].data; // Data to send		gWParamBlock->ioParam.ioReqCount 	= gSerWrite->buf[gSerWrite->ctbWriteReady].length;			// Number of bytes to write		gWParamBlock->ioParam.ioVRefNum 	= 0;				// Not used		gWParamBlock->ioParam.ioPosMode 	= 0;				// Not used		gWParamBlock->ioParam.ioPosOffset 	= 0;				// Not used				status = SerStatus(gOutputRefNum, &serStat);		if (serStat.wrPend)		{			while(serStat.wrPend)			{				status = SerStatus(gOutputRefNum, &serStat);#if __FILTER_DEBUG__				fprintf(debugfile,"**Write pending\n");#endif			}		}		PBWrite(gWParamBlock, true);			// Increment next ready buffer	}	else	//	// No EOM characters in message	{		// Write EOM		dataSrc = (Bytes8 *) data;		dataDst = (Bytes8 *) dst;				for (i = length; i > 0; i -= 8)		{			*dataDst++ = *dataSrc++;		}		dst[length++] = FRAMECHAR1;		dst[length++] = FRAMECHAR2;		gSerWrite->buf[gSerWrite->ctbWriteReady].length = length;		#if __FILTER_DEBUG__		fprintf(debugfile,"$$Sending %d chars ",gSerWrite->buf[gSerWrite->ctbWriteReady].length);		for (count = 0; count < gSerWrite->buf[gSerWrite->ctbWriteReady].length; count++)			fprintf(debugfile,"%x ",gSerWrite->buf[gSerWrite->ctbWriteReady].data[count]);		fprintf(debugfile,"\n");		#endif			gWParamBlock->ioParam.ioCompletion	= NULL;				// No completion routine		gWParamBlock->ioParam.ioRefNum 		= gOutputRefNum;	// Write to output driver		gWParamBlock->ioParam.ioBuffer 		= gSerWrite->buf[gSerWrite->ctbWriteReady].data; // Data to send		gWParamBlock->ioParam.ioReqCount 	= gSerWrite->buf[gSerWrite->ctbWriteReady].length;	// Number of bytes to write		gWParamBlock->ioParam.ioVRefNum 	= 0;				// Not used		gWParamBlock->ioParam.ioPosMode 	= 0;				// Not used		gWParamBlock->ioParam.ioPosOffset 	= 0;				// Not used				status = SerStatus(gOutputRefNum, &serStat);		if (serStat.wrPend)		{			while(serStat.wrPend)			{				status = SerStatus(gOutputRefNum, &serStat);#if __FILTER_DEBUG__				fprintf(debugfile,"**Write pending\n");#endif			}		}		PBWrite(gWParamBlock, true);		}	// Increment next ready buffer	gSerWrite->ctbWriteReady = (gSerWrite->ctbWriteReady + 1) % kNumCTBWriteBuffers;}/*_______________________________________________________________________________	SerSendString	Sends a string of characters to Serial driver - synchronous.	Used in initial arbitration.   _______________________________________________________________________________*/OSErr SerSendString(UInt16 sendTo, Ptr data, Size length){	ParamBlockRec	paramBlock;	OSErr	status;		paramBlock.ioParam.ioCompletion	= NULL;				// No completion routine	paramBlock.ioParam.ioRefNum 	= gOutputRefNum;	// Write to output driver	paramBlock.ioParam.ioBuffer 	= data;				// Data to send	paramBlock.ioParam.ioReqCount 	= length;			// Number of bytes to write	paramBlock.ioParam.ioVRefNum 	= 0;				// Not used	paramBlock.ioParam.ioPosMode 	= 0;				// Not used	paramBlock.ioParam.ioPosOffset 	= 0;				// Not used		status = PBWrite(&paramBlock, false);}/*_______________________________________________________________________________	SerReadString	Reads a string of data up to the specified amount. Returns true 	if any data read	   _______________________________________________________________________________*/Boolean SerReadString(Ptr data, Size *length){	long			bytesAvail,partialRead;	long			temp;	OSErr			status;			// Read a byte	SerGetBuf(gInputRefNum, &bytesAvail);	if (bytesAvail > 0)	{			if (bytesAvail > *length)			bytesAvail = *length;					gRParamBlock->ioParam.ioCompletion 	= NULL;			// No completion routine		gRParamBlock->ioParam.ioRefNum 		= gInputRefNum;	// Read from input driver		gRParamBlock->ioParam.ioBuffer 		= data;			// Data to receive		gRParamBlock->ioParam.ioReqCount 	= bytesAvail;	// Number of bytes to read		gRParamBlock->ioParam.ioVRefNum 	= 0;			// Not used		gRParamBlock->ioParam.ioPosMode 	= 0;			// Not used		gRParamBlock->ioParam.ioPosOffset 	= 0;			// Not used					status = PBRead(gRParamBlock, false);					if (status == noErr)		{			*length = bytesAvail;			return (true);		}		else		{			I_Error("Serial read %d",status);			*length = 0;			return (false);		}	}	else	{		*length = 0;		return(false);	}}void SerFlushData(void){	long	bytesRead;	long	myWaitTicks;	char	flush[256];	OSErr	status;		do 	{		SpinCursor();		SerGetBuf(gInputRefNum,  &bytesRead);			if (bytesRead > 0)		{			if (bytesRead > 256)			{				bytesRead = 256;			}						gRParamBlock->ioParam.ioCompletion 	= NULL;			gRParamBlock->ioParam.ioRefNum 		= gInputRefNum;						gRParamBlock->ioParam.ioBuffer 		= (Ptr)flush;			gRParamBlock->ioParam.ioReqCount 	= bytesRead;			gRParamBlock->ioParam.ioVRefNum 	= 0;			gRParamBlock->ioParam.ioPosMode 	= 0;			gRParamBlock->ioParam.ioPosOffset 	= 0;						SpinCursor();						status = PBRead(gRParamBlock, false);						SpinCursor();		}	} while (bytesRead > 0);	myWaitTicks = TickCount() + (60 * 5);	while(myWaitTicks > TickCount())	{		SpinCursor();	}	do 	{		SerGetBuf(gInputRefNum,  &bytesRead);		SpinCursor();			if (bytesRead > 0)		{			if (bytesRead > 256)			{				bytesRead = 256;			}						gRParamBlock->ioParam.ioCompletion 	= NULL;			gRParamBlock->ioParam.ioRefNum 		= gInputRefNum;						gRParamBlock->ioParam.ioBuffer 		= (Ptr)flush;			gRParamBlock->ioParam.ioReqCount 	= bytesRead;			gRParamBlock->ioParam.ioVRefNum 	= 0;			gRParamBlock->ioParam.ioPosMode 	= 0;			gRParamBlock->ioParam.ioPosOffset 	= 0;						SpinCursor();						status = PBRead(gRParamBlock, false);						SpinCursor();		}	} while (bytesRead > 0);}