	case		ON	machine		mc68020		IMPORT	(dc_yh, dc_yl, columnofs, ylookup, dc_iscale, centery):DATA	IMPORT	(dc_x, dc_texturemid, dc_source, dc_colormap):DATA	IMPORT	(ds_x1, ds_x2, ds_y, ds_source, ds_colormap):DATA	IMPORT	(ds_yfrac, ds_xfrac, ds_ystep, ds_xstep):DATA	SCREENWIDTH		EQU		320HIRESWIDTH		EQU		672;-----------------------------------------------;;	void R_DrawColumn68KLowRes (void);;;	Same as the C version, only a little quicker for;	68K-based Macintoshes.;R_DrawColumn68KLowRes PROC EXPORT	movem.l		A0-A2/D0-D7,-(SP)	move.l		(dc_yh).L,D3	move.l		(dc_yl).L,D2	sub.l		D2,D3	bmi			@L1		lea			(columnofs).L,A1	move.l		(dc_x).L,D1	move.l		(A1,D1.L*4),A1	lea			(ylookup).L,A0	add.l		(A0,D2.L*4),A1		move.l		(dc_iscale).L,D4	sub.l		(centery).L,D2	muls.l		D4,D2	add.l		(dc_texturemid).L,D2		; d0 scratch offset / pixel 1	; d1 qaud count	; d2 frac 1	; d3 count	; d4 fracstep	; d5 SCREENWIDTH	; d6 frac 2	; d7 scratch 2		; a0 source	; a1 dest	; a2 colormap		move.l		(dc_source).L,A0	move.l		(dc_colormap).L,A2		addq.l		#1,D3	move.l		D3,D1	lsr.l		#2,D1	beq.s		@Lcsinglestart	subq.l		#1,D1		bfextu		D2{9:7},D0			; feed the first step of the pipeline	move.l		D2,D6	add.l		D4,D6				; put D6 a step ahead of D2	lsl.l		#1,D4				; make the step a double		move.l		#SCREENWIDTH*4,D5@Lcquadloop	bfextu		D6{9:7},D7	move.b		(A0,D0.w),D0	add.l		D4,D2	move.b		(A0,D7.w),D7	add.l		D4,D6	move.b		(A2,D0.w),(A1)	bfextu		D2{9:7},D0	move.b		(A2,D7.w),SCREENWIDTH(A1)		bfextu		D6{9:7},D7	move.b		(A0,D0.w),D0	add.l		D4,D2	move.b		(A0,D7.w),D7	add.l		D4,D6	move.b		(A2,D0.w),SCREENWIDTH*2(A1)	bfextu		D2{9:7},D0	move.b		(A2,D7.w),SCREENWIDTH*3(A1)		add.l		D5,A1	dbra		D1,@Lcquadloop		lsr.l		#1,D4				; put the step value back to singles@Lcsinglestart	andi.l		#3,D3	beq.s		@L1					; no extras	move.l		#SCREENWIDTH,D5	subq.l		#1,D3@Lcsingleloop	bfextu		D2{9:7},D0	move.b		(A0,D0.w),D0	add.l		D4,D2	move.b		(A2,D0.w),(A1)		add.l		D5,A1	dbra		D3,@Lcsingleloop@L1	movem.l		(SP)+,A0-A2/D0-D7	rts		ENDPROC;-----------------------------------------------;;	void R_DrawColumn68KHiRes (void);;;	Same as the C version, only a little quicker for;	68K-based Macintoshes.;R_DrawColumn68KHiRes PROC EXPORT	movem.l		A0-A2/D0-D7,-(SP)	move.l		(dc_yh).L,D3	move.l		(dc_yl).L,D2	sub.l		D2,D3	bmi			@L1		lea			(columnofs).L,A1	move.l		(dc_x).L,D1	move.l		(A1,D1.L*4),A1	lea			(ylookup).L,A0	add.l		(A0,D2.L*4),A1		move.l		(dc_iscale).L,D4	sub.l		(centery).L,D2	muls.l		D4,D2	add.l		(dc_texturemid).L,D2		; d0 scratch offset / pixel 1	; d1 qaud count	; d2 frac 1	; d3 count	; d4 fracstep	; d5 SCREENWIDTH	; d6 frac 2	; d7 scratch 2		; a0 source	; a1 dest	; a2 colormap		move.l		(dc_source).L,A0	move.l		(dc_colormap).L,A2		addq.l		#1,D3	move.l		D3,D1	lsr.l		#2,D1	beq.s		@Lcsinglestart	subq.l		#1,D1		bfextu		D2{9:7},D0			; feed the first step of the pipeline	move.l		D2,D6	add.l		D4,D6				; put D6 a step ahead of D2	lsl.l		#1,D4				; make the step a double		move.l		#HIRESWIDTH*4,D5@Lcquadloop	bfextu		D6{9:7},D7	move.b		(A0,D0.w),D0	add.l		D4,D2	move.b		(A0,D7.w),D7	add.l		D4,D6	move.b		(A2,D0.w),(A1)	bfextu		D2{9:7},D0	move.b		(A2,D7.w),HIRESWIDTH(A1)		bfextu		D6{9:7},D7	move.b		(A0,D0.w),D0	add.l		D4,D2	move.b		(A0,D7.w),D7	add.l		D4,D6	move.b		(A2,D0.w),HIRESWIDTH*2(A1)	bfextu		D2{9:7},D0	move.b		(A2,D7.w),HIRESWIDTH*3(A1)		add.l		D5,A1	dbra		D1,@Lcquadloop		lsr.l		#1,D4				; put the step value back to singles@Lcsinglestart	andi.l		#3,D3	beq.s		@L1					; no extras	move.l		#HIRESWIDTH,D5	subq.l		#1,D3@Lcsingleloop	bfextu		D2{9:7},D0	move.b		(A0,D0.w),D0	add.l		D4,D2	move.b		(A2,D0.w),(A1)		add.l		D5,A1	dbra		D3,@Lcsingleloop@L1	movem.l		(SP)+,A0-A2/D0-D7	rts		ENDPROC;-----------------------------------------------;;	void R_DrawSpanAsm (void);;;	Same as the C version, only a little quicker for;	68K-based Macintoshes.;R_DrawSpanAsm PROC EXPORT	movem.l		A2/D2-D7,-(SP)		move.l		(ds_x2).L,D7	cmp.l		(ds_x1).L,D7	move.l		(ds_y).L,D1	lea			(ylookup).L,A1	move.l		(ds_x1).L,D0	lea			(columnofs).L,A0	move.l		(A1,D1.L*4),A1	add.l		(A0,D0.L*4),A1	move.l		(ds_x2).L,D3	sub.l		(ds_x1).L,D3	; d0 extracted yfrac / composite	; d1 extracted xfrac	; d2 xfrac yfrac	; d3 loop count	; d4 xstep ystep	; d5 pixel	; d6 quad count	; a0 ds_source	; a1 dest	; a2 ds_colormap		moveq.l		#0,D5	move.l		(ds_source).L,A0	move.l		(ds_colormap).L,A2		; build frac		move.l		(ds_yfrac).L,D2	moveq.l		#10,D0	lsl.l		D0,D2	clr.w		D2					; andi.l	#$FFFF0000,D2	move.l		(ds_xfrac).L,D0	lsr.l		#6,D0	andi.l		#$FFFF,D0	add.l		D0,D2		; build step		move.l		(ds_ystep).L,D4	moveq.l		#10,D0	lsl.l		D0,D4	clr.w		D4					; andi.l	$FFFF0000,D4	move.l		(ds_xstep).L,D0	lsr.l		#6,D0	andi.l		#$FFFF,D0	add.l		D0,D4		addq.l		#1,D3	move.l		D3,D6	lsr.l		#2,D6	beq.s		@Lsinglestart	subq.l		#1,D6 @Lquadloop	bfextu		D2{0:6},D0			; extract y	bfextu		D2{16:6},D1			; extract x	lsl.l		#6,D0	add.l		D1,D0	add.l		D4,D2				; advance fraction	move.b		(A0,D0.w),D5		; get source pixel	move.b		(A2,D5.w),(A1)+		; translate and write out to dest	bfextu		D2{0:6},D0			; extract y	bfextu		D2{16:6},D1			; extract x	lsl.l		#6,D0	add.l		D1,D0	add.l		D4,D2				; advance fraction	move.b		(A0,D0.w),D5		; get source pixel	move.b		(A2,D5.w),(A1)+		; translate and write out to dest	bfextu		D2{0:6},D0			; extract y	bfextu		D2{16:6},D1			; extract x	lsl.l		#6,D0	add.l		D1,D0	add.l		D4,D2				; advance fraction	move.b		(A0,D0.w),D5		; get source pixel	move.b		(A2,D5.w),(A1)+		; translate and write out to dest	bfextu		D2{0:6},D0			; extract y	bfextu		D2{16:6},D1			; extract x	lsl.l		#6,D0	add.l		D1,D0	add.l		D4,D2				; advance fraction	move.b		(A0,D0.w),D5		; get source pixel	move.b		(A2,D5.w),(A1)+		; translate and write out to dest 	dbra		D6,@Lquadloop @Lsinglestart	andi.l		#3,D3	beq.s		@Ldone				; no extras	subq.l		#1,D3@Lsingleloop	bfextu		D2{0:6},D0			; extract y	bfextu		D2{16:6},D1			; extract x	lsl.l		#6,D0	add.l		D1,D0	add.l		D4,D2				; advance fraction	move.b		(A0,D0.w),D5		; get source pixel	move.b		(A2,D5.w),(A1)+		; translate and write out to dest		dbra		D3,@Lsingleloop @Ldone	movem.l		(SP)+,A2/D2-D7	rts		ENDPROC		END