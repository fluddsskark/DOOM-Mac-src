#ifndef __MPW_VERSION__	#if defined(powerc) || defined (__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#endif#include "LionDoom.h"// V_video.c#include "doomdef.h"// #define	SC_INDEX		0x03C4#include "V_VIDEO.PROTO.H"extern byte			remapMac[256];extern CGrafPtr		gOffPort;// screens[0] may be 640x400 if "gHiRes" is TRUE. Otherwise, it is 320x200.// screens[1] - screens[3] are always 320x200 to support WAD files and// original PC graphics.// screens[4] is allocated in "ST_STUFF.C" and contains only the status// bar, which is 320 x 32 pixels.byte		*screens[5] = { NULL, NULL, NULL, NULL, NULL };int			usegamma = 0;byte gammatable[5][256] ={{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,	127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,	224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255},{2,4,5,7,8,10,11,12,14,15,16,18,19,20,21,23,24,25,26,27,29,30,31,32,33,34,36,37,38,39,40,41,42,44,45,46,47,48,49,50,51,52,54,55,56,57,58,59,60,61,62,63,64,65,66,67,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,163,164,165,166,167,168,169,170,171,172,173,174,175,175,176,177,178,179,180,181,182,183,184,185,186,186,187,188,189,190,191,192,193,194,195,196,196,197,198,199,200,201,202,203,204,205,205,206,207,208,209,210,211,212,213,214,214,215,216,217,218,219,220,221,222,222,223,224,225,226,227,228,229,230,230,231,232,233,234,235,236,237,237,238,239,240,241,242,243,244,245,245,246,247,248,249,250,251,252,252,253,254,255},{4,7,9,11,13,15,17,19,21,22,24,26,27,29,30,32,33,35,36,38,39,40,42,43,45,46,47,48,50,51,52,54,55,56,57,59,60,61,62,63,65,66,67,68,69,70,72,73,74,75,76,77,78,79,80,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,133,134,135,136,137,138,139,140,141,142,143,144,144,145,146,147,148,149,150,151,152,153,153,154,155,156,157,158,159,160,160,161,162,163,164,165,166,166,167,168,169,170,171,172,172,173,174,175,176,177,178,178,179,180,181,182,183,183,184,185,186,187,188,188,189,190,191,192,193,193,194,195,196,197,197,198,199,200,201,201,202,203,204,205,206,206,207,208,209,210,210,211,212,213,213,214,215,216,217,217,218,219,220,221,221,222,223,224,224,225,226,227,228,228,229,230,231,231,232,233,234,235,235,236,237,238,238,239,240,241,241,242,243,244,244,245,246,247,247,248,249,250,251,251,252,253,254,254,255},{8,12,16,19,22,24,27,29,31,34,36,38,40,41,43,45,47,49,50,52,53,55,57,58,60,61,63,64,65,67,68,70,71,72,74,75,76,77,79,80,81,82,84,85,86,87,88,90,91,92,93,94,95,96,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,135,136,137,138,139,140,141,142,143,143,144,145,146,147,148,149,150,150,151,152,153,154,155,155,156,157,158,159,160,160,161,162,163,164,165,165,166,167,168,169,169,170,171,172,173,173,174,175,176,176,177,178,179,180,180,181,182,183,183,184,185,186,186,187,188,189,189,190,191,192,192,193,194,195,195,196,197,197,198,199,200,200,201,202,202,203,204,205,205,206,207,207,208,209,210,210,211,212,212,213,214,214,215,216,216,217,218,219,219,220,221,221,222,223,223,224,225,225,226,227,227,228,229,229,230,231,231,232,233,233,234,235,235,236,237,237,238,238,239,240,240,241,242,242,243,244,244,245,246,246,247,247,248,249,249,250,251,251,252,253,253,254,254,255},{16,23,28,32,36,39,42,45,48,50,53,55,57,60,62,64,66,68,69,71,73,75,76,78,80,81,83,84,86,87,89,90,92,93,94,96,97,98,100,101,102,103,105,106,107,108,109,110,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,128,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,143,144,145,146,147,148,149,150,150,151,152,153,154,155,155,156,157,158,159,159,160,161,162,163,163,164,165,166,166,167,168,169,169,170,171,172,172,173,174,175,175,176,177,177,178,179,180,180,181,182,182,183,184,184,185,186,187,187,188,189,189,190,191,191,192,193,193,194,195,195,196,196,197,198,198,199,200,200,201,202,202,203,203,204,205,205,206,207,207,208,208,209,210,210,211,211,212,213,213,214,214,215,216,216,217,217,218,219,219,220,220,221,221,222,223,223,224,224,225,225,226,227,227,228,228,229,229,230,230,231,232,232,233,233,234,234,235,235,236,236,237,237,238,239,239,240,240,241,241,242,242,243,243,244,244,245,245,246,246,247,247,248,248,249,249,250,250,251,251,252,252,253,254,254,255,255}};/****************************************************** *	V_CopyRect.																				* *																										* *	Note for high & medium resolution you send in			* *	high res coordinates if you are accessing screen	* *	0 (source or dest, as applicable). Width and			* *	Height are given in terms of source resolution.		* *	Otherwise, send in low res coordinates.						* ******************************************************/void V_CopyRect (int srcx, int srcy, int srcscrn, int width, int height,	int destx, int desty, int destscrn){	register byte	*src, *dest;	#ifdef RANGECHECK	if (gHiRes)	{		if (srcx<0||srcx+width >kHiResScreenWidth || srcy<0 || srcy+height>kHiResScreenHeight		||destx<0||destx+width >kHiResScreenWidth || desty<0 || desty+height>kHiResScreenHeight		|| (unsigned)srcscrn>4 || (unsigned)destscrn>4)			I_Error ("Bad V_CopyRect");	}	else	{		if (srcx<0||srcx+width >kScreenWidth || srcy<0 || srcy+height>kScreenHeight		||destx<0||destx+width >kScreenWidth || desty<0 || desty+height>kScreenHeight		|| (unsigned)srcscrn>4 || (unsigned)destscrn>4)			I_Error ("Bad V_CopyRect");	}#endif		if (gHiRes && ((srcscrn == 0) || (destscrn == 0)))	{		if ((srcscrn == 0) && (destscrn == 0))		{			src = screens[srcscrn] + (srcy * kHiResRowBytes) + srcx;			dest = screens[destscrn] + (desty * kHiResRowBytes) + destx;			for ( ; height > 0; height--)			{				BlockMoveData (src, dest, width);				src += kHiResRowBytes;				dest += kHiResRowBytes;			}		}		else if (srcscrn == 0)		{			register byte	*rdest;			register byte	*rsrc;			register int	tempWidth;			if (gHiRes == 2)			{				src = screens[srcscrn] + (srcy * kHiResRowBytes) + srcx;				dest = screens[destscrn] + (desty * kScreenWidth) + destx;				height >>= 1;	// Every other line!								while (height--)				{					rdest = dest;					rsrc = src;					tempWidth = width >> 1;	// Every other pixel!										while (tempWidth--)					{						*rdest++ = *rsrc;						rsrc += 2;					}										dest += kScreenWidth;					src += kHiResRowBytes * 2;				}			}			else			{				srcy >>= 1;				height >>= 1;	// Coordinates are HiRes only, even for med. res: 640 x 400. Accounted for!				src = screens[srcscrn] + (srcy * kHiResRowBytes) + srcx;				dest = screens[destscrn] + ((desty << 8) + (desty << 6)) + destx;								while (height--)				{					rdest = dest;					rsrc = src;					tempWidth = width >> 1;										while (tempWidth--)					{						*rdest++ = *rsrc;						rsrc += 2;					}										dest += kScreenWidth;					src += kHiResRowBytes;				}			}		}		else if (destscrn == 0)		{			register byte	*rdest;			register byte	*rsrc;			register int	tempWidth;			if (gHiRes == 2)			{				src = screens[srcscrn] + ((srcy << 8) + (srcy << 6)) + srcx;				dest = screens[destscrn] + (desty * kHiResRowBytes) + destx;					for ( ; height > 0; height--)				{					rdest = dest;					rsrc = src;					tempWidth = width;										while (tempWidth--)					{						rdest[0] =						rdest[1] =						rdest[kHiResRowBytes] =						rdest[kHiResRowBytes + 1] = *rsrc++;						rdest += 2;					}										dest += kHiResRowBytes * 2;					src += kScreenWidth;				}			}			else			{				src = screens[srcscrn] + ((srcy << 8) + (srcy << 6)) + srcx;				desty >>= 1;				dest = screens[destscrn] + (desty * kHiResRowBytes) + destx;					for ( ; height > 0; height--)				{					rdest = dest;					rsrc = src;					tempWidth = width;										while (tempWidth--)					{						rdest[0] =						rdest[1] = *rsrc++;						rdest += 2;					}										dest += kHiResRowBytes;					src += kScreenWidth;				}			}		}	}	else	{		src = screens[srcscrn] + (srcy << 8) + (srcy << 6) + srcx;		dest = screens[destscrn] + (desty << 8) + (desty << 6) + destx;		for ( ; height > 0; height--)		{			BlockMoveData(src, dest, width);			src += kScreenWidth;			dest += kScreenWidth;		}	}}void V_DrawPatchLRes (int x, int y, int scrn, patch_t *patch){	if (gHiRes && (scrn == 0))		V_DrawPatch(x << 1, y << 1, scrn, patch);	else		V_DrawPatch(x, y, scrn, patch);}void V_DrawPatchLResFlipped (int x, int y, int scrn, patch_t *patch){	if (gHiRes && (scrn == 0))		V_DrawPatchFlipped(x << 1, y << 1, scrn, patch);	else		V_DrawPatchFlipped(x, y, scrn, patch);}/*==================== V_DrawPatch== Masks a column based masked pic to the screen.===================*/void V_DrawPatch (int x, int y, int scrn, patch_t *patch){	register byte		*remapArray;	register byte		*dest;	register byte		*source;	register int		count;	register column_t	*column;	register int		col;	register byte		*desttop;	int					w;	Boolean				hires1, hires2;		hires2 = ((gHiRes == 2) && (scrn == 0));	hires1 = ((gHiRes == 1) && (scrn == 0));		if (hires2)	{		y -= ((int) SHORT(patch->topoffset)) * 2;		x -= ((int) SHORT(patch->leftoffset)) * 2;	}	else if (hires1)	{		y >>= 1;		y -= ((int) SHORT(patch->topoffset));		x -= ((int) SHORT(patch->leftoffset)) * 2;	}	else	{		y -= (int) SHORT(patch->topoffset);		x -= (int) SHORT(patch->leftoffset);	}	#ifdef RANGECHECK	if (gHiRes)	{		if ( (x < 0) || (y < 0) ||			((x + SHORT(patch->width)) > kHiResScreenWidth) ||			(y + SHORT(patch->height) > kHiResScreenHeight) ||			(((unsigned)scrn) > 4) )			I_Error ("Bad V_DrawPatch");	}	else	{		if ( (x < 0) || (y < 0) ||			((x + SHORT(patch->width)) > kScreenWidth) ||			(y + SHORT(patch->height) > kScreenHeight) ||			(((unsigned)scrn) > 4) )			I_Error ("Bad V_DrawPatch");	}#endif		if (hires1 || hires2)		desttop = screens[scrn] + x + (y * kHiResRowBytes);	else		desttop = screens[scrn] + (y << 8) + (y << 6) + x;		w = SHORT(patch->width);	remapArray = remapMac;		if (hires2)	// High Resolution	{		for (col = 0; col < w; x++, col++, desttop += 2)		{			column = (column_t *)((byte *)patch + LONG(patch->columnofs[col]));		// step through the posts in a column				while ( column->topdelta != 0xFF )			{				source = (byte *) column + 3;				dest = desttop + column->topdelta * (kHiResRowBytes * 2);				count = column->length;								while (count--)				{					dest[0] =					dest[1] =					dest[kHiResRowBytes] =					dest[kHiResRowBytes + 1] = remapArray[ *source++ ];					dest += (kHiResRowBytes * 2);				}								column = (column_t *)( (byte *)column + column->length + 4 );			}		}	}	else if (hires1)	// Medium resolution	{		for (col = 0; col < w; x++, col++, desttop += 2)		{			column = (column_t *)((byte *)patch + LONG(patch->columnofs[col]));		// step through the posts in a column				while ( column->topdelta != 0xFF )			{				source = (byte *) column + 3;				dest = desttop + column->topdelta * kHiResRowBytes;				count = column->length;								while (count--)				{					dest[0] =					dest[1] = remapArray[ *source ];					dest += kHiResRowBytes;					source++;				}								column = (column_t *)( (byte *)column + column->length + 4 );			}		}	}	else	// Low Resolution	{		for (col = 0; col < w; x++, col++, desttop++)		{			column = (column_t *)((byte *)patch + LONG(patch->columnofs[col]));		// step through the posts in a column				while ( column->topdelta != 0xFF )			{				source = (byte *) column + 3;				dest = desttop + (((int)column->topdelta) << 8) + (((int)column->topdelta) << 6);				count = column->length;								while (count--)				{					*dest = remapArray[ *source++ ];					dest += kScreenWidth;				}								column = (column_t *)( (byte *)column + column->length + 4 );			}		}	}}/*==================== V_DrawPatchFlipped== Masks a column based masked pic to the screen.===================*/void V_DrawPatchFlipped (int x, int y, int scrn, patch_t *patch){	register byte		*remapArray;	register byte		*dest;	register byte		*source;	register int		count;	register column_t	*column;	register int		col;	register byte		*desttop;	int					w;	Boolean				hires1, hires2;		hires2 = ((gHiRes == 2) && (scrn == 0));	hires1 = ((gHiRes == 1) && (scrn == 0));		if (hires2)	{		y -= ((int) SHORT(patch->topoffset)) * 2;		x -= ((int) SHORT(patch->leftoffset)) * 2;	}	else if (hires1)	{		y >>= 1;		y -= ((int) SHORT(patch->topoffset));		x -= ((int) SHORT(patch->leftoffset)) * 2;	}	else	{		y -= (int) SHORT(patch->topoffset);		x -= (int) SHORT(patch->leftoffset);	}	#ifdef RANGECHECK	if (gHiRes)	{		if ( (x < 0) || (y < 0) ||			((x + SHORT(patch->width)) > kHiResScreenWidth) ||			(y + SHORT(patch->height) > kHiResScreenHeight) ||			(((unsigned)scrn) > 4) )			I_Error ("Bad V_DrawPatch");	}	else	{		if ( (x < 0) || (y < 0) ||			((x + SHORT(patch->width)) > kScreenWidth) ||			(y + SHORT(patch->height) > kScreenHeight) ||			(((unsigned)scrn) > 4) )			I_Error ("Bad V_DrawPatch");	}#endif		if (hires1 || hires2)		desttop = screens[scrn] + x + (y * kHiResRowBytes);	else		desttop = screens[scrn] + (y << 8) + (y << 6) + x;		w = SHORT(patch->width);	remapArray = remapMac;		if (hires2)	// High Resolution	{		for (col = 0; col < w; x++, col++, desttop += 2)		{			column = (column_t *)((byte *)patch + LONG(patch->columnofs[w - 1 - col]));		// step through the posts in a column				while ( column->topdelta != 0xFF )			{				source = (byte *) column + 3;				dest = desttop + (((int)column->topdelta) << 10) + (((int)column->topdelta) << 8);				count = column->length;								while (count--)				{					dest[0] =					dest[1] =					dest[kHiResRowBytes] =					dest[kHiResRowBytes + 1] = remapArray[ *source++ ];					dest += (kHiResRowBytes * 2);				}								column = (column_t *)( (byte *)column + column->length + 4 );			}		}	}	else if (hires1)	// Medium resolution	{		for (col = 0; col < w; x++, col++, desttop += 2)		{			column = (column_t *)((byte *)patch + LONG(patch->columnofs[w - 1 - col]));		// step through the posts in a column				while ( column->topdelta != 0xFF )			{				source = (byte *) column + 3;				dest = desttop + ((int)column->topdelta * kHiResRowBytes);				count = column->length;								while (count--)				{					dest[0] =					dest[1] = remapArray[ *source ];					dest += kHiResRowBytes;					source++;				}								column = (column_t *)( (byte *)column + column->length + 4 );			}		}	}	else	// Low Resolution	{		for (col = 0; col < w; x++, col++, desttop++)		{			column = (column_t *)((byte *)patch + LONG(patch->columnofs[w - 1 - col]));		// step through the posts in a column				while ( column->topdelta != 0xFF )			{				source = (byte *) column + 3;				dest = desttop + (((int)column->topdelta) << 8) + (((int)column->topdelta) << 6);				count = column->length;								while (count--)				{					*dest = remapArray[ *source++ ];					dest += kScreenWidth;				}								column = (column_t *)( (byte *)column + column->length + 4 );			}		}	}/*	register column_t	*column;	register byte		*dest;	register byte		*source;	register byte		*remapArray;	register int		count;	int					col;	byte				*desttop;	int					w;	Boolean				hires;		hires = ((gHiRes != 0) && (scrn == 0));		if (hires)	{		y -= ((int) SHORT(patch->topoffset)) * 2;		x -= ((int) SHORT(patch->leftoffset)) * 2;	}	else	{		y -= (int) SHORT(patch->topoffset);		x -= (int) SHORT(patch->leftoffset);	}	#ifdef RANGECHECK	if (gHiRes)	{		if (x<0||x+SHORT(patch->width) >kHiResScreenWidth || y<0 || y+SHORT(patch->height)>kHiResScreenHeight		|| (unsigned)scrn>4)			I_Error ("Bad V_DrawPatchFlipped");	}	else	{		if (x<0||x+SHORT(patch->width) >kScreenWidth || y<0 || y+SHORT(patch->height)>kScreenHeight		|| (unsigned)scrn>4)			I_Error ("Bad V_DrawPatchFlipped");	}#endif	if (hires)		desttop = screens[scrn] + x + ((y << 9) + (y << 7));	else		desttop = screens[scrn] + x + ((y << 8) + (y << 6));		w = SHORT(patch->width);	remapArray = remapMac;		if (hires)	{		for (col = 0; col < w; x++, col++, desttop += 2)		{			column = (column_t *)((byte *)patch + LONG(patch->columnofs[w - 1 - col]));		// step through the posts in a column				while ( column->topdelta != 0xFF )			{				source = (byte *) column + 3;				dest = desttop + column->topdelta * (kHiResScreenWidth * 2);				count = column->length;								while (count--)				{					dest[0] =					dest[1] =					dest[kHiResScreenWidth] =					dest[kHiResScreenWidth + 1] = remapArray[ *source++ ];					dest += (kHiResScreenWidth * 2);				}								column = (column_t *)( (byte *)column + column->length + 4 );			}		}	}	else	{		for (col = 0; col < w; x++, col++, desttop++)		{			column = (column_t *)((byte *)patch + LONG(patch->columnofs[w - 1 - col]));		// step through the posts in a column				while ( column->topdelta != 0xFF )			{				source = (byte *) column + 3;				dest = desttop + (((int)column->topdelta) << 8) + (((int)column->topdelta) << 6);				count = column->length;								while (count--)				{					*dest = remapArray[ *source++ ];					dest += kScreenWidth;				}								column = (column_t *)( (byte *)column + column->length + 4 );			}		}	}*/}/*==================== V_DrawPatchDirect== Draws directly to the screen on the pc. macro-ed out on the Mac.==================*//*void V_DrawPatchDirect (int x, int y, int scrn, patch_t *patch){	V_DrawPatch (x, y, scrn, patch);}*//*================= V_Init================*/void V_Init (void){	byte	*base;	long	*longPtr;	int		totalMem;	// allocate in the Macintosh application heap.		totalMem = (kHiResRowBytes * kHiResScreenHeight) +		((kScreenWidth * kScreenHeight) * 3);	base = I_AllocLow (totalMem);		screens[0] = base;	screens[1] = base + (kHiResRowBytes * kHiResScreenHeight);	screens[2] = screens[1] + (kScreenWidth * kScreenHeight);	screens[3] = screens[2] + (kScreenWidth * kScreenHeight);	// Initialize to Macintosh black ($FF, or 255).		longPtr = (long *)base;	totalMem /= 4;	while (totalMem--)		*longPtr++ = 0xFFFFFFFF;}