#define __MAC_VERSION__#define __LION_SHOWFRAMERATE 0#ifndef __MPW_VERSION__	#if defined(powerc) || defined (__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif		#if __profile__		#include "profiler.h"	#endif#endif#if __APPLE_DEBUG__	#include <stdio.h>#endif#include <Lion.h>#include "LionDoom.h"#include "DebugSwitches.h"#include "DoomResources.h"		#include "PCMacNet.h"#define __OPTFIX__ 1				// Fixes for Open Transport version 1.0 bugs// #include "GeneralStuff.h"/* #include <Devices.h>#include <AppleTalk.h>#include <Memory.h>#include <Stdio.h>#include <GestaltEqu.h>//#include <Types.h>#include <OSUtils.h>#include <TextUtils.h>#include <ToolUtils.h>#include <Errors.h>#include <Resources.h> */#include "AppleTalkNet.h"#include "Traps.h"#include "DOOMDEF.H"/* *  Global Variables *//*  * 	gFreeQ and gUsedQ,are used to track whether gBuffers packet record buffers are  *  available for use or have been filled in by the socket listener and are available *  for processing. */QHdr		gFreeQ, gUsedQ;					// Set up by InitSocketListenerHandle 		gSockCodeHndl = nil; 			// Handle to socket listener code resource#define				kNumSendStructs		12				// Number of structures to be used for asynch netshort				gNumPlayersOnNet = 0;				// Current number of players on the networkshort				gMPPRefNum;							// Reference number for .MPP driverNamesTableEntry 	gNamesTableEntry;					// Names table entrychar				gSocketNum			= 0;			// Number of the socket														// Should be initialized to 0Ptr					gEntityInfoPtr;						// Pointer to entity info from PLookupName call// Data structures used in sending dataMPPParamBlock		gMPPSendBlockArr[kNumSendStructs];	// Parameter block for MPPPtr					gDDPWDSPtrArr;						// DDP write data structurePtr					gDDPHeaderPtrArr;					// DDP header packet pointerdoomdata_t			gSendDataArr[kNumSendStructs];		// Data to be sentEntityName			gEntityNameArr[kMaxNetPlayers];		// Array of network entity namesAddrBlock			gAddressNameArr[kMaxNetPlayers];	// Array of entity address blocksStr32				gPlayerName;						// Name to be registered on net#define				kPlayerNameLength 13/*  * 	The socket listener uses the gBuffers buffers to save received packets *	until they can be processed. */PacketBuffer	gBuffers[kNumBuffers];			// Set up by InitSocketListenerBoolean			gVirtualMem;				// State of virtual memory (true == on)Boolean			gInSetup = true;				// Lets ReceivePacket know if it should store												// address of sender/*	 *	Information for zones */#define			kMaxZones		32Str32			gZoneNames[kMaxZones];			// Names of zonesint		 		gNumZones;						// Number of zonesint		 		gNumZonesUsed;					// Number of zones used by the gameBoolean			gNoRouter	= false;#define 		kZoneBufferSize	578												extern DialogPtr		gStatusDialog;extern void StatusDialog (tLong total, tLong current);extern void DrawStatusDialog (Boolean forUpdate);extern void StatusParamText(char *one, char *two, char *three, char *four);extern Boolean CompPStr (void *strA, void *strB);extern void SpinCursor (void);extern void BlackScreen(void);extern 			WindowPtr	gDoomWindow;extern short 	gCursID;extern int		gPlayersWanted;extern FSSpec	gPendingGame;extern RedrawScreen();//_____________________________________________________________________________________________//_____________________________________________________________________________________________//			MISC ROUTINES//_____________________________________________________________________________________________//_____________________________________________________________________________________________//_____________________________________________________________________________________________//	CheckAppleTalkGestalt//// If AppleTalk is on, checks for a version of AppleTalk Phase 2. If AppleTalk is not on, asks// user to turn on and exits with error.  If version is less than Phase 2, returns error.//_____________________________________________________________________________________________OSErr CheckAppleTalkState(void){	OSErr	status = noErr;			// Error encountered, if any	long	atlkAttributes;			// Attributes for current version of AppleTalk		/*	 * Do this before Network code	 */	// Do We have Gestalt?	if (NGetTrapAddress(_Gestalt, OSTrap) == GetToolboxTrapAddress(_Unimplemented)){		I_Error("Gestalt is not available");	// We don't even have Gestalt, bail out		return(dsChkErr);	}		/*	 * Check for active, correct version of AppleTalk (we are accepting any version starting with Phase 2	 */	if ((status = Gestalt(gestaltAppleTalkVersion, &atlkAttributes)) != noErr){		I_Error("Error in calling gestalt on gestaltAppleTalkVersion %d", status);		return(status);	} else if (atlkAttributes == 0){		I_Error("AppleTalk is not active.  Please turn on AppleTalk in the Chooser and reboot");		return(kDMNoATalkActive);	} else if (atlkAttributes < kEarliestPhase2Vers){		I_Error("Doom II will not work with this version of AppleTalk.  Please install AppleTalk version 53 or later");		return(kDMOldATalkVers);	}	return (status);}//_____________________________________________________________________________________________//	Check if Virtual Memory is on//_____________________________________________________________________________________________Boolean IsVMOn(void){	long	message;				if(Gestalt(gestaltVMAttr, &message))		return (false);		if (BitTst((Ptr)&message, 31 - gestaltVMPresent))		return (true);	else		return (false);}//_____________________________________________________________________________________________//	RemoveEntityName////	Removes our name and ATP socket.////_____________________________________________________________________________________________OSErr RemoveEntityName(void){	MPPParamBlock 	mppPB;	OSErr			status = noErr;		mppPB.NBP.ioCompletion		= nil;						// no completion routine	mppPB.NBP.ioRefNum			= gMPPRefNum;				// .MPP driver refnum	mppPB.NBP.csCode			= removeName;				// Code for this call	mppPB.NBP.nbpPtrs.entityPtr	= (Ptr)&gNamesTableEntry.nt.entityData[0];	// Pointer to NamesTableEntry	status = PRemoveName(&mppPB, true);	 	// Remove name asynchronously	while (mppPB.MPP.ioResult == 1)	{		SpinCursor();	}	if (mppPB.MPP.ioResult != noErr)	{		status = mppPB.MPP.ioResult;		I_Error("Error in calling PRemoveName %d", status);		return (status);	}	return(status);}//_____________________________________________________________________________________________//_____________________________________________________________________________________________//			INITIALIZATION ROUTINES//_____________________________________________________________________________________________//_____________________________________________________________________________________________//_____________________________________________________________________________________________//	RegisterEntityName//// Creates an entity structure pointed to by the pointer ntePtr with the object name, type name//  and the socket.  Then registers that name in the NBP names table.// Must be called after the socket is opened.//// Initializes gNamesTableEntry structure.//// PERFORMANCE NOTES://	1) Call to PRegisterName is synchronous.//	2) Count and interval values may need to be analyzed for best performance in PRegisterName.////_____________________________________________________________________________________________static OSErr	RegisterEntityName(ConstStr32Param entityType, Boolean changeAll){	MPPParamBlock	mppPB;	Boolean			done;	int				zoneIndex = 1;	OSErr			status = noErr;	int				add = 1;			// *** AT THIS POINT, changeAll THIS DOES NOTHING	// Decide whether to just register on the latest zone, or do them all			if (CheckForTermination())	{		I_Exit();	}		done = false;	while (!done)	{		if (add > 20)		{			done = true; 	// try just one more time		}				/*		 *  Build names table		 */		if (gSocketNum == 0)	// Make sure we have a valid socket number		{			I_Error("Trying to register entity before socket is opened");			return(ddpSktErr);		}		NBPSetNTE((Ptr)&gNamesTableEntry,					(ConstStr32Param) gPlayerName,					(ConstStr32Param) entityType,					(ConstStr32Param) &gZoneNames[zoneIndex - 1],					gSocketNum);							/*		 *  Register name		 */		mppPB.NBP.ioCompletion		= nil;						// No completion routine, synchronous (may be done in glue)		mppPB.NBP.ioRefNum			= gMPPRefNum;				// Reference number for driver (may be done in glue)		mppPB.NBP.csCode			= registerName;				// Routine code		mppPB.NBP.interval			= (UInt8) 16;				// Interval to wait between verification of name's uniqueness		mppPB.NBP.count				= (UInt8) 3;				// Number of times to verify name's uniqueness		mppPB.NBP.nbpPtrs.entityPtr	= (Ptr)&gNamesTableEntry;	// Pointer to NamesTableEntry		mppPB.NBP.parm.verifyFlag	= (UInt8) true;				// Be sure that name is unique			status = PRegisterName(&mppPB, true);		while (mppPB.MPP.ioResult == 1)		{			SpinCursor();		}		if (mppPB.MPP.ioResult != noErr)// Register name asynchronously		{			status = mppPB.MPP.ioResult;			if (status == nbpDuplicate)			{				// This name is already registered, try another				gPlayerName[12] += TickCount();				add++;			}			else			{				done = true;			}		}		else		{			done = true;		}	}	return(status);}//_____________________________________________________________________________//// Tests whether the current address block is not yet known////_____________________________________________________________________________Boolean IsNotYetKnown(EntityName *tempEntityName, AddrBlock *tempAddr, short currentPlayers){	int	count;	unsigned long *check, *current;	check = (unsigned long *) tempAddr;		if (CompPStr(tempEntityName, gPlayerName))	{		return(false);	}		for(count = 1; count <= currentPlayers; count++)	{		current = (unsigned long *) &gAddressNameArr[count];		if(*current == *check)			return(false);	}		return(true);}//_____________________________________________________________________________________________//	CheckNameEntries////	See who is on the net of our type.//_____________________________________________________________________________________________static OSErr CheckNameEntries(short *numPlayers, ConstStr32Param lookupType, Boolean getAddresses, Boolean moreZones){	MPPParamBlock	mppPB;	EntityName		searchEntity;	UInt16			whichEntity;	OSErr 			status;	Str32			searchName;	short			players = 0;	int				count;	int				zoneIndex = 1;	AddrBlock		tempAddr;	EntityName		tempEntityName;		do	{		// Search for a player of name starting with new or saved name		for(count = 12; count >= 0; count--)		{			searchName[count] = gPlayerName[count];		}				searchName[12] = 'Å';				// Create entity name to search for		NBPSetEntity((Ptr)&searchEntity,						(ConstStr32Param) searchName,					 	(ConstStr32Param) lookupType,						(ConstStr32Param) &gZoneNames[zoneIndex - 1]);				// Call PLookupName		mppPB.NBP.ioCompletion				= nil;						// no completion routine		mppPB.NBP.ioRefNum					= gMPPRefNum;				//.MPP driver refnum		mppPB.NBP.csCode					= lookupName;				// Code for this call		mppPB.NBP.interval					= 16;						// Retry interval		mppPB.NBP.count						= 3;						// Retry count		mppPB.NBP.nbpPtrs.entityPtr			= (Ptr) &searchEntity;		// Name to look for		mppPB.NBP.parm.Lookup.retBuffPtr	= (Ptr) gEntityInfoPtr;		// Pointer to return buffer		mppPB.NBP.parm.Lookup.retBuffSize	= kNameTupleSize * kMaxNetPlayers - 1;	// Size of return buffer		mppPB.NBP.parm.Lookup.maxToGet		= kMaxNetPlayers - 1;			// Maximum number of matches to get			status = PLookupName(&mppPB, true);		while (mppPB.MPP.ioResult == 1)		{			SpinCursor();		}		#if __OPTFIX__		// The check for nbpNotFound is for a bug in Open Transport		if (mppPB.MPP.ioResult != noErr && mppPB.MPP.ioResult != nbpNotFound)// Register name synchronously		{			status = mppPB.MPP.ioResult;			I_Error("Unable to check for other players on net %d", status);			return(status);		}		if (mppPB.MPP.ioResult == nbpNotFound)		{			players = 0;		}		else		{			players = mppPB.NBP.parm.Lookup.numGotten;		}#else		// The check for nbpNotFound is for a bug in Open Transport		if (mppPB.MPP.ioResult != noErr)// Register name synchronously		{			status = mppPB.MPP.ioResult;			I_Error("Unable to check for other players on net %d", status);			return(status);		}				players = mppPB.NBP.parm.Lookup.numGotten;#endif // __OPTFIX__														if(getAddresses)		{			// Extract info for each entity			for (whichEntity = 0; whichEntity < players; whichEntity++)			{				// Place address in name array starting after the last recorded address				//  leaving index 0 open for my own address				status = NBPExtract(gEntityInfoPtr,									 players,									 whichEntity + 1,									 &tempEntityName,									 &tempAddr);									 				if (status != noErr)				{					I_Error("Error in calling NBPExtract %d");				}				if(IsNotYetKnown(&tempEntityName, &tempAddr, *numPlayers))				{					gEntityNameArr[1 + *numPlayers] = tempEntityName;					gAddressNameArr[1 + *numPlayers] = tempAddr;					*numPlayers = *numPlayers + 1;					}			}		}		// Don't get addresses		else		{			*numPlayers =  players;			return(status);		}				zoneIndex++;			}while(*numPlayers < kMaxNetPlayers && zoneIndex <= gNumZonesUsed && moreZones);		return(status);}//_____________________________________________________________________________________________//	This routine loads the socket listener code and initializes the buffers to //  be used by the socket listener code. A check is made to determine whether VM//  is active and to hold the memory associated with buffers that might be //  critical to the operation of the socket listener.  We load the socket //  socket listener code resource and lock it in memory.////	Intitializes gSocketNum.//_____________________________________________________________________________________________OSErr InitSocketListener(void){	OSErr			status = noErr;	short			i;	Size			listenerSize;	MPPParamBlock	ddpParmBlock;		/* set up the free and used queues */	gFreeQ.qFlags = 0;	gFreeQ.qHead = nil;	gFreeQ.qTail = nil;		gUsedQ.qFlags = 0;	gUsedQ.qHead = nil;	gUsedQ.qTail = nil;		/* enqueue the packet buffer records to the free queue */	for (i=0; i<kNumBuffers; i++, gFreeQ.qFlags ++)		Enqueue((QElemPtr)&gBuffers[i], &gFreeQ);			/* check whether VM is on and hold the packet buffers */	if (gVirtualMem) {		status = HoldMemory(&gBuffers, sizeof(gBuffers));		if (status == noErr)  {			/* mark queue structures for hold */			HoldMemory(&gFreeQ, sizeof(QHdr));			HoldMemory(&gUsedQ, sizeof(QHdr));		}	}				/*********** get socket listener code **********/	if (gSockCodeHndl == nil)	{		gSockCodeHndl = Get1Resource('Sock',128);		if (gSockCodeHndl == nil)		{			I_Error("Unable to load socket code resource");			return (resNotFound);		}				MoveHHi(gSockCodeHndl);		HLock(gSockCodeHndl);				/* tell the socket listener about the 2 queues */		status = CallInitSktListenerProc(((InitSktListenerProcPtr)((long) *gSockCodeHndl + 2)), &gFreeQ, &gUsedQ);	/*********** end get socket listener code **********/		if (status == noErr) {			if (gVirtualMem) 			{				listenerSize = GetHandleSize(gSockCodeHndl);				status = HoldMemory(*gSockCodeHndl, listenerSize);				if (status == noErr)					; // ¥ What?			}		}		if (status)			I_Error("Unable to initialize socket");		}		// Add socket and socket listener to socket table	ddpParmBlock.DDP.ioCompletion		= nil;	ddpParmBlock.DDP.csCode				= openSkt;	ddpParmBlock.DDP.socket				= gSocketNum;	ddpParmBlock.DDP.u.listener	= (DDPSocketListenerUPP)*gSockCodeHndl;	status = POpenSkt(&ddpParmBlock, false);	if (status != noErr)	{		I_Error("Error %d opening socket", status);		return (status);	}			gSocketNum	= ddpParmBlock.DDP.socket;	return(status);}//_____________________________________________________________________//// Extracts the zone name from the buffer of packed pascal strings//OSErr  MyZipExtract(Ptr theBuffer, int numInBuf, int whichOne, Str32 zoneName){	Ptr	zonePtr;	if( whichOne == 0 || whichOne > numInBuf)	{		return (paramErr);	}		zonePtr = theBuffer;	do	{		whichOne--;		if(whichOne != 0)		{			zonePtr += (*zonePtr + 1);		}	}while( whichOne != 0);		BlockMove(zonePtr, zoneName, *zonePtr + 1);		return(noErr);}//_____________________________________________________________________//// Adds zone name to list//void MyAddToZoneList(Str32 zoneName){	if(gNumZones < kMaxZones - 1)	{		BlockMoveData(zoneName, &gZoneNames[gNumZones], 33);	}}//_____________________________________________________________________//// Puts the zone names in the zone list//OSErr GetTheZoneList(){	XPPParamBlock	xppPB;	OSErr			result;	Ptr				zoneBuffer;	int				index;	Str32			zoneName;		zoneBuffer = NewPtr(kZoneBufferSize);	if (zoneBuffer == NULL)	{		I_Error("There is not enough free memory");	}		xppPB.XCALL.xppTimeout 		= 3;	xppPB.XCALL.xppRetry		= 4;	xppPB.XCALL.zipBuffPtr		= zoneBuffer;	xppPB.XCALL.zipLastFlag 	= 0;	xppPB.XCALL.zipInfoField[0] = 0;	xppPB.XCALL.zipInfoField[1] = 0;		do	{		result = GetZoneList(&xppPB, false);		if(result == noErr)		{			for(index = 1; index <= xppPB.XCALL.zipNumZones; index ++)			{				if( MyZipExtract(zoneBuffer, xppPB.XCALL.zipNumZones, index, zoneName) == noErr)				{					// Add this zone if it's not our zone					if (!CompPStr (zoneName, &gZoneNames[0]))					{						MyAddToZoneList(zoneName);						gNumZones++;					}				}			}		}		else		{			return(result);		}	}	while ( xppPB.XCALL.zipLastFlag == 0 && result == noErr && gNumZones < kMaxZones);		return(result);}//_____________________________________________________________________//// Adds local zone name to list//OSErr GetMyZoneName(){	XPPParamBlock	xppPB;	char			myZoneName[33];	OSErr			status;		xppPB.XCALL.xppTimeout 		= 3;	xppPB.XCALL.xppRetry		= 4;	xppPB.XCALL.zipBuffPtr		= myZoneName;	xppPB.XCALL.zipInfoField[0] = 0;	xppPB.XCALL.zipInfoField[1] = 0;		status = GetMyZone(&xppPB, false);		if (status == noErr)	{		BlockMoveData(myZoneName, &gZoneNames[0], 33);	}	else if (status == noBridgeErr)	{		Str32	temp = "\p*";				BlockMoveData(temp, &gZoneNames[0], 3);		status = noErr;		gNoRouter = true;	}	else	{		return (status);	}	gNumZones 		= 1; 	gNumZonesUsed	= 1; 		return(status);	}//_____________________________________________________________________________________________//	InitializeNet//// Open the MPP driver (although may already be open), //_____________________________________________________________________________________________OSErr InitializeNet(){	OSErr			status	= noErr;	Str32			newName = "\pDoomNewPlay0";	Str32			saveName = "\pDoomSavPlay0";	unsigned char	*strPtr;	int				count;	short			otherRecruit	= 0;		// Get the correct name string depending on whether game is a saved game	if (gPendingGame.vRefNum == 0 && gPendingGame.parID == 0 )	{		strPtr = newName;	}	else	{		strPtr = saveName;	}		// Copy the string to global	for (count = 12; count >= 0; count--)	{		gPlayerName[count] = strPtr[count];		gEntityNameArr[0].objStr[count] = strPtr[count];	}	// Make the last character random	gPlayerName[12] = (unsigned char) TickCount();	gEntityNameArr[0].objStr[12] = gPlayerName[12];		// Is VM on	gVirtualMem = IsVMOn();	// Open MPP driver, if not already open	if (IsMPPOpen() == false)	{	//	I_Error("Opening MPP driver\n");				if ((status	= OpenDriver("\p.MPP", &gMPPRefNum)) != noErr)	// Open the MPP driver		{			if (status == portInUse)			{				I_Error("Error, the network port is in use by another application");			}			else if (status == portNotCf)			{				I_Error("Error, Parameter RAM is not configured for this configuration");			} 			else			{ 				I_Error("Error in opening MPP driver %d", status);			}			return (status);		}	}	else	{		// Get MPP name eventhough it's already open		OpenDriver("\p.MPP", &gMPPRefNum);	// Open the MPP driver	//	I_Error("MPP driver was already open\n");	}		// Initialize Socket	if ((status = InitSocketListener()) != noErr)	{		I_Error("Error %d in opening Socket Listener", status);		return (status);	}			StatusDialog(80, 1);	StatusParamText("\pRegistering on network...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	// Allocate zone names buffer and get name of our zone	gNumZones 		= 0;	gNumZonesUsed 	= 0;		if ((status = GetMyZoneName()) != noErr)	{		I_Error("Getting my zone info %d", status);	}		if (!gNoRouter)	{		status = GetTheZoneList();		if (status != noErr)		{		#if __OPTFIX__			// Open Transport bug			if(status == noBridgeErr)			{				Str32	temp = "\p*";								BlockMoveData(temp, &gZoneNames[0], 3);				status = noErr;				gNoRouter = true;			}			else				I_Error("Getting the zone info %d", status);#else			I_Error("Getting the zone info %d", status);#endif	// __OPTFIX__		}	}		// Dont start if another game is already starting	CheckNameEntries(&otherRecruit, kRecruitingEntityType, false, false);	if(otherRecruit)	{		InitCursor();		gCursID = -2;				ParamText("\pAnother game is starting, please wait about a minute and try again.", "\p", "\p", "\p");		Alert(rAlertErrGeneral, NULL);								BlackScreen();		RedrawScreen();						I_Exit();		}	// Register on net	if ((status = RegisterEntityName(kFreeEntityType, true)) != noErr)	{		I_Error("Registering player on AppleTalk net %d", status);		return (status);	}	// Allocate memory for call to PLookupNames	gEntityInfoPtr	= NewPtrClear(kNameTupleSize * kMaxNetPlayers);	if (gEntityInfoPtr == nil)	{		I_Error("Allocating gEntityInfoPtr buffer");		return(memFullErr);	}	// Allocate DDP write data structure	gDDPWDSPtrArr	= NewPtrClear(kDDPWDSSize * kNumSendStructs);	if (gDDPWDSPtrArr == nil)	{		I_Error("Error in allocating gDDPWDSPtr buffer");		return(memFullErr);	}			// Allocate DDP header packet structure	gDDPHeaderPtrArr = NewPtrClear(kDDPHeaderSize * kNumSendStructs);	if (gDDPHeaderPtrArr == nil)	{		I_Error("Error in allocating gDDPHeaderPtr buffer");		return(memFullErr);	}		return(status);}//_____________________________________________________________________________________________//_____________________________________________________________________________________________//			TERMINATION ROUTINES//_____________________________________________________________________________________________//_____________________________________________________________________________________________//_____________________________________________________________________________________________//	TerminateSocketListener////	Removes our name and ATP socket.////_____________________________________________________________________________________________OSErr TerminateSocketListener(void){	MPPParamBlock 	mppPB;	OSErr			status = noErr;		mppPB.DDP.ioCompletion			= nil;					// no completion routine	mppPB.DDP.csCode				= closeSkt;				// Code for this call	mppPB.DDP.socket = gSocketNum;	// Socket number	if ((status = PCloseSkt(&mppPB, false)) != noErr)	 // Register name synchronously	{		I_Error("Error in calling PCloseSkt %d", status);		return (status);	}		HUnlock(gSockCodeHndl);	// Should free also		return(status);}//_____________________________________________________________________________________________//	TerminateNet//// Remove entry name fromNBP directory and deallocate names table entry record.//// Although we can check if MPP driver is open before opening (ISMPPOpen) and restore state // when quitting, we will not the close the driver when quitting the application because a// co-resident program may need it open.	//_____________________________________________________________________________________________OSErr TerminateNet(){	OSErr		status;	if ((status = RemoveEntityName()) != noErr)	{		I_Error("Error in calling RemoveEntityName %d", status);	}	if ((status = TerminateSocketListener()) != noErr)	{		I_Error("Error in calling TerminateSocketListener %d", status);	}		// Deallocate entity info	if (gEntityInfoPtr != nil)	{		DisposePtr(gEntityInfoPtr);	}			// Deallocate DDP write data structure	if (gDDPWDSPtrArr != nil)	{		DisposePtr(gDDPWDSPtrArr);	}		// Deallocate DDP header packet pointer	if (gDDPHeaderPtrArr != nil)	{		DisposePtr(gDDPHeaderPtrArr);	}	return	(status);}//_____________________________________________________________________________________________//_____________________________________________________________________________________________//			READ/WRITE ROUTINES//_____________________________________________________________________________________________//_____________________________________________________________________________________________//_____________________________________________________________________________________________//	SendDDPPacket////	Sends a packet to the entity at index sendTo in the address array//_____________________________________________________________________________________________OSErr SendDDPPacket(UInt16 sendTo, Ptr data, Size length){	OSErr		status = noErr;	UInt16		freeStruct;	Bytes8 		*dataDst;	Bytes8 		*dataSrc;	int 		i;		// Find a free structure	freeStruct = 0;	while (gMPPSendBlockArr[freeStruct].DDP.ioResult == 1)	{		freeStruct = (freeStruct + 1) % kNumSendStructs;	}	// Copy the data	//¥¥JDM ACCELERATE	dataSrc = (Bytes8 *) data;	dataDst = (Bytes8 *) &gSendDataArr[freeStruct];		for (i = length; i > 0; i -= 8)	{		*dataDst++ = *dataSrc++;	}	//	BlockMove(data, &gSendDataArr[freeStruct], length);		// Build the write data structure	BuildDDPwds((Ptr)(gDDPWDSPtrArr + (kDDPWDSSize * freeStruct)),				(Ptr)(gDDPHeaderPtrArr + (kDDPHeaderSize * freeStruct)),				(Ptr) &gSendDataArr[freeStruct], gAddressNameArr[sendTo], kDDPPacketType, length);		// Send the data	gMPPSendBlockArr[freeStruct].DDP.ioCompletion		= nil;	gMPPSendBlockArr[freeStruct].DDP.csCode				= writeDDP;	gMPPSendBlockArr[freeStruct].DDP.socket				= gSocketNum;	#ifdef __INTERNALCHECKSUM__				// If the socket listener is calculating checksum		gMPPSendBlockArr[freeStruct].DDP.checksumFlag 	= true;#else		gMPPSendBlockArr[freeStruct].DDP.checksumFlag 	= false;#endif	gMPPSendBlockArr[freeStruct].DDP.u.wdsPointer 		= (gDDPWDSPtrArr + (kDDPWDSSize * freeStruct));			if ((status = PWriteDDP(&gMPPSendBlockArr[freeStruct], true)) != noErr)	{		if (status == excessCollsns)	//continue on excessCollsns error		{					SysBeep(20);			SysBeep(20);			SysBeep(20);			SysBeep(20);			SysBeep(20);			SysBeep(20);			SysBeep(20);			SysBeep(20);#if __SYSBEEPS__			SysBeep(20);#endif		}		else		{			I_Error("Error in calling PWriteDDP %d", status);		}	}		return(status);}//_____________________________________________________________________________________________//	ReceivePacket//// Returns false if no packet is available, otherwise assigns to //_____________________________________________________________________________________________Boolean ReceiveDDPPacket(Ptr data, Size *length, short *remoteNode){	PacketPtr	bufPtr;	OSErr		status = noErr;	long		size;	Bytes8 		*dataSrc;	Bytes8 		*dataDst;	int 		i;		if(gUsedQ.qHead) {			//Get the packet		bufPtr = (PacketPtr)gUsedQ.qHead;				// Dequeue the packet so that it doesn't get overwritten		if (Dequeue((QElemPtr)gUsedQ.qHead, &gUsedQ) == noErr)		{#ifdef __INTERNALCHECKSUM__	// If the socket listener is calculating checksum			if (bufPtr->buffer_CheckSum != noErr)			{				I_Error("Checksum error occurred");			}			else			{#endif //__INTERNALCHECKSUM__			//¥¥JDM changed for size/*				size = (sizeof(doomdata_t) 						- (sizeof(ticcmd_t) * (BACKUPTICS - ((doomdata_t *)(bufPtr->buffer_Data))->numtics)));*/				size = bufPtr->buffer_ActCount;				if (size > *length)				{					I_Error("If we read all this data from the net, there would be an overflow");				}				//¥¥JDM Accelerate				dataSrc = (Bytes8 *) bufPtr->buffer_Data;				dataDst = (Bytes8 *) data;								for (i = size; i > 0; i -= 8)				{					*dataDst++ = *dataSrc++;				}//				BlockMove(bufPtr->buffer_Data, data, size);				*length = size;				#ifdef __INTERNALCHECKSUM__			}#endif //__INTERNALCHECKSUM__						// if not in setup, find out who it is from			if (!gInSetup)			{				int i;								for(i = 1; i <= gNumPlayersOnNet; i++)				{					if(!memcmp(&gAddressNameArr[i], &bufPtr->buffer_Address, sizeof(AddrBlock)))					{						break;					}									}				if(i <= gNumPlayersOnNet)				{					*remoteNode = i;				}				else // This shouldn't happen				{					/* requeue the packet buffer for use. */					Enqueue((QElemPtr)bufPtr, &gFreeQ);					return(false);				}				}			else			// if we are in setup, set source address in [0]			{				gAddressNameArr[0] = bufPtr->buffer_Address;			}			/* requeue the packet buffer for use. */			Enqueue((QElemPtr)bufPtr, &gFreeQ);		}		else 		{			I_Error("Packet Dequeue error");		}	}	else 	{		return(false);	}		return(true);	}void Wait(){	long myWaitTicks;	long currWaitTics;		myWaitTicks = TickCount() + (60 * 10);	while((currWaitTics = TickCount()) < myWaitTicks)	{		if (CheckForTermination())		{			I_Exit();		}				if(currWaitTics % 10)		{			SpinCursor();		}	}}typedef enum SetupState		// These are random values{	kIWouldLikeYou 	= 89,	// Sent from initiator to available node	kYouCanHaveMe  	= 72,	// Sent from available after receiving kIWouldLikeYou	kHereWeAre		= 66,	// Sent from initiator with addresses of all players	kCancelSetup	= 99	// Sent to abort setup with the receiver} SetupState;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endiftypedef struct ATalkSetup{	SetupState	state;	long		numPlayers;	AddrBlock	adrArr[kMaxNetPlayers];      } ATalkSetup;#if defined(powerc) || defined(__powerc)#pragma options align=reset#endifBoolean IAmBeingRecruited(){	int				length;	ATalkSetup		setup;	short 			node;	if (CheckForTermination())	{		I_Exit();	}	SpinCursor();	length = sizeof(doomdata_t);					if ( ReceiveDDPPacket((Ptr) &setup, &length, &node) )	{		SpinCursor();		// if its a setup packet, we are done		if (setup.state == kIWouldLikeYou)		{			StatusDialog(80, 8);			StatusParamText("\pFound a game to join...", "\p", "\p", "\p");			DrawStatusDialog(TRUE);			return (true);		}	}	return(false);}void AppleTalkConnect(){	ATalkSetup		setup;	long			time;	int				src, dst;	Boolean			done, waitAgain;	int				length;	AddrBlock		KeyAddr;	short			numPlayers;	int				numDesiredPlayers;	int				lowIndex, currIndex;	unsigned long 	*longAddr;	Boolean			moreZones = false;	Boolean 		recruitMe = false;	OSErr			status;	AddrBlock		Addrs[4];		StatusDialog(80, 4);TRYAGAIN:	numPlayers = 0;	numDesiredPlayers = gPlayersWanted;		// We are a player, so need to look for 1 less	numDesiredPlayers--;		StatusParamText("\pLooking for other players...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	// Wait until all players are available	done = false;	while (!done && !recruitMe)	{		// If someone sees me and I havent seen them yet, and they are trying to recruit		// me, accept.		if (IAmBeingRecruited())		{			recruitMe = true;		}							SpinCursor();		CheckNameEntries(&numPlayers, kFreeEntityType, true, moreZones);		// If someone sees me and I havent seen them yet, and they are trying to recruit		// me, accept.		if (IAmBeingRecruited())		{			recruitMe = true;		}		SpinCursor();		if (numPlayers < numDesiredPlayers && !recruitMe)		{			Wait();						// If someone sees me and I havent seen them yet, and they are trying to recruit			// me, accept.			if (IAmBeingRecruited())			{				recruitMe = true;			}			else			{				// Check one more time in my zone				CheckNameEntries(&numPlayers, kFreeEntityType, true, false);					// If someone sees me and I havent seen them yet, and they are trying to recruit				// me, accept.				if (IAmBeingRecruited())				{					recruitMe = true;				}			}			if (numPlayers < numDesiredPlayers && !recruitMe)			{				// Will we play with the available players				if (numPlayers >= 1)				{					Str255	str = "\pThere are currently 1 players available.  Would you like to wait for more players?";										str[21] = (unsigned char) numPlayers + '0';					if (numPlayers > 1)						ParamText(str, "\p", "\p", "\p");					else						ParamText("\pThere is currently 1 player available.  Would you like to wait for more players?", "\p", "\p", "\p");					waitAgain = Alert(rAlertGeneralYN, NULL);																BlackScreen();					RedrawScreen();										if (waitAgain == kNoButton)					{						Str255	str = "\pPreparing for 1 player game...";												str[15] = (unsigned char) numPlayers + '0' + 1;						StatusParamText(str, "\p", "\p", "\p");						DrawStatusDialog(TRUE);						done = true;						numDesiredPlayers = numPlayers;					}					else					{						StatusParamText("\pLooking for other players...", "\p", "\p", "\p");						DrawStatusDialog(TRUE);					}				}				else if (!recruitMe)				{					InitCursor();					gCursID = -2;										ParamText("\pThere are currently no other players available.  Would you like to continue waiting?", "\p", "\p", "\p");					waitAgain = Alert(rAlertGeneralYN, NULL);																BlackScreen();					RedrawScreen();											if (waitAgain == kNoButton)					{						I_Exit();					}					else					{						StatusParamText("\pLooking for other players...", "\p", "\p", "\p");						DrawStatusDialog(TRUE);												SpinCursor();										}				}			}						moreZones = true;		// Next time through, use additional zones			if (gNumZonesUsed < gNumZones && !gNoRouter &&!recruitMe)			{					// If someone sees me and I havent seen them yet, and they are trying to recruit				// me, accept.				if (IAmBeingRecruited())				{					recruitMe = true;				}								gNumZonesUsed++;			}		}		else		{			done = true;		}	}		if(!recruitMe)	{					gAddressNameArr[0].aNet = gNamesTableEntry.nt.nteAddress.aNet; 		// my address in 0		gAddressNameArr[0].aNode = gNamesTableEntry.nt.nteAddress.aNode; 		gAddressNameArr[0].aSocket = gNamesTableEntry.nt.nteAddress.aSocket;			gEntityNameArr[0].objStr[12] = gPlayerName[12];	// In case it changed in a register name call		for(currIndex = 0, lowIndex = 0; currIndex <= numPlayers; currIndex++)		{			if(gAddressNameArr[currIndex].aSocket < gAddressNameArr[lowIndex].aSocket)			{				lowIndex = currIndex;			}			else if ((gAddressNameArr[currIndex].aSocket == gAddressNameArr[lowIndex].aSocket)					&&	(gEntityNameArr[currIndex].objStr[12] < gEntityNameArr[lowIndex].objStr[12]))			{				lowIndex = currIndex;			}		}	}		// I am lowest	if(lowIndex == 0 && !recruitMe)	{		int		numFailed;		int		numTried;		short	otherRecruit	= 0;		Boolean restartConnect	= false;		Boolean alertedUser 	= false;		int i;				SpinCursor();		// Check if someone else is recruiting		CheckNameEntries(&otherRecruit, kRecruitingEntityType, false, false);		time = TickCount();		while(otherRecruit)		{			otherRecruit = 0;						// Wait until other is done recruiting			CheckNameEntries(&otherRecruit, kRecruitingEntityType, false, false);			if (otherRecruit)			{				restartConnect = true;								if (!alertedUser)				{					StatusParamText("\pWaiting for another game to start...", "\p", "\p", "\p");					DrawStatusDialog(TRUE);					alertedUser = true;				}			}						if(TickCount() > time + (60 * 20))			{					InitCursor();				gCursID = -2;								ParamText("\pThere is still another game starting.  Would you like to continue waiting?", "\p", "\p", "\p");				waitAgain = Alert(rAlertGeneralYN, NULL);														BlackScreen();				RedrawScreen();									if (waitAgain == kNoButton)				{					I_Exit();				}				else				{					StatusParamText("\pWaiting for another game to start...", "\p", "\p", "\p");					DrawStatusDialog(TRUE);					time = TickCount();					SpinCursor();				}			}		}		if (restartConnect)		{			goto TRYAGAIN;		}				gKeyPlayer = true;		StatusDialog(80, 6);		StatusParamText("\pInitiating start of game...", "\p", "\p", "\p");		DrawStatusDialog(TRUE);		SpinCursor();				// Remove old name		RemoveEntityName();		// Register as recruiting		if ((status = RegisterEntityName(kRecruitingEntityType, true)) != noErr)		{			I_Error("Unable to register as a recruiter on the net %d", status);		}				SpinCursor();		// Try each entity until either all tried or got desired number of players		numFailed = 0;		for(numTried = 1; numTried <=  numDesiredPlayers; numTried++)		{			SpinCursor();			StatusDialog(80, 6 + numTried);			StatusParamText("\pAsking player to join game...", "\p", "\p", "\p");			DrawStatusDialog(TRUE);			// Send initial packet			setup.state = kIWouldLikeYou;			SendDDPPacket(numTried, (Ptr) &setup, sizeof(ATalkSetup));			SpinCursor();						// Wait for response			done 		= false;			time		= TickCount();						StatusParamText("\pWaiting for response...", "\p", "\p", "\p");			DrawStatusDialog(TRUE);			while( !done )			{				short node;								SpinCursor();				length = sizeof(doomdata_t);								if ( ReceiveDDPPacket((Ptr) &setup, &length, &node) )				{					// Is it an ack					if (setup.state == kYouCanHaveMe)					{						StatusParamText("\pPlayer has been recruited.", "\p", "\p", "\p");						DrawStatusDialog(TRUE);												done = true;					}				}					// This guy did not respond				if ( !done && (TickCount() > time + (60 * 30)) )				{					SpinCursor();										StatusParamText("\pAborting current recruit...", "\p", "\p", "\p");					DrawStatusDialog(TRUE);					setup.state = kCancelSetup;					// SendDDPPacket(numTried, (Ptr) &setup, sizeof(ATalkSetup));					numFailed += 1;					done = true;				}			}							SpinCursor();			// if received, add to list starting at 1			if (setup.state == kYouCanHaveMe)			{				Addrs[numTried - numFailed] = gAddressNameArr[0];			}									}				// If unable to acquire any, alert user		if (numFailed == numDesiredPlayers)		{			InitCursor();			gCursID = -2;						ParamText("\pUnable to recruit any players.", "\p", "\p", "\p");			waitAgain = Alert(rAlertErrGeneral, NULL);									BlackScreen();			RedrawScreen();							I_Exit();			}				// Copy players to own address array		gNumPlayersOnNet = numTried - numFailed -1;				memcpy (&gAddressNameArr[1], &Addrs[1], sizeof(AddrBlock) * gNumPlayersOnNet);//		memcpy (&gAddressNameArr[1], &setup.adrArr[1], sizeof(AddrBlock) * gNumPlayersOnNet);		// Send out packet with number of players, indices and addresses		setup.state = kHereWeAre;		setup.numPlayers = gNumPlayersOnNet;		for (i = 1; i <= gNumPlayersOnNet; i++)		{			SpinCursor();			memcpy (&setup.adrArr[1], &Addrs[1], sizeof(AddrBlock) * gNumPlayersOnNet);			SendDDPPacket(i,(Ptr) &setup, sizeof(ATalkSetup));		}		StatusDialog(80, 11);		if(numFailed)		{			StatusParamText("\pUnable to recruit all players.", "\p", "\p", "\p");				}		else		{			StatusParamText("\pAll players have been recruited.", "\p", "\p", "\p");		}		DrawStatusDialog(TRUE);				doomcom->consoleplayer = 0;		// Remove old name		RemoveEntityName();		// Register as reserved		if ((status = RegisterEntityName(kReservedEntityType, true)) != noErr)		{			I_Error("Unable to re-register on the net %d", status);		}	}	else	{		//		// Wait for initiation		//		gKeyPlayer	= false;				if(!recruitMe)		{			waitAgain 	= kYesButton;			done 		= false;			time		= TickCount();						StatusDialog(80, 6);			StatusParamText("\pWaiting to be recruited...", "\p", "\p", "\p");			DrawStatusDialog(TRUE);				while( !done && (waitAgain == kYesButton) )			{								if (IAmBeingRecruited())				{					done = true;				}									if ( !done && (TickCount() > time + (60 * 45)) )				{					InitCursor();					gCursID = -2;										ParamText("\pThere are currently no players initiating a game.  Would you like to continue waiting?", "\p", "\p", "\p");					waitAgain = Alert(rAlertGeneralYN, NULL);												BlackScreen();					RedrawScreen();														if (waitAgain == kNoButton)					{						I_Exit();					}					else					{						StatusDialog(80, 9);						StatusParamText("\pWaiting to be recruited...", "\p", "\p", "\p");						DrawStatusDialog(TRUE);						SpinCursor();								time		= TickCount();						waitAgain = kYesButton;					}				}							}		}			// Go Here if received a recruit message			SpinCursor();				// Get address of key player		KeyAddr = gAddressNameArr[0];				SpinCursor();				SpinCursor();		StatusDialog(80, 10);		StatusParamText("\pPreparing to join game...", "\p", "\p", "\p");		DrawStatusDialog(TRUE);		SpinCursor();						// Send ack back to initiator		setup.state = kYouCanHaveMe;		// Make sure it gets sent to key player		gAddressNameArr[1] = KeyAddr;		SendDDPPacket(1,(Ptr) &setup, sizeof(ATalkSetup));		 		SpinCursor();				// Remove old name		RemoveEntityName();		// Register as reserved		if (RegisterEntityName(kReservedEntityType, true) != noErr)		{			I_Error("Unable to re-register on the net");		}				SpinCursor();				// Wait for list of players		waitAgain 	= kYesButton;		done 		= false;		time		= TickCount();				StatusParamText("\pWaiting for player list...", "\p", "\p", "\p");		StatusDialog(80, 11);		DrawStatusDialog(TRUE);		while( !done && (waitAgain == kYesButton) )		{			short node;						SpinCursor();			length = sizeof(doomdata_t);							if ( ReceiveDDPPacket((Ptr) &setup, &length, &node) )			{				SpinCursor();				// if its a setup packet, we are done				if (setup.state == kHereWeAre)				{					done = true;					gNumPlayersOnNet = setup.numPlayers;				}			}			if ( !done && (TickCount() > time + (60 * 13)) )			{				InitCursor();				gCursID = -2;								ParamText("\pStill waiting for the player list.  Would you like to continue waiting?", "\p", "\p", "\p");				waitAgain = Alert(rAlertGeneralYN, NULL);														BlackScreen();				RedrawScreen();									if (waitAgain == kNoButton)				{					I_Exit();				}				else				{					StatusParamText("\pWaiting for player list...", "\p", "\p", "\p");					DrawStatusDialog(TRUE);					SpinCursor();						waitAgain 	= kYesButton;					time		= TickCount();				}			}					}				// Assign all players and their addresses		dst = 2;				// Copy key player		SpinCursor();				StatusParamText("\pHave been accepted into game...", "\p", "\p", "\p");		DrawStatusDialog(TRUE);		gAddressNameArr[1] = KeyAddr;		for (src = 1; src <= gNumPlayersOnNet ; src++)		{			SpinCursor();			if (memcmp(&setup.adrArr[src], &gNamesTableEntry.nt.nteAddress, sizeof(AddrBlock)))			{				gAddressNameArr[dst] = setup.adrArr[src];				dst++;			}			else			{				doomcom->consoleplayer = src;			}					}			}		gInSetup = false;}