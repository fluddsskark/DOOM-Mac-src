#ifndef __MPW_VERSION__	#if defined(powerc) || defined (__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#else	#include <Dialogs.h>#endif#include "LionDoom.h"#include <Lion.h>#include <ctype.h>#include "MacAllocA.h"// R_data.c#include "doomdef.h"#include "r_local.h"#include "p_local.h"#include "R_DATA.PROTO.H"extern void StatusDialog (long total, long current);extern void DrawStatusDialog (Boolean forUpdate);extern void StatusParamText(char *one, char *two, char *three, char *four);typedef struct{	int					originx;	// block origin (allways UL), which has allready	int					originy;	// accounted  for the patch's internal origin	int					patch;} texpatch_t;// a maptexturedef_t describes a rectangular texture, which is composed of one// or more mappatch_t structures that arrange graphic patchestypedef struct{	char				name[8];		// for switch changing, etc	short				width;	short				height;	short				patchcount;	texpatch_t	patches[1];		// [patchcount] drawn back to front								//  into the cached texture} texture_t;int							firstflat = 0, lastflat = 0, numflats = 0;int							firstpatch = 0, lastpatch = 0, numpatches = 0;int							firstspritelump = 0, lastspritelump = 0, numspritelumps = 0;int							numtextures = 0;texture_t				**textures = NULL;int							*texturewidthmask = NULL;fixed_t					*textureheight = NULL;			// needed for texture peggingint							*texturecompositesize = NULL;short						**texturecolumnlump = NULL;unsigned short	**texturecolumnofs = NULL;byte						**texturecomposite = NULL;int							*flattranslation = NULL;		// for global animationint							*texturetranslation = NULL;	// for global animationfixed_t					*spritewidth = NULL;			// needed for pre renderingfixed_t					*spriteoffset = NULL;fixed_t					*spritetopoffset = NULL;lighttable_t		*colormaps = NULL;int							colormapslength = 0;extern void SpinCursor (void);/*===================== strcasecmp== string insensitive case compare, no specified length.====================*/int strcasecmp (char *first, char *second){	register short		index = 0;	register char			c1, c2;		// Compare until a string runs out of characters or not equal		while (TRUE)	{		c1 = toupper(first[index]);		c2 = toupper(second[index++]);				if (!c1)							// string 1 is done.		{			if (!c2)						// so is string 2				return 0;			else				return -1;				// string 2 continues...		}				if (!c2)			return 1;						// both done				if (c1 != c2)					// don't match?		{			if (c1 < c2)				// string 1 < string 2				return -1;			else				return 1;					// else string 1 > string 2		}	}		return 0;}/*===================== strncasecmp== string insensitive case compare.====================*/int strncasecmp (char *first,	char *second, long len){	register short		index = 0;	register char			c1, c2;		// Compare until a string runs out of characters or not equal		while (index < len)	{		c1 = toupper(first[index]);		c2 = toupper(second[index++]);				if (!c1)							// string 1 is done.		{			if (!c2)						// so is string 2				return 0;			else				return -1;				// string 2 continues...		}				if (!c2)			return 1;						// both done				if (c1 != c2)					// don't match?		{			if (c1 < c2)				// string 1 < string 2				return -1;			else				return 1;					// else string 1 > string 2		}	}		return 0;}/*==============================================================================						MAPTEXTURE_T CACHINGwhen a texture is first needed, it counts the number of composite columnsrequired in the texture and allocates space for a column directory and anynew columns.  The directory will simply point inside other patches if thereis only one patch in a given column, but any columns with multiple patcheswill have new column_ts generated.==============================================================================*//*===================== R_DrawColumnInCache== Clip and draw a column from a patch into a cached post====================*/void R_DrawColumnInCache (column_t *patch, byte *cache, int originy, int cacheheight){	int			count, position;	byte		*source, *dest;		dest = cache + 3;					// "dest" is never used. Why not?		while (patch->topdelta != 0xff)	{		source = ((byte *)patch) + 3;		// Why add 3? why not 2 for "byte topdelta" &																		// "byte		length" fields?				count = patch->length;		position = originy + patch->topdelta;				if (position < 0)		{			count += position;		// Why doesn't "source" get incremented by -position?														// I tried it, it made no difference.			position = 0;		}				if (position + count > cacheheight)			count = cacheheight - position;				if (count > 0)			memcpy (cache + position, source, count);				patch = (column_t *)( ((byte *)patch) + (patch->length + 4) );		// Why add 4?	}}/*===================== R_GenerateComposite====================*/void R_GenerateComposite (int texnum){	byte						*block;	texture_t				*texture;	texpatch_t			*patch;		patch_t					*realpatch;	int							x, x1, x2;	int							i;	column_t				*patchcol;	short						*collump;	unsigned short 	*colofs;		texture = textures[texnum];	block = Z_Malloc (texturecompositesize[texnum], PU_STATIC, 		&texturecomposite[texnum]);	collump = texturecolumnlump[texnum];	colofs = texturecolumnofs[texnum];	//// composite the columns together//	patch = texture->patches;		for (i = 0; i < texture->patchcount; i++, patch++)	{	/*		if (i == 36)		{			realpatch = NULL;			break;		}	*/				realpatch = W_CacheLumpNum (patch->patch, PU_CACHE);		x1 = patch->originx;		x2 = SHORT(realpatch->width);		x2 += x1;				x = (x1 < 0) ? 0 : x1;				if (x2 > texture->width)			x2 = texture->width;				for ( ; x < x2; x++)		{		// If column has multiple patches...			if (collump[x] < 0)			{				patchcol = (column_t *)( ((byte *)realpatch) + 					LONG(realpatch->columnofs[x - x1]) );								R_DrawColumnInCache (patchcol, block + colofs[x], patch->originy,					(int) texture->height);			}		}	}// now that the texture has been built, it is purgable	Z_ChangeTag (block, PU_CACHE);}/*===================== R_GenerateLookup====================*/void R_GenerateLookup (int texnum){	texture_t				*texture;	byte						*patchcount;		// [texture->width]	texpatch_t			*patch;		patch_t					*realpatch;	int							x, x1, x2;	int							i;	short						*collump;	unsigned short	*colofs;		// PushRoutineAllocA();		texture = textures[texnum];		texturecomposite[texnum] = 0;					// composite not created yet	texturecompositesize[texnum] = 0;	collump = texturecolumnlump[texnum];	colofs = texturecolumnofs[texnum];	//// count the number of columns that are covered by more than one patch// fill in the lump / offset, so columns with only a single patch are// all done//	// patchcount = (byte *) alloca (texture->width);	// memset (patchcount, 0, texture->width);		patchcount = (byte *) NewPtrClear( texture->width );		patch = texture->patches;		for (i = 0; i < texture->patchcount; i++, patch++)	{		realpatch = W_CacheLumpNum (patch->patch, PU_CACHE);		x1 = patch->originx;		x2 = x1 + SHORT(realpatch->width);				x = (x1 < 0) ? 0 : x1;				if (x2 > texture->width)			x2 = texture->width;				for ( ; x < x2 ; x++)		{			if (patchcount[x] > 127)				I_Error("R_GenerateLookup: blew out ÒpatchcountÓ.");			patchcount[x]++;			collump[x] = patch->patch;			colofs[x] = LONG(realpatch->columnofs[x - x1]) + 3;		}	}		for (x = 0; x < texture->width; x++)	{		if (!patchcount[x])		{			I_Error ("R_GenerateLookup: column without a patch (%s)\n", texture->name);			DisposePtr( patchcount );			// PopRoutineAllocA();			return;		}		if (patchcount[x] > 1)		{			collump[x] = -1;	// use the cached block			colofs[x] = texturecompositesize[texnum];			if (texturecompositesize[texnum] > (0x10000L - texture->height))				I_Error ("R_GenerateLookup: texture %i is greater than 64k", texnum);			texturecompositesize[texnum] += texture->height;		}	}		DisposePtr( patchcount );	// PopRoutineAllocA();}/*================== R_GetColumn=================*/byte *R_GetColumn (int tex, int col){	int		lump, ofs;		col &= texturewidthmask[tex];	lump = (texturecolumnlump[tex])[col];	ofs = (texturecolumnofs[tex])[col];		if (lump > 0)		return (byte *) W_CacheLumpNum(lump, PU_CACHE) + ofs;		if (!texturecomposite[tex])		R_GenerateComposite (tex);		return texturecomposite[tex] + ofs;}/*==================== R_InitTextures== Initializes the texture list with the textures from the world map===================*/// #define __PATCH_PROBLEM__	1void R_InitTextures (void){	maptexture_t	*mtexture;	texture_t			*texture;	mappatch_t		*mpatch;	texpatch_t		*patch;	int						i, j;	int						*maptex, *maptex2, *maptex1;	char					name[9], *names, *name_p;	int						*patchlookup;	int						totalwidth;	int						nummappatches;	int						offset, maxoff, maxoff2;	int						numtextures1, numtextures2;	int						*directory;	int						powerBar,powerDiv;	#ifdef __PATCH_PROBLEM__	FILE					*patchfile;		patchfile = fopen("patchstuff", "w");#endif	//// load the patch names from pnames.lmp//	name[8] = 0;	names = W_CacheLumpName ("PNAMES", PU_STATIC);	nummappatches = LONG ( *((int *)names) );	name_p = names + 4;	patchlookup = (int *) NewPtrClear(nummappatches * sizeof(int));	#ifdef __PATCH_PROBLEM__	if (TRUE)	{		int		*plookupsave = patchlookup;				// Dump the 'PNAMES' list		for (i = 0; i < nummappatches; i++)		{			strncpy (name, name_p, 8);			name_p += 8;						patchlookup[i] = W_CheckNumForName (name);						fprintf(patchfile, "Patch Index %d   *   Num %d   *   Name Ô%sÕ\n", i, patchlookup[i], name);		}				patchlookup = plookupsave;	}	name_p = names + 4;#endif		for (i = 0; i < nummappatches; i++)	{		strncpy (name, name_p, 8);		name_p += 8;				patchlookup[i] = W_CheckNumForName (name);		if (patchlookup[i] == -1)		{#ifdef __PATCH_PROBLEM__			fclose(patchfile);#endif			if (!shareware || (i < 163))				I_Error("Bad patch at index %d.", i);			else				break;		}	}	Z_Free (names);//// load the map texture definitions from textures.lmp//	maptex = maptex1 = W_CacheLumpName ("TEXTURE1", PU_STATIC);	numtextures1 = LONG(*maptex);	maxoff = W_LumpLength (W_GetNumForName ("TEXTURE1"));	directory = maptex + 1;		if (W_CheckNumForName ("TEXTURE2") != -1)	{		maptex2 = W_CacheLumpName ("TEXTURE2", PU_STATIC);		numtextures2 = LONG(*maptex2);		maxoff2 = W_LumpLength (W_GetNumForName ("TEXTURE2"));	}	else	{		maptex2 = NULL;		numtextures2 = 0;		maxoff2 = 0;	}	numtextures = numtextures1 + numtextures2;		textures = Z_Malloc (numtextures * 4, PU_STATIC, 0);	texturecolumnlump = Z_Malloc (numtextures * 4, PU_STATIC, 0);	texturecolumnofs = Z_Malloc (numtextures * 4, PU_STATIC, 0);	texturecomposite = Z_Malloc (numtextures * 4, PU_STATIC, 0);	texturecompositesize = Z_Malloc (numtextures * 4, PU_STATIC, 0);	texturewidthmask = Z_Malloc (numtextures * 4, PU_STATIC, 0);	textureheight = Z_Malloc (numtextures * 4, PU_STATIC, 0);		totalwidth = 0;	// Increase powerBar (12) from 16 to 28	powerBar = 16;	powerDiv = numtextures / 12;	for (i = 0; i < numtextures; i++, directory++)	{		SpinCursor();		if(!(i % powerDiv) && powerBar < 28)		{			powerBar += 1;			StatusDialog(80, powerBar);		}		if (i == numtextures1)		{		// start looking in second texture file			maptex = maptex2;			maxoff = maxoff2;			directory = maptex + 1;		}				offset = *directory;		offset = LONG(offset);				if (offset > maxoff)			I_Error ("R_InitTextures: bad texture directory");				mtexture = (maptexture_t *) ( (byte *)maptex + offset);		texture = textures[i] = Z_Malloc (sizeof(texture_t) 			+ sizeof(texpatch_t) * (SHORT(mtexture->patchcount) - 1), PU_STATIC, 0);		texture->width = SHORT(mtexture->width);		texture->height = SHORT(mtexture->height);		texture->patchcount = SHORT(mtexture->patchcount);		memcpy (texture->name, mtexture->name, sizeof(texture->name));		mpatch = &mtexture->patches[0];		patch = &texture->patches[0];		for (j = 0; j < texture->patchcount; j++, mpatch++, patch++)		{ 			patch->originx = SHORT(mpatch->originx);			patch->originy = SHORT(mpatch->originy);						/*			if ((SHORT(mpatch->patch) < 0) || (SHORT(mpatch->patch) >= nummappatches))				I_Error("R_InitTextures: blew out ÒpatchlookupÓ.");			*/						patch->patch = patchlookup[ SHORT(mpatch->patch) ];			#ifdef __PATCH_PROBLEM__			if (i == 270)			{				fprintf(patchfile, "\nmpatch[%ld][%ld]  .originx=0x%04hX  .originy=0x%04hX  .patch(ndx)=0x%04hX\n",					i, j, mpatch->originx, mpatch->originy, mpatch->patch);				fprintf(patchfile, "patch[%ld][%ld]  .originx=%hd  .originy=%hd  .patch(num)=%hd\n",					i, j, patch->originx, patch->originy, patch->patch);			}#endif			if (patch->patch == -1)				I_Error ("R_InitTextures: Missing patch in texture %s",texture->name);		}		texturecolumnlump[i] = Z_Malloc (texture->width * 2, PU_STATIC, 0);		texturecolumnofs[i] = Z_Malloc (texture->width * 2, PU_STATIC, 0);		j = 1;		while ((j * 2) <= texture->width)			j <<= 1;		texturewidthmask[i] = j - 1;		textureheight[i] = texture->height << FRACBITS;				totalwidth += texture->width;	}	StatusDialog(80, 28);		Z_Free (maptex1);	if (maptex2)		Z_Free (maptex2);	//// precalculate whatever possible//			// Increase powerBar (20) from 28 to 48	powerBar = 28;	powerDiv = numtextures / 20;	for (i = 0; i < numtextures; i++)	{		if(!(i % powerDiv) && powerBar < 48)		{			powerBar += 1;			StatusDialog(80, powerBar);		}		SpinCursor();		R_GenerateLookup (i);	}	StatusDialog(80, 48);//// translation table for global animation//	texturetranslation = Z_Malloc ((numtextures + 1) * 4, PU_STATIC, 0);	for (i = 0; i < numtextures; i++)	{		SpinCursor();		texturetranslation[i] = i;	}		DisposePtr((Ptr)patchlookup);	#ifdef __PATCH_PROBLEM__	fclose(patchfile);#endif}/*================== R_InitFlats==================*/void R_InitFlats (void){	int		i;		firstflat = W_GetNumForName ("F_START") + 1;	lastflat = W_GetNumForName ("F_END") - 1;	numflats = lastflat - firstflat + 1;	// translation table for global animation	flattranslation = Z_Malloc ((numflats+1)*4, PU_STATIC, 0);	for (i=0 ; i<numflats ; i++)		flattranslation[i] = i;}/*================== R_InitSpriteLumps== Finds the width and hoffset of all sprites in the wad, so the sprite doesn't= need to be cached just for the header during rendering=================*/void R_InitSpriteLumps (void){	int				i;	patch_t		*patch;	int				powerBar,powerDiv;		firstspritelump = W_GetNumForName ("S_START") + 1;	lastspritelump = W_GetNumForName ("S_END") - 1;	numspritelumps = lastspritelump - firstspritelump + 1;	spritewidth = Z_Malloc (numspritelumps * 4, PU_STATIC, 0);	spriteoffset = Z_Malloc (numspritelumps * 4, PU_STATIC, 0);	spritetopoffset = Z_Malloc (numspritelumps * 4, PU_STATIC, 0);		// Increase powerBar (20) from 48 to 68	powerBar = 48;	powerDiv = numspritelumps / 20;	for (i = 0; i < numspritelumps; i++)	{		if(!(i % powerDiv) && powerBar < 68)		{			powerBar += 1;			StatusDialog(80, powerBar);		}		SpinCursor();		patch = W_CacheLumpNum (firstspritelump + i, PU_CACHE);		spritewidth[i] = SHORT(patch->width) << FRACBITS;		spriteoffset[i] = SHORT(patch->leftoffset) << FRACBITS;		spritetopoffset[i] = SHORT(patch->topoffset) << FRACBITS;	}	StatusDialog(80, 68);}/*================== R_InitColormaps==================*/void R_InitColormaps (void){	int		lump, length;// // load in the light tables // 256 byte align tables//	lump = W_GetNumForName("COLORMAP"); 	length = W_LumpLength (lump) + 255; 	colormaps = Z_Malloc (length, PU_STATIC, 0); 	colormaps = (byte *)( ((int)colormaps + 255) & ~0xff); 	W_ReadLump (lump, colormaps);	colormapslength = length - 255;		// Added for Mac.}/*================== R_InitData== Locates all the lumps that will be used by all views= Must be called after W_Init=================*/void R_InitData (void){	StatusParamText("\pLoading textures...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	R_InitTextures ();	StatusParamText("\pLoading floors and ceilings...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	R_InitFlats ();	StatusDialog(80, 50);	StatusParamText("\pLoading sprites...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	R_InitSpriteLumps ();	R_InitColormaps ();}//=============================================================================/*================== R_FlatNumForName=================*/int	R_FlatNumForName (char *name){	int		i;	char	namet[9];	i = W_CheckNumForName (name);	if (i == -1)	{		namet[8] = 0;		memcpy (namet, name, 8);		I_Error ("R_FlatNumForName: %s not found", namet);	}	return i - firstflat;}/*================== R_CheckTextureNumForName=================*/int	R_CheckTextureNumForName (char *name){	int		i;		if (name[0] == '-')		// no texture marker		return 0;		for (i = 0; i < numtextures; i++)		if (!strncasecmp (textures[i]->name, name, 8) )			return i;			return -1;}/*================== R_TextureNumForName=================*/int	R_TextureNumForName (char *name){	int		i;		i = R_CheckTextureNumForName (name);	if (i == -1)		I_Error ("R_TextureNumForName: %s not found", name);		return i;}/*=================== R_PrecacheLevel== Preloads all relevent graphics for the level=================*/int		flatmemory = 0, texturememory = 0, spritememory = 0;void R_PrecacheLevel (void){	char			*flatpresent;	char			*texturepresent;	char			*spritepresent;	int				i, j, k, lump;	texture_t		*texture;	thinker_t		*th;	spriteframe_t	*sf;	if (demoplayback)		return;		PushRoutineAllocA();			//// precache flats//		flatpresent = alloca(numflats);	memset(flatpresent, 0, numflats);		for (i = 0; i < numsectors; i++)	{		flatpresent[sectors[i].floorpic] = 1;		flatpresent[sectors[i].ceilingpic] = 1;	}		flatmemory = 0;	for (i = 0; i < numflats; i++)	{		if (flatpresent[i])		{			lump = firstflat + i;			flatmemory += lumpinfo[lump].size;			W_CacheLumpNum(lump, PU_CACHE);		}	}		//// precache textures//	texturepresent = alloca(numtextures);	memset (texturepresent, 0, numtextures);		for (i = 0; i < numsides; i++)	{		texturepresent[sides[i].toptexture] = 1;		texturepresent[sides[i].midtexture] = 1;		texturepresent[sides[i].bottomtexture] = 1;	}		texturepresent[skytexture] = 1;		texturememory = 0;	for (i = 0; i < numtextures; i++)	{		if (!texturepresent[i])			continue;				texture = textures[i];				for (j = 0; j < texture->patchcount; j++)		{			lump = texture->patches[j].patch;			texturememory += lumpinfo[lump].size;			W_CacheLumpNum(lump , PU_CACHE);		}	}	//// precache sprites//	spritepresent = alloca(numsprites);	memset(spritepresent, 0, numsprites);		for (th = thinkercap.next; th != &thinkercap; th = th->next)	{		if (th->function == gP_MobjThinkerPtr)			spritepresent[((mobj_t *)th)->sprite] = 1;	}		spritememory = 0;	for (i = 0; i < numsprites; i++)	{		if (!spritepresent[i])			continue;				for (j = 0; j < sprites[i].numframes; j++)		{			sf = &sprites[i].spriteframes[j];						for (k = 0; k < 8; k++)			{				lump = firstspritelump + sf->lump[k];				spritememory += lumpinfo[lump].size;				W_CacheLumpNum(lump , PU_CACHE);			}		}	}		PopRoutineAllocA();}