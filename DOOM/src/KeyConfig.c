#define global#ifndef __MPW_VERSION__	#if defined(powerc) || defined(__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#else	#include <Controls.h>	#include <Dialogs.h>	#include <Resources.h>#endif#include "LionDoom.h"#include <Lion.h>#include <ctype.h>#include <string.h>#include "DoomResources.h"#define kCntlCode			0x3B#define kShftCode			0x38extern CTabHandle		gClut;extern GDHandle			gMainDevice;extern CGrafPtr			gOffPort;extern int					useMouse;extern int					followplayer;extern int					usejoystick;extern void 				NetUpdate(void);extern Boolean			gInForeground;Boolean gArrowKeyIsStrafe = false;int			gDoomMoveConfig = 1;				// 1=MainKB, 2=NumericKeypad, 3=ArrowKeysint			gActionKeyCharCode = ' ';		// Spaceint			gActionKeyScanCode = 0x31;int			gFireKeyCharCode = 'D';int			gFireKeyScanCode = 0x02;		// letter 'D'int			gFastKey = kShftCode;				// scan code of Shift or Control keysint			gStrafeKey = kCntlCode;			// scan code of Shift or Control keysint			gNewFireKeyCharCode;int			gNewFireKeyScanCode;int			gNewActionKeyCharCode;int			gNewActionKeyScanCode;int			gNewDoomMoveConfig;int			gNewFastKey;int			gNewStrafeKey;extern WindowPtr			gDoomWindow;extern short					gCursID;extern Str255					gStr1;extern boolean				automapactive;extern boolean				chat_on;extern boolean				menuactive;extern void AM_UpdateForGameKeys (void);extern void CenterRect (Rect *a, Rect *b);extern Boolean CompPStr (void *stra, void *strb);extern void ShowMenuBar (void);extern void HideMenuBar (void);typedef unsigned char chatStr[64];extern  chatStr chat_macros[10];#define kNumChatMacros		10		// Number of chat macros#define kMaxChatChars			39		// The maximum number of char characters in a macroextern void I_FinishUpdate (void);char		*gScanCodeStr[256] = {//         0       1       2       3       4       5       6       7       8       9       A       B       C       D       E       F/* 0 */  "A",		 "S",		 "D",			"",		 "H",			"",		 "Z",		 "X",			"",		 "V",			"",		 "B",		 "Q",		 "W",		 "E",		 "R",/* 1 */  "Y",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",		 "]",			"",/* 2 */   "",		 "[",			"",		 "P",			"",			"",			"",		 "'",			"",		 ";",		"\\",		 ",",		 "/",		 "N",			"",		 ".",/* 3 */   "","Space",		 "`",			"",			"",			"",			"",			"",	"Shift",		"",	    "", "Cntl",		  "",			"",			"",			"",/* 4 */   "",		 ".",			"",		 "*",			"",		 "+",			"",	 "Clr",			"",			"",			"",		 "/",			"",			"",		 "-",			"",/* 5 */   "",		 "=",		 "0",		 "1",		 "2",		 "3",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",/* 6 */   "",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",/* 7 */   "",			"",	"Help",	"Home",	"PgUp",	 "Del",			"",	 "End",			"",	"PgDn",			"",			"",			"",			"",			"",			"",/* 8 */   "",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",/* 9 */   "",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",/* A */   "",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",/* B */   "",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",/* C */   "",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",/* D */   "",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",/* E */   "",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",/* F */   "",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",			"",};/* * *	Prototypes. * */void KeyboardPrefsDialog (Boolean inInitial);pascal Boolean KeyboardConfigFilter (DialogPtr dlg, EventRecord *evt, tWord *itm);void ReadActionKeys (void);#define IsKeyPressed(a) ((gKeyState[ a >> 3 ] >> (a & 0x07)) & 0x01)extern int				key_right,									key_left,									key_up,									key_down,									key_strafeleft,									key_straferight,									key_fire,									key_use,									key_strafe,									key_speed;#define NUMKEYS		256extern boolean		gamekeydown[NUMKEYS];extern Boolean		gCmdKeyDown;extern Boolean		gShftKeyDown;extern Boolean		gCntlKeyDown;extern Boolean		gOptKeyDown;extern unsigned char 		gKeyState[16];/******************************************************** *	ReadActionKeys.																			* *																											* *	Get the condition of the "fire", "action", "fast",	* *	"strafe", "forward", etc. by GetKeys.								* ********************************************************/ void ReadActionKeys (void){	GetKeys((long *)gKeyState);		gCmdKeyDown = IsKeyPressed(0x37);	gShftKeyDown = IsKeyPressed(0x38);	gCntlKeyDown = IsKeyPressed(0x3B);	gOptKeyDown = IsKeyPressed(0x3A);		gamekeydown[key_speed] = 0;	gamekeydown[key_strafe] = 0;	gamekeydown[key_fire] = 0;	gamekeydown[key_use] = 0;	gamekeydown[key_up] = 0;	gamekeydown[key_strafeleft] = 0;	gamekeydown[key_straferight] = 0;	gamekeydown[key_left] = 0;	gamekeydown[key_down] = 0;	gamekeydown[key_right] = 0;		if (!chat_on && !menuactive)	{		gamekeydown[key_speed] = IsKeyPressed(gFastKey);		gamekeydown[key_strafe] = IsKeyPressed(gStrafeKey);		gamekeydown[key_fire] = IsKeyPressed(gFireKeyScanCode);		gamekeydown[key_use] = IsKeyPressed(gActionKeyScanCode);	}		switch (gDoomMoveConfig)	{		case 1 :		// Main Keyboard			if (!chat_on && !menuactive && !gCmdKeyDown)			{				gamekeydown[key_up] = IsKeyPressed(0x22);						// I				gamekeydown[key_strafeleft] = IsKeyPressed(0x20);		// U				gamekeydown[key_straferight] = IsKeyPressed(0x1F);	// O				gamekeydown[key_left] = IsKeyPressed(0x26);					// J				gamekeydown[key_down] = IsKeyPressed(0x28);					// K				gamekeydown[key_right] = IsKeyPressed(0x25);				// L			}			break;					case 2 :		// Numeric Keypad			if (!chat_on && !menuactive && !gCmdKeyDown)			{				gamekeydown[key_up] = IsKeyPressed(0x5B);						// 8 on keypad				gamekeydown[key_strafeleft] = IsKeyPressed(0x59);		// 7 on keypad				gamekeydown[key_straferight] = IsKeyPressed(0x5C);	// 9 on keypad				gamekeydown[key_left] = IsKeyPressed(0x56);					// 4 on keypad				gamekeydown[key_down] = IsKeyPressed(0x57);					// 5 on keypad				gamekeydown[key_right] = IsKeyPressed(0x58);				// 6 on keypad			}			break;					case 3 :		// Arrow keys			if (!menuactive && !gCmdKeyDown)			{				gamekeydown[key_up] = IsKeyPressed(0x7E);						// Up Arrow				gamekeydown[key_down] = IsKeyPressed(0x7D);					// Down Arrow							if (gArrowKeyIsStrafe)				{					gamekeydown[key_strafeleft] = IsKeyPressed(0x7B);					gamekeydown[key_straferight] = IsKeyPressed(0x7C);				}				else				{					gamekeydown[key_left] = IsKeyPressed(0x7B);					// Left Arrow					gamekeydown[key_right] = IsKeyPressed(0x7C);				// Right Arrow					gamekeydown[key_strafeleft] = gamekeydown[key_left] && gamekeydown[key_strafe];					gamekeydown[key_straferight] = gamekeydown[key_right] && gamekeydown[key_strafe];				}			}			break;	}}/******************************************************** *	KeyboardConfigFilter.																* *																											* *	Filter proc for the keyboard configuration dialog.	* ********************************************************/ pascal Boolean KeyboardConfigFilter (DialogPtr dlg, EventRecord *evt, tWord *itm){	tWord				kind;	Handle			h;	Rect				r, r2, pr;	short				pId, scanCode;	PicHandle		pic;	DialogPeek	dPeek;		if ((evt->what == keyDown) || (evt->what == autoKey))	{		if (evt->modifiers & cmdKey)		{			if ((evt->message & charCodeMask) == '.')				goto DoCancel;			else if ((evt->message & charCodeMask) == 'c')				return(kTrue);			else if ((evt->message & charCodeMask) == 'v')				return(kTrue);		}		else if (!(evt->modifiers & (optionKey | controlKey)))		{			switch (evt->message & charCodeMask)			{				case 0x0D :				case 0x03 :					*itm = 1;					GetDItem(dlg, iKeyConfigOK, &kind, &h, &r);					HiliteControl((ControlHandle)h, iKeyConfigOK);					return(TRUE);					break;								case '\t' :					return(FALSE);					break;									case 0x1B :				DoCancel :					*itm = iKeyConfigCancel;					GetDItem(dlg, iKeyConfigCancel, &kind, &h, &r);					HiliteControl((ControlHandle)h, iKeyConfigOK);					return(TRUE);					break;								default :					scanCode = (evt->message >> 8) & charCodeMask;										if ( gScanCodeStr[ scanCode ][0] != 0)					{							dPeek = (DialogPeek)dlg;														if (dPeek->editField == iKeyConfigFireLabel) 			// Fire field							{								if ( scanCode != gNewActionKeyScanCode )								{									GetDItem(dlg, iKeyConfigFireText, &kind, &h, &r);									strcpy((char *)gStr1, gScanCodeStr[ scanCode ]);									c2pstr((char *)gStr1);									SetIText(h, gStr1);									SelIText(dlg, iKeyConfigFireText, 0, 100);																		gNewFireKeyScanCode = scanCode;									gNewFireKeyCharCode = evt->message & charCodeMask;								}								else									SysBeep(1);								evt->what = nullEvent;							}							else if (dPeek->editField == iKeyConfigActionLabel)	// Action field							{								if ( scanCode != gNewFireKeyScanCode )								{									GetDItem(dlg, iKeyConfigActionText, &kind, &h, &r);									strcpy((char *)gStr1, gScanCodeStr[ scanCode ]);									c2pstr((char *)gStr1);									SetIText(h, gStr1);									SelIText(dlg, iKeyConfigActionText, 0, 100);																		gNewActionKeyScanCode = scanCode;									gNewActionKeyCharCode = evt->message & charCodeMask;								}								else									SysBeep(1);																evt->what = nullEvent;							}					}					else					{						evt->what = nullEvent;						SysBeep(1);					}					break;			}		}	}	else if (evt->what == updateEvt)	{		BeginUpdate(dlg);		DrawDialog(dlg);				// Outline the "OK" button.		GetDItem(dlg, iKeyConfigOK, &kind, &h, &r);		InsetRect(&r, -4, -4);		PenSize(3, 3);		FrameRoundRect(&r, 15, 15);		PenNormal();				// Draw our little line.		GetDItem(dlg, iKeyConfigLine, &kind, &h, &r);		PenPat(&qd.gray);		MoveTo(r.left, r.top);		LineTo(r.right - 1, r.top);		PenPat(&qd.black);				// Draw keyboard configuration		GetDItem(dlg, iKeyConfigMovePICT, &kind, &h, &r);		GetDItem(dlg, iKeyConfigMoveNumeric, &kind, &h, &r2);		if (GetCtlValue((ControlHandle)h))		{			pId = 130;			gNewDoomMoveConfig = 2;		}		else		{			GetDItem(dlg, iKeyConfigMoveArrow, &kind, &h, &r2);			if (GetCtlValue((ControlHandle)h))			{				if (gArrowKeyIsStrafe)					pId = 140;				else					pId = 129;				gNewDoomMoveConfig = 3;			}			else			{				pId = 131;				gNewDoomMoveConfig = 1;			}		}		pic = GetPicture(pId);		if (pic != NULL)		{			pr = (**pic).picFrame;			CenterRect(&pr, &r);			DrawPicture(pic, &pr);		}				EndUpdate(dlg);	}		return(kFalse);}/******************************************************** *	ChatMacrosFilter.																		* *																											* *	Filter proc for the chat macros dialog.							* ********************************************************/pascal Boolean ChatMacrosFilter (DialogPtr dlg, EventRecord *evt, tWord *itm){	tWord				kind;	Handle			h;	Rect				r, pr;	short				pId, scanCode;	PicHandle		pic;	DialogPeek	dPeek;		if ((evt->what == keyDown) || (evt->what == autoKey))	{		if (evt->modifiers & cmdKey)		{			if ((evt->message & charCodeMask) == '.')				goto DoCancel;		}		else		{			switch (evt->message & charCodeMask)			{				case 0x0D :				case 0x03 :					*itm = iChatMacrosOK;					GetDItem(dlg, iChatMacrosOK, &kind, &h, &r);					HiliteControl((ControlHandle)h, iChatMacrosOK);					return(TRUE);					break;								case '\t' :					return(FALSE);					break;									case 0x1B :				DoCancel :					*itm = iChatMacrosCancel;					GetDItem(dlg, iChatMacrosCancel, &kind, &h, &r);					HiliteControl((ControlHandle)h, iChatMacrosOK);					return(TRUE);					break;				default:					// evt->what = nullEvent;					return (false);			}		}	}	else if (evt->what == updateEvt)	{		BeginUpdate(dlg);		DrawDialog(dlg);				// Outline the "OK" button.		GetDItem(dlg, 1, &kind, &h, &r);		InsetRect(&r, -4, -4);		PenSize(3, 3);		FrameRoundRect(&r, 15, 15);		PenNormal();						// Draw our little line.		GetDItem(dlg, iChatMacrosLine, &kind, &h, &r);		PenPat(&qd.gray);		MoveTo(r.left, r.top);		LineTo(r.right - 1, r.top);		PenPat(&qd.black);				EndUpdate(dlg);	}	return(kFalse);}static ConvertCToPStr(unsigned char *cStr, unsigned char *pStr){	int	i=0;		while(cStr[i] != '\0')	{		pStr[i+1] = cStr[i];		i++;	}			pStr[0] = (unsigned char) i;}ConvertPToCStr(unsigned char *pStr, unsigned char *cStr){	int	i;		i = pStr[0];	cStr[i] = '\0';		while(i >= 1)	{		cStr[i-1] = pStr[i];		i--;	}}/******************************************************** *	EditChatMacros.																* *																											* *	Allows the user to change the chat macros which 		* *	will be saved in the preferences file.							* ********************************************************/void EditChatMacros(Boolean inInitial){	DialogPtr					dlg;	tWord							itm, i, kind;	Boolean						done;	GrafPtr						oldPort;	ModalFilterUPP		ChatMacrosFilterProc;	Str255						tempStr;	Handle						h;	Rect							r, r2;		ShowMenuBar();	EnableItem(GetMenu(mAppleMenu), 1);		ChatMacrosFilterProc = NewModalFilterProc(ChatMacrosFilter);	dlg = GetNewDialog(rDialogChatMacros, NULL, (WindowPtr)-1L);	if (dlg == NULL)	{		HideMenuBar();		return;	}		GetPort(&oldPort);	SelectWindow(dlg);	SetPort(dlg);		ShowDItem(dlg, iChatMacrosTitle);	ShowDItem(dlg, iChatMacrosLine);	// Set macro labels	itm = iChatMacros0Title;	for(i = 0; i < kNumChatMacros; i++)	{		ShowDItem(dlg, itm);		itm += 2;	}	// Set macros	itm = iChatMacros0Text;	for(i = 0; i < kNumChatMacros; i++)	{		GetDItem(dlg, itm, &kind, &h, &r);		ConvertCToPStr(&chat_macros[i], tempStr);		SetIText(h, tempStr);		itm += 2;	}		ShowWindow(dlg);		SelIText(dlg, iChatMacros0Text, 0, 1000);	InitCursor();	gCursID = -2;		done = false;	do	{		Boolean stringsOK = true;				ModalDialog(ChatMacrosFilterProc, &itm);				switch (itm)		{			case iChatMacrosOK :								itm = iChatMacros0Text;				for(i = 0; i < kNumChatMacros && stringsOK; i++)				{					GetDItem(dlg, itm, &kind, &h, &r2);					GetIText(h, tempStr);					if (tempStr[0] > kMaxChatChars)					{						tempStr[0] = kMaxChatChars;						stringsOK = false;						SetIText(h, tempStr);						SelIText(dlg, itm, 0, 32767);						stringsOK = false;					}					ConvertPToCStr(tempStr, &chat_macros[i]);					itm += 2;				}				if (stringsOK)				{					done = TRUE;				}				else					SysBeep(5);				break;			case iChatMacrosCancel :				done = TRUE;				break;			default:			 break;		}	}	while (!done);		HideWindow(dlg);			if (!inInitial)	{		SelectWindow((WindowPtr) oldPort);		SetPort(gDoomWindow);		I_FinishUpdate();	}	else	{		Rect	sr, r;		//			SetPort(oldPort);						SetPort(gDoomWindow);			PaintRect(&gDoomWindow->portRect);			SetRect(&sr, 0, 0, 480, 360);			r = sr;			CenterRect(&r, &gDoomWindow->portRect);					SetPort(gDoomWindow);			(**gClut).ctSeed = (**(**(**gMainDevice).gdPMap).pmTable).ctSeed;			CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);						SelectWindow(gDoomWindow);			ShowWindow(gDoomWindow);	}	DisposDialog(dlg);	SetPort(oldPort);	ReleaseResource(GetResource('DLOG', rDialogChatMacros));	ReleaseResource(GetResource('DITL', rDitlChatMacros));		return;}/******************************************************** *	KeyboardPrefsDialog.																* *																											* *	Allows the user to set up the keyboard configura-		* *	tion.																								* ********************************************************/ void KeyboardPrefsDialog (Boolean inInitial){	DialogPtr					dlg;	tWord							itm, i, kind;	Boolean						done;	GrafPtr						oldPort;	ModalFilterUPP		keyboardFilterProc;	Handle						h, hStrafe;	Rect							r, rStrafe;			keyboardFilterProc = NewModalFilterProc(KeyboardConfigFilter);	dlg = GetNewDialog(133, NULL, (WindowPtr)-1L);	if (dlg == NULL)	{		HideMenuBar();		return;	}		GetPort(&oldPort);	SelectWindow(dlg);	SetPort(dlg);	ShowWindow(dlg);		gNewFireKeyCharCode = gFireKeyCharCode;	gNewFireKeyScanCode = gFireKeyScanCode;	gNewActionKeyCharCode = gActionKeyCharCode;	gNewActionKeyScanCode = gActionKeyScanCode;	gNewDoomMoveConfig = gDoomMoveConfig;	gNewFastKey = gFastKey;	gNewStrafeKey = gStrafeKey;	InitCursor();	gCursID = -2;	// Fire Key	GetDItem(dlg, iKeyConfigFireText, &kind, &h, &r);	strcpy((char *)gStr1, gScanCodeStr[ gFireKeyScanCode ]);	c2pstr((char *)gStr1);	SetIText(h, gStr1);	SelIText(dlg, iKeyConfigFireText, 0, 100);			GetDItem(dlg, iKeyConfigActionText, &kind, &h, &r);	strcpy((char *)gStr1, gScanCodeStr[ gActionKeyScanCode ]);	c2pstr((char *)gStr1);	SetIText(h, gStr1);		if (gFastKey == kShftCode) // Shift		GetDItem(dlg, iKeyConfigFastShftKey, &kind, &h, &r);	else		GetDItem(dlg, iKeyConfigFastCtlKey, &kind, &h, &r);	SetCtlValue((ControlHandle)h, 1);		if (gStrafeKey == kShftCode)		GetDItem(dlg, iKeyConfigSideShftKey, &kind, &h, &r);	else		GetDItem(dlg, iKeyConfigSideCtlKey, &kind, &h, &r);	SetCtlValue((ControlHandle)h, 1);		if (gDoomMoveConfig == 1)		GetDItem(dlg, iKeyConfigMoveMain, &kind, &h, &r);	else if (gDoomMoveConfig == 2)		GetDItem(dlg, iKeyConfigMoveNumeric, &kind, &h, &r);	else		GetDItem(dlg, iKeyConfigMoveArrow, &kind, &h, &r);	SetCtlValue((ControlHandle)h, 1);		// Arrow keys always strafe	GetDItem(dlg, iKeyConfigArrowStrafe, &kind, &hStrafe, &r);	if (gArrowKeyIsStrafe)		SetCtlValue((ControlHandle)hStrafe, 1);	else		SetCtlValue((ControlHandle)hStrafe, 0);		GetDItem(dlg, iKeyConfigMoveArrow, &kind, &h, &r);	if(GetCtlValue((ControlHandle)h))		HiliteControl((ControlHandle) hStrafe, 0);	else		HiliteControl((ControlHandle) hStrafe, 255);		done = kFalse;	do	{		int jump = 2;		ModalDialog(keyboardFilterProc, &itm);				switch (itm)		{			case iKeyConfigOK :				gFireKeyCharCode = gNewFireKeyCharCode;				gFireKeyScanCode = gNewFireKeyScanCode;				gActionKeyCharCode = gNewActionKeyCharCode;				gActionKeyScanCode = gNewActionKeyScanCode;				gDoomMoveConfig = gNewDoomMoveConfig;				gFastKey = gNewFastKey;				gStrafeKey = gNewStrafeKey;				done = TRUE;				break;							case iKeyConfigCancel :				done = TRUE;				break;									case iKeyConfigFastShftKey :	// Fast = Shift				SetFastShift:					gNewFastKey = kShftCode; // Shift					GetDItem(dlg, iKeyConfigFastShftKey, &kind, &h, &r);					SetCtlValue((ControlHandle)h, 1);					GetDItem(dlg, iKeyConfigFastCtlKey, &kind, &h, &r);					SetCtlValue((ControlHandle)h, 0);					jump--;					if (jump)						goto SetSideCtl;				break;							case iKeyConfigFastCtlKey :	// Fast = Control				SetFastCtl:					gNewFastKey = kCntlCode;	// Control					GetDItem(dlg, iKeyConfigFastCtlKey, &kind, &h, &r);					SetCtlValue((ControlHandle)h, 1);					GetDItem(dlg, iKeyConfigFastShftKey, &kind, &h, &r);					SetCtlValue((ControlHandle)h, 0);					jump--;					if (jump)						goto SetSideShift;				break;						case iKeyConfigSideShftKey :				SetSideShift:					gNewStrafeKey = kShftCode;					GetDItem(dlg, iKeyConfigSideShftKey, &kind, &h, &r);					SetCtlValue((ControlHandle)h, 1);					GetDItem(dlg, iKeyConfigSideCtlKey, &kind, &h, &r);					SetCtlValue((ControlHandle)h, 0);					jump--;					if (jump)						goto SetFastCtl;			break;									case iKeyConfigSideCtlKey :				SetSideCtl:					gNewStrafeKey = kCntlCode;					GetDItem(dlg, iKeyConfigSideCtlKey, &kind, &h, &r);					SetCtlValue((ControlHandle)h, 1);					GetDItem(dlg, iKeyConfigSideShftKey, &kind, &h, &r);					SetCtlValue((ControlHandle)h, 0);					jump--;					if (jump)						goto SetFastShift;				break;							case iKeyConfigArrowStrafe:				GetDItem(dlg, iKeyConfigArrowStrafe, &kind, &h, &r);				if (gArrowKeyIsStrafe)				{					SetCtlValue((ControlHandle)h, 0);					gArrowKeyIsStrafe = false;				}				else				{					SetCtlValue((ControlHandle)h, 1);					gArrowKeyIsStrafe = true;				}								GetDItem(dlg, iKeyConfigMovePICT, &kind, &h, &r);				EraseRect(&r);				InvalRect(&r);							break;							case iKeyConfigMoveNumeric :			case iKeyConfigMoveArrow :			case iKeyConfigMoveMain :								GetDItem(dlg, iKeyConfigArrowStrafe, &kind, &hStrafe, &rStrafe);				if(itm == iKeyConfigMoveArrow)					HiliteControl((ControlHandle) hStrafe, 0);				else					HiliteControl((ControlHandle) hStrafe, 255);								for (i = iKeyConfigMoveNumeric; i <= iKeyConfigMoveMain; i++)				{					GetDItem(dlg, i,&kind, &h, &r);					if (i == itm)						SetCtlValue((ControlHandle)h, 1);					else						SetCtlValue((ControlHandle)h, 0);				}								if (i == iKeyConfigMoveNumeric)					gNewDoomMoveConfig = 2;				else if (i == iKeyConfigMoveArrow)					gNewDoomMoveConfig = 3;				else					gNewDoomMoveConfig = 1;								GetDItem(dlg, iKeyConfigMovePICT, &kind, &h, &r);				EraseRect(&r);				InvalRect(&r);				break;		}	}	while (!done);		EnableItem(GetMenu(mAppleMenu), 1);	HideWindow(dlg);	DisposDialog(dlg);	SetPort(oldPort);		ReleaseResource(GetResource('DLOG', 133));	ReleaseResource(GetResource('DITL', 133));		if (useMouse)		HideCursor();	return;}