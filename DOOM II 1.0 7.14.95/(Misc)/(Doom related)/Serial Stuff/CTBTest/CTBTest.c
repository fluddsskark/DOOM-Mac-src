#ifdef __MPW_VERSION__	#include "DGMacHeaders.c"#else	#if defined(powerc) || defined (__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#endif#include "CTBRoutines.h"#define	kOSEvent				app4Evt	/* event used by MultiFinder 					*/#define	kSuspendResumeMessage	1		/* high byte of suspend/resume event message 	*/#define	kResumeMask				1		/* bit of message field for resume vs. suspend 	*/#define 	_CommToolboxTrap		0x8B#define 	_UnimplementedOSTrap	0x9F#define	rMenuBar	128				/* application's menu bar 				*/#define	mApple					128		/* Apple menu 						*/#define	iAbout					1#define	mFile					129		/* File menu 						*/#define	iOpenConnection			1#define iCloseConnection		2#define iSendData				4#define iReceiveData			5#define iWaitConnect			6#define	iConfigure				8#define	iQuit					10char data[10] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'};	ConnHandle	gConn = NULL;Boolean		gInBackground;		//maintained by Initialize and DoEvent	Boolean		gKeepGoing;Boolean		gHaveConnection;Initialize(){	Handle		menuBar;	// Standard Fare			InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();		gInBackground = false;		// Does CommToolbox Exist?		if (NGetTrapAddress(_CommToolboxTrap,OSTrap) == NGetTrapAddress(_UnimplementedOSTrap, OSTrap))	{		fprintf(tempfile,"ACK!! No CommToolbox\n");		goto ErrorDone;	}		menuBar = GetNewMBar(rMenuBar);		//read menus into menu bar	if (menuBar == NULL) 		fprintf(tempfile,"Can't get the menu bar\n");			SetMenuBar(menuBar);					//install menus	DisposHandle(menuBar);		AddResMenu(GetMHandle(mApple), 'DRVR');	//add DA names to Apple menu	DrawMenuBar();	CTBInitializeNet();	ErrorDone:;}void Terminate(){	CTBTerminateNet();	fclose(tempfile);	gKeepGoing = false;}void OpenConnection(){	if (CTBOpenConnection())	{		gHaveConnection = true;	}}void DoCloseConnection(){	CTBCloseConnection();	gHaveConnection = false;}void DoSend(){	CTBSendPacket(1, data, 10);}void DoReceive(){	Boolean	gotit = false;	Size	length;	int		i;		if (gHaveConnection)	{		length = 10;		for (i = 0; i < 100 && !gotit; i++)		{			gotit = CTBReceivePacket(data, &length);		}		if (gotit)		{			fprintf(tempfile,"We gotit...Size %d \n", length);			for (i = 0; i< length; i++)			{				fprintf(tempfile,"%c ",data[i]);					}			fprintf(tempfile,"\n");			SysBeep(10);		}		else		{			fprintf(tempfile,"Did not recieve\n");			SysBeep(10);			SysBeep(10);			SysBeep(10);		}	}	} Boolean IsAppWindow(WindowPtr window){	long	theRefCon;	// Check the userkind and the refcon for tool windows	if (window == NULL)		return FALSE;	else 	{		theRefCon = GetWRefCon(window);		return			((((WindowPeek) window)->windowKind >= userKind) || 			 (((WindowPeek) window)->windowKind == dialogKind)) &&			(gConn != (ConnHandle) theRefCon);	}} //IsAppWindowvoid DoActivate(WindowPtr window, Boolean becomingActive){	if (IsAppWindow(window)) 	{		SetPort(window);			/* Tools need to adjust their menus, text selection, etc	*/					if (gConn != NULL)			CMActivate(gConn, becomingActive);	}	} //DoActivatevoid DoResume(Boolean becomingActive){	WindowPtr	theWindow;	GrafPtr		savedPort;		// Since the front window could be a tool window, we need		// to find the app window by walking the list so we can			// send resume messages to the tools									GetPort(&savedPort);		theWindow = FrontWindow();		while (theWindow != NULL)	{		if (IsAppWindow(theWindow)) 		{			SetPort(theWindow);					/* Tools need to adjust their menus, text selection, etc	*/						if (gConn != NULL)				CMResume(gConn, becomingActive);		} // app window					// Try the next window			theWindow = (WindowPtr) ((WindowPeek) theWindow)->nextWindow;	}		SetPort(savedPort);	} //DoResumeBoolean DoToolEvent(EventRecord event, WindowPtr window){	if ((gConn != NULL) &&  (gConn == (ConnHandle) GetWRefCon(window)))	{		CMEvent(gConn, &event);	}}Boolean IsDAWindow(WindowPtr window){	if (window == NULL)		return FALSE;	else	// DA windows have negative windowKinds		return ((WindowPeek) window)->windowKind < 0;} //IsDAWindowvoid AdjustMenus(void){	WindowPtr		window;		// whose in front				MenuHandle		menu;		// the menu to manipulate		CMErr			theErr;	CMBufferSizes	sizes;		// Connection tool data			CMStatFlags		status;	window = FrontWindow();	menu = GetMHandle(mFile);	if (menu == NULL)		fprintf(tempfile,"Can't get menu resource\n");			if (gConn != NULL) 	{		theErr = CMStatus(gConn, sizes, &status);		if (theErr == noErr) 		{			if (!IsDAWindow(window)) 			{				// Let the menu show the proper state of the union					if ((status & (cmStatusOpen + cmStatusOpening)) == 0) 				{					EnableItem(menu, iOpenConnection);					DisableItem(menu, iCloseConnection);					DisableItem(menu,iSendData);					DisableItem(menu,iReceiveData);					EnableItem(menu,iWaitConnect);				}								else 				{					DisableItem(menu, iOpenConnection);					EnableItem(menu, iCloseConnection);					EnableItem(menu,iSendData);					EnableItem(menu,iReceiveData);					DisableItem(menu,iWaitConnect);				}							}						else 			{				// Set for desk accesories					DisableItem(menu, iOpenConnection);				EnableItem(menu,iCloseConnection);				DisableItem(menu,iSendData);				DisableItem(menu,iReceiveData);				DisableItem(menu,iWaitConnect);			}					} // good status		} // good connection		} //AdjustMenusBoolean DoToolMenu(int menuID, int menuItem){	if (gConn != NULL)		if (CMMenu(gConn, menuID, menuItem)) 			return TRUE;				return FALSE;	} //DoToolMenuvoid DoMenuCommand(long menuResult){	short	menuID;			// resource ID of the selected menu		short	menuItem;		// item number of the selected menu		Str255	daName;			// for opening desk accesories			short	daRefNum;	menuID = HiWord(menuResult);	//use built-ins (for efficiency)...	menuItem = LoWord(menuResult);	//to get menu item number and menu number		// First see if the menu belonged to a tool				if (!DoToolMenu(menuID,menuItem))		switch (menuID) 		{			case mApple:				switch (menuItem) 				{					case iAbout:										//bring up alert for About					//	itemHit = Alert(rAboutAlert, NULL);						break;											default: 						// all non-About items in this menu are DAs						GetItem(GetMHandle(mApple), menuItem, daName);						daRefNum = OpenDeskAcc(daName);						break;				} 								case mFile:				switch (menuItem) 				{					case iOpenConnection:						if (!IsDAWindow(FrontWindow()))							OpenConnection();						break;											case iCloseConnection:						if (!IsDAWindow(FrontWindow()))							DoCloseConnection();						break;											case iSendData:						if (!IsDAWindow(FrontWindow()))							DoSend();						break;											case iReceiveData:						if (!IsDAWindow(FrontWindow()))							DoReceive();						break;											case iWaitConnect:						if (!IsDAWindow(FrontWindow()))						{							if (CTBWaitForConnection() == noErr)							{								gHaveConnection = true;								fprintf(tempfile,"Connection received\n");							}							else							{								fprintf(tempfile,"Connection not received\n");							}						}						break;											case iConfigure:						if (!IsDAWindow(FrontWindow()))							CTBCloseConnection();							ConfigConnection();						break;											case iQuit:						Terminate();						break;				} 							} // case	menuitem								HiliteMenu(0);					//unhighlight what MenuSelect (or MenuKey) hilited} //DoMenuCommandvoid DoEvent(EventRecord event){	int			part;			// where the mouse click was		WindowPtr	window;			// the click's window			char		key;			// the letter typed				long		result;			// result from MenuKey			Boolean		processed;		// Did the App handle it			switch (event.what)	{		case mouseDown: 			part = FindWindow(event.where, &window);			switch (part) 			{				case inMenuBar: 		//process the menu command						AdjustMenus();					DoMenuCommand(MenuSelect(event.where));					break;								case inSysWindow:				//let the system handle the mouseDown					SystemClick(&event, window);					break;									case inContent:					// The terminal tool needs to handle selections						if (!DoToolEvent(event,window)) 					{					}					break;									case inDrag:		//pass screenBits.bounds to get all gDevices					if (!DoToolEvent(event,window))						DragWindow(window, event.where, &qd.screenBits.bounds);					break;									case inGrow:				case inZoomIn:				case inZoomOut:				case inGoAway:					DoToolEvent(event,window);					break;			}			break; // case mouseDown								case keyDown:		case autoKey: 		//check for menukey equivalents			window = FrontWindow();						// Get the key				key = event.message & charCodeMask;			processed = FALSE;						// The terminal tool might be mapping the cmd key 				// so if menukey fails, send it to the tool									if (((event.modifiers) & cmdKey) != 0) 			{				AdjustMenus();			//enable/disable/check menu items properly				result = MenuKey(key);				if (result != 0) {					processed = TRUE;					DoMenuCommand(result);				}			}						break;				case activateEvt: 			window = (WindowPtr) event.message;						if (!DoToolEvent(event,window))				DoActivate(window, ((event.modifiers) & activeFlag) != 0);			break;				case updateEvt: 			if (!DoToolEvent(event,window))			;//	DoUpdate(window);			break;							case kOSEvent:			// Send to frontmost tool window && all tools				// as this is an application-wide event									switch((event.message >> 8) & 0xFF) 	//high byte of message			{				case kSuspendResumeMessage:					DoToolEvent(event,FrontWindow());					gInBackground = ((event.message & kResumeMask) == 0);					DoResume(!gInBackground);					break;			}			break;	}} //DoEventvoid DoIdle(void){	WindowPtr		theWindow;				// The target to idle			GrafPtr			savedPort;				// for later reset				GetPort(&savedPort);						// Save for later				theWindow = FrontWindow();				// Gimme the first one				// Give idle time for the window		while (theWindow != NULL)	{		if (IsAppWindow(theWindow)) 		{			SetPort(theWindow);					// Focus on it										if (gConn != NULL) 			// Give time to the connection					CMIdle(gConn);						} // App Window					// Try the next window			theWindow = (WindowPtr) ((WindowPeek) theWindow)->nextWindow;				} // while each window					SetPort(savedPort);						// Back to the way it was				} // DoIdle	void EventLoop(void){	Boolean		gotEvent;	EventRecord	event;	//loop forever; we quit through an ExitToShell	while (gKeepGoing)		{		DoIdle();				gotEvent = WaitNextEvent(everyEvent, &event, 0, NULL);				if (gotEvent) 		{//			AdjustCursor(event.where); 			//make sure we have the right cursor			DoEvent(event);		}		//		AdjustCursor(event.where);	}				} //EventLoopmain(){ 	tempfile = fopen("tempfile","w");	gKeepGoing	= true;	gHaveConnection = false;		MaxApplZone();			// expand the heap so code segments load at the top		Initialize();			// initialize the program								EventLoop();}