#ifdef __MPW_VERSION__	#include "DGMacHeaders.c"#else	#if defined(powerc) || defined (__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#endif#include "CTBRoutines.h"#define	kOSEvent				app4Evt	/* event used by MultiFinder 					*/#define	kSuspendResumeMessage	1		/* high byte of suspend/resume event message 	*/#define	kResumeMask				1		/* bit of message field for resume vs. suspend 	*/#define	rMenuBar	128				/* application's menu bar 				*/#define	mApple					128		/* Apple menu 						*/#define	iAbout					1#define	mFile					129		/* File menu 						*/#define	iOpenConnection			1#define iCloseConnection		2#define iSendData				4#define iReceiveData			5#define iWaitConnect			6#define	iConfigure				8#define	iQuit					10doomdata_t data;ConnHandle	gConn = NULL;Boolean		gInBackground;		//maintained by Initialize and DoEvent	Boolean		gKeepGoing;Boolean		gHaveConnection;Wait(){	int	i;	for(i=1;i<1000;i++)	;}Initialize(){	Handle		menuBar;	// Standard Fare			InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(NULL);	InitCursor();		gInBackground = false;		menuBar = GetNewMBar(rMenuBar);		//read menus into menu bar	if (menuBar == NULL) 		fprintf(tempfile,"Can't get the menu bar\n");			SetMenuBar(menuBar);					//install menus	DisposHandle(menuBar);		AddResMenu(GetMHandle(mApple), 'DRVR');	//add DA names to Apple menu	DrawMenuBar();	CTBInitializeNet();	ErrorDone:;}void Terminate(){	CTBTerminateNet();	fclose(tempfile);	gKeepGoing = false;}void OpenConnection(){	if (CTBOpenConnection())	{		gHaveConnection = true;	}}void DoCloseConnection(){	CTBCloseConnection();	gHaveConnection = false;}void DoSend(){	Size	length;		length = sizeof(doomdata_t) - (sizeof(ticcmd_t) * (BACKUPTICS - 2));		data.checksum 			= 256;	data.retransmitfrom 	= 'a';	data.starttic			= 'b';	data.player				= 'c';	data.numtics				= 2;	data.cmds[0].forwardmove	= 'd';	data.cmds[0].sidemove		= 'e';	data.cmds[0].angleturn		= 3;	data.cmds[0].consistancy	= 4;	data.cmds[0].chatchar		= 'f';	data.cmds[0].buttons		= 'g';		data.cmds[1].forwardmove	= 'D';	data.cmds[1].sidemove		= 'E';	data.cmds[1].angleturn		= 3;	data.cmds[1].consistancy	= 4;	data.cmds[1].chatchar		= 'F';	data.cmds[1].buttons		= 'G';			CTBSendPacket(1, (Ptr)&data, length);	data.checksum 			= 0;	data.retransmitfrom 	= '-';	data.starttic			= '-';	data.player				= '-';	data.numtics				= 0;	data.cmds[0].forwardmove	= '-';	data.cmds[0].sidemove		= '-';	data.cmds[0].angleturn		= 0;	data.cmds[0].consistancy	= 0;	data.cmds[0].chatchar		= '-';	data.cmds[0].buttons		= '-';		data.cmds[1].forwardmove	= '-';	data.cmds[1].sidemove		= '-';	data.cmds[1].angleturn		= 0;	data.cmds[1].consistancy	= 0;	data.cmds[1].chatchar		= '-';	data.cmds[1].buttons		= '-';}void DoReceive(){	Boolean	gotit = false;	Size	length;	int		i;		if (gHaveConnection)	{		length =  sizeof(doomdata_t);		gotit = CTBReceivePacket((Ptr)&data, &length);		if (gotit)		{			int	i;						fprintf(tempfile,"Weeee Got it Size: %d\n",length);			fprintf(tempfile,"checksum %d\n retransmitfrom %c\n starttic %c\n  player%c\n numtics %d\n",							data.checksum,							data.retransmitfrom,							data.starttic,							data.player,							data.numtics);										for (i=0; i<data.numtics; i++)			{				fprintf(tempfile," forwardmove %c\n sidemove %c\n angleturn  %d\n consistancy %d\n chatchar %c\n buttons %c\n",								data.cmds[i].forwardmove,								data.cmds[i].sidemove,								data.cmds[i].angleturn,								data.cmds[i].consistancy,								data.cmds[i].chatchar,								data.cmds[i].buttons);				fprintf(tempfile,"\n");			}			SysBeep(10);		}		else		{			fprintf(tempfile,"Did not recieve\n");			SysBeep(10);			SysBeep(10);			SysBeep(10);		}	}	} Boolean IsAppWindow(WindowPtr window){	long	theRefCon;	// Check the userkind and the refcon for tool windows	if (window == NULL)		return FALSE;	else 	{		theRefCon = GetWRefCon(window);		return			((((WindowPeek) window)->windowKind >= userKind) || 			 (((WindowPeek) window)->windowKind == dialogKind)) &&			(gConn != (ConnHandle) theRefCon);	}} //IsAppWindowvoid DoActivate(WindowPtr window, Boolean becomingActive){	if (IsAppWindow(window)) 	{		SetPort(window);			/* Tools need to adjust their menus, text selection, etc	*/					if (gConn != NULL)			CMActivate(gConn, becomingActive);	}	} //DoActivatevoid DoResume(Boolean becomingActive){	WindowPtr	theWindow;	GrafPtr		savedPort;		// Since the front window could be a tool window, we need		// to find the app window by walking the list so we can			// send resume messages to the tools									GetPort(&savedPort);		theWindow = FrontWindow();		while (theWindow != NULL)	{		if (IsAppWindow(theWindow)) 		{			SetPort(theWindow);					/* Tools need to adjust their menus, text selection, etc	*/						if (gConn != NULL)				CMResume(gConn, becomingActive);		} // app window					// Try the next window			theWindow = (WindowPtr) ((WindowPeek) theWindow)->nextWindow;	}		SetPort(savedPort);	} //DoResumeBoolean DoToolEvent(EventRecord event, WindowPtr window){	if ((gConn != NULL) &&  (gConn == (ConnHandle) GetWRefCon(window)))	{		CMEvent(gConn, &event);	}}Boolean IsDAWindow(WindowPtr window){	if (window == NULL)		return FALSE;	else	// DA windows have negative windowKinds		return ((WindowPeek) window)->windowKind < 0;} //IsDAWindowvoid AdjustMenus(void){	WindowPtr		window;		// whose in front				MenuHandle		menu;		// the menu to manipulate		CMErr			theErr;	CMBufferSizes	sizes;		// Connection tool data			CMStatFlags		status;	window = FrontWindow();	menu = GetMHandle(mFile);	if (menu == NULL)		fprintf(tempfile,"Can't get menu resource\n");			if (gConn != NULL) 	{		theErr = CMStatus(gConn, sizes, &status);		if (theErr == noErr) 		{			if (!IsDAWindow(window)) 			{				// Let the menu show the proper state of the union					if ((status & (cmStatusOpen + cmStatusOpening)) == 0) 				{					EnableItem(menu, iOpenConnection);					DisableItem(menu, iCloseConnection);					DisableItem(menu,iSendData);					DisableItem(menu,iReceiveData);					EnableItem(menu,iWaitConnect);				}								else 				{					DisableItem(menu, iOpenConnection);					EnableItem(menu, iCloseConnection);					EnableItem(menu,iSendData);					EnableItem(menu,iReceiveData);					DisableItem(menu,iWaitConnect);				}							}						else 			{				// Set for desk accesories					DisableItem(menu, iOpenConnection);				EnableItem(menu,iCloseConnection);				DisableItem(menu,iSendData);				DisableItem(menu,iReceiveData);				DisableItem(menu,iWaitConnect);			}					} // good status		} // good connection		} //AdjustMenusBoolean DoToolMenu(int menuID, int menuItem){	if (gConn != NULL)		if (CMMenu(gConn, menuID, menuItem)) 			return TRUE;				return FALSE;	} //DoToolMenuvoid DoMenuCommand(long menuResult){	short	menuID;			// resource ID of the selected menu		short	menuItem;		// item number of the selected menu		Str255	daName;			// for opening desk accesories			short	daRefNum;	menuID = HiWord(menuResult);	//use built-ins (for efficiency)...	menuItem = LoWord(menuResult);	//to get menu item number and menu number		// First see if the menu belonged to a tool				if (!DoToolMenu(menuID,menuItem))		switch (menuID) 		{			case mApple:				switch (menuItem) 				{					case iAbout:										//bring up alert for About					//	itemHit = Alert(rAboutAlert, NULL);						break;											default: 						// all non-About items in this menu are DAs						GetItem(GetMHandle(mApple), menuItem, daName);						daRefNum = OpenDeskAcc(daName);						break;				} 								case mFile:				switch (menuItem) 				{					case iOpenConnection:						if (!IsDAWindow(FrontWindow()))							OpenConnection();						break;											case iCloseConnection:						if (!IsDAWindow(FrontWindow()))							DoCloseConnection();						break;											case iSendData:						if (!IsDAWindow(FrontWindow()))							DoSend();						break;											case iReceiveData:						if (!IsDAWindow(FrontWindow()))							DoReceive();						break;											case iWaitConnect:						if (!IsDAWindow(FrontWindow()))						{							if (CTBWaitForConnection() == noErr)							{								gHaveConnection = true;								fprintf(tempfile,"Connection received\n");							}							else							{								fprintf(tempfile,"Connection not received\n");							}						}						break;											case iConfigure:						if (!IsDAWindow(FrontWindow()))							CTBCloseConnection();							ConfigConnection();						break;											case iQuit:						Terminate();						break;				} 							} // case	menuitem								HiliteMenu(0);					//unhighlight what MenuSelect (or MenuKey) hilited} //DoMenuCommandvoid DoEvent(EventRecord event){	int			part;			// where the mouse click was		WindowPtr	window;			// the click's window			char		key;			// the letter typed				long		result;			// result from MenuKey			Boolean		processed;		// Did the App handle it			switch (event.what)	{		case mouseDown: 			part = FindWindow(event.where, &window);			switch (part) 			{				case inMenuBar: 		//process the menu command						AdjustMenus();					DoMenuCommand(MenuSelect(event.where));					break;								case inSysWindow:				//let the system handle the mouseDown					SystemClick(&event, window);					break;									case inContent:					// The terminal tool needs to handle selections						if (!DoToolEvent(event,window)) 					{					}					break;									case inDrag:		//pass screenBits.bounds to get all gDevices					if (!DoToolEvent(event,window))						DragWindow(window, event.where, &qd.screenBits.bounds);					break;									case inGrow:				case inZoomIn:				case inZoomOut:				case inGoAway:					DoToolEvent(event,window);					break;			}			break; // case mouseDown								case keyDown:		case autoKey: 		//check for menukey equivalents			window = FrontWindow();						// Get the key				key = event.message & charCodeMask;			processed = FALSE;						// The terminal tool might be mapping the cmd key 				// so if menukey fails, send it to the tool									if (((event.modifiers) & cmdKey) != 0) 			{				AdjustMenus();			//enable/disable/check menu items properly				result = MenuKey(key);				if (result != 0) {					processed = TRUE;					DoMenuCommand(result);				}			}						break;				case activateEvt: 			window = (WindowPtr) event.message;						if (!DoToolEvent(event,window))				DoActivate(window, ((event.modifiers) & activeFlag) != 0);			break;				case updateEvt: 			if (!DoToolEvent(event,window))			;//	DoUpdate(window);			break;							case kOSEvent:			// Send to frontmost tool window && all tools				// as this is an application-wide event									switch((event.message >> 8) & 0xFF) 	//high byte of message			{				case kSuspendResumeMessage:					DoToolEvent(event,FrontWindow());					gInBackground = ((event.message & kResumeMask) == 0);					DoResume(!gInBackground);					break;			}			break;	}} //DoEventvoid DoIdle(void){	WindowPtr		theWindow;				// The target to idle			GrafPtr			savedPort;				// for later reset				GetPort(&savedPort);						// Save for later				theWindow = FrontWindow();				// Gimme the first one				// Give idle time for the window		while (theWindow != NULL)	{		if (IsAppWindow(theWindow)) 		{			SetPort(theWindow);					// Focus on it										if (gConn != NULL) 			// Give time to the connection					CMIdle(gConn);						} // App Window					// Try the next window			theWindow = (WindowPtr) ((WindowPeek) theWindow)->nextWindow;				} // while each window					SetPort(savedPort);						// Back to the way it was				} // DoIdle	void EventLoop(void){	Boolean		gotEvent;	EventRecord	event;	//loop forever; we quit through an ExitToShell	while (gKeepGoing)		{		DoIdle();				gotEvent = WaitNextEvent(everyEvent, &event, 0, NULL);				if (gotEvent) 		{//			AdjustCursor(event.where); 			//make sure we have the right cursor			DoEvent(event);		}		//		AdjustCursor(event.where);	}				} //EventLoopmain(){ 	tempfile = fopen("tempfile","w");	gKeepGoing	= true;	gHaveConnection = false;		MaxApplZone();			// expand the heap so code segments load at the top		Initialize();			// initialize the program								EventLoop();}