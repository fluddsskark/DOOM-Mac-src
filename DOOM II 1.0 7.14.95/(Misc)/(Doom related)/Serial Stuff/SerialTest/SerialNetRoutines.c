#define __MAC_VERSION__#define __LION_SHOWFRAMERATE 1#ifndef __MPW_VERSION__	#if (defined(powerc) || defined (__powerc))		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#else	#include <Devices.h>	#include <Memory.h>	#include <Types.h>	#include <Stdio.h>#endif#include <Lion.h>#include "LionDoom.h"#include <Serial.h>#include "SerialNetRoutines.h"#include "GeneralStuff.h"#include "DoomDef.h"short	gOutputRefNum;			// Output driver reference numbershort	gInputRefNum;			// Input driver reference numberPtr	gInputBufPtr;			// Pointer to extended input buffer#define	kInputBufSize	1024	// Size of extended input buffer#define kConfigParam	baud300 + data8 + noParity + stop10#define kMinReadSize (sizeof(doomdata_t) - (sizeof(ticcmd_t) * BACKUPTICS))OSErr	SerInitializeNet(){	SerShk		serShake;	OSErr		status;		// Open Input and output drivers	status = OpenDriver("\p.AOut", &gOutputRefNum);	if (status != noErr)	{		// fprintf(tempFile,"Error in opening driver AOut %d\n",status);		goto ErrorDone;	}		status = OpenDriver("\p.AIn", &gInputRefNum);	if (status != noErr)	{		// fprintf(tempFile,"Error in opening driver AIn %d\n",status);		goto ErrorDone;	}	// Change input buffer	gInputBufPtr = NewPtrClear((Size) kInputBufSize);	if (gInputBufPtr == NULL)	{		// fprintf(tempFile,"Error in Allocating serial input buffer\n");		goto ErrorDone;	}	status = SerSetBuf(gInputRefNum, gInputBufPtr, kInputBufSize);	if (status != noErr)	{		// fprintf(tempFile,"Error in Changing input buffer %d\n",status);		goto ErrorDone;	}		// Set handshake options	serShake.fXOn	= 0;	// Turn off XON/XOFF output flow control	serShake.fCTS	= 0;	// Turn off CTS/DTR flow control	serShake.errs	= 0;	// Clear error mask	serShake.evts	= 0;	// Clear event mask	serShake.fInX	= 0;	// Turn off XON/XOFF input flow control	serShake.fDTR	= 0;	// Turn off DTR input flow control		status = Control(gOutputRefNum, 14, &serShake);	if (status != noErr)	{		// fprintf(tempFile,"Error in Setting handshake options %d\n",status);		goto ErrorDone;	}		// Configure port	status = SerReset(gOutputRefNum,kConfigParam);	if (status != noErr)	{		// fprintf(tempFile,"Error in Configuring port %d\n",status);		goto ErrorDone;	}	ErrorDone:	return(status);}OSErr 	SerTerminateNet(){	OSErr	status;		// Restore default input buffer	SerSetBuf(gInputRefNum, gInputBufPtr, 0);	DisposPtr(gInputBufPtr);		// Terminate all pending I/O	status = KillIO(gOutputRefNum);	if (status != noErr)	{		// fprintf(tempFile,"Error in KillIO %d\n",status);		goto ErrorDone;	}		// Close serial driver	status = CloseDriver(gInputRefNum);	if (status != noErr)	{		// fprintf(tempFile,"Error in Closing input driver %d\n",status);		goto ErrorDone;	}		status = CloseDriver(gOutputRefNum);	if (status != noErr)	{		// fprintf(tempFile,"Error in Closing output driver %d\n",status);		goto ErrorDone;	}		ErrorDone:	return(status);}OSErr 	SerSendPacket(UInt16 sendTo, Ptr data, Size length){	ParamBlockRec	paramBlock;	OSErr			status;		paramBlock.ioParam.ioCompletion = NULL;				// No completion routine	paramBlock.ioParam.ioRefNum 	= gOutputRefNum;	// Write to output driver	paramBlock.ioParam.ioBuffer 	= data;				// Data to send	paramBlock.ioParam.ioReqCount 	= length;			// Number of bytes to write	paramBlock.ioParam.ioVRefNum 	= 0;				// Not used	paramBlock.ioParam.ioPosMode 	= 0;				// Not used	paramBlock.ioParam.ioPosOffset 	= 0;				// Not used		status = PBWrite(&paramBlock, false);		if (status != noErr)	{		// fprintf(tempFile,"Error in writing serial data port %d\n",status);		goto ErrorDone;	}	else	{		// fprintf(tempFile,"Sent %d bytes\n",paramBlock.ioParam.ioActCount);			}ErrorDone:		return (status);}Boolean SerReceivePacket(Ptr data, Size *length){	ParamBlockRec	paramBlock;	long			size = 0;	SerStaRec		serialStatus;	OSErr			status;				status = SerGetBuf(gInputRefNum, &size);		status = SerStatus(gInputRefNum, &serialStatus);	if ((size >= kMinReadSize) && !serialStatus.rdPend)		// There is data to read	{		// fprintf(tempFile,"About to read header %d bytes\n",kMinReadSize);		if (kMinReadSize > *length)		{			// fprintf(tempFile,"Error in receiving data: buffer is not large enough\n");			*length = 0;			return (false);					}				paramBlock.ioParam.ioCompletion = NULL;				// No completion routine		paramBlock.ioParam.ioRefNum 	= gInputRefNum;		// Read from input driver		paramBlock.ioParam.ioBuffer 	= data;				// Data to receive		paramBlock.ioParam.ioReqCount 	= kMinReadSize;		// Number of bytes to read		paramBlock.ioParam.ioVRefNum 	= 0;				// Not used		paramBlock.ioParam.ioPosMode 	= 0;				// Not used		paramBlock.ioParam.ioPosOffset 	= 0;				// Not used				status = PBRead(&paramBlock, false);				if (status != noErr)		{			// fprintf(tempFile,"Error in reading from serial data port %d\n",status);			*length = 0;			return (false);		}				// Read the ticcmds				// fprintf(tempFile,"About to read %d bytes\n",size);		size = sizeof(ticcmd_t) * ((doomdata_t *)data)->numtics;		if (size + kMinReadSize > *length)		{			// fprintf(tempFile,"Error in receiving data: buffer is not large enough\n");			*length = 0;			return (false);					}				paramBlock.ioParam.ioCompletion = NULL;					// No completion routine		paramBlock.ioParam.ioRefNum 	= gInputRefNum;			// Read from input driver		paramBlock.ioParam.ioBuffer 	= data + kMinReadSize;	// Data to receive		paramBlock.ioParam.ioReqCount 	= size;					// Number of bytes to read		paramBlock.ioParam.ioVRefNum 	= 0;					// Not used		paramBlock.ioParam.ioPosMode 	= 0;					// Not used		paramBlock.ioParam.ioPosOffset 	= 0;					// Not used				status = PBRead(&paramBlock, false);				if (status != noErr)		{			// fprintf(tempFile,"Error in reading from serial data port %d\n",status);			*length = 0;			return (false);		}		else		// Ends here if all is well		{			*length = paramBlock.ioParam.ioActCount;			return (true);		}			}	else				// No data to read	{		*length = 0;		return(false);	}}