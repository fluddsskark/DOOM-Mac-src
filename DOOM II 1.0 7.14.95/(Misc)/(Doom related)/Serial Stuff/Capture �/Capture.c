/* Capture program - example of serial port control**  File:  Capture.c**  Programmer:		James R. Logan Jr.*  Organization:	Brigham Young University*  Email:		loganj@byuvax.bitnet* 			loganj@yvax.byu.edu*  Phone:		(801) 378-3617**   Captures incoming data from the active serial port and*   displays visible characters via a TextEdit record.*   Provides control of serial port characteristics (baud *   rate, parity, stop bits, handshaking ... ).**   If you convert this program to interact with real time *   data obtained through the serial port then you should  *   remove the call to "TEKey()" below (because it's slow) *   and add your own code at that point to process incoming *   data.**   Version 1.1 improvement:**   When data is being captured to a file it is not displayed *   on the screen, but the mouse cursor flickers between the *   arrow and watch cursors to indicate that data is being *   received.**  TBD:  Incoming text is never removed from the TextEdit *        record, so eventually the program will run out *        of memory.**        The use of TextEdit for display purposes is very *        slow, and causes the processing of serial port *        traffic to be slow.**        Menus should be done by "MENU" resource.**        The cursor should only flicker when the application *        window is front most.  As it is now, the cursor may *        continue to flicker even if another application owns *        the front most window.**        The intent here is not to be a "terminal emulator"*        so the "insertion point" doesn't blink, the "delete"*        and "backspace" keys don't work, and the "copy, cut, *        and paste" functions don't work.*/#include <Quickdraw.h>#include <WindowMgr.h>#include <SerialDvr.h>#include <MenuMgr.h>#include <EventMgr.h>#include <TextEdit.h>#include <DialogMgr.h>#include <ControlMgr.h>#include <FontMgr.h>#include "StdFilePkg.h"#include <stdio.h>#include "ToolboxUtil.h"#include "Capture.h"#define lastmenu 4#define applemenu 1#define filemenu 256#define editmenu 257#define settingsmenu 258#define input_size 2048CursHandle watch;	/* cursors */static ResType  creator = 'EDIT',  driver = 'DRVR',  filetype = 'TEXT',    Setres = 'CNFG',  texttype = 'TEXT';static char   *minputnam[] 	= {"\p.ain","\p.bin"};static char   *moutputnam[] = {"\p.aout","\p.bout"};static char  *mbtext[] = {  	"\p300 baud","\p600 baud","\p1200 baud","\p1800 baud","\p2400 baud",    "\p3600 baud","\p4800 baud","\p7200 baud","\p9600 baud",	"\p19200 baud","\p57600 baud", 0};static char  *mdtext[] = {"\p5 data bits","\p6 data bits","\p7 data bits","\p8 data bits", 0};static char  *mptext[] = {"\pNo parity","\pOdd parity","\pEven parity", 0};static char  *mstext[] = {"\p1 stop bit","\p1.5 stop bits","\p2 stop bits", 0};static char  *mPorttext[] = {"\pModem Port","\pPrinter Port", 0};static char  *mprottext[] = {"\pNo handshaking","\pXon/Xoff Handshaking", 0};static int  mbtable[] 	=   { baud300, baud600,    baud1200,baud1800,    baud2400,baud3600,    baud4800,baud7200,    baud9600,baud19200,baud57600};static int  mdtable[] 	= {data5,data6,data7,data8};static int  mptable[] 	= {noParity,oddParity,evenParity};static int  mstable[] 	= {stop10,stop15,stop20};static int  minputnum[] = {-6,-8};	/* File numbers of incoming modem/printer ports */static int  moutputnum[] = {-7,-9};	/* File numbers of outgoing modem/printer ports */static int  mramnum[] 	= {sPortA, sPortB};SerShk shakies =   { (char)0,    (char)0,    (char)17,	/* "xon" character is control q */    (char)19,	/* "xoff" character is control s */    (char)0,    (char)0,    (char)1,	/* "fInX" field: enable incoming "xon/xoff" handshaking */    (char)0};Boolean capturing,doneflag;EventRecord myevent;MenuHandle mymenus[lastmenu+1];WindowPtr  whichwindow,  /* Working variable to test which window is the frontmost */  noticeWindow; /* Window for copyright notice */WindowRecord  nrecord;	/* Window record for copyright notice */int  capturefile,	/* Capture incoming data to file, file id */  mpi,		/* Modem input file refnum 		*/  mpo,		/* Modem output file refnum 		*/  mbaud,        /* Port speed 		*/  mdata,        /* Port data bits 	*/  mparity,      /* Port parity 		*/  mport,        /* Port selected 	*/  mprot,        /* Port protocol 	*/  mstop;        /* Port stop bits 	*/Rect 	dragRect;	/* used by DragWindow(...)	*/char *modembuf,*incoming;Str255 EnterOutputFilename_TempBuf; /* Set up the menu bar (TBD: do it with resources) */setupmenus() {int i;Str255 appletitle;  InitMenus();  appletitle[0] = 1; appletitle[1] = 20;  mymenus[1] = NewMenu(applemenu, appletitle);  AppendMenu(mymenus[1], "\pAbout Capture…;(-");  AddResMenu(mymenus[1], driver);  mymenus[2] = NewMenu(filemenu, "\pFile");  AppendMenu(mymenus[2], "\pCapture to file…;Save as…;Save Settings;Quit");  mymenus[3] = NewMenu(editmenu, "\pEdit");  AppendMenu(mymenus[3], "\pCopy;Cut;Paste;Clear");  mymenus[4] = NewMenu(settingsmenu, "\pSettings");  AppendMenu(mymenus[4], "\pModem");  for (i=1; i<=lastmenu; i++) InsertMenu(mymenus[i], 0);  DrawMenuBar();}/* Process menu items */docommand(g,themenu,theitem) screen *g; int themenu, theitem; {/* This procedure processes all actions initiated by mouse down events on    items of menus in the menu bar. */char name[256];int i,refnum;  switch (themenu) {  case applemenu:    if (theitem == 1) { /* About Capture */      DoAbout(g);    } else if (theitem > 2) {      GetItem(mymenus[1], theitem, &name);      refnum = OpenDeskAcc(name);    }    break;  case filemenu:    switch (theitem) {      case 1:        if (capturing) {          CloseCaptureFile(g);          capturing = FALSE;        } else {          CaptureToFile(g);          capturing = TRUE;        }        CheckItem( mymenus[2], 1, capturing);        break;      case 2:         SaveToFile(g);        break;      case 3:         saveSettings(g);        break;      case 4:         doneflag = TRUE;         break;    }    break;  case editmenu:    if (!SystemEdit(theitem-1)) {      switch (theitem) {      case 1: break;      case 2: break;      case 3: break;      case 4:         clearrem(g);        break;    } }    break;  case settingsmenu:    switch (theitem) {      case 1:         Setmodem();        break;    }    break;  }  HiliteMenu(0);}/* Get the (program settings) "CNFG" resource */getSettings(g) screen *g; {char **myResource; int i,*resptr;#define	SettingsID	31324	myResource = GetResource( Setres, SettingsID);	resptr = (int*) *myResource;	SetSettings(g,resptr);  	ReleaseResource(myResource);}/* Set the program settings from the "CNFG" resource */SetSettings(g,rp) screen *g; int *rp; {int i,*resptr;  resptr = rp;  mbaud 	= *(resptr++);  mdata 	= *(resptr++);  mparity 	= *(resptr++);  mport 	= *(resptr++);  mprot 	= *(resptr++);  mstop 	= *(resptr++);  for (i = 0; i < maxwinpars; i++) {    g->Windowsize[i] = *(resptr++);  }}/* Save the program settings in the "CNFG" resource */saveSettings(g)  screen *g; {Point 	myPoint;int 	i,*resptr;char 	**myResource; GrafPtr tempPort;  GetPort(&tempPort);  myResource = GetResource( Setres, SettingsID);  resptr = (int*) *myResource;  *(resptr++) = mbaud;  *(resptr++) = mdata;  *(resptr++) = mparity;  *(resptr++) = mport;  *(resptr++) = mprot;  *(resptr++) = mstop;    g->Windowsize[0] = 0;		/* Not used */  g->Windowsize[1] = 0;		/* Not used *//* First window */  myPoint = topLeft(  g->storyWindow->portRect);  SetPort(g->storyWindow); LocalToGlobal(&myPoint);  g->Windowsize[2] = myPoint.h;  g->Windowsize[3] = myPoint.v;  g->Windowsize[4] = g->storyWindow->portRect.right;  g->Windowsize[5] = g->storyWindow->portRect.bottom;/* Second window */  g->Windowsize[6] = 0;		/* Not used */  g->Windowsize[7] = 0;		/* Not used */  g->Windowsize[8] = 0;		/* Not used */  g->Windowsize[9] = 0;		/* Not used */    for (i = 0; i < maxwinpars; i++)    *(resptr++) = g->Windowsize[i];  		   ChangedResource(myResource);  WriteResource(myResource);  ReleaseResource(myResource);  SetPort(tempPort);}/* Open a serial port, use the "incoming" buffer, and    set "xon/xoff" handshaking on */PortOpen() {int fstatus,mSettings;  fstatus = RAMSDOpen(mramnum[mport]);  fstatus = FSOpen( minputnam[mport],  minputnum[mport],&mpi);  fstatus = FSOpen( moutputnam[mport], moutputnum[mport],&mpo);  mSettings = mbtable[mbaud] + mdtable[mdata] + mptable[mparity] + mstable[mstop];  SerReset(mpi,mSettings);  SerReset(mpo,mSettings);  SerSetBuf(mpi,incoming,input_size);	/* Input buffer specification */  shakies.fInX = (char) mprot;  SerHShake(mpi,&shakies);		/* Handshake parameters */}/* Close the serial port */PortClose() {int fstatus;  RAMSDClose(mramnum[mport]);  if (mpi != NULL) {     fstatus = FSClose(mpi);     mpi = NULL;     unlink(minputnam[mport]);  }  if (mpo != NULL) {     fstatus = FSClose(mpo);     mpo = NULL;     unlink(moutputnam[mport]);   } }CloseCaptureFile(g) screen *g; {int fstatus;  fstatus = FSClose(capturefile); }/* Write the incoming data to a file */CaptureToFile(g) screen *g; {int fstatus;long fcount,mysize;Point 	pt; SFReply reply; Str255 	origname;  SetPt(&pt, 198, 40);  strcpy( origname, "\p");  SFPutFile( pt, EnterOutputFilename_TempBuf, origname, NULL, &reply);  if (reply.good) {    fstatus = Create(reply.fName,reply.vRefNum,creator,filetype);    fstatus = FSOpen(reply.fName,reply.vRefNum,&capturefile);} }/* Write the contents of the TextEdit record to a file */SaveToFile(g) screen *g; {int fp,fstatus;long fcount,mysize;Point 	pt; SFReply reply; Str255 	origname;  mysize = GetHandleSize((*g->storyth)->hText);  if (mysize > 0L) {    SetPt(&pt, 198, 40);    strcpy( origname, "\p");    SFPutFile( pt, EnterOutputFilename_TempBuf, origname, NULL, &reply);    if (reply.good) {      fstatus = Create(reply.fName,reply.vRefNum,creator,filetype);      fstatus = FSOpen(reply.fName,reply.vRefNum,&fp);      HLock((*g->storyth)->hText);      fcount = mysize;      fstatus = FSWrite(fp,&fcount,*(*g->storyth)->hText);      HUnlock((*g->storyth)->hText);      fstatus = FSClose(fp);   } }}/* This function checks to see if there is any data coming into    the serial port, and if so captures the data. */DoModem(g,modembuf) screen *g; char *modembuf; {register int mycount1,mycount2;OSErr 	mpistatus;	/* mpi is modem.port.in	*/long	fcount,mpicount,mx;int	fstatus;unsigned char c;  mpistatus = SerGetBuf(mpi,&mpicount);		/* How much data is coming? */  if (mpicount > 0) {				/* Number of characters. */    if (capturing)      SetCursor(*watch);    fcount = mpicount;    fstatus = FSRead(mpi,&fcount,modembuf);	/* Read all of the data. *//* If capturing to file then don't display on screen */    if (capturing) {      mycount2 = 0;      for (mycount1 = 0; mycount1 < fcount; mycount1++) { /* Remove line feeds */        if (modembuf[mycount1] != 10)          modembuf[mycount2++] = modembuf[mycount1];      }      fcount = mycount2;      fstatus = FSWrite(capturefile,&fcount,modembuf);      InitCursor();/* Display the data into the serial port window. */    } else {      for (mx = 0; mx < mpicount; mx++) {		/* For each character received...*/        c = modembuf[mx];        if ((c > 31) || (c == 13) || (c == 8))	/* Only characters that are visible *//* It would speed things up a lot if we didn't use    TEKey here and put the data directly into the    TextEdit record.  Or, better yet, don't use    TextEdit at all. */          TEKey(modembuf[mx],g->storyth);	/* Put each character in the window */      }/* Scroll the window so that the insertion point is visible */      ShowSelect(g->storyWindow,g->storybar,g->storyth);} } }/* Paint a wide border around button #1 to indicate which    button is the default button */PaintDial(myDialog) 	/* Circle OK	item 1	*/DialogPtr myDialog; {int 	item_type;Handle 	item_Handle;  Rect 	item_box;   SetPort(	myDialog);  GetDItem(	myDialog,1,&item_type,&item_Handle,&item_box);  item_box.left--; item_box.top--;	/* TBD:  use InsetRect() */  item_box.right++; item_box.bottom++;  PenSize(3,3);  InsetRect(	  &item_box,-3,-3);  FrameRoundRect( &item_box,16,16);}/* GetDIHandle - return handle value of dialog item */Handle GetDIHandle(theDia,i) DialogPtr theDia;int i; {int theType;Handle theHandle;Rect theRect;  GetDItem(theDia, i, &theType, &theHandle, &theRect);  return theHandle;}/* Restrict the value of an integer to between "lo" and "hi" */int BoundsLimitWithWrapAround( vPtr, lo, hi) int *vPtr, lo, hi; {  if( *vPtr < lo) *vPtr = hi;  else if( *vPtr > hi) *vPtr = lo;  return( *vPtr);}/* Set the characteristics of the serial port */Setmodem() {GrafPtr 	tempPort;int 	the_item,item_type,mSettings,tbaud,tdata,tparity,tport,tprot,tstop;Handle 	item_Handle;  Rect 	item_box; char 	item_text[256];  DialogPtr myDialog;    InitCursor();    GetPort(&tempPort);#define MODEM_DLOD_ID	28243  myDialog = GetNewDialog( MODEM_DLOD_ID,(DialogPeek) 0L, (WindowPtr)-1L);    PaintDial(myDialog);	/* OK	*/  SetIText( GetDIHandle( myDialog, 15), (Str255 *) mbtext[mbaud]);    SetIText( GetDIHandle( myDialog, 16), (Str255 *) mdtext[mdata]);    SetIText( GetDIHandle( myDialog, 17), (Str255 *) mptext[mparity]);    SetIText( GetDIHandle( myDialog, 18), (Str255 *) mstext[mstop]);  SetIText( GetDIHandle( myDialog, 19), (Str255 *) mPorttext[mport]);  SetIText( GetDIHandle( myDialog, 20), (Str255 *) mprottext[mprot]);	/* set dlog temps	*/  tbaud = mbaud; tdata = mdata; tparity = mparity;   tport = mport; tprot = mprot; tstop = mstop;    do {     ModalDialog((long) 0,&the_item); 	if ((the_item == 3) || (the_item == 4) ) 	/* UP/DOWN 	tbaud	*/    {       tbaud += ((the_item == 3 /* UP*/) ? 1 : -1);      BoundsLimitWithWrapAround( &tbaud, 0, 10);      SetIText( GetDIHandle( myDialog, 15),  (Str255 *) mbtext[tbaud]);      }     else if ((the_item == 5) || (the_item == 6)) /* UP/DOWN tdata	*/    {       tdata += ((the_item == 5 /* UP*/) ? 1 : -1);            BoundsLimitWithWrapAround( &tdata, 0, 3);      SetIText( GetDIHandle( myDialog, 16), (Str255 *) mdtext[tdata]);      }    else if ((the_item == 7) || (the_item == 8)) /* UP/DOWN tparity	*/    {       tparity += ((the_item == 7 /* UP*/) ? 1 : -1);      BoundsLimitWithWrapAround( &tparity, 0, 2);      SetIText( GetDIHandle( myDialog, 17), (Str255 *) mptext[tparity]);      }     else if ((the_item == 9) || (the_item == 10)) /* UP/DOWN tstop	*/    {       tstop += ((the_item == 9 /* UP*/) ? 1 : -1);      BoundsLimitWithWrapAround( &tstop, 0, 2);      SetIText( GetDIHandle( myDialog, 18), (Str255 *) mstext[ tstop]);      }    else if ((the_item == 11) || (the_item == 12)) /* UP/DOWN tpORt	*/    {       tport += ((the_item == 11 /* UP*/) ? 1 : -1);      BoundsLimitWithWrapAround( &tport, 0, 1);      SetIText( GetDIHandle( myDialog, 19), (Str255 *) mPorttext[ tport]);      } 	else if ((the_item == 13) || (the_item == 14)) /* UP/DOWN tpROt	*/    {       tprot += ((the_item == 13 /* UP*/) ? 1 : -1);      BoundsLimitWithWrapAround( &tprot, 0, 1);      SetIText( GetDIHandle( myDialog, 20), (Str255 *) mprottext[ tprot]);      }  } while ((the_item != OK) && (the_item != Cancel));    if (the_item == OK) 	/* save temps to theRealThings	*/  {    PortClose();    mbaud = tbaud; mdata = tdata; mparity = tparity;     mport = tport; mprot = tprot; mstop = tstop;    PortOpen();  }  CloseDialog( myDialog);   SetPort(tempPort);  return( the_item);}/* Update the TextEdit record in an active window */updatestory (g) screen *g; {Rect mybox;  BeginUpdate(g->storyWindow);   SetPort(g->storyWindow);  mybox = g->storyWindow->portRect;  mybox.left = mybox.right - 15;  ClipRect(&mybox);  DrawGrowIcon(g->storyWindow);  ClipRect(&g->storyWindow->portRect);  DrawControls(g->storyWindow);  mybox = (*g->storyth)->destRect;  mybox.bottom = 32767;  TEUpdate(&mybox,g->storyth);  EndUpdate(g->storyWindow);}/* Interface with the operator */main() {unsigned char c;       /* Keyboard character */Boolean   commandkey,  extendtext,  returnkey,  temp;       /* Receives value from GetNextEvent - ignored */int   fp,  fstatus,  windowcode, /* The value indicates what object the mouse button was pointing to when pressed */  theItem,  theMenu;long   fcount,  theCommand;Point   dragpoint,  mypoint;DialogPtr whichdialog;Rect windowrect;long bit,hexvalue,hexout,myerror,mysize,offset;GrafPtr tempPort;int i,item_type,the_item;Handle item_Handle,myhandle;  Rect mybox,screenRect; screen *g;Str255 tbuf,txtbuf,mpobuf;  InitGraf( (Ptr) &thePort);  InitFonts();  FlushEvents( everyEvent, 0);  InitWindows();  TEInit();  InitDialogs( 0L);	/* "0L" should be the restart proc address */  setupmenus();  InitCursor();  GetPort(&tempPort);  InitCursor();  watch = GetCursor(watchCursor);  capturing = FALSE;  mysize = sizeof(screen);  g = (screen*) NewPtr(mysize);  mysize = 65536L;  modembuf = NewPtr(mysize);  incoming = NewPtr(mysize);  getSettings(g);	/* Get default settings from "CNFG" resource */  PortOpen();		/* Open the serial port *//* Create the copyright notice window */  SetRect(&screenRect,30,40,290,292);  noticeWindow = NewWindow(&nrecord,&screenRect,"\p",FALSE,3,(long)-1L,0,(long)0L);/* Create the display window */  SetRect( &screenRect,     g->Windowsize[2],  g->Windowsize[3],     g->Windowsize[2] + g->Windowsize[4],     g->Windowsize[3] + g->Windowsize[5]);        g->storyWindow = NewWindow(&g->storyrecord, &screenRect,      "\pSerial Port" , 	/* WTitle */     FALSE,		/* Visible */      0,      (long)-1,      TRUE		/* GoAway */,      (long)0);  SetRect( &screenRect,     g->Windowsize[4] - 15, 0, g->Windowsize[4], g->Windowsize[5] - 13);  g->storybar = NewControl( g->storyWindow,     &screenRect, "\p", FALSE, 0, 0, 0, scrollBarProc, 0L);  SetPort(g->storyWindow);  TextSize(9); TextMode( srcCopy); TextFont( geneva);  SetRect( &screenRect, 4, 12, g->Windowsize[4] - 15, g->Windowsize[5]);  g->storyth = TENew( &screenRect,&screenRect);  FixStoryWindow(g,FALSE,g->Windowsize[5],g->Windowsize[4]);  SetRect(&dragRect,0,0,32767,32767);	/* TBD set to screenSize *//* This is the main event loop, which scans for input from the modem    and from the keyboard. */     do {    commandkey = FALSE;    returnkey = FALSE;    SystemTask();  /* Process desk accessories and other system stuff */    temp = GetNextEvent(everyEvent, &myevent);             /* Get the next event */    mypoint = myevent.where;                               /* Save the event mouse position */    windowcode = FindWindow(myevent.where, &whichwindow);  /* Save the event window info *//* Call a function to capture the data from the serial port. */    DoModem(g,modembuf);/* Process all events */    switch (myevent.what) {    case mouseDown:      switch (windowcode) {/* Process menu bar events here */      case inMenuBar:         theCommand = MenuSelect(&myevent.where);	theMenu = HiWord( theCommand);	theItem = LoWord( theCommand);	docommand(g,theMenu, theItem);        break;/* Process events for desk accessories here */      case inSysWindow: SystemClick(&myevent, whichwindow); break;      case inDrag: 	DragWindow( whichwindow, myevent.where, &dragRect);        break;      case inGrow: 	{	          long tPtlong;          Point growPoint;	          SetRect(&mybox,187,187,32767,32767);          tPtlong =  GrowWindow( whichwindow, myevent.where, &mybox);          growPoint.h = LoWord( tPtlong);          growPoint.v = HiWord( tPtlong);	            if (tPtlong != 0 ) {		/* TBD DO_IT_RIGHT */	    if (whichwindow == g->storyWindow)               FixStoryWindow(g,FALSE,growPoint.v,growPoint.h);          }        }        break;      case inContent:         if (whichwindow == g->storyWindow) {          SetPort(whichwindow);          GlobalToLocal(&myevent.where);          if ( PtInRect( myevent.where, &(*g->storyth)->viewRect)) {            if ((myevent.modifiers & shiftKey) == 0)               extendtext = FALSE;             else              extendtext = TRUE; 	                  TEClick( myevent.where, extendtext,g->storyth);          } else myControls(g,whichwindow,g->storyth,&myevent.where);        }        break;      case inGoAway: break;      }      break;    case mouseUp:       switch (windowcode) {      case inMenuBar: break;      case inSysWindow: break;      case inGrow: break;/* Process mouseup events that occur in the main font window if the letter    dialogue window is not visible. */      case inContent: break;      case inGoAway: break;      }      break;/* Process Control key characters from the keyboard */    case keyDown:    case autoKey: /* Clear the notice window whenever a key is pressed. */      c = (char) (255 & myevent.message);      if ((myevent.modifiers & cmdKey) != 0) {        commandkey = TRUE;/* If the key is visible then send it out the serial port. */      } else if ((c > 31) || (c == 13) || (c == 8) || (c == 3)) {        fcount = 1;         fstatus = FSWrite(mpo,&fcount,&c);/* If the key is not visible (unknown) then display it's value. */      } else {        sprintf(modembuf,"Key: %d\r",c);        i = 0;        while (modembuf[i] != 0) {          TEKey(modembuf[i++],g->storyth);      } }      break;    case activateEvt:       if (whichwindow == g->storyWindow) {	SetPort(g->storyWindow);	mybox = g->storyWindow->portRect;	mybox.left = mybox.right - 16;	InvalRect(&mybox);	if ((myevent.modifiers & 1) != 0)           ShowControl(g->storybar);        else 	          HideControl(g->storybar); 	 }      break;/* Update the display of the indicated application window.  These update    events occur whenever the letter dialogue appears or disappears and    when desk accessories are moved around on the screen. */    case updateEvt:       if (myevent.message == (long) g->storyWindow) updatestory(g);      break;    }  } while (doneflag == 0);  SetPort(tempPort);}