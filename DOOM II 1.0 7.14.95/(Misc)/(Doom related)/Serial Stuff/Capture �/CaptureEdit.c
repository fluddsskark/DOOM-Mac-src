/* Capture program - example of serial port control**  Programmer:		James R. Logan Jr.*  Organization:	Brigham Young University*/#include "QuickDraw.h"#include "MacTypes.h"#include "WindowMgr.h"#include "TextEdit.h"#include "ControlMgr.h"#include "EventMgr.h"#include "capture.h"TEHandle mainTEHandle;int		linesInFolder;intGetLinesInFolder( tH)TEHandle	tH;{int			local_linesInFolder, wsize;int			height;FontInfo	myInfo;	GetFontInfo( &myInfo );	height = myInfo.ascent+myInfo.descent+myInfo.leading;	local_linesInFolder = 		(wsize=(( **tH).viewRect.bottom - ( **tH).viewRect.top)) / height;	return( local_linesInFolder);}/* Make the line in the TextEdit record with with the    "insertion point" visible */ShowSelect(mywindow,mycontrol,mytexthandle) WindowPtr mywindow; ControlHandle mycontrol; TEHandle mytexthandle; {register int	theLine, point;int				curLine, adjust;GrafPtr savePort;  GetPort( &savePort );  SetPort( mywindow );  linesInFolder = GetLinesInFolder( mytexthandle);  SetVScrollMax( mycontrol, mytexthandle);  curLine = GetCtlValue( mycontrol );	  point = (**mytexthandle).teLength-1;	/* (**mytexthandle).selStart;	*/  for (theLine=0;                       /* Find the line where the control points */    ((point<(**mytexthandle).lineStarts[theLine]) ||     (point>=(**mytexthandle).lineStarts[theLine+1]))	; theLine++ ) ;  if ( (theLine<curLine ) || (theLine>(curLine+linesInFolder-1))) {    adjust = (linesInFolder-1)/2;    SetCtlValue( mycontrol, theLine - adjust );  }  if(theLine!=curLine) ScrollBits(mycontrol, mytexthandle);  SetPort( savePort );}/* The following routines scroll the TextEdit record within the    display window */ScrollMax(myControl,myTEHandle)ControlHandle myControl; TEHandle myTEHandle; {	SetVScrollMax( myControl, myTEHandle);/* NOTE: the topline of the TE is saved in WRefCon	*/  	SetWRefCon((*myTEHandle)->inPort,0L);	  	SetCtlValue(	myControl,0);		/* ???	*/}	/* TBD rename	*/Scroll0(myControl,myTEHandle) ControlHandle myControl; TEHandle myTEHandle; {/* NOTE: the topline of the TE is saved in WRefCon	*/  	SetWRefCon((*myTEHandle)->inPort,0L);		SetCtlMax( 		myControl, 0);  	SetCtlValue(	myControl,0);		/* ???	*/}ScrollBits(		myControl, myTEHandle) ControlHandle 	myControl; TEHandle myTEHandle; {long 	oldtop = GetWRefCon((*myTEHandle)->inPort);long	topline= GetCtlValue(myControl);int linevalue;/* The only place WRefCon is changed, other than when it is set to 0	*/  SetWRefCon((*myTEHandle)->inPort,topline);	  linevalue = oldtop - topline;  TEScroll(0, linevalue * (*myTEHandle)->lineHeight, myTEHandle);	/* 	*/}pascal scrollup(myControl,partcode) ControlHandle myControl; int partcode; {int value;  if (partcode == inUpButton) {    value = GetCtlValue(myControl) - 1;    SetCtlValue(myControl,value);    ScrollBits(myControl,mainTEHandle);  }}pascal scrolldown(myControl,partcode) ControlHandle myControl; int partcode; {int value;  if (partcode == inDownButton) {    value = GetCtlValue(myControl) + 1;    SetCtlValue(myControl,value);    ScrollBits(myControl,mainTEHandle);  } }pagescroll(myControl,whichpart,myTEHandle) ControlHandle myControl; int whichpart; TEHandle myTEHandle; { Point myPoint; int amount,value;   if (whichpart == inPageUp)   		amount = -1;   else 	amount = 1;     do {     GetMouse(&myPoint);     if (TestControl( myControl, myPoint) == whichpart) {      value = GetCtlValue(myControl) + amount *         (((*myTEHandle)->destRect.bottom - (*myTEHandle)->destRect.top) >> 1) / 	      (*myTEHandle)->lineHeight;       SetCtlValue(	myControl,value);       ScrollBits(	myControl,myTEHandle);     }   } while (StillDown());}/* Process scroll bar controls */myControls( g, myWindow, myTEHandle, myPoint) screen *g; WindowPtr myWindow; TEHandle myTEHandle; Point *myPoint; {int 	t,whichpart;ControlHandle myControl;GrafPtr savePort;  GetPort( &savePort );  SetPort( (*myTEHandle)->inPort );  mainTEHandle = myTEHandle;  whichpart = FindControl( *myPoint, myWindow, &myControl);  if ((myControl == g->storybar)) {    switch (whichpart) {    case inUpButton: 	t = TrackControl(myControl, *myPoint,&scrollup); break;    case inDownButton: 	t = TrackControl(myControl, *myPoint,&scrolldown); break;    case inPageUp: 	 pagescroll(myControl,whichpart,myTEHandle); break;    case inPageDown: pagescroll(myControl,whichpart,myTEHandle); break;    case inThumb:       t = TrackControl(	myControl, *myPoint,0L);       ScrollBits( 		myControl, myTEHandle);      break;    default: break;  } }  SetPort( savePort );} storytext(myWindowPtr,myTEHandle,mybar,wdx) WindowPtr myWindowPtr; TEHandle myTEHandle; ControlHandle mybar; int wdx; {  (*myTEHandle)->viewRect.right = wdx - 15;  (*myTEHandle)->destRect.right = (*myTEHandle)->viewRect.right - 2;  (*myTEHandle)->viewRect.bottom =     	myWindowPtr->portRect.bottom - myWindowPtr->portRect.top;  TECalText(myTEHandle);  SetVScrollMax( mybar, myTEHandle);  if (GetWRefCon((*myTEHandle)->inPort) > GetCtlValue(mybar))     ShowSelect(myWindowPtr,mybar,myTEHandle);}SetVScrollMax( mybar, myTEHandle)ControlHandle mybar;TEHandle myTEHandle; {int ctlMax, n= (*myTEHandle)->nLines - GetLinesInFolder( myTEHandle);/* if last line ends in a \r, one more line	*/  if ( IsLastCharacterCR( myTEHandle))     n += 1;  SetCtlMax( mybar, ctlMax = ( n>0 ? n : 0 ) );}int								/* (ODD ADDR ERR) if last line ends in a \r	*/IsLastCharacterCR( myTEHandle)TEHandle myTEHandle; {char	*cptr;		cptr = *((**myTEHandle).hText);			/* point to text	*/	cptr += (**myTEHandle).teLength;	/* point to last char of text	*/	return ( ((**myTEHandle).teLength>0) && (*(cptr - 1) == '\r') ) ;}storygrow(myWindowPtr,mybar,mytop) WindowPtr myWindowPtr; ControlHandle mybar; int mytop; {				/* Adjust the position and size of the scroll bars */  HideControl(mybar);  MoveControl(mybar,	myWindowPtr->portRect.right - 15, mytop - 1);  SizeControl(mybar,16, myWindowPtr->portRect.bottom - mytop - 13);  ShowControl(mybar);}FixStoryWindow(g,deletetext,height,width) screen *g; Boolean deletetext; int height,width; {Rect mybox;  SetPort(g->storyWindow);  if (deletetext)   	DeleteAllText(  g->storyth);  SizeWindow(	g->storyWindow,width,height,TRUE);  storytext(	g->storyWindow,g->storyth,g->storybar,width);  storygrow(	g->storyWindow,g->storybar,g->storyWindow->portRect.top);  ShowWindow(	g->storyWindow);/* Erase the previous text - required to erase the grow box sometimes */  SetRect(	&mybox,0,0,width - 15,height);  EraseRect(&mybox);/* Invalidate the whole Window - required to redisplay the grow box */  SetRect(	&mybox,0,0,width,height);  InvalRect(&mybox);}/* Clear the text window */clearrem(g) screen *g; {GrafPtr savePort;  GetPort( &savePort );  SetPort( g->storyWindow );  ClearText( g);  SetPort( savePort );}ClearText(g) screen *g; {	DeleteAllText( g->storyth);  	Scroll0(g->storybar,g->storyth);}DeleteAllText(  myTEHandle)TEHandle myTEHandle; {  TESetSelect(0L,32768L, myTEHandle);   TEDelete( myTEHandle);   (*myTEHandle)->destRect = (*myTEHandle)->viewRect;	/* reset destRect	*/}/* Print a C comment "..." to the txt window	*/ccomment(g,mytext)screen *g; char *mytext; {long mycount = strlen(mytext);GrafPtr savePort;  GetPort( &savePort );  SetPort( g->storyWindow );  TEInsert(mytext,mycount,g->storyth);  storytext(	g->storyWindow,g->storyth,g->storybar,g->storyWindow->portRect.right);  ScrollBits(	g->storybar,g->storyth);  SetPort( savePort );}/* Print a Pascal comment "\p..." to the txt window	*/pcomment(g,mytext)screen *g; char *mytext; {long mycount; char mychar,*myptr;GrafPtr savePort;  GetPort( &savePort );  SetPort( g->storyWindow );  mychar  = *mytext;  mycount = mychar & 0xff;  myptr   = mytext + 1;    if( !mytext) return;  if(*mytext == 0) return;  TEInsert( myptr, mycount, g->storyth);  storytext( g->storyWindow, g->storyth, g->storybar, g->storyWindow->portRect.right);  ScrollBits( g->storybar,g->storyth);  SetPort( savePort );}