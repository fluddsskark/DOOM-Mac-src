#ifdef __MPW_VERSION__	#include "DGMacHeaders.c"#else	#if defined(powerc) || defined (__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#endif#define __MAC_VERSION__#include "LionDoom.h"#include "Doomdef.h"#include <CTBUtilities.h>#include <CommResources.h>#include <Connections.h>#include "CTBBuffer.h"// Status of the buffersenum tBufStatus{	kHeadFree,						// Ready to read header	kHeadWaiting,					// Header read has been requested	kDataFree,						// Header read has been completed	kDataWaiting,					// Data  read has been requested	kDataFull							// Data read has been completed						};typedef enum tBufStatus tBufStatus;// The buffer containing status and a complete message.typedef struct tMessageBuf tMessageBuf;struct tMessageBuf{	tBufStatus			bufStat;								// Status of the buffer	tDoomDataHeader	headMsg;								// Header data	tDoomDataData		dataMsg;								// Message data};#define kNumMessageBufs	10									// Number of buffers in the array// An array of message bufferstypedef struct tMessageBufArr tMessageBufArr;struct tMessageBufArr{	short				bufPend;										// The next buffer to be filled						short				nextMsg;										// The next message to pass on	long				readSize;										// The size of the current read				tMessageBuf	bufs[kNumMessageBufs];			// The actual buffer};tMessageBufArr	*gMsgBufPtr;					// Global pointer to message bufferlong						gSizeToRead;					long						gSizeToWrite;extern ConnHandle	gConn;#define kHeaderSize (sizeof(tDoomDataHeader))	ConnectionCompletionUPP gReadCompletionProc;/*___________________________________________________________________________________	ReadCompletionRoutine	___________________________________________________________________________________*/pascal void ReadCompletion(ConnHandle hConn){	tMessageBuf		*theMessPtr;	CMStatFlags		statusFlags;	CMFlags				cmFlags;	CMBufferSizes	sizes;	OSErr					status;	theMessPtr = &(gMsgBufPtr->bufs[gMsgBufPtr->bufPend]);		// Find out what was read and check if all data read	if (theMessPtr->bufStat == kHeadWaiting)	{		if ((**hConn).asyncCount[cmDataIn] == gMsgBufPtr->readSize)		{			theMessPtr->bufStat = kDataFree;			#if __ASYNCH_DEBUG__				fprintf(debugfile,"kHeadWaiting -> kDataFree\n");			#endif		}		else			// Read remaining data for the header		{I_Error("Read of header did not complete");			gSizeToRead = gMsgBufPtr->readSize - (**hConn).asyncCount[cmDataIn];			status = CMRead(hConn, (Ptr) (&(theMessPtr->headMsg) + (**hConn).asyncCount[cmDataIn]), &gSizeToRead, cmData, true, gReadCompletionProc, 0, &cmFlags);			#if __ASYNCH_DEBUG__				fprintf(debugfile,"Full header was not read\n");			#endif		}	}	else if (theMessPtr->bufStat == kDataWaiting)	{		if ((**hConn).asyncCount[cmDataIn] == gMsgBufPtr->readSize)		{			theMessPtr->bufStat = kDataFull;			// Advance pending buffer pointer			gMsgBufPtr->bufPend = (gMsgBufPtr->bufPend +1 ) % kNumMessageBufs;			#if __ASYNCH_DEBUG__				fprintf(debugfile,"kDataWaiting -> kDataFull\n");			#endif		}		else			// Read remaining data for the msg		{I_Error("Read of data did not complete");			gSizeToRead = gMsgBufPtr->readSize - (**hConn).asyncCount[cmDataIn];			status = CMRead(hConn, (Ptr) (&(theMessPtr->dataMsg) + (**hConn).asyncCount[cmDataIn]), &gSizeToRead,cmData, true, gReadCompletionProc, 0, &cmFlags);			#if __ASYNCH_DEBUG__				fprintf(debugfile,"Full data was not read\n");			#endif		}	}}/*___________________________________________________________________________________	___________________________________________________________________________________*//*___________________________________________________________________________________	InitCTBBuffer		Initializes the message buffer.	___________________________________________________________________________________*/void	InitCTBBuffer(void){	short	numBufs;		// Allocate buffer	gMsgBufPtr = (tMessageBufArr *) NewPtrClear(sizeof(tMessageBufArr));	if (gMsgBufPtr == NULL)	{		I_Error("Error in allocating message buffer");	}		//Set default values	gMsgBufPtr->bufPend 		= 0;											// Fill first buffer	gMsgBufPtr->nextMsg			= 0;											// The next message to pass on	gMsgBufPtr->readSize		= 0;											// Size of the current read	for (numBufs = 0; numBufs < kNumMessageBufs; numBufs++)	{		gMsgBufPtr->bufs[numBufs].bufStat = kHeadFree;		// All free	}		gReadCompletionProc = NewConnectionCompletionProc((ProcPtr) ReadCompletion);	if (gReadCompletionProc == NULL)	{		I_Error("Error in allocating Read completion routine");	}	#if __ASYNCH_DEBUG__	fprintf(debugfile,"CTBBuffer initialised\n");#endif}/*___________________________________________________________________________________	TerminateCTBBuffer		Terminates the message buffer.	___________________________________________________________________________________*/void	TerminateCTBBuffer(void){	// Deallocate buffer	DisposePtr((Ptr)gMsgBufPtr);}OSErr ServiceWrite(UInt16 sendTo, Ptr data, Size length){	CMFlags				cmFlags = 0;	CMBufferSizes	sizes;	CMStatFlags		statusFlags;	OSErr					status;		status = CMStatus(gConn, sizes, &statusFlags);	if (statusFlags & cmStatusDRPend)	{			I_Error("Trying to write with write pending");	}	else	{		gSizeToWrite = length;				status = CMWrite(gConn, data, &gSizeToWrite, cmData, true, NULL, -1, cmFlags);		if (status != cmNoErr)		{			I_Error("Error in calling CMWrite %hd", status);			goto ErrorDone;		}	}ErrorDone:	return(status);}/*___________________________________________________________________________________	ServiceRead		-BEHAVIOR-	If there is a full message in a buffer, passes on that data,	initiaites the next read and returns true.		If there is not a full message, initiates the next read and returns	false.		-INITIATING A READ-	If a read is pending, do nothing.	If we don't have a free buffer, do nothing.	If we do have a free buffer,		If there is a header which does not have its accompanying data, read the data		 and mark that buffer as read requested.		Otherwise, read the next header and mark that buffer as read requested			-PASSING ON THE DATA-	Copy data to location specified by caller and invalidate the data in buffer.		---COMPLETION ROUTINE---	Marks the current buffer as read.		___________________________________________________________________________________*/Boolean ServiceRead(Ptr data, Size	*length){	Boolean				doRead;	Boolean				gotData;	long					msgSize;	long 					size;	Ptr						src, dst;	tMessageBuf		*theMessPtr;	CMStatFlags		statusFlags;	CMFlags				cmFlags;	CMBufferSizes	sizes;	OSErr					status;		#if __ASYNCH_DEBUG__		fprintf(debugfile,"Next message = %i\n",gMsgBufPtr->nextMsg);	#endif//////		theMessPtr = &(gMsgBufPtr->bufs[gMsgBufPtr->nextMsg]);	// If the data is ready, pass it on to caller	if (theMessPtr->bufStat == kDataFull)	{		// Copy the data		src = (Ptr) &(theMessPtr->headMsg);		dst	= data;		size = kHeaderSize;		while(size > 0)		{			*dst++ = *src++;			size--;		}				// Get size of message		msgSize = theMessPtr->headMsg.numtics * sizeof(ticcmd_t);				src = (Ptr) &(theMessPtr->dataMsg);		size = msgSize;		while(size > 0)		{			*dst++ = *src++;			size--;		}				#if __ASYNCH_DEBUG__			fprintf(debugfile,"Data ready and copied to caller\n");		#endif		// Assign length		*length = msgSize + kHeaderSize;				// Reset flags		theMessPtr->bufStat = kHeadFree;				#if __ASYNCH_DEBUG__			fprintf(debugfile,"kDataFull -> kHeadFree\n");		#endif		gMsgBufPtr->nextMsg = (gMsgBufPtr->nextMsg + 1) % kNumMessageBufs;				gotData = true;			}	else	{		*length = 0;		gotData = false;	}		theMessPtr = &(gMsgBufPtr->bufs[gMsgBufPtr->bufPend]);		// Dont read if there is a read pending	status = CMStatus(gConn, sizes, &statusFlags);		if (statusFlags & cmStatusDRPend)	{		doRead = false;		#if __ASYNCH_DEBUG__			fprintf(debugfile,"Read is pending...\n");		#endif	}		// Read header	else if (theMessPtr->bufStat == kHeadFree)	{		theMessPtr->bufStat		= kHeadWaiting;		gSizeToRead 					= kHeaderSize;		gMsgBufPtr->readSize	= gSizeToRead;		status = CMRead(gConn, (Ptr) &(theMessPtr->headMsg), &gSizeToRead, cmData, true, gReadCompletionProc, 0, &cmFlags);		#if __ASYNCH_DEBUG__			fprintf(debugfile,"Read header\n");		#endif	}		// Read message (header has already been read)	else if (theMessPtr->bufStat == kDataFree)	{		theMessPtr->bufStat	 = kDataWaiting;		gSizeToRead 					= theMessPtr->headMsg.numtics * sizeof(ticcmd_t);		gMsgBufPtr->readSize 	= gSizeToRead;		status = CMRead(gConn, (Ptr) &(theMessPtr->dataMsg), &gSizeToRead, cmData, true, gReadCompletionProc, 0, &cmFlags);		#if __ASYNCH_DEBUG__			fprintf(debugfile,"Read data\n");		#endif	}		return (gotData);}