#define __MAC_VERSION__#include "LionDoom.h"// R_draw.c#include "doomdef.h"#include "r_local.h"extern byte				remapMac[256];/*All drawing to the view buffer is accomplished in this file.  The other refreshfiles only know about ccordinates, not the architecture of the frame buffer.*/byte	*viewimage = NULL;int		viewwidth = 0, scaledviewwidth = 0, viewheight = 0, viewwindowx = 0, viewwindowy = 0;byte	*ylookup[MAXHEIGHT];int		columnofs[MAXWIDTH];byte	translations[3][256];	// color tables for different playersvoid R_VideoErase (unsigned ofs, int count);/*==================== R_DrawColumn== Source is the top of the column to scale===================*/lighttable_t	*dc_colormap = NULL;int				dc_x = 0;int				dc_yl = 0;int				dc_yh = 0;fixed_t			dc_iscale = 0;fixed_t			dc_texturemid = 0;byte			*dc_source = NULL;		// first pixel in a column (possibly virtual)int				dccount = 0;		// just for profiling#include "R_DRAW.PROTO.H"#if 0void R_DrawColumn (void){	register int		count;	register byte		*dest, *regDCMap, *regDCSrc;	register fixed_t	frac, fracstep;		count = dc_yh - dc_yl;	if (count < 0)		return;					#ifdef RANGECHECK		if ((unsigned)dc_x >= SCREENWIDTH || dc_yl < 0 || dc_yh >= SCREENHEIGHT)			I_Error ("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);	#endif		dest = ylookup[dc_yl] + columnofs[dc_x];		fracstep = dc_iscale;	frac = dc_texturemid + (dc_yl - centery) * fracstep;	regDCMap = dc_colormap;	regDCSrc = dc_source;		if (gHiRes)	{		do		{			*dest = regDCMap[ regDCSrc[ (short)((frac >> FRACBITS) & 127) ] ];			dest += kHiResScreenWidth;			frac += fracstep;		} while (count--);	}	else	{		do		{			*dest = regDCMap[ regDCSrc[ (short)((frac >> FRACBITS) & 127) ] ];			dest += kScreenWidth;			frac += fracstep;		} while (count--);	}}#endifvoid R_DrawColumn (void){	register byte			*source, *dest, *colormap;	register unsigned long	frac, fracstep, fracstep2, fracstep3, fracstep4;		register long			count;		count = dc_yh - dc_yl + 1;	if (count < 0)		return;		source = dc_source;	colormap = dc_colormap;	dest = ylookup[dc_yl] + columnofs[dc_x];		fracstep = dc_iscale << 9;	frac = (dc_texturemid + (dc_yl - centery) * dc_iscale) << 9;		fracstep2 = fracstep + fracstep;	fracstep3 = fracstep2 + fracstep;	fracstep4 = fracstep3 + fracstep;#if defined(powerc) || defined (__powerc)	if (gHiRes)	{		while (count >= 4)		{			unsigned long	tempA, tempB, tempC, tempD;			unsigned long	indexA, indexB, indexC, indexD;					indexA = source[ (frac>>25) ];			indexB = source[ ((frac+fracstep) >> 25) ];			indexC = source[ ((frac+fracstep2) >> 25) ];			indexD = source[ ((frac+fracstep3) >> 25) ];			frac += fracstep4;						tempA = colormap[indexA];			tempB = colormap[indexB];			tempC = colormap[indexC];			tempD = colormap[indexD];			count -= 4;			dest[kHiResScreenWidth*0] = tempA;			dest[kHiResScreenWidth*1] = tempB;			dest[kHiResScreenWidth*2] = tempC;			dest[kHiResScreenWidth*3] = tempD;			dest += kHiResScreenWidth * 4;		}				while (count > 0)		{			*dest = colormap[source[ (frac >> 25) ]];			dest += kHiResScreenWidth;			frac += fracstep;			count--;		}	}	else	{		while (count >= 4)		{			unsigned long	tempA, tempB, tempC, tempD;			unsigned long	indexA, indexB, indexC, indexD;					indexA = source[ (frac>>25) ];			indexB = source[ ((frac+fracstep) >> 25) ];			indexC = source[ ((frac+fracstep2) >> 25) ];			indexD = source[ ((frac+fracstep3) >> 25) ];			frac += fracstep4;						tempA = colormap[indexA];			tempB = colormap[indexB];			tempC = colormap[indexC];			tempD = colormap[indexD];			count -= 4;			dest[kScreenWidth*0] = tempA;			dest[kScreenWidth*1] = tempB;			dest[kScreenWidth*2] = tempC;			dest[kScreenWidth*3] = tempD;			dest += kScreenWidth * 4;		}				while (count > 0)		{			*dest = colormap[source[ (frac >> 25) ]];			dest += kScreenWidth;			frac += fracstep;			count--;		}	}#else	if (gHiRes)	{		while (count >= 8)		{			dest[0] = colormap[source[ (short)(frac>>25) ]];			dest[kHiResScreenWidth] = colormap[source[ (short) ((frac+fracstep) >> 25) ]];			dest[kHiResScreenWidth*2] = colormap[source[ (short)((frac+fracstep2) >> 25) ]];			dest[kHiResScreenWidth*3] = colormap[source[ (short)((frac+fracstep3) >> 25) ]];			frac += fracstep4;			dest[kHiResScreenWidth*4] = colormap[source[ (short) (frac >> 25) ]];			dest[kHiResScreenWidth*5] = colormap[source[ (short) ((frac+fracstep) >> 25) ]];			dest[kHiResScreenWidth*6] = colormap[source[ (short) ((frac+fracstep2) >> 25) ]];			dest[kHiResScreenWidth*7] = colormap[source[ (short) ((frac+fracstep3) >> 25) ]];			frac += fracstep4;			dest += kHiResScreenWidth * 8;			count -= 8;		}				while (count > 0)		{			*dest = colormap[source[ (short) (frac >> 25) ]];			dest += kHiResScreenWidth;			frac += fracstep;			count--;		}	}	else	{		while (count >= 8)		{			dest[0] = colormap[source[ (short)(frac>>25) ]];			dest[kScreenWidth] = colormap[source[ (short) ((frac+fracstep) >> 25) ]];			dest[kScreenWidth*2] = colormap[source[ (short)((frac+fracstep2) >> 25) ]];			dest[kScreenWidth*3] = colormap[source[ (short)((frac+fracstep3) >> 25) ]];			frac += fracstep4;			dest[kScreenWidth*4] = colormap[source[ (short) (frac >> 25) ]];			dest[kScreenWidth*5] = colormap[source[ (short) ((frac+fracstep) >> 25) ]];			dest[kScreenWidth*6] = colormap[source[ (short) ((frac+fracstep2) >> 25) ]];			dest[kScreenWidth*7] = colormap[source[ (short) ((frac+fracstep3) >> 25) ]];			frac += fracstep4;			dest += kScreenWidth * 8;			count -= 8;		}				while (count > 0)		{			*dest = colormap[source[ (short) (frac >> 25) ]];			dest += kScreenWidth;			frac += fracstep;			count--;		}	}	#endif}void R_DrawMultiColumn (tMultiDrawColumnRec *colsRec){/*	tMultiDrawColumnRec	mycrec;		mycrec.rec[0].fSource = dc_source;	mycrec.rec[0].fColormap = dc_colormap;	mycrec.rec[0].fX = dc_x;	mycrec.rec[0].fYl = dc_yl;	mycrec.rec[0].fYh = dc_yh;	mycrec.rec[0].fiScale = dc_iscale;	mycrec.rec[0].fTextureMid = dc_texturemid;		dc_source = colsRec->rec[0].fSource;	dc_colormap = colsRec->rec[0].fColormap;	dc_x = colsRec->rec[0].fX;	dc_yl = colsRec->rec[0].fYl;	dc_yh = colsRec->rec[0].fYh;	dc_iscale = colsRec->rec[0].fiScale;	dc_texturemid = colsRec->rec[0].fTextureMid;		R_DrawColumn();	dc_source = colsRec->rec[1].fSource;	dc_colormap = colsRec->rec[1].fColormap;	dc_x = colsRec->rec[1].fX;	dc_yl = colsRec->rec[1].fYl;	dc_yh = colsRec->rec[1].fYh;	dc_iscale = colsRec->rec[1].fiScale;	dc_texturemid = colsRec->rec[1].fTextureMid;		R_DrawColumn();		dc_source = mycrec.rec[0].fSource;	dc_colormap = mycrec.rec[0].fColormap;	dc_x = mycrec.rec[0].fX;	dc_yl = mycrec.rec[0].fYl;	dc_yh = mycrec.rec[0].fYh;	dc_iscale = mycrec.rec[0].fiScale;	dc_texturemid = mycrec.rec[0].fTextureMid;	return;*/	register byte		*destA, *destB, *cmapA, *cmapB;	register byte		*srcA, *srcB, *dest;	register fixed_t	fracA, fracB, fracstepA, fracstepB;	register int		count, sourceBytes;		if (TRUE)	{		register int		countA, countB;		countA = colsRec->rec[0].fYh - colsRec->rec[0].fYl;		countB = colsRec->rec[1].fYh - colsRec->rec[1].fYl;		if ((countA < 0) && (countB < 0))			return;				if (countA < 0)		{			dc_source = colsRec->rec[1].fSource;			dc_colormap = colsRec->rec[1].fColormap;			dc_x = colsRec->rec[1].fX;			dc_yl = colsRec->rec[1].fYl;			dc_yh = colsRec->rec[1].fYh;			dc_iscale = colsRec->rec[1].fiScale;			dc_texturemid = colsRec->rec[1].fTextureMid;			R_DrawColumn();			return;		}				if (countB < 0)		{			dc_source = colsRec->rec[0].fSource;			dc_colormap = colsRec->rec[0].fColormap;			dc_x = colsRec->rec[0].fX;			dc_yl = colsRec->rec[0].fYl;			dc_yh = colsRec->rec[0].fYh;			dc_iscale = colsRec->rec[0].fiScale;			dc_texturemid = colsRec->rec[0].fTextureMid;			R_DrawColumn();			return;		}	}	#if (0)// ее Finish up.	if (gHiRes)	{		if ((unsigned)colsRec->rec[0].fX >= kHiResScreenWidth || 			colsRec->rec[0].fYl < 0 || colsRec->rec[0].fYh >= kHiResScreenHeight)			I_Error ("R_DrawColumn: %i to %i at %i", colsRec->rec[0].fYl, colsRec->rec[0].fYh, colsRec->rec[0].fX);		if ((unsigned)colsRec->rec[1].fX >= kHiResScreenWidth || 			colsRec->rec[1].fYl < 0 || colsRec->rec[1].fYh >= kHiResScreenHeight)			I_Error ("R_DrawColumn: %i to %i at %i", colsRec->rec[1].fYl, colsRec->rec[1].fYh, colsRec->rec[1].fX);	}	else	{		if ((unsigned)colsRec->rec[0].fX >= kScreenWidth || 			colsRec->rec[0].fYl < 0 || colsRec->rec[0].fYh >= kScreenHeight)			I_Error ("R_DrawColumn: %i to %i at %i", colsRec->rec[0].fYl, colsRec->rec[0].fYh, colsRec->rec[0].fX);		if ((unsigned)colsRec->rec[1].fX >= kScreenWidth || 			colsRec->rec[1].fYl < 0 || colsRec->rec[1].fYh >= kScreenHeight)			I_Error ("R_DrawColumn: %i to %i at %i", colsRec->rec[1].fYl, colsRec->rec[1].fYh, colsRec->rec[1].fX);	}#endif		destA = ylookup[ colsRec->rec[0].fYl ] + columnofs[ colsRec->rec[0].fX ];	destB = ylookup[ colsRec->rec[1].fYl ] + columnofs[ colsRec->rec[1].fX ];		fracstepA = colsRec->rec[0].fiScale;	fracstepB = colsRec->rec[1].fiScale;		srcA = colsRec->rec[0].fSource;	srcB = colsRec->rec[1].fSource;		fracA = colsRec->rec[0].fTextureMid + (colsRec->rec[0].fYl - centery) * fracstepA;	fracB = colsRec->rec[1].fTextureMid + (colsRec->rec[1].fYl - centery) * fracstepB;		cmapA = colsRec->rec[0].fColormap;	cmapB = colsRec->rec[1].fColormap;		if (gHiRes)		sourceBytes = kHiResScreenWidth;	else		sourceBytes = kScreenWidth;	// Process areas of leading Y difference to get the two columns in sync.	if ( colsRec->rec[0].fYl > colsRec->rec[1].fYl )	{		register int		diff;				diff = colsRec->rec[0].fYl - colsRec->rec[1].fYl;		colsRec->rec[1].fYl += diff;				while (diff--)		{			*destB = cmapB[ srcB[ (fracB >> FRACBITS) & 127 ] ];			destB += sourceBytes;			fracB += fracstepB;		}	}	else	{		register int		diff;				diff = colsRec->rec[1].fYl - colsRec->rec[0].fYl;		colsRec->rec[0].fYl += diff;				while (diff--)		{			*destA = cmapA[ srcA[ (fracA >> FRACBITS) & 127 ] ];			destA += sourceBytes;			fracA += fracstepA;		}	}		dest = (byte *) destA;// rec[0].fYl should equal rec[1].fYl ! (both columns synced on "y" values.	if ( colsRec->rec[0].fYh < colsRec->rec[1].fYh )	{		count = (colsRec->rec[0].fYh - colsRec->rec[0].fYl) + 1;		colsRec->rec[0].fYl = 0;		colsRec->rec[1].fYl += count;	}	else	{		count = (colsRec->rec[1].fYh - colsRec->rec[1].fYl) + 1;		colsRec->rec[0].fYl += count;		colsRec->rec[1].fYl = 0;	}		if (count)	{		while (count--)		{			unsigned long	tempA;			unsigned long	tempB;			unsigned long	tempC;			unsigned long	tempD;						tempA = srcA[ (fracA >> FRACBITS) & 127 ];			fracA += fracstepA;			tempB = srcB[ (fracB >> FRACBITS) & 127 ];			fracB += fracstepB;						tempC = cmapA[ tempA ];			tempD = cmapB[ tempB ];						dest[0] = tempC;			dest[1] = tempD;						dest += sourceBytes;		}	}		/*	if (colsRec->rec[0].fYl)	{		count = (colsRec->rec[1].fYh - colsRec->rec[1].fYl) + 1;		if (count > 0)		{			while (count--)			{				*dest = cmapA[ srcA[ (fracA >> FRACBITS) & 127 ] ];				fracA += fracstepA;				dest += sourceBytes;			}		}	}	else	{		count = (colsRec->rec[0].fYh - colsRec->rec[0].fYl) + 1;		if (count > 0)		{			while (count--)			{				*dest = cmapB[ srcB[ (fracB >> FRACBITS) & 127 ] ];				fracB += fracstepB;				dest += sourceBytes;			}		}	}	*/}void R_DrawColumnLow (void){	register int		count;	register byte		*dest;	register byte		*remapArray, *regDCMap, *regDCSrc;	register fixed_t	frac, fracstep;		count = dc_yh - dc_yl;	if (count < 0)		return;	#ifdef RANGECHECK	if ((unsigned)dc_x >= SCREENWIDTH || dc_yl < 0 || dc_yh >= SCREENHEIGHT)		I_Error ("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);//	dccount++;#endif	dest = ylookup[dc_yl] + columnofs[dc_x];		fracstep = dc_iscale;	frac = dc_texturemid + (dc_yl-centery)*fracstep;	remapArray = remapMac;	regDCMap = dc_colormap;	regDCSrc = dc_source;		if (gHiRes)	{		do		{			*dest = regDCMap[ regDCSrc[(frac >> FRACBITS) & 127]];			dest += kHiResScreenWidth;			frac += fracstep;		} while (count--);	}	else	{		do		{			*dest = regDCMap[ regDCSrc[(frac >> FRACBITS) & 127]];			dest += kScreenWidth;			frac += fracstep;		} while (count--);	}}#define FUZZTABLE	50#define FUZZOFF	(kScreenWidth)int		fuzzoffset[FUZZTABLE] = {FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF};int		fuzzpos = 0;void R_DrawFuzzColumn (void){	register int		count, regFuzzPos;	register byte		*dest, *regCMaps;	register int		*regFuzzOff;		if (!dc_yl)		dc_yl = 1;	if (dc_yh == viewheight-1)		dc_yh = viewheight - 2;		count = dc_yh - dc_yl;	if (count < 0)		return;	#ifdef RANGECHECK	if ((unsigned)dc_x >= SCREENWIDTH || dc_yl < 0 || dc_yh >= SCREENHEIGHT)		I_Error ("R_DrawFuzzColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);#endif		dest = ylookup[dc_yl] + columnofs[dc_x];		regCMaps = &colormaps[6 * 256];	regFuzzOff = fuzzoffset;	regFuzzPos = fuzzpos;		if (gHiRes)	{		do		{			*dest = regCMaps[ dest[ regFuzzOff[ regFuzzPos ] << 1 ] ];			if (++regFuzzPos == FUZZTABLE)				regFuzzPos = 0;			dest += kHiResScreenWidth;		} while (count--);	}	else	{		do		{			*dest = regCMaps[ dest[ regFuzzOff[ regFuzzPos ] ] ];			if (++regFuzzPos == FUZZTABLE)				regFuzzPos = 0;			dest += kScreenWidth;		} while (count--);	}		fuzzpos = regFuzzPos;}/*========================== R_DrawTranslatedColumn=========================*/byte	*dc_translation;byte	*translationtables;void R_DrawTranslatedColumn (void){	register byte			*dest;	register byte			*remapArray;	register byte			*regDCCMap;	register byte			*regDCTrans;	register byte			*regDCSrc;	register int			count;	register fixed_t		frac, fracstep;	count = dc_yh - dc_yl;	if (count < 0)		return;				#ifdef RANGECHECK	if ((unsigned)dc_x >= SCREENWIDTH || dc_yl < 0 || dc_yh >= SCREENHEIGHT)		I_Error ("R_DrawColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);#endif	dest = ylookup[dc_yl] + columnofs[dc_x];	fracstep = dc_iscale;	frac = dc_texturemid + (dc_yl - centery) * fracstep;	remapArray = remapMac;	regDCCMap = dc_colormap;	regDCTrans = dc_translation;	regDCSrc = dc_source;	if (gHiRes)	{		do		{			*dest = regDCCMap[ regDCTrans[ regDCSrc[ (byte) (frac >> FRACBITS) ]]];			dest += kHiResScreenWidth;			frac += fracstep;		} while (count--);	}	else	{		do		{			*dest = regDCCMap[ regDCTrans[ regDCSrc[ (byte) (frac >> FRACBITS) ]]];			dest += kScreenWidth;			frac += fracstep;		} while (count--);	}}/*====================== R_InitTranslationTables=====================*/void R_InitTranslationTables (void){	int		i;		translationtables = Z_Malloc (256*3+255, PU_STATIC, 0);	translationtables = (byte *)(( (int)translationtables + 255 )& ~255);	//// translate just the 16 green colors//	for (i=0 ; i<256 ; i++)	{		if (i >= 0x70 && i<= 0x7f)		{	// green, gray, brown, red			translationtables[i] = 0x60 + (i&0xf);			translationtables [i+256] = 0x40 + (i&0xf);			translationtables [i+512] = 0x20 + (i&0xf);		}		else			translationtables[i] = translationtables[i+256]			= translationtables[i+512] = i;	}}/*================== R_DrawSpan=================*/int				ds_y;int				ds_x1;int				ds_x2;lighttable_t	*ds_colormap;fixed_t			ds_xfrac;fixed_t			ds_yfrac;fixed_t			ds_xstep;fixed_t			ds_ystep;byte			*ds_source;		// start of a 64*64 tile imageint				dscount;		// just for profiling#if defined(NORMALUNIX) || (!defined(__WATCOMC__) && !defined(__i386) && !defined(__m68k))void R_DrawSpan (void){	register fixed_t	xfrac, yfrac;	register byte		*dest;	register int		count, spot;	register byte		*remapArray;	register byte		*regDSColor;	register byte		*regDSSrc;	register fixed_t	regDSXStep = ds_xstep;	register fixed_t	regDSYStep = ds_ystep;	#ifdef RANGECHECK	if (ds_x2 < ds_x1 || ds_x1<0 || ds_x2>=SCREENWIDTH	|| (unsigned)ds_y>SCREENHEIGHT)		I_Error ("R_DrawSpan: %i to %i at %i",ds_x1,ds_x2,ds_y);//	dscount++;#endif		xfrac = ds_xfrac;	yfrac = ds_yfrac;		dest = ylookup[ds_y] + columnofs[ds_x1];		count = ds_x2 - ds_x1;	remapArray = remapMac;	regDSColor = ds_colormap;	regDSSrc = ds_source;	#if defined(powerc) || defined (__powerc)	while (count >= 4)	{		byte	tempA;		byte	tempB;		byte	tempC;		byte	tempD;				spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		tempA = regDSSrc[spot];		xfrac += regDSXStep;		dest[0] = regDSColor[tempA];		yfrac += regDSYStep;				spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		tempB = regDSSrc[spot];		xfrac += regDSXStep;		dest[1] = regDSColor[tempB];		yfrac += regDSYStep;				count -= 4;		spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		tempC = regDSSrc[spot];		xfrac += regDSXStep;		dest[2] = regDSColor[tempC];		yfrac += regDSYStep;		spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		tempD = regDSSrc[spot];		xfrac += regDSXStep;		dest[3] = regDSColor[tempD];		yfrac += regDSYStep;				dest += 4;	}		while (count >= 0)	{		byte	tempA;				spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		tempA = regDSSrc[spot];		xfrac += regDSXStep;		count--;		*dest++ = regDSColor[tempA];		yfrac += regDSYStep;	}#else	while (count >= 4)	{		dest[0] = regDSColor[ regDSSrc[ ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63) ]];		xfrac += regDSXStep;		yfrac += regDSYStep;		dest[1] = regDSColor[ regDSSrc[ ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63) ]];		xfrac += regDSXStep;		yfrac += regDSYStep;		dest[2] = regDSColor[ regDSSrc[ ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63) ]];		xfrac += regDSXStep;		yfrac += regDSYStep;		dest[3] = regDSColor[ regDSSrc[ ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63) ]];		xfrac += regDSXStep;		yfrac += regDSYStep;				dest += 4;		count -= 4;	}		while (count >= 0)	{		*dest++ = regDSColor[ regDSSrc[ ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63) ]];		xfrac += regDSXStep;		yfrac += regDSYStep;		count--;	}#endif}/*void R_DrawSpan (void){	unsigned	position, step;	byte		*source,*colormap,*dest;	unsigned	count, spot;	unsigned	value, temp;	unsigned	xtemp, ytemp;			position = ((ds_xfrac<<10)&0xffff0000) | ((ds_yfrac>>6)&0xffff);	step = ((ds_xstep<<10)&0xffff0000) | ((ds_ystep>>6)&0xffff);			source = ds_source;	colormap = ds_colormap;	dest = ylookup[ds_y] + columnofs[ds_x1];		count = ds_x2 - ds_x1 + 1;		while (count >= 4)	{		ytemp = position>>4;		ytemp = ytemp & 4032;		xtemp = position>>26;		spot = xtemp | ytemp;		position += step;		dest[0] = colormap[source[spot]];		ytemp = position>>4;		ytemp = ytemp & 4032;		xtemp = position>>26;		spot = xtemp | ytemp;		position += step;		dest[1] = colormap[source[spot]];		ytemp = position>>4;		ytemp = ytemp & 4032;		xtemp = position>>26;		spot = xtemp | ytemp;		position += step;		dest[2] = colormap[source[spot]];		ytemp = position>>4;		ytemp = ytemp & 4032;		xtemp = position>>26;		spot = xtemp | ytemp;		position += step;		dest[3] = colormap[source[spot]];				count -= 4;		dest += 4;	}	while (count > 0)	{		ytemp = position>>4;		ytemp = ytemp & 4032;		xtemp = position>>26;		spot = xtemp | ytemp;		position += step;		*dest++ = colormap[source[spot]];		count--;	}}*/void R_DrawSpanLow (void){	register byte			*dest;	register byte			*remapArray;	register byte			*regDSCMap;	register byte			*regDSSrc;	register int			count, spot;	register fixed_t		xfrac, yfrac;	#ifdef RANGECHECK	if (ds_x2 < ds_x1 || ds_x1<0 || ds_x2>=SCREENWIDTH	|| (unsigned)ds_y>SCREENHEIGHT)		I_Error ("R_DrawSpan: %i to %i at %i",ds_x1,ds_x2,ds_y);//	dscount++;#endif		xfrac = ds_xfrac;	yfrac = ds_yfrac;		dest = ylookup[ds_y] + columnofs[ds_x1];	count = ds_x2 - ds_x1;	remapArray = remapMac;	regDSCMap = ds_colormap;	regDSSrc = ds_source;		do	{		spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		// *dest++ = remapArray[ regDSCMap[ regDSSrc[spot]]];		*dest++ = regDSCMap[ regDSSrc[spot]];		xfrac += ds_xstep;		yfrac += ds_ystep;	} while (count--);}#endif/*================== R_InitBuffer==================*/void R_InitBuffer (int width, int height){	register int	i;		if (gHiRes == 2)	{		viewwindowx = (kHiResScreenWidth - width) >> 1;		for (i = 0; i < width; i++)			columnofs[i] = viewwindowx + i;		if (width == kHiResScreenWidth)			viewwindowy = 0;		else			viewwindowy = (kHiResScreenHeight - (SBARHEIGHT * 2) - height) >> 1;				for (i = 0; i < height; i++)			ylookup[i] = screens[0] + (i + viewwindowy) * kHiResScreenWidth;	}	else if (gHiRes == 1)	{		viewwindowx = (kHiResScreenWidth - width) >> 1;		for (i = 0; i < width; i++)			columnofs[i] = viewwindowx + i;		if (width == kHiResScreenWidth)			viewwindowy = 0;		else			viewwindowy = (kScreenHeight - SBARHEIGHT - height) >> 1;				for (i = 0; i < height; i++)			ylookup[i] = screens[0] + (i + viewwindowy) * kHiResScreenWidth;	}	else	{		viewwindowx = (kScreenWidth - width) >> 1;		for (i = 0; i < width; i++)			columnofs[i] = viewwindowx + i;		if (width == kScreenWidth)			viewwindowy = 0;		else			viewwindowy = (kScreenHeight - SBARHEIGHT - height) >> 1;				for (i = 0; i < height; i++)			ylookup[i] = screens[0] + (i + viewwindowy) * kScreenWidth;	}}/*==================== R_FillBackScreen== Fills the back screen with a pattern for variable screen sizes= Also draws a beveled edge==================*/void R_FillBackScreen (void){	register byte		*src, *dest, *remapArray;	register short		x, y;	register short		i, temp;	patch_t				*patch;	char				name1[] = "FLOOR7_2";	// DOOM	char				name2[] = "GRNROCK";	// DOOM II	char				*name;		if ((gHiRes == FALSE) && (scaledviewwidth == kScreenWidth))		return;	if ((gHiRes == TRUE) && (scaledviewwidth == kHiResScreenWidth))		return;		if (commercial)		name = name2;	else		name = name1;		src = W_CacheLumpName (name, PU_CACHE);	dest = screens[1];	remapArray = remapMac;		// Draw the rock, but remap into Macintosh colors.		for (y = 0; y < kScreenHeight - SBARHEIGHT; y++)	{		for (x = 0; x < kScreenWidth / 64; x++)		{			temp = ((y & 63) << 6);			for (i = 0; i < 64; i++)				dest[i] = remapArray[ src[ temp++ ]];						dest += 64;		}	}		if (TRUE)	{		int		svw = scaledviewwidth;		int		vwx = viewwindowx;		int		vwy = viewwindowy;		int		vh = viewheight;				// scaledviewwidth, viewwindowx, etc. are based on coordinates		// for screen[0], not screen[1], which is low resolution. Divide by 2.				if (gHiRes == 2)		{			svw >>= 1;			vwx >>= 1;			vwy >>= 1;			vh >>= 1;		}		else if (gHiRes == 1)		{			svw >>= 1;			vwx >>= 1;		}				patch = W_CacheLumpName ("brdr_t", PU_CACHE);		for (x = 0; x < svw ; x += 8)			V_DrawPatch (vwx + x, vwy - 8, 1, patch);				patch = W_CacheLumpName ("brdr_b", PU_CACHE);		for (x = 0; x < svw; x += 8)			V_DrawPatch (vwx + x, vwy + vh, 1, patch);				patch = W_CacheLumpName ("brdr_l",PU_CACHE);		for (y = 0; y < vh; y += 8)			V_DrawPatch (vwx - 8, vwy + y, 1, patch);				patch = W_CacheLumpName ("brdr_r",PU_CACHE);		for (y = 0; y < vh; y += 8)			V_DrawPatch (vwx + svw, vwy + y, 1, patch);		V_DrawPatch (vwx - 8, vwy - 8, 1, W_CacheLumpName ("brdr_tl",PU_CACHE));		V_DrawPatch (vwx + svw, vwy - 8, 1, W_CacheLumpName ("brdr_tr",PU_CACHE));		V_DrawPatch (vwx - 8, vwy + vh, 1, W_CacheLumpName ("brdr_bl",PU_CACHE));		V_DrawPatch (vwx + svw, vwy + vh, 1, W_CacheLumpName ("brdr_br",PU_CACHE));	}}void R_VideoErase (unsigned ofs, int count){	if (gHiRes)	{		I_Error("R_VideoErase called in Hi res mode!");	}	else		memcpy (screens[0] + ofs, screens[1] + ofs, count);}/*==================== R_DrawViewBorder== Draws the border around the view for different size windows==================*/void R_DrawViewBorder (void){	int			top, top2, side, ofs, i;	if ((gHiRes == FALSE) && (scaledviewwidth == kScreenWidth))		return;	if ((gHiRes == TRUE) && (scaledviewwidth == kHiResScreenWidth))		return; 	 	if (gHiRes == 2) 	{ 	// V_CopyRect: src coordinates are low resolution, dst coordinates 	// are high resolution. width and height are src-coordinate based. 			top = ((kScreenHeight - SBARHEIGHT) - (viewheight >> 1)) >> 1;		side = (kScreenWidth - (scaledviewwidth >> 1)) >> 1;				//          x, y, srcScreen, width, height, dstX, dstY, dstScreen		 	// top 		V_CopyRect (0, 0, 1, kScreenWidth, top, 0, 0, 0); 	// left: to bottom.		V_CopyRect (0, top, 1, side, (kScreenHeight - SBARHEIGHT) - top, 0, top * 2, 0);	// right: to bottom.		V_CopyRect (kScreenWidth - side, top, 1, side, (kScreenHeight - SBARHEIGHT) - top, 			(kScreenWidth - side) * 2, top * 2, 0);	// bottom		V_CopyRect (side, top + (viewheight >> 1), 1, (scaledviewwidth >> 1),			(kScreenHeight - SBARHEIGHT) - (top + (viewheight >> 1)),			side * 2, (top + (viewheight >> 1)) * 2, 0); 	} 	else if (gHiRes == 1) 	{ 	} 	else 	{		top = ((kScreenHeight - SBARHEIGHT) - viewheight) >> 1;		side = (kScreenWidth - scaledviewwidth) >> 1;				top2 = ((top << 8) + (top << 6));				// copy top and one line of left side		R_VideoErase (0, top2 + side);				// copy one line of right side and bottom		ofs = (viewheight + top) * kScreenWidth - side;		R_VideoErase (ofs, top2 + side);				// copy sides using wraparound		ofs = top2 + kScreenWidth - side;		side <<= 1;				for (i = 1; i < viewheight; i++)		{			R_VideoErase (ofs, side);			ofs += kScreenWidth;		}	}}