#ifndef __SANE__#define __SANE__#ifndef __TYPES__#include <Types.h>#endif#define INF		__inf()#define PI		piextern const long double pi;extern long double __inf(void);enum {	FloatDecimal,FixedDecimal };enum {	SigDigLen=20,DecStrLen=80 };enum {	GreaterThan,LessThan,EqualTo,Unordered };enum {	SNaN=1,QNaN,Infinite,ZeroNum,NormalNum,DenormalNum };enum {	ToNearest,Upward,Downward,TowardZero };enum {	ExtPrecision,DblPrecision,FloatPrecision };typedef short RelOp;						typedef short NumClass; 					typedef short RoundDir; 					typedef short RoundPre; 					typedef struct Decimal {	char	sgn;									char	unused;	short	exp;									struct	{		unsigned char length;		unsigned char text[SigDigLen];				unsigned char unused;	} sig;} Decimal;typedef struct DecForm {	char style;	char unused;	short digits;} DecForm;#if __MC68881__#define INEXACT			8L#define DIVBYZERO		16L#define UNDERFLOW		32L#define OVERFLOW		64L#define INVALID			128L#define CURINEX1		256L#define CURINEX2		512L#define CURDIVBYZERO	1024L#define CURUNDERFLOW	2048L#define CUROVERFLOW		4096L#define CUROPERROR		8192L#define CURSIGNAN		16384L#define CURBSONUNOR		32768Ltypedef long Exception;typedef struct Environment {	long FPCR;	long FPSR;} Environment;typedef struct TrapVector {	void (*unordered)(void);	void (*inexact)(void);	void (*divbyzero)(void);	void (*underflow)(void);	void (*operror)(void);	void (*overflow)(void);	void (*signan)(void);} TrapVector;#ifdef __cplusplusextern "C" {#endifvoid GetTrapVector(TrapVector *);void SetTrapVector(TrapVector *);#ifdef __cplusplus}#endif#else#define IEEEDEFAULTENV	0#define INVALID			1#define UNDERFLOW		2#define OVERFLOW		4#define DIVBYZERO		8#define INEXACT			16typedef short Exception;typedef short Environment;typedef struct MiscHaltInfo {	unsigned short haltexceptions;	unsigned short pendingCCR;	long pendingD0;} MiscHaltInfo;#ifdef __cplusplusextern "C" {#endiftypedef pascal void (*HaltVector)(MiscHaltInfo *,void *,void *,void *,short);pascal void GetHaltVector(HaltVector *) = { 0x3F3C,0x0007,0xA9EB };pascal void SetHaltVector(HaltVector) = { 0x3F3C,0x0005,0xA9EB };#ifdef __cplusplus}#endif#endif										#ifdef __cplusplusextern "C" {#endif/*	Special conversion routines */void x96tox80(extended96 *,extended80 *);void x80tox96(extended80 *,extended96 *);/*	FP68K functions */pascal void SetEnvironment(Environment *) = { 0x3F3C,0x0001,0xA9EB };pascal void GetEnvironment(Environment *) = { 0x3F3C,0x0003,0xA9EB };pascal void SetException(Exception *) = { 0x3F3C,0x0015,0xA9EB };pascal void TestException(Exception *) = { 0x3F3C,0x001B,0xA9EB };pascal void ProcEntry(Environment *) = { 0x3F3C,0x0017,0xA9EB }; pascal void ProcExit(Environment *) = { 0x3F3C,0x0019,0xA9EB };pascal void Dec2Num(Decimal *,extended80 *) = { 0x3F3C,0x0009,0xA9EB };pascal void Num2Dec(DecForm *,extended80 *,Decimal *) = { 0x3F3C,0x000B,0xA9EB };pascal void Neg(extended80 *) = { 0x3F3C,0x000D,0xA9EB };pascal void Abs(extended80 *) = { 0x3F3C,0x000F,0xA9EB };pascal void CopySign(extended80 *to,extended80 *from) = { 0x3F3C,0x0011,0xA9EB };pascal void Sqrt(extended80 *) = { 0x3F3C,0x0012,0xA9EB };pascal void NextExtended(extended80 *,extended80 *) = { 0x3F3C,0x0013,0xA9EB };pascal void NextDouble(double *,double *) = { 0x3F3C,0x0813,0xA9EB }; pascal void NextFloat(float *,float *) = { 0x3F3C,0x1013,0xA9EB };pascal void Rint(extended80 *) = { 0x3F3C,0x0014,0xA9EB };pascal void Tint(extended80 *) = { 0x3F3C,0x0016,0xA9EB };pascal void Scalb(short *,extended80 *) = { 0x3F3C,0x0018,0xA9EB };pascal void Logb(extended80 *) = { 0x3F3C,0x001A,0xA9EB };pascal void ClassFloat(float *,NumClass *) = { 0x3F3C,0x101C,0xA9EB };pascal void ClassDouble(double *,NumClass *) = { 0x3F3C,0x081C,0xA9EB };pascal void ClassComp(comp *,NumClass *) = { 0x3F3C,0x301C,0xA9EB };pascal void ClassExtended(extended80 *,NumClass *) = { 0x3F3C,0x001C,0xA9EB };void Remainder(extended80 *source,extended80 *dest,short *quot);RelOp Relation(extended80 *source,extended80 *dest);short SignNum(extended80);void SetRound(RoundDir);RoundDir GetRound(void);void SetPrecision(RoundPre);RoundPre GetPrecision(void);extended NaN(short);/*	DecStr68K functions */pascal void PStr2Dec(StringPtr,short *,Decimal *,Boolean *) = { 0x3F3C,0x0002,0xA9EE };pascal void CStr2Dec(char *,short *,Decimal *,Boolean *) = { 0x3F3C,0x0004,0xA9EE };pascal void Dec2Str(DecForm *,Decimal *,StringPtr) = { 0x3F3C,0x0003,0xA9EE };/*	Elems68K functions */pascal void Ln(extended80 *) = { 0x3F3C,0x0000,0xA9EC };pascal void Log2(extended80 *) = { 0x3F3C,0x0002,0xA9EC };pascal void Ln1(extended80 *) = { 0x3F3C,0x0004,0xA9EC };pascal void Log21(extended80 *) = { 0x3F3C,0x0006,0xA9EC };pascal void Exp(extended80 *) = { 0x3F3C,0x0008,0xA9EC };pascal void Exp2(extended80 *) = { 0x3F3C,0x000A,0xA9EC };pascal void Exp1(extended80 *) = { 0x3F3C,0x000C,0xA9EC };pascal void Exp21(extended80 *) = { 0x3F3C,0x000E,0xA9EC };pascal void PowerI(short *source,extended80 *dest) = { 0x3F3C,0x8010,0xA9EC };pascal void Power(extended80 *source,extended80 *dest) = { 0x3F3C,0x8012,0xA9EC };pascal void Compound(extended80 *r,extended80 *n,extended80 *dest) = { 0x3F3C,0xC014,0xA9EC };pascal void Annuity(extended80 *r,extended80 *n,extended80 *dest) = { 0x3F3C,0xC016,0xA9EC };pascal void Sin(extended80 *) = { 0x3F3C,0x0018,0xA9EC };pascal void Cos(extended80 *) = { 0x3F3C,0x001A,0xA9EC };pascal void Tan(extended80 *) = { 0x3F3C,0x001C,0xA9EC };pascal void Atan(extended80 *) = { 0x3F3C,0x001E,0xA9EC };pascal void RandomX(extended80 *) = { 0x3F3C,0x0020,0xA9EC };#ifdef __cplusplus}#endif#endif