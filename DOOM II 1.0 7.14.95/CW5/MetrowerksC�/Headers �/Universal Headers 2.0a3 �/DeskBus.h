/* 	File:		DeskBus.h  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __DESKBUS__#define __DESKBUS__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __MIXEDMODE__#include <MixedMode.h>#endif#ifdef __cplusplusextern "C" {#endif#if GENERATINGPOWERPC#pragma options align=mac68k#endif#ifdef __CFM68K__#pragma lib_export on#endiftypedef char ADBAddress;/*		ADBCompletionProcPtr uses register based parameters on the 68k and cannot		be written in or called from a high-level language without the help of		mixed mode or assembly glue.		In:		 => dataBuffPtr 	A0.L		 => opDataAreaPtr	A2.L		 => command     	D0.L*/#if GENERATINGCFMtypedef UniversalProcPtr ADBCompletionUPP;#elsetypedef Register68kProcPtr ADBCompletionUPP;#endifenum {	uppADBCompletionProcInfo = kRegisterBased		 | REGISTER_ROUTINE_PARAMETER(1, kRegisterA0, SIZE_CODE(sizeof(Ptr)))		 | REGISTER_ROUTINE_PARAMETER(2, kRegisterA2, SIZE_CODE(sizeof(Ptr)))		 | REGISTER_ROUTINE_PARAMETER(3, kRegisterD0, SIZE_CODE(sizeof(long)))};#if GENERATINGCFM#define NewADBCompletionProc(userRoutine)		\		(ADBCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppADBCompletionProcInfo, GetCurrentArchitecture())#else#define NewADBCompletionProc(userRoutine)		\		((ADBCompletionUPP) (userRoutine))#endif#if GENERATINGCFM#define CallADBCompletionProc(userRoutine, dataBuffPtr, opDataAreaPtr, command)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppADBCompletionProcInfo, (dataBuffPtr), (opDataAreaPtr), (command))#else/* (*ADBCompletionProcPtr) cannot be called from a high-level language without the Mixed Mode Manager */#endif/*		ADBDeviceDriverProcPtr uses register based parameters on the 68k and cannot		be written in or called from a high-level language without the help of		mixed mode or assembly glue.		In:		 => devAddress  	D0.B		 => devType     	D1.B*/#if GENERATINGCFMtypedef UniversalProcPtr ADBDeviceDriverUPP;#elsetypedef Register68kProcPtr ADBDeviceDriverUPP;#endifenum {	uppADBDeviceDriverProcInfo = kRegisterBased		 | REGISTER_ROUTINE_PARAMETER(1, kRegisterD0, SIZE_CODE(sizeof(char)))		 | REGISTER_ROUTINE_PARAMETER(2, kRegisterD1, SIZE_CODE(sizeof(char)))};#if GENERATINGCFM#define NewADBDeviceDriverProc(userRoutine)		\		(ADBDeviceDriverUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppADBDeviceDriverProcInfo, GetCurrentArchitecture())#else#define NewADBDeviceDriverProc(userRoutine)		\		((ADBDeviceDriverUPP) (userRoutine))#endif#if GENERATINGCFM#define CallADBDeviceDriverProc(userRoutine, devAddress, devType)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppADBDeviceDriverProcInfo, (devAddress), (devType))#else/* (*ADBDeviceDriverProcPtr) cannot be called from a high-level language without the Mixed Mode Manager */#endif/*		ADBServiceRoutineProcPtr uses register based parameters on the 68k and cannot		be written in or called from a high-level language without the help of		mixed mode or assembly glue.		In:		 => dataBuffPtr 	A0.L		 => completionProc	A1.L		 => dataPtr     	A2.L		 => command     	D0.L*/#if GENERATINGCFMtypedef UniversalProcPtr ADBServiceRoutineUPP;#elsetypedef Register68kProcPtr ADBServiceRoutineUPP;#endifenum {	uppADBServiceRoutineProcInfo = kRegisterBased		 | REGISTER_ROUTINE_PARAMETER(1, kRegisterA0, SIZE_CODE(sizeof(Ptr)))		 | REGISTER_ROUTINE_PARAMETER(2, kRegisterA1, SIZE_CODE(sizeof(ADBCompletionUPP)))		 | REGISTER_ROUTINE_PARAMETER(3, kRegisterA2, SIZE_CODE(sizeof(Ptr)))		 | REGISTER_ROUTINE_PARAMETER(4, kRegisterD0, SIZE_CODE(sizeof(long)))};#if GENERATINGCFM#define NewADBServiceRoutineProc(userRoutine)		\		(ADBServiceRoutineUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppADBServiceRoutineProcInfo, GetCurrentArchitecture())#else#define NewADBServiceRoutineProc(userRoutine)		\		((ADBServiceRoutineUPP) (userRoutine))#endif#if GENERATINGCFM#define CallADBServiceRoutineProc(userRoutine, dataBuffPtr, completionProc, dataPtr, command)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppADBServiceRoutineProcInfo, (dataBuffPtr), (completionProc), (dataPtr), (command))#else/* (*ADBServiceRoutineProcPtr) cannot be called from a high-level language without the Mixed Mode Manager */#endif/*		ADBInitProcPtr uses register based parameters on the 68k and cannot		be written in or called from a high-level language without the help of		mixed mode or assembly glue.		In:		 => callOrder   	D0.B*/#if GENERATINGCFMtypedef UniversalProcPtr ADBInitUPP;#elsetypedef Register68kProcPtr ADBInitUPP;#endifenum {	uppADBInitProcInfo = kRegisterBased		 | REGISTER_ROUTINE_PARAMETER(1, kRegisterD0, SIZE_CODE(sizeof(char)))};#if GENERATINGCFM#define NewADBInitProc(userRoutine)		\		(ADBInitUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppADBInitProcInfo, GetCurrentArchitecture())#else#define NewADBInitProc(userRoutine)		\		((ADBInitUPP) (userRoutine))#endif#if GENERATINGCFM#define CallADBInitProc(userRoutine, callOrder)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppADBInitProcInfo, (callOrder))#else/* (*ADBInitProcPtr) cannot be called from a high-level language without the Mixed Mode Manager */#endifstruct ADBOpBlock {	Ptr								dataBuffPtr;				/* address of data buffer */	ADBServiceRoutineUPP			opServiceRtPtr;				/* service routine pointer */	Ptr								opDataAreaPtr;				/* optional data area address */};typedef struct ADBOpBlock ADBOpBlock;typedef ADBOpBlock *ADBOpBPtr;struct ADBDataBlock {	char							devType;					/* device type */	char							origADBAddr;				/* original ADB Address */	ADBServiceRoutineUPP			dbServiceRtPtr;				/* service routine pointer */	Ptr								dbDataAreaAddr;				/* data area address */};typedef struct ADBDataBlock ADBDataBlock;typedef ADBDataBlock *ADBDBlkPtr;struct ADBSetInfoBlock {	ADBServiceRoutineUPP			siService;					/* service routine pointer */	Ptr								siDataAreaAddr;				/* data area address */};typedef struct ADBSetInfoBlock ADBSetInfoBlock;typedef ADBSetInfoBlock *ADBSInfoPtr;extern pascal void ADBReInit(void) ONEWORDINLINE(0xA07B);extern pascal OSErr ADBOp(Ptr data, ADBCompletionUPP compRout, Ptr buffer, short commandNum);#if !GENERATINGCFM#pragma parameter __D0 CountADBs#endifextern pascal short CountADBs(void) ONEWORDINLINE(0xA077);#if !GENERATINGCFM#pragma parameter __D0 GetIndADB(__A0, __D0)#endifextern pascal ADBAddress GetIndADB(ADBDataBlock *info, short devTableIndex) ONEWORDINLINE(0xA078);#if !GENERATINGCFM#pragma parameter __D0 GetADBInfo(__A0, __D0)#endifextern pascal OSErr GetADBInfo(ADBDataBlock *info, ADBAddress adbAddr) ONEWORDINLINE(0xA079);#if !GENERATINGCFM#pragma parameter __D0 SetADBInfo(__A0, __D0)#endifextern pascal OSErr SetADBInfo(const ADBSetInfoBlock *info, ADBAddress adbAddr) ONEWORDINLINE(0xA07A);#ifdef __CFM68K__#pragma lib_export off#endif#if GENERATINGPOWERPC#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __DESKBUS__ */