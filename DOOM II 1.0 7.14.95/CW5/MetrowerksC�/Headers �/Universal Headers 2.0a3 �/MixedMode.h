/* 	File:		MixedMode.h  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __MIXEDMODE__#define __MIXEDMODE__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifdef __cplusplusextern "C" {#endif#if GENERATINGPOWERPC#pragma options align=mac68k#endif#ifdef __CFM68K__#pragma lib_export on#endifenum {	kRoutineDescriptorVersion	= 7};/* MixedModeMagic Magic Cookie/Trap number */enum {	_MixedModeMagic				= 0xAAFE};/* Calling Conventions */typedef unsigned short CallingConventionType;enum {	kPascalStackBased			= (CallingConventionType)0,	kCStackBased				= (CallingConventionType)1,	kRegisterBased				= (CallingConventionType)2,	kD0DispatchedPascalStackBased = (CallingConventionType)8,	kD1DispatchedPascalStackBased = (CallingConventionType)12,	kD0DispatchedCStackBased	= (CallingConventionType)9,	kStackDispatchedPascalStackBased = (CallingConventionType)14,	kThinkCStackBased			= (CallingConventionType)5};/* ISA Types */typedef SInt8 ISAType;enum {	kM68kISA					= (ISAType)0,	kPowerPCISA					= (ISAType)1};/* RTA Types */typedef SInt8 RTAType;enum {	kOld68kRTA					= (RTAType)(0 << 4),	kPowerPCRTA					= (RTAType)(0 << 4),	kCFM68kRTA					= (RTAType)(1 << 4)};#if GENERATINGPOWERPC#define GetCurrentISA() ((ISAType) kPowerPCISA)#define GetCurrentRTA() ((RTAType) kPowerPCRTA)#else#define GetCurrentISA() ((ISAType) kM68kISA)#if GENERATINGCFM#define GetCurrentRTA() ((RTAType) kCFM68kRTA)#else#define GetCurrentRTA() ((RTAType) kOld68kRTA)#endif#endif#define GetCurrentArchitecture() (GetCurrentISA() | GetCurrentRTA())enum {	kRegisterD0					= 0,	kRegisterD1					= 1,	kRegisterD2					= 2,	kRegisterD3					= 3,	kRegisterD4					= 8,	kRegisterD5					= 9,	kRegisterD6					= 10,	kRegisterD7					= 11,	kRegisterA0					= 4,	kRegisterA1					= 5,	kRegisterA2					= 6,	kRegisterA3					= 7,	kRegisterA4					= 12,	kRegisterA5					= 13,	kRegisterA6					= 14,/* A7 is the same as the PowerPC SP */	kCCRegisterCBit				= 16,	kCCRegisterVBit				= 17,	kCCRegisterZBit				= 18,	kCCRegisterNBit				= 19,	kCCRegisterXBit				= 20};typedef unsigned short registerSelectorType;/* SizeCodes we use everywhere */enum {	kNoByteCode					= 0,	kOneByteCode				= 1,	kTwoByteCode				= 2,	kFourByteCode				= 3};/* Mixed Mode Routine Records */typedef unsigned long ProcInfoType;/* Routine Flag Bits */typedef unsigned short RoutineFlagsType;enum {	kProcDescriptorIsAbsolute	= (RoutineFlagsType)0x00,	kProcDescriptorIsRelative	= (RoutineFlagsType)0x01};enum {	kFragmentIsPrepared			= (RoutineFlagsType)0x00,	kFragmentNeedsPreparing		= (RoutineFlagsType)0x02};enum {	kUseCurrentISA				= (RoutineFlagsType)0x00,	kUseNativeISA				= (RoutineFlagsType)0x04};enum {	kPassSelector				= (RoutineFlagsType)0x0,	kDontPassSelector			= (RoutineFlagsType)0x08};enum {	kRoutineIsNotDispatchedDefaultRoutine = (RoutineFlagsType)0x0,	kRoutineIsDispatchedDefaultRoutine = (RoutineFlagsType)0x10};struct RoutineRecord {	ProcInfoType					procInfo;					/* calling conventions */	SInt8							reserved1;					/* Must be 0 */	ISAType							ISA;						/* Instruction Set Architecture */	RoutineFlagsType				routineFlags;				/* Flags for each routine */	ProcPtr							procDescriptor;				/* Where is the thing weÕre calling? */	unsigned long					reserved2;					/* Must be 0 */	unsigned long					selector;					/* For dispatched routines, the selector */};typedef struct RoutineRecord RoutineRecord;typedef RoutineRecord *RoutineRecordPtr, **RoutineRecordHandle;/* Mixed Mode Routine Descriptors *//* Definitions of the Routine Descriptor Flag Bits */typedef UInt8 RDFlagsType;enum {	kSelectorsAreNotIndexable	= (RDFlagsType)0x00,	kSelectorsAreIndexable		= (RDFlagsType)0x01};/* Routine Descriptor Structure */struct RoutineDescriptor {	unsigned short					goMixedModeTrap;			/* Our A-Trap */	SInt8							version;					/* Current Routine Descriptor version */	RDFlagsType						routineDescriptorFlags;		/* Routine Descriptor Flags */	unsigned long					reserved1;					/* Unused, must be zero */	UInt8							reserved2;					/* Unused, must be zero */	UInt8							selectorInfo;				/* If a dispatched routine, calling convention, else 0 */	short							routineCount;				/* Number of routines in this RD */	RoutineRecord					routineRecords[1];			/* The individual routines */};typedef struct RoutineDescriptor RoutineDescriptor;typedef RoutineDescriptor *RoutineDescriptorPtr, **RoutineDescriptorHandle;#define BUILD_ROUTINE_DESCRIPTOR(procInfo, procedure)  \	{								\	_MixedModeMagic,				\	kRoutineDescriptorVersion,		\	kSelectorsAreNotIndexable,		\	0,								\	0,								\	0,								\	0,								\	{								\	{								\	(procInfo),					\	0,								\	GetCurrentArchitecture(), 	\	kProcDescriptorIsAbsolute |	 \	kFragmentIsPrepared |			\	kUseNativeISA,					\	(ProcPtr)(procedure),			\	0,								\	0,								\	},								\	},								\	}#define BUILD_FAT_ROUTINE_DESCRIPTOR(m68kProcInfo, m68kProcPtr, powerPCProcInfo, powerPCProcPtr)  \	{								\	_MixedModeMagic,				\	kRoutineDescriptorVersion,		\	kSelectorsAreNotIndexable,		\	0,								\	0,								\	0,								\	1,								\	{								\	{								\	(m68kProcInfo),				\	0,								\	kM68kISA |						\	kOld68kRTA,					\	kProcDescriptorIsAbsolute |	 \	kUseCurrentISA,				\	(ProcPtr)(m68kProcPtr),		\	0,								\	0,								\	},								\	{								\	(powerPCProcInfo),				\	0,								\	GetCurrentArchitecture(), 	\	kProcDescriptorIsAbsolute |	 \	kFragmentIsPrepared |			\	kUseCurrentISA,				\	(ProcPtr)(powerPCProcPtr),		\	0,								\	0,								\	},								\	},								\	}enum {/* Calling Convention Offsets */	kCallingConventionWidth		= 4,	kCallingConventionPhase		= 0,	kCallingConventionMask		= 0xF,/* Result Offsets */	kResultSizeWidth			= 2,	kResultSizePhase			= kCallingConventionWidth,	kResultSizeMask				= 0x30,/* Parameter offsets & widths */	kStackParameterWidth		= 2,	kStackParameterPhase		= (kCallingConventionWidth + kResultSizeWidth),	kStackParameterMask			= 0xFFFFFFC0,/* Register Result Location offsets & widths */	kRegisterResultLocationWidth = 5,	kRegisterResultLocationPhase = (kCallingConventionWidth + kResultSizeWidth),/* Register Parameter offsets & widths */	kRegisterParameterWidth		= 5,	kRegisterParameterPhase		= (kCallingConventionWidth + kResultSizeWidth + kRegisterResultLocationWidth),	kRegisterParameterSizePhase	= 0,	kRegisterParameterSizeWidth	= 2,	kRegisterParameterWhichPhase = kRegisterParameterSizeWidth,	kRegisterParameterWhichWidth = 3,/* Dispatched Stack Routine Selector offsets & widths */	kDispatchedSelectorSizeWidth = 2,	kDispatchedSelectorSizePhase = (kCallingConventionWidth + kResultSizeWidth),/* Dispatched Stack Routine Parameter offsets */	kDispatchedParameterPhase	= (kCallingConventionWidth + kResultSizeWidth + kDispatchedSelectorSizeWidth),/* Special Case offsets & widths */	kSpecialCaseSelectorWidth	= 6,	kSpecialCaseSelectorPhase	= kCallingConventionWidth,	kSpecialCaseSelectorMask	= 0x3F0,/* Component Manager Special Case offsets & widths */	kComponentMgrResultSizeWidth = 2,	kComponentMgrResultSizePhase = kCallingConventionWidth + kSpecialCaseSelectorWidth, /* 4 + 6 = 10 */	kComponentMgrParameterWidth	= 2,	kComponentMgrParameterPhase	= kComponentMgrResultSizePhase + kComponentMgrResultSizeWidth /* 10 + 2 = 12 */};#define SIZE_CODE(size) 		\	(((size) == 4) ? kFourByteCode : (((size) == 2) ? kTwoByteCode : (((size) == 1) ? kOneByteCode : 0)))#define RESULT_SIZE(sizeCode) 	\	((ProcInfoType)(sizeCode) << kResultSizePhase)#define STACK_ROUTINE_PARAMETER(whichParam, sizeCode)  \	((ProcInfoType)(sizeCode) << (kStackParameterPhase + (((whichParam) - 1) * kStackParameterWidth)))#define DISPATCHED_STACK_ROUTINE_PARAMETER(whichParam, sizeCode)  \	((ProcInfoType)(sizeCode) << (kDispatchedParameterPhase + (((whichParam) - 1) * kStackParameterWidth)))#define DISPATCHED_STACK_ROUTINE_SELECTOR_SIZE(sizeCode)  \	((ProcInfoType)(sizeCode) << kDispatchedSelectorSizePhase)#define REGISTER_RESULT_LOCATION(whichReg)  \	((ProcInfoType)(whichReg) << kRegisterResultLocationPhase)#define REGISTER_ROUTINE_PARAMETER(whichParam, whichReg, sizeCode)  \	((((ProcInfoType)(sizeCode) << kRegisterParameterSizePhase) | ((ProcInfoType)(whichReg) << kRegisterParameterWhichPhase)) <<  \	(kRegisterParameterPhase + (((whichParam) - 1) * kRegisterParameterWidth)))#define COMPONENT_MGR_RESULT_SIZE(sizeCode)  \	((ProcInfoType)(sizeCode) << kComponentMgrResultSizePhase)#define COMPONENT_MGR_PARAMETER(whichParam, sizeCode)  \	((ProcInfoType)(sizeCode) << (kComponentMgrParameterPhase + (((whichParam) - 1) * kComponentMgrParameterWidth)))#define SPECIAL_CASE_PROCINFO(specialCaseCode)  \	(kSpecialCase | ((ProcInfoType)(specialCaseCode) << 4))enum {	kSpecialCase				= (CallingConventionType)0x0000000F};enum {/* all of the special cases enumerated.  The selector field is 6 bits wide */	kSpecialCaseHighHook		= 0,	kSpecialCaseCaretHook		= 0,							/* same as kSpecialCaseHighHook */	kSpecialCaseEOLHook			= 1,	kSpecialCaseWidthHook		= 2,	kSpecialCaseTextWidthHook	= 2,							/* same as kSpecialCaseWidthHook */	kSpecialCaseNWidthHook		= 3,	kSpecialCaseDrawHook		= 4,	kSpecialCaseHitTestHook		= 5,	kSpecialCaseTEFindWord		= 6,	kSpecialCaseProtocolHandler	= 7,	kSpecialCaseSocketListener	= 8,	kSpecialCaseTERecalc		= 9,	kSpecialCaseTEDoText		= 10,	kSpecialCaseGNEFilterProc	= 11,	kSpecialCaseMBarHook		= 12,	kSpecialCaseComponentMgr	= 13};#if GENERATINGCFMextern pascal UniversalProcPtr NewRoutineDescriptor(ProcPtr theProc, ProcInfoType theProcInfo, ISAType theISA) TWOWORDINLINE(0x7000, 0xAA59);extern pascal void DisposeRoutineDescriptor(UniversalProcPtr theProcPtr) TWOWORDINLINE(0x7001, 0xAA59);extern pascal UniversalProcPtr NewFatRoutineDescriptor(ProcPtr theM68kProc, ProcPtr thePowerPCProc, ProcInfoType theProcInfo) TWOWORDINLINE(0x7002, 0xAA59);#else#define DisposeRoutineDescriptor(theProcPtr)#define NewRoutineDescriptor(theProc, theProcInfo, theISA) ((UniversalProcPtr)theProc)#endif#if CFMSYSTEMCALLSextern long CallUniversalProc(UniversalProcPtr theProcPtr, ProcInfoType procInfo, ...);extern long CallOSTrapUniversalProc(UniversalProcPtr theProcPtr, ProcInfoType procInfo, ...);#endif#ifdef __CFM68K__#pragma lib_export off#endif#if GENERATINGPOWERPC#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __MIXEDMODE__ */