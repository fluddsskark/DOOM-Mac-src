/* 	File:		ImageCompression.h  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __IMAGECOMPRESSION__#define __IMAGECOMPRESSION__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __QUICKDRAW__#include <Quickdraw.h>#endif/*	#include <MixedMode.h>										*//*	#include <QuickdrawText.h>									*/#ifndef __QDOFFSCREEN__#include <QDOffscreen.h>#endif/*	#include <Errors.h>											*/#ifndef __COMPONENTS__#include <Components.h>#endif#ifndef __WINDOWS__#include <Windows.h>#endif/*	#include <Memory.h>											*//*	#include <Events.h>											*//*		#include <OSUtils.h>									*//*	#include <Controls.h>										*//*		#include <Menus.h>										*/#ifndef __STANDARDFILE__#include <StandardFile.h>#endif/*	#include <Dialogs.h>										*//*		#include <TextEdit.h>									*//*	#include <Files.h>											*/#ifdef __cplusplusextern "C" {#endif#if GENERATINGPOWERPC#pragma options align=mac68k#endif#ifdef __CFM68K__#pragma lib_export on#endifstruct MatrixRecord {	Fixed							matrix[3][3];};typedef struct MatrixRecord MatrixRecord, *MatrixRecordPtr;struct FixedPoint {	Fixed							x;	Fixed							y;};typedef struct FixedPoint FixedPoint;struct FixedRect {	Fixed							left;	Fixed							top;	Fixed							right;	Fixed							bottom;};typedef struct FixedRect FixedRect;/* These are the bits that are set in the Component flags, and also in the codecInfo struct. */enum {	codecInfoDoes1				= (1L << 0),	codecInfoDoes2				= (1L << 1),	codecInfoDoes4				= (1L << 2),	codecInfoDoes8				= (1L << 3),	codecInfoDoes16				= (1L << 4),	codecInfoDoes32				= (1L << 5),	codecInfoDoesDither			= (1L << 6),	codecInfoDoesStretch		= (1L << 7),	codecInfoDoesShrink			= (1L << 8),	codecInfoDoesMask			= (1L << 9),	codecInfoDoesTemporal		= (1L << 10),	codecInfoDoesDouble			= (1L << 11),	codecInfoDoesQuad			= (1L << 12),	codecInfoDoesHalf			= (1L << 13),	codecInfoDoesQuarter		= (1L << 14),	codecInfoDoesRotate			= (1L << 15),	codecInfoDoesHorizFlip		= (1L << 16),	codecInfoDoesVertFlip		= (1L << 17),	codecInfoDoesSkew			= (1L << 18),	codecInfoDoesBlend			= (1L << 19),	codecInfoDoesWarp			= (1L << 20),	codecInfoDoesRecompress		= (1L << 21),	codecInfoDoesSpool			= (1L << 22),	codecInfoDoesRateConstrain	= (1L << 23)};enum {	codecInfoDepth1				= (1L << 0),	codecInfoDepth2				= (1L << 1),	codecInfoDepth4				= (1L << 2),	codecInfoDepth8				= (1L << 3),	codecInfoDepth16			= (1L << 4),	codecInfoDepth32			= (1L << 5),	codecInfoDepth24			= (1L << 6),	codecInfoDepth33			= (1L << 7),	codecInfoDepth34			= (1L << 8),	codecInfoDepth36			= (1L << 9),	codecInfoDepth40			= (1L << 10),	codecInfoStoresClut			= (1L << 11),	codecInfoDoesLossless		= (1L << 12),	codecInfoSequenceSensitive	= (1L << 13)};enum {	codecFlagUseImageBuffer		= (1L << 0),	codecFlagUseScreenBuffer	= (1L << 1),	codecFlagUpdatePrevious		= (1L << 2),	codecFlagNoScreenUpdate		= (1L << 3),	codecFlagWasCompressed		= (1L << 4),	codecFlagDontOffscreen		= (1L << 5),	codecFlagUpdatePreviousComp	= (1L << 6),	codecFlagForceKeyFrame		= (1L << 7),	codecFlagOnlyScreenUpdate	= (1L << 8),	codecFlagLiveGrab			= (1L << 9),	codecFlagDontUseNewImageBuffer = (1L << 10),	codecFlagInterlaceUpdate	= (1L << 11),	codecFlagCatchUpDiff		= (1L << 12),	codecFlagUsedNewImageBuffer	= (1L << 14),	codecFlagUsedImageBuffer	= (1L << 15)};enum {/* The minimum data size for spooling in or out data */	codecMinimumDataSize		= 32768};enum {	compressorComponentType		= 'imco',						/* the type for "Components" which compress images */	decompressorComponentType	= 'imdc'};typedef Component CompressorComponent;typedef Component DecompressorComponent;typedef Component CodecComponent;#define anyCodec ((CodecComponent)0)#define bestSpeedCodec ((CodecComponent)-1)#define bestFidelityCodec ((CodecComponent)-2)#define bestCompressionCodec ((CodecComponent)-3)typedef long CodecType;typedef unsigned short CodecFlags;typedef unsigned long CodecQ;enum {	codecLosslessQuality		= 0x400L,	codecMaxQuality				= 0x3ffL,	codecMinQuality				= 0x000L,	codecLowQuality				= 0x100L,	codecNormalQuality			= 0x200L,	codecHighQuality			= 0x300L};enum {	codecCompletionSource		= (1 << 0),						/* asynchronous codec is done with source data */	codecCompletionDest			= (1 << 1)						/* asynchronous codec is done with destination data */};enum {	codecProgressOpen			= 0,	codecProgressUpdatePercent	= 1,	codecProgressClose			= 2};typedef pascal OSErr (*ICMDataProcPtr)(Ptr *dataP, long bytesNeeded, long refcon);typedef pascal OSErr (*ICMFlushProcPtr)(Ptr data, long bytesAdded, long refcon);typedef pascal void (*ICMCompletionProcPtr)(OSErr result, short flags, long refcon);typedef pascal OSErr (*ICMProgressProcPtr)(short message, Fixed completeness, long refcon);typedef pascal void (*StdPixProcPtr)(PixMap *src, Rect *srcRect, MatrixRecord *matrix, short mode, RgnHandle mask, PixMap *matte, Rect *matteRect, short flags);typedef pascal void (*ICMAlignmentProcPtr)(Rect *rp, long refcon);#if GENERATINGCFMtypedef UniversalProcPtr ICMDataUPP;typedef UniversalProcPtr ICMFlushUPP;typedef UniversalProcPtr ICMCompletionUPP;typedef UniversalProcPtr ICMProgressUPP;typedef UniversalProcPtr StdPixUPP;typedef UniversalProcPtr ICMAlignmentUPP;#elsetypedef ICMDataProcPtr ICMDataUPP;typedef ICMFlushProcPtr ICMFlushUPP;typedef ICMCompletionProcPtr ICMCompletionUPP;typedef ICMProgressProcPtr ICMProgressUPP;typedef StdPixProcPtr StdPixUPP;typedef ICMAlignmentProcPtr ICMAlignmentUPP;#endiftypedef long ImageSequence;struct ICMProgressProcRecord {	ICMProgressUPP					progressProc;	long							progressRefCon;};typedef struct ICMProgressProcRecord ICMProgressProcRecord, *ICMProgressProcRecordPtr;struct ICMCompletionProcRecord {	ICMCompletionUPP				completionProc;	long							completionRefCon;};typedef struct ICMCompletionProcRecord ICMCompletionProcRecord, *ICMCompletionProcRecordPtr;struct ICMDataProcRecord {	ICMDataUPP						dataProc;	long							dataRefCon;};typedef struct ICMDataProcRecord ICMDataProcRecord, *ICMDataProcRecordPtr;struct ICMFlushProcRecord {	ICMFlushUPP						flushProc;	long							flushRefCon;};typedef struct ICMFlushProcRecord ICMFlushProcRecord, *ICMFlushProcRecordPtr;struct ICMAlignmentProcRecord {	ICMAlignmentUPP					alignmentProc;	long							alignmentRefCon;};typedef struct ICMAlignmentProcRecord ICMAlignmentProcRecord, *ICMAlignmentProcRecordPtr;struct DataRateParams {	long							dataRate;	long							dataOverrun;	long							frameDuration;	long							keyFrameRate;	CodecQ							minSpatialQuality;	CodecQ							minTemporalQuality;};typedef struct DataRateParams DataRateParams, *DataRateParamsPtr;struct ImageDescription {	long							idSize;						/* total size of ImageDescription including extra data ( CLUTs and other per sequence data */	CodecType						cType;						/* what kind of codec compressed this data */	long							resvd1;						/* reserved for Apple use */	short							resvd2;						/* reserved for Apple use */	short							dataRefIndex;				/* set to zero  */	short							version;					/* which version is this data */	short							revisionLevel;				/* what version of that codec did this */	long							vendor;						/* whose  codec compressed this data */	CodecQ							temporalQuality;			/* what was the temporal quality factor  */	CodecQ							spatialQuality;				/* what was the spatial quality factor */	short							width;						/* how many pixels wide is this data */	short							height;						/* how many pixels high is this data */	Fixed							hRes;						/* horizontal resolution */	Fixed							vRes;						/* vertical resolution */	long							dataSize;					/* if known, the size of data for this image descriptor */	short							frameCount;					/* number of frames this description applies to */	Str31							name;						/* name of codec ( in case not installed )  */	short							depth;						/* what depth is this data (1-32) or ( 33-40 grayscale ) */	short							clutID;						/* clut id or if 0 clut follows  or -1 if no clut */};typedef struct ImageDescription ImageDescription, *ImageDescriptionPtr, **ImageDescriptionHandle;struct CodecInfo {	Str31							typeName;					/* name of the codec type i.e.: 'Apple Image Compression' */	short							version;					/* version of the codec data that this codec knows about */	short							revisionLevel;				/* revision level of this codec i.e: 0x00010001 (1.0.1) */	long							vendor;						/* Maker of this codec i.e: 'appl' */	long							decompressFlags;			/* codecInfo flags for decompression capabilities */	long							compressFlags;				/* codecInfo flags for compression capabilities */	long							formatFlags;				/* codecInfo flags for compression format details */	UInt8							compressionAccuracy;		/* measure (1-255) of accuracy of this codec for compress (0 if unknown) */	UInt8							decompressionAccuracy;		/* measure (1-255) of accuracy of this codec for decompress (0 if unknown) */	unsigned short					compressionSpeed;			/* ( millisecs for compressing 320x240 on base mac II) (0 if unknown)  */	unsigned short					decompressionSpeed;			/* ( millisecs for decompressing 320x240 on mac II)(0 if unknown)  */	UInt8							compressionLevel;			/* measure (1-255) of compression level of this codec (0 if unknown)  */	UInt8							resvd;						/* pad */	short							minimumHeight;				/* minimum height of image (block size) */	short							minimumWidth;				/* minimum width of image (block size) */	short							decompressPipelineLatency;	/* in milliseconds ( for asynchronous codecs ) */	short							compressPipelineLatency;	/* in milliseconds ( for asynchronous codecs ) */	long							privateData;};typedef struct CodecInfo CodecInfo;struct CodecNameSpec {	CodecComponent					codec;	CodecType						cType;	Str31							typeName;	Handle							name;};typedef struct CodecNameSpec CodecNameSpec;struct CodecNameSpecList {	short							count;	CodecNameSpec					list[1];};typedef struct CodecNameSpecList CodecNameSpecList, *CodecNameSpecListPtr;enum {	defaultDither				= 0,	forceDither					= 1,	suppressDither				= 2,	useColorMatching			= 4};struct ICMFrameTimeRecord {	wide							value;						/* frame time*/	long							scale;						/* timescale of value/duration fields*/	void							*base;						/* timebase*/	long							duration;					/* duration frame is to be displayed (0 if unknown)*/	Fixed							rate;						/* rate of timebase relative to wall-time*/};typedef struct ICMFrameTimeRecord ICMFrameTimeRecord, *ICMFrameTimePtr;#if GENERATINGCFM#else#endifenum {	uppICMDataProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),	uppICMFlushProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),	uppICMCompletionProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),	uppICMProgressProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Fixed)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),	uppStdPixProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(PixMap*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Rect*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(MatrixRecord*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(RgnHandle)))		 | STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(PixMap*)))		 | STACK_ROUTINE_PARAMETER(7, SIZE_CODE(sizeof(Rect*)))		 | STACK_ROUTINE_PARAMETER(8, SIZE_CODE(sizeof(short))),	uppICMAlignmentProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Rect*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long)))};#if GENERATINGCFM#define NewICMDataProc(userRoutine)		\		(ICMDataUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppICMDataProcInfo, GetCurrentArchitecture())#define NewICMFlushProc(userRoutine)		\		(ICMFlushUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppICMFlushProcInfo, GetCurrentArchitecture())#define NewICMCompletionProc(userRoutine)		\		(ICMCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppICMCompletionProcInfo, GetCurrentArchitecture())#define NewICMProgressProc(userRoutine)		\		(ICMProgressUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppICMProgressProcInfo, GetCurrentArchitecture())#define NewStdPixProc(userRoutine)		\		(StdPixUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppStdPixProcInfo, GetCurrentArchitecture())#define NewICMAlignmentProc(userRoutine)		\		(ICMAlignmentUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppICMAlignmentProcInfo, GetCurrentArchitecture())#else#define NewICMDataProc(userRoutine)		\		((ICMDataUPP) (userRoutine))#define NewICMFlushProc(userRoutine)		\		((ICMFlushUPP) (userRoutine))#define NewICMCompletionProc(userRoutine)		\		((ICMCompletionUPP) (userRoutine))#define NewICMProgressProc(userRoutine)		\		((ICMProgressUPP) (userRoutine))#define NewStdPixProc(userRoutine)		\		((StdPixUPP) (userRoutine))#define NewICMAlignmentProc(userRoutine)		\		((ICMAlignmentUPP) (userRoutine))#endif#if GENERATINGCFM#define CallICMDataProc(userRoutine, dataP, bytesNeeded, refcon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppICMDataProcInfo, (dataP), (bytesNeeded), (refcon))#define CallICMFlushProc(userRoutine, data, bytesAdded, refcon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppICMFlushProcInfo, (data), (bytesAdded), (refcon))#define CallICMCompletionProc(userRoutine, result, flags, refcon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppICMCompletionProcInfo, (result), (flags), (refcon))#define CallICMProgressProc(userRoutine, message, completeness, refcon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppICMProgressProcInfo, (message), (completeness), (refcon))#define CallStdPixProc(userRoutine, src, srcRect, matrix, mode, mask, matte, matteRect, flags)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppStdPixProcInfo, (src), (srcRect), (matrix), (mode), (mask), (matte), (matteRect), (flags))#define CallICMAlignmentProc(userRoutine, rp, refcon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppICMAlignmentProcInfo, (rp), (refcon))#else#define CallICMDataProc(userRoutine, dataP, bytesNeeded, refcon)		\		(*(userRoutine))((dataP), (bytesNeeded), (refcon))#define CallICMFlushProc(userRoutine, data, bytesAdded, refcon)		\		(*(userRoutine))((data), (bytesAdded), (refcon))#define CallICMCompletionProc(userRoutine, result, flags, refcon)		\		(*(userRoutine))((result), (flags), (refcon))#define CallICMProgressProc(userRoutine, message, completeness, refcon)		\		(*(userRoutine))((message), (completeness), (refcon))#define CallStdPixProc(userRoutine, src, srcRect, matrix, mode, mask, matte, matteRect, flags)		\		(*(userRoutine))((src), (srcRect), (matrix), (mode), (mask), (matte), (matteRect), (flags))#define CallICMAlignmentProc(userRoutine, rp, refcon)		\		(*(userRoutine))((rp), (refcon))#endifextern pascal OSErr CodecManagerVersion(long *version) TWOWORDINLINE(0x7000, 0xAAA3);extern pascal OSErr GetCodecNameList(CodecNameSpecListPtr *list, short showAll) TWOWORDINLINE(0x7001, 0xAAA3);extern pascal OSErr DisposeCodecNameList(CodecNameSpecListPtr list) TWOWORDINLINE(0x700F, 0xAAA3);extern pascal OSErr GetCodecInfo(CodecInfo *info, CodecType cType, CodecComponent codec) TWOWORDINLINE(0x7003, 0xAAA3);extern pascal OSErr GetMaxCompressionSize(PixMapHandle src, const Rect *srcRect, short colorDepth, CodecQ quality, CodecType cType, CompressorComponent codec, long *size) TWOWORDINLINE(0x7004, 0xAAA3);extern pascal OSErr GetCompressionTime(PixMapHandle src, const Rect *srcRect, short colorDepth, CodecType cType, CompressorComponent codec, CodecQ *spatialQuality, CodecQ *temporalQuality, unsigned long *compressTime) TWOWORDINLINE(0x7005, 0xAAA3);extern pascal OSErr CompressImage(PixMapHandle src, const Rect *srcRect, CodecQ quality, CodecType cType, ImageDescriptionHandle desc, Ptr data) TWOWORDINLINE(0x7006, 0xAAA3);extern pascal OSErr FCompressImage(PixMapHandle src, const Rect *srcRect, short colorDepth, CodecQ quality, CodecType cType, CompressorComponent codec, CTabHandle clut, CodecFlags flags, long bufferSize, ICMFlushProcRecordPtr flushProc, ICMProgressProcRecordPtr progressProc, ImageDescriptionHandle desc, Ptr data) TWOWORDINLINE(0x7007, 0xAAA3);extern pascal OSErr DecompressImage(Ptr data, ImageDescriptionHandle desc, PixMapHandle dst, const Rect *srcRect, const Rect *dstRect, short mode, RgnHandle mask) TWOWORDINLINE(0x7008, 0xAAA3);extern pascal OSErr FDecompressImage(Ptr data, ImageDescriptionHandle desc, PixMapHandle dst, const Rect *srcRect, MatrixRecordPtr matrix, short mode, RgnHandle mask, PixMapHandle matte, const Rect *matteRect, CodecQ accuracy, DecompressorComponent codec, long bufferSize, ICMDataProcRecordPtr dataProc, ICMProgressProcRecordPtr progressProc) TWOWORDINLINE(0x7009, 0xAAA3);extern pascal OSErr CompressSequenceBegin(ImageSequence *seqID, PixMapHandle src, PixMapHandle prev, const Rect *srcRect, const Rect *prevRect, short colorDepth, CodecType cType, CompressorComponent codec, CodecQ spatialQuality, CodecQ temporalQuality, long keyFrameRate, CTabHandle clut, CodecFlags flags, ImageDescriptionHandle desc) TWOWORDINLINE(0x700A, 0xAAA3);extern pascal OSErr CompressSequenceFrame(ImageSequence seqID, PixMapHandle src, const Rect *srcRect, CodecFlags flags, Ptr data, long *dataSize, UInt8 *similarity, ICMCompletionProcRecordPtr asyncCompletionProc) TWOWORDINLINE(0x700B, 0xAAA3);extern pascal OSErr DecompressSequenceBegin(ImageSequence *seqID, ImageDescriptionHandle desc, CGrafPtr port, GDHandle gdh, const Rect *srcRect, MatrixRecordPtr matrix, short mode, RgnHandle mask, CodecFlags flags, CodecQ accuracy, DecompressorComponent codec) TWOWORDINLINE(0x700D, 0xAAA3);extern pascal OSErr DecompressSequenceBeginS(ImageSequence *seqID, ImageDescriptionHandle desc, Ptr data, long dataSize, CGrafPtr port, GDHandle gdh, const Rect *srcRect, MatrixRecordPtr matrix, short mode, RgnHandle mask, CodecFlags flags, CodecQ accuracy, DecompressorComponent codec) FOURWORDINLINE(0x203C, 0x30, 0x5D, 0xAAA3);extern pascal OSErr DecompressSequenceFrame(ImageSequence seqID, Ptr data, CodecFlags inFlags, CodecFlags *outFlags, ICMCompletionProcRecordPtr asyncCompletionProc) TWOWORDINLINE(0x700E, 0xAAA3);extern pascal OSErr DecompressSequenceFrameS(ImageSequence seqID, Ptr data, long dataSize, CodecFlags inFlags, CodecFlags *outFlags, ICMCompletionProcRecordPtr asyncCompletionProc) FOURWORDINLINE(0x203C, 0x16, 0x47, 0xAAA3);extern pascal OSErr DecompressSequenceFrameWhen(ImageSequence seqID, Ptr data, long dataSize, CodecFlags inFlags, CodecFlags *outFlags, ICMCompletionProcRecordPtr asyncCompletionProc, const ICMFrameTimeRecord *frameTime) FOURWORDINLINE(0x203C, 0x1A, 0x5E, 0xAAA3);extern pascal OSErr CDSequenceFlush(ImageSequence seqID) FOURWORDINLINE(0x203C, 0x4, 0x5F, 0xAAA3);extern pascal OSErr SetDSequenceMatrix(ImageSequence seqID, MatrixRecordPtr matrix) TWOWORDINLINE(0x7010, 0xAAA3);extern pascal OSErr SetDSequenceMatte(ImageSequence seqID, PixMapHandle matte, const Rect *matteRect) TWOWORDINLINE(0x7011, 0xAAA3);extern pascal OSErr SetDSequenceMask(ImageSequence seqID, RgnHandle mask) TWOWORDINLINE(0x7012, 0xAAA3);extern pascal OSErr SetDSequenceTransferMode(ImageSequence seqID, short mode, const RGBColor *opColor) TWOWORDINLINE(0x7013, 0xAAA3);extern pascal OSErr SetDSequenceDataProc(ImageSequence seqID, ICMDataProcRecordPtr dataProc, long bufferSize) TWOWORDINLINE(0x7014, 0xAAA3);extern pascal OSErr SetDSequenceAccuracy(ImageSequence seqID, CodecQ accuracy) TWOWORDINLINE(0x7034, 0xAAA3);extern pascal OSErr SetDSequenceSrcRect(ImageSequence seqID, const Rect *srcRect) TWOWORDINLINE(0x7035, 0xAAA3);extern pascal OSErr GetDSequenceImageBuffer(ImageSequence seqID, GWorldPtr *gworld) TWOWORDINLINE(0x7015, 0xAAA3);extern pascal OSErr GetDSequenceScreenBuffer(ImageSequence seqID, GWorldPtr *gworld) TWOWORDINLINE(0x7016, 0xAAA3);extern pascal OSErr SetCSequenceQuality(ImageSequence seqID, CodecQ spatialQuality, CodecQ temporalQuality) TWOWORDINLINE(0x7017, 0xAAA3);extern pascal OSErr SetCSequencePrev(ImageSequence seqID, PixMapHandle prev, const Rect *prevRect) TWOWORDINLINE(0x7018, 0xAAA3);extern pascal OSErr SetCSequenceFlushProc(ImageSequence seqID, ICMFlushProcRecordPtr flushProc, long bufferSize) TWOWORDINLINE(0x7033, 0xAAA3);extern pascal OSErr SetCSequenceKeyFrameRate(ImageSequence seqID, long keyframerate) TWOWORDINLINE(0x7036, 0xAAA3);extern pascal OSErr GetCSequenceKeyFrameRate(ImageSequence seqID, long *keyframerate) FOURWORDINLINE(0x203C, 0x8, 0x4B, 0xAAA3);extern pascal OSErr GetCSequencePrevBuffer(ImageSequence seqID, GWorldPtr *gworld) TWOWORDINLINE(0x7019, 0xAAA3);extern pascal OSErr CDSequenceBusy(ImageSequence seqID) TWOWORDINLINE(0x701A, 0xAAA3);extern pascal OSErr CDSequenceEnd(ImageSequence seqID) TWOWORDINLINE(0x701B, 0xAAA3);extern pascal OSErr GetCompressedImageSize(ImageDescriptionHandle desc, Ptr data, long bufferSize, ICMDataProcRecordPtr dataProc, long *dataSize) TWOWORDINLINE(0x701C, 0xAAA3);extern pascal OSErr GetSimilarity(PixMapHandle src, const Rect *srcRect, ImageDescriptionHandle desc, Ptr data, Fixed *similarity) TWOWORDINLINE(0x701D, 0xAAA3);extern pascal OSErr GetImageDescriptionCTable(ImageDescriptionHandle desc, CTabHandle *ctable) TWOWORDINLINE(0x701E, 0xAAA3);extern pascal OSErr SetImageDescriptionCTable(ImageDescriptionHandle desc, CTabHandle ctable) TWOWORDINLINE(0x701F, 0xAAA3);extern pascal OSErr GetImageDescriptionExtension(ImageDescriptionHandle desc, Handle *extension, long idType, long index) TWOWORDINLINE(0x7020, 0xAAA3);extern pascal OSErr SetImageDescriptionExtension(ImageDescriptionHandle desc, Handle extension, long idType) TWOWORDINLINE(0x7021, 0xAAA3);extern pascal OSErr RemoveImageDescriptionExtension(ImageDescription **desc, long idType, long index) FOURWORDINLINE(0x203C, 0xC, 0x3A, 0xAAA3);extern pascal OSErr CountImageDescriptionExtensionType(ImageDescription **desc, long idType, long *count) FOURWORDINLINE(0x203C, 0xC, 0x3B, 0xAAA3);extern pascal OSErr GetNextImageDescriptionExtensionType(ImageDescription **desc, long *idType) FOURWORDINLINE(0x203C, 0x8, 0x3C, 0xAAA3);extern pascal OSErr FindCodec(CodecType cType, CodecComponent specCodec, CompressorComponent *compressor, DecompressorComponent *decompressor) TWOWORDINLINE(0x7023, 0xAAA3);extern pascal OSErr CompressPicture(PicHandle srcPicture, PicHandle dstPicture, CodecQ quality, CodecType cType) TWOWORDINLINE(0x7024, 0xAAA3);extern pascal OSErr FCompressPicture(PicHandle srcPicture, PicHandle dstPicture, short colorDepth, CTabHandle clut, CodecQ quality, short doDither, short compressAgain, ICMProgressProcRecordPtr progressProc, CodecType cType, CompressorComponent codec) TWOWORDINLINE(0x7025, 0xAAA3);extern pascal OSErr CompressPictureFile(short srcRefNum, short dstRefNum, CodecQ quality, CodecType cType) TWOWORDINLINE(0x7026, 0xAAA3);extern pascal OSErr FCompressPictureFile(short srcRefNum, short dstRefNum, short colorDepth, CTabHandle clut, CodecQ quality, short doDither, short compressAgain, ICMProgressProcRecordPtr progressProc, CodecType cType, CompressorComponent codec) TWOWORDINLINE(0x7027, 0xAAA3);extern pascal OSErr GetPictureFileHeader(short refNum, Rect *frame, OpenCPicParams *header) TWOWORDINLINE(0x7028, 0xAAA3);extern pascal OSErr DrawPictureFile(short refNum, const Rect *frame, ICMProgressProcRecordPtr progressProc) TWOWORDINLINE(0x7029, 0xAAA3);extern pascal OSErr DrawTrimmedPicture(PicHandle srcPicture, const Rect *frame, RgnHandle trimMask, short doDither, ICMProgressProcRecordPtr progressProc) TWOWORDINLINE(0x702E, 0xAAA3);extern pascal OSErr DrawTrimmedPictureFile(short srcRefnum, const Rect *frame, RgnHandle trimMask, short doDither, ICMProgressProcRecordPtr progressProc) TWOWORDINLINE(0x702F, 0xAAA3);extern pascal OSErr MakeThumbnailFromPicture(PicHandle picture, short colorDepth, PicHandle thumbnail, ICMProgressProcRecordPtr progressProc) TWOWORDINLINE(0x702A, 0xAAA3);extern pascal OSErr MakeThumbnailFromPictureFile(short refNum, short colorDepth, PicHandle thumbnail, ICMProgressProcRecordPtr progressProc) TWOWORDINLINE(0x702B, 0xAAA3);extern pascal OSErr MakeThumbnailFromPixMap(PixMapHandle src, const Rect *srcRect, short colorDepth, PicHandle thumbnail, ICMProgressProcRecordPtr progressProc) TWOWORDINLINE(0x702C, 0xAAA3);extern pascal OSErr TrimImage(ImageDescriptionHandle desc, Ptr inData, long inBufferSize, ICMDataProcRecordPtr dataProc, Ptr outData, long outBufferSize, ICMFlushProcRecordPtr flushProc, Rect *trimRect, ICMProgressProcRecordPtr progressProc) TWOWORDINLINE(0x702D, 0xAAA3);extern pascal OSErr ConvertImage(ImageDescriptionHandle srcDD, Ptr srcData, short colorDepth, CTabHandle clut, CodecQ accuracy, CodecQ quality, CodecType cType, CodecComponent codec, ImageDescriptionHandle dstDD, Ptr dstData) TWOWORDINLINE(0x7030, 0xAAA3);extern pascal OSErr GetCompressedPixMapInfo(PixMapPtr pix, ImageDescriptionHandle *desc, Ptr *data, long *bufferSize, ICMDataProcRecord *dataProc, ICMProgressProcRecord *progressProc) TWOWORDINLINE(0x7037, 0xAAA3);extern pascal OSErr SetCompressedPixMapInfo(PixMapPtr pix, ImageDescriptionHandle desc, Ptr data, long bufferSize, ICMDataProcRecordPtr dataProc, ICMProgressProcRecordPtr progressProc) TWOWORDINLINE(0x7038, 0xAAA3);extern pascal void StdPix(PixMapPtr src, const Rect *srcRect, MatrixRecordPtr matrix, short mode, RgnHandle mask, PixMapPtr matte, const Rect *matteRect, short flags) TWOWORDINLINE(0x700C, 0xAAA3);extern pascal OSErr TransformRgn(MatrixRecordPtr matrix, RgnHandle rgn) TWOWORDINLINE(0x7039, 0xAAA3);/***********	preview stuff***********/extern pascal void SFGetFilePreview(Point where, ConstStr255Param prompt, FileFilterUPP fileFilter, short numTypes, SFTypeList typeList, DlgHookUPP dlgHook, SFReply *reply) TWOWORDINLINE(0x7041, 0xAAA3);extern pascal void SFPGetFilePreview(Point where, ConstStr255Param prompt, FileFilterUPP fileFilter, short numTypes, SFTypeList typeList, DlgHookUPP dlgHook, SFReply *reply, short dlgID, ModalFilterUPP filterProc) TWOWORDINLINE(0x7042, 0xAAA3);extern pascal void StandardGetFilePreview(FileFilterUPP fileFilter, short numTypes, SFTypeList typeList, StandardFileReply *reply) TWOWORDINLINE(0x7043, 0xAAA3);extern pascal void CustomGetFilePreview(FileFilterYDUPP fileFilter, short numTypes, SFTypeList typeList, StandardFileReply *reply, short dlgID, Point where, DlgHookYDUPP dlgHook, ModalFilterYDUPP filterProc, const short *activeList, ActivateYDUPP activateProc, void *yourDataPtr) TWOWORDINLINE(0x7044, 0xAAA3);extern pascal OSErr MakeFilePreview(short resRefNum, ICMProgressProcRecordPtr progress) TWOWORDINLINE(0x7045, 0xAAA3);extern pascal OSErr AddFilePreview(short resRefNum, OSType previewType, Handle previewData) TWOWORDINLINE(0x7046, 0xAAA3);enum {	sfpItemPreviewAreaUser		= 11,	sfpItemPreviewStaticText	= 12,	sfpItemPreviewDividerUser	= 13,	sfpItemCreatePreviewButton	= 14,	sfpItemShowPreviewButton	= 15};struct PreviewResourceRecord {	unsigned long					modDate;	short							version;	OSType							resType;	short							resID;};typedef struct PreviewResourceRecord PreviewResourceRecord, *PreviewResourcePtr, **PreviewResource;extern pascal void AlignScreenRect(Rect *rp, ICMAlignmentProcRecordPtr alignmentProc) FOURWORDINLINE(0x203C, 0x8, 0x4C, 0xAAA3);extern pascal void AlignWindow(WindowPtr wp, Boolean front, const Rect *alignmentRect, ICMAlignmentProcRecordPtr alignmentProc) FOURWORDINLINE(0x203C, 0xE, 0x4D, 0xAAA3);extern pascal void DragAlignedWindow(WindowPtr wp, Point startPt, Rect *boundsRect, Rect *alignmentRect, ICMAlignmentProcRecordPtr alignmentProc) FOURWORDINLINE(0x203C, 0x14, 0x4E, 0xAAA3);extern pascal long DragAlignedGrayRgn(RgnHandle theRgn, Point startPt, Rect *boundsRect, Rect *slopRect, short axis, UniversalProcPtr actionProc, Rect *alignmentRect, ICMAlignmentProcRecordPtr alignmentProc) FOURWORDINLINE(0x203C, 0x1E, 0x4F, 0xAAA3);extern pascal OSErr SetCSequenceDataRateParams(ImageSequence seqID, DataRateParamsPtr params) FOURWORDINLINE(0x203C, 0x8, 0x50, 0xAAA3);extern pascal OSErr SetCSequenceFrameNumber(ImageSequence seqID, long frameNumber) FOURWORDINLINE(0x203C, 0x8, 0x51, 0xAAA3);extern pascal QDErr NewImageGWorld(GWorldPtr *gworld, ImageDescriptionHandle idh, GWorldFlags flags) FOURWORDINLINE(0x203C, 0xC, 0x52, 0xAAA3);extern pascal OSErr GetCSequenceDataRateParams(ImageSequence seqID, DataRateParamsPtr params) FOURWORDINLINE(0x203C, 0x8, 0x53, 0xAAA3);extern pascal OSErr GetCSequenceFrameNumber(ImageSequence seqID, long *frameNumber) FOURWORDINLINE(0x203C, 0x8, 0x54, 0xAAA3);extern pascal OSErr GetBestDeviceRect(GDHandle *gdh, Rect *rp) FOURWORDINLINE(0x203C, 0x8, 0x55, 0xAAA3);extern pascal OSErr SetSequenceProgressProc(ImageSequence seqID, ICMProgressProcRecord *progressProc) FOURWORDINLINE(0x203C, 0x8, 0x56, 0xAAA3);extern pascal OSErr GDHasScale(GDHandle gdh, short depth, Fixed *scale) FOURWORDINLINE(0x203C, 0xA, 0x5A, 0xAAA3);extern pascal OSErr GDGetScale(GDHandle gdh, Fixed *scale, short *flags) FOURWORDINLINE(0x203C, 0xC, 0x5B, 0xAAA3);extern pascal OSErr GDSetScale(GDHandle gdh, Fixed scale, short flags) FOURWORDINLINE(0x203C, 0xA, 0x5C, 0xAAA3);extern pascal OSErr ICMShieldSequenceCursor(ImageSequence seqID) FOURWORDINLINE(0x203C, 0x4, 0x62, 0xAAA3);extern pascal void ICMDecompressComplete(ImageSequence seqID, OSErr err, short flag, ICMCompletionProcRecordPtr completionRtn) FOURWORDINLINE(0x203C, 0xC, 0x63, 0xAAA3);extern pascal OSErr SetDSequenceTimeCode(ImageSequence seqID, void *timeCodeFormat, void *timeCodeTime) FOURWORDINLINE(0x203C, 0xC, 0x64, 0xAAA3);enum {	identityMatrixType			= 0x00,							/* result if matrix is identity */	translateMatrixType			= 0x01,							/* result if matrix translates */	scaleMatrixType				= 0x02,							/* result if matrix scales */	scaleTranslateMatrixType	= 0x03,							/* result if matrix scales and translates */	linearMatrixType			= 0x04,							/* result if matrix is general 2 x 2 */	linearTranslateMatrixType	= 0x05,							/* result if matrix is general 2 x 2 and translates */	perspectiveMatrixType		= 0x06							/* result if matrix is general 3 x 3 */};typedef unsigned short MatrixFlags;extern pascal short GetMatrixType(const MatrixRecord *m) TWOWORDINLINE(0x7014, 0xABC2);extern pascal void CopyMatrix(const MatrixRecord *m1, MatrixRecord *m2) TWOWORDINLINE(0x7020, 0xABC2);extern pascal Boolean EqualMatrix(const MatrixRecord *m1, const MatrixRecord *m2) TWOWORDINLINE(0x7021, 0xABC2);extern pascal void SetIdentityMatrix(MatrixRecord *matrix) TWOWORDINLINE(0x7015, 0xABC2);extern pascal void TranslateMatrix(MatrixRecord *m, Fixed deltaH, Fixed deltaV) TWOWORDINLINE(0x7019, 0xABC2);extern pascal void RotateMatrix(MatrixRecord *m, Fixed degrees, Fixed aboutX, Fixed aboutY) TWOWORDINLINE(0x7016, 0xABC2);extern pascal void ScaleMatrix(MatrixRecord *m, Fixed scaleX, Fixed scaleY, Fixed aboutX, Fixed aboutY) TWOWORDINLINE(0x7017, 0xABC2);extern pascal void SkewMatrix(MatrixRecord *m, Fixed skewX, Fixed skewY, Fixed aboutX, Fixed aboutY) TWOWORDINLINE(0x7018, 0xABC2);extern pascal OSErr TransformFixedPoints(const MatrixRecord *m, FixedPoint *fpt, long count) TWOWORDINLINE(0x7022, 0xABC2);extern pascal OSErr TransformPoints(const MatrixRecord *mp, Point *pt1, long count) TWOWORDINLINE(0x7023, 0xABC2);extern pascal Boolean TransformFixedRect(const MatrixRecord *m, FixedRect *fr, FixedPoint *fpp) TWOWORDINLINE(0x7024, 0xABC2);extern pascal Boolean TransformRect(const MatrixRecord *m, Rect *r, FixedPoint *fpp) TWOWORDINLINE(0x7025, 0xABC2);extern pascal Boolean InverseMatrix(const MatrixRecord *m, MatrixRecord *im) TWOWORDINLINE(0x701C, 0xABC2);extern pascal void ConcatMatrix(const MatrixRecord *a, MatrixRecord *b) TWOWORDINLINE(0x701B, 0xABC2);extern pascal void RectMatrix(MatrixRecord *matrix, const Rect *srcRect, const Rect *dstRect) TWOWORDINLINE(0x701E, 0xABC2);extern pascal void MapMatrix(MatrixRecord *matrix, const Rect *fromRect, const Rect *toRect) TWOWORDINLINE(0x701D, 0xABC2);#ifdef __CFM68K__#pragma lib_export off#endif#if GENERATINGPOWERPC#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __IMAGECOMPRESSION__ */