/* 	File:		Events.h  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __EVENTS__#define __EVENTS__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __QUICKDRAW__#include <Quickdraw.h>#endif/*	#include <MixedMode.h>										*//*	#include <QuickdrawText.h>									*/#ifndef __OSUTILS__#include <OSUtils.h>#endif/*	#include <Memory.h>											*/#ifdef __cplusplusextern "C" {#endif#if GENERATINGPOWERPC#pragma options align=mac68k#endif#ifdef __CFM68K__#pragma lib_export on#endifenum {	nullEvent					= 0,	mouseDown					= 1,	mouseUp						= 2,	keyDown						= 3,	keyUp						= 4,	autoKey						= 5,	updateEvt					= 6,	diskEvt						= 7,	activateEvt					= 8,	osEvt						= 15,/* event mask equates */	mDownMask					= 0x0002,						/* mouse button pressed */	mUpMask						= 0x0004,						/* mouse button released */	keyDownMask					= 0x0008,						/* key pressed */	keyUpMask					= 0x0010,						/* key released */	autoKeyMask					= 0x0020,						/* key repeatedly held down */	updateMask					= 0x0040,						/* window needs updating */	diskMask					= 0x0080,						/* disk inserted */	activMask					= 0x0100,						/* activate/deactivate window */	highLevelEventMask			= 0x0400,						/* high-level events (includes AppleEvents) */	osMask						= 0x8000,						/* operating system events (suspend, resume) */	everyEvent					= 0xFFFF						/* all of the above */};enum {/* event message equates */	charCodeMask				= 0x000000FF,	keyCodeMask					= 0x0000FF00,	adbAddrMask					= 0x00FF0000,	osEvtMessageMask			= 0xFF000000L,/* OS event messages.  Event (sub)code is in the high byte of the message field. */	mouseMovedMessage			= 0x00FA,	suspendResumeMessage		= 0x0001,	resumeFlag					= 1,							/* Bit 0 of message indicates resume vs suspend */	convertClipboardFlag		= 2,							/* Bit 1 in resume message indicates clipboard change *//* modifiers */	activeFlag					= 0x0001,						/* Bit 0 of modifiers for activateEvt and mouseDown events */	btnState					= 0x0080,						/* Bit 7 of low byte is mouse button state */	cmdKey						= 0x0100,						/* Bit 0 of high byte */	shiftKey					= 0x0200,						/* Bit 1 of high byte */	alphaLock					= 0x0400,						/* Bit 2 of high byte */	optionKey					= 0x0800,						/* Bit 3 of high byte */	controlKey					= 0x1000,						/* Bit 4 of high byte *//* obsolete equates */	networkEvt					= 10,	driverEvt					= 11,	app1Evt						= 12,	app2Evt						= 13};enum {	app3Evt						= 14,	app4Evt						= 15,	networkMask					= 0x0400,	driverMask					= 0x0800,	app1Mask					= 0x1000,	app2Mask					= 0x2000,	app3Mask					= 0x4000,	app4Mask					= 0x8000};struct EventRecord {	short							what;	long							message;	long							when;	Point							where;	short							modifiers;};typedef struct EventRecord EventRecord;typedef long KeyMap[4];struct EvQEl {	QElemPtr						qLink;	short							qType;	short							evtQWhat;					/* this part is identical to the EventRecord as... */	long							evtQMessage;				/* defined in ToolIntf */	long							evtQWhen;	Point							evtQWhere;	short							evtQModifiers;};typedef struct EvQEl EvQEl;typedef EvQEl *EvQElPtr;typedef void (*GetNextEventFilterProcPtr)(EventRecord *theEvent, Boolean *result);#if GENERATINGCFMtypedef UniversalProcPtr GetNextEventFilterUPP;#elsetypedef Register68kProcPtr GetNextEventFilterUPP;#endifenum {	uppGetNextEventFilterProcInfo = SPECIAL_CASE_PROCINFO( kSpecialCaseGNEFilterProc )};#if GENERATINGCFM#define NewGetNextEventFilterProc(userRoutine)		\		(GetNextEventFilterUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppGetNextEventFilterProcInfo, GetCurrentArchitecture())#else#define NewGetNextEventFilterProc(userRoutine)		\		((GetNextEventFilterUPP) (userRoutine))#endif#if GENERATINGCFM#define CallGetNextEventFilterProc(userRoutine, theEvent, result)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppGetNextEventFilterProcInfo, (theEvent), (result))#else/* (*GetNextEventFilterProcPtr) cannot be called from a high-level language without the Mixed Mode Manager */#endiftypedef GetNextEventFilterUPP GNEFilterUPP;extern pascal long GetDblTime( void )	TWOWORDINLINE( 0x2EB8, 0x02F0 ); /* MOVE.L $02F0,(SP) */extern pascal long GetCaretTime( void )	TWOWORDINLINE( 0x2EB8, 0x02F4 ); /* MOVE.L $02F4,(SP) */extern pascal void SetEventMask( short value )	TWOWORDINLINE( 0x31DF, 0x0144 ); /* MOVE.W (SP)+,$0144 */extern pascal QHdrPtr LMGetEventQueue(void) THREEWORDINLINE(0x2EBC, 0x0000, 0x014A);extern pascal Boolean GetNextEvent(short eventMask, EventRecord *theEvent) ONEWORDINLINE(0xA970);extern pascal Boolean WaitNextEvent(short eventMask, EventRecord *theEvent, unsigned long sleep, RgnHandle mouseRgn) ONEWORDINLINE(0xA860);extern pascal Boolean EventAvail(short eventMask, EventRecord *theEvent) ONEWORDINLINE(0xA971);extern pascal void GetMouse(Point *mouseLoc) ONEWORDINLINE(0xA972);extern pascal Boolean Button(void) ONEWORDINLINE(0xA974);extern pascal Boolean StillDown(void) ONEWORDINLINE(0xA973);extern pascal Boolean WaitMouseUp(void) ONEWORDINLINE(0xA977);extern pascal void GetKeys(KeyMap theKeys) ONEWORDINLINE(0xA976);extern pascal long KeyTranslate(const void *transData, short keycode, long *state) ONEWORDINLINE(0xA9C3);extern pascal unsigned long TickCount(void) ONEWORDINLINE(0xA975);#if !GENERATINGCFM#pragma parameter __D0 PostEvent(__A0, __D0)#endifextern pascal OSErr PostEvent(short eventNum, long eventMsg) ONEWORDINLINE(0xA02F);#if !GENERATINGCFM#pragma parameter __D0 PPostEvent(__A0, __D0, __A1)#endifextern pascal OSErr PPostEvent(short eventCode, long eventMsg, EvQElPtr *qEl) TWOWORDINLINE(0xA12F, 0x2288);#if !GENERATINGCFM#pragma parameter __D0 OSEventAvail(__D0, __A0)#endifextern pascal Boolean OSEventAvail(short mask, EventRecord *theEvent) TWOWORDINLINE(0xA030, 0x5240);#if !GENERATINGCFM#pragma parameter __D0 GetOSEvent(__D0, __A0)#endifextern pascal Boolean GetOSEvent(short mask, EventRecord *theEvent) TWOWORDINLINE(0xA031, 0x5240);extern pascal void FlushEvents(short whichMask, short stopMask) TWOWORDINLINE(0x201F, 0xA032);extern pascal void SystemClick(const EventRecord *theEvent, WindowPtr theWindow) ONEWORDINLINE(0xA9B3);extern pascal void SystemTask(void) ONEWORDINLINE(0xA9B4);extern pascal Boolean SystemEvent(const EventRecord *theEvent) ONEWORDINLINE(0xA9B2);#if OLDROUTINENAMES#define KeyTrans(transData, keycode, state) KeyTranslate(transData, keycode, state)#define GetEvQHdr() LMGetEventQueue()#endif#ifdef __CFM68K__#pragma lib_export off#endif#if GENERATINGPOWERPC#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __EVENTS__ */