/* color layout library.c -- routines for applying colors to portions of layouts */#ifndef __MEMORY__#include <Memory.h>#endif#ifndef graphicsTypesIncludes#include "graphics types.h"#endif#ifndef graphicsRoutinesIncludes#include "graphics routines.h"#endif#ifndef layoutTypesIncludes#include "layout types.h"#endif#ifndef layoutRoutinesIncludes#include "layout routines.h"#endif#ifndef selectionLibraryIncludes#include "selection library.h"#endif#ifndef graphicsLibrariesIncludes#include "graphics libraries.h"#endif#ifndef colorLayoutLibraryIncludes#include "color layout library.h"#endif/* ----------------------------------------------------------------------------------------- *//* ExtractGlyphsFromSelection takes a layout shape and a Selection and returns a glyph		shape effectively containing only the glyphs present in the Selection. The other		glyphs have a textface added that prevents their being drawn. If the Selection		has any ranges that either start or end in the middle of a ligature glyph, the		rule is this: the whole ligature will be present if the numerically lowest offset		of the two offsets representing the ligature edges is present in the Selection. */#define bufSize 40gxShape ExtractGlyphsFromSelection(gxShape layout, SelectionHandle selection);gxShape ExtractGlyphsFromSelection(gxShape layout, SelectionHandle selection)	{	boolean					inAnIncludedRun = false;	gxShape					retShape = nil;	gxStyle					currentRunStyle, localStylesBuffer[bufSize], *pBaseStyles, *pStyles = nil;	gxTextFace			myFace;	long						nRuns;	SelectionOffset	maxOffset;	short						currentRunEndIndex = 0, currentRunStartIndex = 0, localRunsBuffer[bufSize],									nGlyphs, *pBaseRuns, *pRuns = nil, thisIndex;		/* Make a glyph shape that preserves the layout effects. */		maxOffset = GXGetLayout(layout, nil, nil, nil, nil, nil, nil, nil, nil, nil);	retShape = GXCopyToShape(nil, layout);	GXPrimitiveShape(retShape);		/* Walk the glyphs in this shape one by one, doing cumulations of the non-included			glyphs in order to set their textfaces. */		nGlyphs = (short) GXGetLayoutGlyphs(layout, nil, nil, nil, nil, &nRuns, nil, nil);	if (nRuns <= bufSize)		{		pStyles = pBaseStyles = localStylesBuffer;		pRuns = pBaseRuns = localRunsBuffer;		}	else		{		pStyles = pBaseStyles = (gxStyle *) NewPtr(nRuns * sizeof(gxStyle));		pRuns = pBaseRuns = (short *) NewPtr(nRuns * sizeof(short));		if (pStyles == nil || pRuns == nil)			{			if (pStyles != nil)				DisposePtr((Ptr) pStyles);			if (pRuns != nil)				DisposePtr((Ptr) pRuns);			GXDisposeShape(retShape);			return nil;			}		}			GXGetLayoutGlyphs(layout, nil, nil, nil, nil, nil, pRuns, pStyles);	currentRunStyle = (gxStyle) ((char *) *pStyles + 1);	/* force it to not match */		/* Initialize the textFace we'll be using. Note that we're relying on the value of			gxAnyNumber being 1, which is a bit of a cheat... */		myFace.faceLayers = 1;	ResetMapping(&myFace.advanceMapping);	myFace.faceLayer[0].outlineFill = gxWindingFill;	myFace.faceLayer[0].flags = gxWhiteLayer;	myFace.faceLayer[0].outlineStyle = nil;	myFace.faceLayer[0].outlineTransform = nil;	myFace.faceLayer[0].boldOutset.x = 0;	myFace.faceLayer[0].boldOutset.y = 0;		/* Begin the loop. */		for (thisIndex = 1; thisIndex <= nGlyphs; thisIndex += 1)		{		boolean					thisGlyphInSelection, wasReal;		gxByteOffset			leftOffset, rightOffset;		SelectionOffsetRange	myRange;				GXGetGlyphOffset(layout, thisIndex, true, &leftOffset, nil, &wasReal);				/* If this glyph does not correspond to any character in the original text (e.g. it's a				kashida glyph), we treat it as belonging to the glyph to its left, and therefore				it is part of this cumulation by definition. In this case, we continue the loop. */				if (!wasReal)			{			currentRunEndIndex = thisIndex;			if ((*pRuns -= 1) == 0)				{				pRuns += 1;				pStyles += 1;				}			continue;			}				GXGetGlyphOffset(layout, thisIndex, false, &rightOffset, nil, nil);				if (leftOffset < rightOffset)			{			myRange.minOffset = leftOffset;			myRange.maxOffset = rightOffset;			}		else			{			myRange.minOffset = rightOffset;			myRange.maxOffset = leftOffset;			}				if (myRange.minOffset == 0)			myRange.minOffset = selectionExtremeEdge;		if (myRange.maxOffset == maxOffset)			myRange.maxOffset = selectionExtremeEdge;				switch (RangeInSelection(selection, &myRange))			{			case notInSelection:				thisGlyphInSelection = false;				break;			case partlyInSelection:				{				boolean								is16Bit;				gxLayoutOffsetState		offsetState;								/* Here we have to handle the ligature edge case. In this case we look at the						first character comprising the ligature, and use its state to determine						the state for the whole ligature. */				if (leftOffset < rightOffset)					{					myRange.minOffset = leftOffset;					myRange.maxOffset = rightOffset;					}				else					{					myRange.minOffset = rightOffset;					myRange.maxOffset = leftOffset;					}				GXGetOffsetGlyphs(layout, myRange.minOffset, true, &offsetState, nil, nil);				offsetState &= ~gxOffsetInsideLigature;				is16Bit = (offsetState == gxOffset8_16 || offsetState == gxOffset16_16);				myRange.maxOffset = myRange.minOffset + (is16Bit ? 2 : 1);								if (myRange.minOffset == 0)					myRange.minOffset = selectionExtremeEdge;				if (myRange.maxOffset == maxOffset)					myRange.maxOffset = selectionExtremeEdge;								thisGlyphInSelection = (RangeInSelection(selection, &myRange) == fullyInSelection);				break;				}			case fullyInSelection:				thisGlyphInSelection = true;				break;			}	/* end switch */				if (*pStyles != currentRunStyle || thisGlyphInSelection != inAnIncludedRun)			{	/* dump previous cumulation */			if (currentRunStartIndex != 0 && !inAnIncludedRun)				{	/* regular case */				gxStyle		newStyle = GXCopyToStyle(nil, currentRunStyle);				short			runLength = currentRunEndIndex - currentRunStartIndex + 1;								/* We know the glyphs from currentRunStartIndex through currentRunEndIndex all						belong to the same style run, so we need only make a new style that has the						appropriate textFace, and set that style for those glyphs. */								GXSetStyleFace(newStyle, &myFace);				GXSetGlyphParts(retShape, currentRunStartIndex, runLength, runLength, nil, nil, nil, nil, &runLength, &newStyle);				GXDisposeStyle(newStyle);				}	/* end regular case */			currentRunStyle = *pStyles;			currentRunStartIndex = thisIndex;			inAnIncludedRun = thisGlyphInSelection;			}	/* end dump previous cumulation */				/* Do loop housekeeping and continue. */				currentRunEndIndex = thisIndex;		if ((*pRuns -= 1) == 0)			{			pRuns += 1;			pStyles += 1;			}		}	/* endloop thisIndex */		/* Check the final cumulation */		if (currentRunStartIndex != 0 && !inAnIncludedRun)		{	/* regular case */		gxStyle		newStyle = GXCopyToStyle(nil, currentRunStyle);		short			runLength = currentRunEndIndex - currentRunStartIndex + 1;				/* We know the glyphs from currentRunStartIndex through currentRunEndIndex all				belong to the same style run, so we need only make a new style that has the				appropriate textFace, and set that style for those glyphs. */				GXSetStyleFace(newStyle, &myFace);		GXSetGlyphParts(retShape, currentRunStartIndex, runLength, runLength, nil, nil, nil, nil, &runLength, &newStyle);		GXDisposeStyle(newStyle);		}	/* end regular case */		if (pBaseStyles != localStylesBuffer)		DisposePtr((Ptr) pBaseStyles);	if (pBaseRuns != localRunsBuffer)		DisposePtr((Ptr) pBaseRuns);		return retShape;	}	/* ExtractGlyphsFromSelection *//* ----------------------------------------------------------------------------------------- *//* ApplyInksToLayout takes a layout shape and an array of inks and returns a picture shape		which is a collection of glyph shapes such that the specified inks are applied to the		specified byte lengths in the original layout. */gxShape ApplyInksToLayout(	gxShape					layout,	long						inkRunCount,	const short			inkRunLengths[],	const gxInk			inks[])		{	gxInk							*pInk, *pInk2, *pUniqueInks = nil;	gxShape						retShape;	long							count, count2, uniqueCount = 0;	SelectionOffset		maxOffset;	short							*pLength, totalInkRunLength = 0;		/* Make sure the sum of the specified inkRunLengths equals the total byte length present			in the layout. */		pLength = (short *) inkRunLengths;	count = inkRunCount;		while (count--)		totalInkRunLength += *pLength++;		if (totalInkRunLength != GXGetLayout(layout, nil, nil, nil, nil, nil, nil, nil, nil, nil))		return nil;		/* Go through and build up an array containing the unique inks present in the inks[] list. */		if ((pUniqueInks = (gxInk *) NewPtr(inkRunCount * sizeof(gxInk))) == nil)	/* overestimate OK */		return nil;		pInk = (gxInk *) inks;	count = inkRunCount;		while (count--)		{		/* Search for this ink in the array we're building. */		pInk2 = pUniqueInks;		for (count2 = 0; count2 < uniqueCount; count2 += 1)			if (*pInk == *pInk2++)				break;		if (count2 == uniqueCount)			{			*pInk2 = *pInk;			uniqueCount += 1;			}		pInk += 1;		}		/* At this point, uniqueCount has the number of unique inks that were present in the input			inks array. This will be the same as the number of glyph shapes present in the final			picture. Now, for each ink in the unique array, we need to determine the group of			bytes covered. The selection library is of great help here. */		maxOffset = GXGetLayout(layout, nil, nil, nil, nil, nil, nil, nil, nil, nil);	retShape = GXNewShape(gxPictureType);	GXSetShapeAttributes(retShape, GXGetShapeAttributes(retShape) | gxUniqueItemsShape);		for (count = 0; count < uniqueCount; count += 1)		{		gxShape						thisGlyphShape;		SelectionHandle		workSelection = NewEmptySelection();		SelectionOffset		startOffset = 0;				for (count2 = 0; count2 < inkRunCount; count2 += 1)			{			if (pUniqueInks[count] == inks[count2])				{				SelectionHandle				newPiece;				SelectionOffsetRange	range;								range.minOffset = startOffset;				range.maxOffset = startOffset + inkRunLengths[count2];				if (range.minOffset == 0)					range.minOffset = selectionExtremeEdge;				if (range.maxOffset == maxOffset)					range.maxOffset = selectionExtremeEdge;				newPiece = NewRangeSelection(&range);				UnionSelection(workSelection, newPiece);				DisposeSelection(newPiece);				}			startOffset += inkRunLengths[count2];			}	/* endloop count2 */		thisGlyphShape = ExtractGlyphsFromSelection(layout, workSelection);		if (pUniqueInks[count] != nil)			GXSetShapeInk(thisGlyphShape, pUniqueInks[count]);		GXSetShapeTransform(thisGlyphShape, GXGetShapeTransform(layout));		AddToPicture(retShape, thisGlyphShape, nil, nil, nil);		GXDisposeShape(thisGlyphShape);		DisposeSelection(workSelection);		}	/* endloop count */		return retShape;	}	/* ApplyInksToLayout *//* ----------------------------------------------------------------------------------------- */gxShape NewLayoutWithInks(	long									textRunCount,	const short						textRunLengths[],	const void						*text[],	long									styleRunCount,	const short						styleRunLengths[],	const gxStyle					styles[],	long									levelRunCount,	const short						levelRunLengths[],	const short						levels[],	const gxLayoutOptions	*layoutOptions,	const gxPoint					*position,	gxShape								*newLayout,	long									inkRunCount,	const short						inkRunLengths[],	const gxInk						inks[])		{	*newLayout = GXNewLayout(textRunCount, textRunLengths, text, styleRunCount, styleRunLengths,		styles, levelRunCount, levelRunLengths, levels, layoutOptions, position);		return ApplyInksToLayout(*newLayout, inkRunCount, inkRunLengths, inks);	}	/* NewLayoutWithInks */