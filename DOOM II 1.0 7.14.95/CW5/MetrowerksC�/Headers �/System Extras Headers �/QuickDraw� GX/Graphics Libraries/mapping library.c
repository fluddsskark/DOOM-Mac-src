/* Mapping generation routines    by Cary Clark, Georgiann Delaney, Michael Fairman, Dave Good, Robert Johnson, Keith McGreggor, Oliver Steele, David Van Brink, Chris Yerga    Copyright 1987 - 1991 Apple Computer, Inc.  All rights reserved.    */#include "graphics libraries.h"static void PolyToPoint(const gxPolygon *poly, gxPoint *pt){    register Fixed x = fixed1, y = fixed1;    gxPoint pt1, pt2;    if (poly->vectors > 1)    {   pt1.x = poly->vector[1].x - poly->vector[0].x;        pt1.y = poly->vector[1].y - poly->vector[0].y;        y = Magnitude(pt1.x, pt1.y);        switch (poly->vectors)        {   case 2:            break;            case 3:                pt2.x = poly->vector[0].y - poly->vector[2].y;                pt2.y = poly->vector[2].x - poly->vector[0].x;            goto calcX;            default:                pt2.x = poly->vector[0].y - poly->vector[3].y;                pt2.y = poly->vector[3].x - poly->vector[0].x;            calcX:                x = VectorMultiplyDivide(2, &pt1.x, 1, &pt2.x, 1, y);            break;        }    }    pt->x = x;    pt->y = y;}static void Map1Pt(const gxPoint *source, Fixed *dest){    register Fixed *destPtr = dest;    register const gxPoint *srcPt = source;    *destPtr++ = fixed1;    *destPtr++ = 0;    *destPtr++ = 0;    *destPtr++ = 0;    *destPtr++ = fixed1;    *destPtr++ = 0;    *destPtr++ = srcPt[0].x;    *destPtr++ = srcPt[0].y;    *destPtr = fract1;}static void Map2Pt(const gxPoint *source, Fixed *dest, Fixed scale){    register Fixed *destPtr = dest;    register const gxPoint *srcPt = source;    *destPtr++ = FixedDivide(srcPt[1].y - srcPt[0].y, scale);    *destPtr++ = FixedDivide(srcPt[0].x - srcPt[1].x, scale);    *destPtr++ = 0;    *destPtr++ = FixedDivide(srcPt[1].x - srcPt[0].x, scale);    *destPtr++ = FixedDivide(srcPt[1].y - srcPt[0].y, scale);    *destPtr++ = 0;    *destPtr++ = srcPt[0].x;    *destPtr++ = srcPt[0].y;    *destPtr = fract1;}static void Map3Pt(const gxPoint *source, Fixed *dest, Fixed scaleX, Fixed scaleY){    register Fixed *destPtr = dest;    register const gxPoint *srcPt = source;    *destPtr++ = FixedDivide(srcPt[2].x - srcPt[0].x, scaleX);    *destPtr++ = FixedDivide(srcPt[2].y - srcPt[0].y, scaleX);    *destPtr++ = 0;    *destPtr++ = FixedDivide(srcPt[1].x - srcPt[0].x, scaleY);    *destPtr++ = FixedDivide(srcPt[1].y - srcPt[0].y, scaleY);    *destPtr++ = 0;    *destPtr++ = srcPt[0].x;    *destPtr++ = srcPt[0].y;    *destPtr = fract1;}static void Map4Pt(const gxPoint *source, Fixed *dest, Fixed scaleX, Fixed scaleY){    register Fixed *destPtr = dest;    register const gxPoint *srcPt = source;    fract a1, a2;    Fixed x0, y0, x1, y1, x2, y2;    x0 = srcPt[2].x - srcPt[0].x;    y0 = srcPt[2].y - srcPt[0].y;    x1 = srcPt[2].x - srcPt[1].x;    y1 = srcPt[2].y - srcPt[1].y;    x2 = srcPt[2].x - srcPt[3].x;    y2 = srcPt[2].y - srcPt[3].y;    /* check if abs(x2) > abs(y2) */    if ( x2 > 0 ? y2 > 0 ? x2 > y2 : x2 > -y2 : y2 > 0 ? -x2 > y2 : x2 < y2)        a1 = FractDivide(MultiplyDivide(x0 - x1, y2, x2) - y0 + y1, MultiplyDivide(x1, y2, x2) - y1);    else        a1 = FractDivide(x0 - x1 - MultiplyDivide(y0 - y1, x2, y2), x1 - MultiplyDivide(y1, x2, y2));    /* check if abs(x1) > abs(y1) */    if ( x1 > 0 ? y1 > 0 ? x1 > y1 : x1 > -y1 : y1 > 0 ? -x1 > y1 : x1 < y1)        a2 = FractDivide(y0 - y2 - MultiplyDivide(x0 - x2, y1, x1), y2 - MultiplyDivide(x2, y1, x1));    else        a2 = FractDivide(MultiplyDivide(y0 - y2, x1, y1) - x0 + x2, MultiplyDivide(y2, x1, y1) - x2);    *destPtr++ = FixedDivide(FractMultiply(a2, srcPt[3].x) + srcPt[3].x - srcPt[0].x, scaleX);    *destPtr++ = FixedDivide(FractMultiply(a2, srcPt[3].y) + srcPt[3].y - srcPt[0].y, scaleX);    *destPtr++ = FixedDivide(a2, scaleX);    *destPtr++ = FixedDivide(FractMultiply(a1, srcPt[1].x) + srcPt[1].x - srcPt[0].x, scaleY);    *destPtr++ = FixedDivide(FractMultiply(a1, srcPt[1].y) + srcPt[1].y - srcPt[0].y, scaleY);    *destPtr++ = FixedDivide(a1, scaleY);    *destPtr++ = srcPt[0].x;    *destPtr++ = srcPt[0].y;    *destPtr = fract1;}void PolyToPolyMap(const gxPolygon *source, const gxPolygon *dest, gxMapping *map){    gxPoint tempPt;    gxMapping tempMap;    long vectors = source->vectors;    if( vectors != dest->vectors && (vectors < 4 || dest->vectors < 4) ) {        GXPostGraphicsWarning(polygons_have_different_size_contours);        if (vectors > dest->vectors) vectors = dest->vectors;    }    PolyToPoint(source, &tempPt);    switch (vectors)    {   case 0:            ResetMapping(map);            break;        case 1:            Map1Pt(source->vector, &tempMap.map[0][0]);            InvertMapping(map, &tempMap);            Map1Pt(dest->vector, &tempMap.map[0][0]);            goto mapMap;        case 2:            Map2Pt(source->vector, &tempMap.map[0][0], tempPt.y);            InvertMapping(map, &tempMap);            Map2Pt(dest->vector, &tempMap.map[0][0], tempPt.y);            goto mapMap;        case 3:            Map3Pt(source->vector, &tempMap.map[0][0], tempPt.x, tempPt.y);            InvertMapping(map, &tempMap);            Map3Pt(dest->vector, &tempMap.map[0][0], tempPt.x, tempPt.y);            goto mapMap;        default:            Map4Pt(source->vector, &tempMap.map[0][0], tempPt.x, tempPt.y);            InvertMapping(map, &tempMap);            Map4Pt(dest->vector, &tempMap.map[0][0], tempPt.x, tempPt.y);        mapMap:            MapMapping(map, &tempMap);            break;    }}