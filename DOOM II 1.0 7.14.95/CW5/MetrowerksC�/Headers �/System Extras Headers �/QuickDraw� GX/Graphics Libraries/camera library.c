/* graphics libraries:    Perspective gxMapping generation routines    by Cary Clark, Georgiann Delaney, Michael Fairman, Dave Good, Robert Johnson, Keith McGreggor, Oliver Steele, David Van Brink, Chris Yerga    Copyright 1987 - 1991 Apple Computer, Inc.  All rights reserved.    */#include "graphics libraries.h"#include "camera library.h"void InitCamera(camera *obscura){    obscura->location.x = 0;    obscura->location.y = 0;    obscura->location.z = -IntToFixed(1440);    /* 20 inches backward */    obscura->axis.x = 0;    obscura->axis.y = 0;    obscura->axis.z = fixed1;             /* forward */    obscura->zenith.x = 0;    obscura->zenith.y = -fixed1;          /* up */    obscura->zenith.z = 0;    obscura->observer.x = 0;    obscura->observer.y = 0;    obscura->observer.z = -IntToFixed(1440);    /* 20 inches backward */    UpdateCamera(obscura);}void UpdateCamera(camera *obscura){    unit3D temp[2];    register unit3D *axis = temp;    register unit3D *zenith = axis + 1;    Unitize(&obscura->axis, axis);    {   register Fixed dot = FracDot((unit3D *)&obscura->zenith, axis);        zenith->x = obscura->zenith.x - FractMultiply(dot, axis->x);        zenith->y = obscura->zenith.y - FractMultiply(dot, axis->y);        zenith->z = obscura->zenith.z - FractMultiply(dot, axis->z);        Unitize((point3D *)zenith, zenith);    }    {   register unit3D *destPtr = (unit3D *)&obscura->orientation.map[0][0];        FracCross(axis, zenith, destPtr++);        *destPtr++ = *zenith;        *destPtr++ = *axis;    }    {   register Fixed *destPtr = &obscura->orientation.map[0][0];        register Fixed x = obscura->observer.x;        register Fixed y = obscura->observer.y;        register Fixed z = obscura->observer.z;        destPtr[0] = -FractMultiply(z, destPtr[0]) + FractMultiply(x, destPtr[6]);        destPtr[1] = -FractMultiply(z, destPtr[1]) + FractMultiply(x, destPtr[7]);        destPtr[2] = -FractMultiply(z, destPtr[2]) + FractMultiply(x, destPtr[8]);        destPtr[3] = FractMultiply(z, destPtr[3]) + FractMultiply(y, destPtr[6]);        destPtr[4] = FractMultiply(z, destPtr[4]) + FractMultiply(y, destPtr[7]);        destPtr[5] = FractMultiply(z, destPtr[5]) + FractMultiply(y, destPtr[8]);    }}void PatchToCameraMap(patch *quilt, camera *obscura, gxMapping *map){    register Fixed *destPtr = &map->map[0][0];    register Fixed *mapPtr = &obscura->orientation.map[0][0];    register Fixed *patchPtr;    point3D diff;    register Fixed dot;    diff.x = quilt->origin.x - obscura->location.x;    diff.y = quilt->origin.y - obscura->location.y;    diff.z = quilt->origin.z - obscura->location.z;    dot = FracDot((unit3D *)&diff, (unit3D *)&obscura->orientation.map[2][0]);    patchPtr = (Fixed *)quilt;    *destPtr++ = VectorMultiplyDivide(3, patchPtr, 1, mapPtr, 1, dot);    *destPtr++ = VectorMultiplyDivide(3, patchPtr, 1, mapPtr+3, 1, dot);    *destPtr++ = VectorMultiplyDivide(3, patchPtr, 1, mapPtr+6, 1, dot);    patchPtr += 3;    *destPtr++ = VectorMultiplyDivide(3, patchPtr, 1, mapPtr, 1, dot);    *destPtr++ = VectorMultiplyDivide(3, patchPtr, 1, mapPtr+3, 1, dot);    *destPtr++ = VectorMultiplyDivide(3, patchPtr, 1, mapPtr+6, 1, dot);    patchPtr = (Fixed *)&diff;    *destPtr++ = VectorMultiplyDivide(3, patchPtr, 1, mapPtr, 1, dot);    *destPtr++ = VectorMultiplyDivide(3, patchPtr, 1, mapPtr+3, 1, dot);    *destPtr = fract1;}Fixed Unitize(point3D *aPoint, unit3D *bPoint){    register Fixed r = Magnitude(Magnitude(aPoint->x, aPoint->y), aPoint->z);    if (bPoint)    {   bPoint->x = FractDivide(aPoint->x, r);        bPoint->y = FractDivide(aPoint->y, r);        bPoint->z = FractDivide(aPoint->z, r);    }    return r;}fract FracDot(unit3D *aPoint, unit3D *bPoint){    return FractMultiply(aPoint->x, bPoint->x) + FractMultiply(aPoint->y, bPoint->y) + FractMultiply(aPoint->z, bPoint->z);}void FracCross(unit3D *aPoint, unit3D *bPoint, unit3D *cPoint){    unit3D temp;    register fract *tempPtr = (fract *)&temp;    *tempPtr++ = FractMultiply(aPoint->y, bPoint->z) - FractMultiply(aPoint->z, bPoint->y);    *tempPtr++ = FractMultiply(aPoint->z, bPoint->x) - FractMultiply(aPoint->x, bPoint->z);    *tempPtr++ = FractMultiply(aPoint->x, bPoint->y) - FractMultiply(aPoint->y, bPoint->x);    *cPoint = temp;}