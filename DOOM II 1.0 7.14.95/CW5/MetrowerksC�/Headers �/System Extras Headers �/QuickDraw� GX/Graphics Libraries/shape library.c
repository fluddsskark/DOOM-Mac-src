/* graphics libraries:    gxShape library    by Cary Clark, Georgiann Delaney, Michael Fairman, Dave Good, Robert Johnson, Keith McGreggor, Oliver Steele, David Van Brink, Chris Yerga    Copyright 1987 - 1991 Apple Computer, Inc.  All rights reserved.    */    #include <Memory.h>#include "graphics libraries.h"gxShape NewPolygon(const gxPolygon *polyData){    gxShape sh;    NilParamReturnNil(polyData);    sh = GXNewShape(gxPolygonType);    SetPolygon(sh, 0, polyData);    return sh;}gxShape NewPath(const gxPath *pathData){    gxShape sh;    NilParamReturnNil(pathData);    sh = GXNewShape(gxPathType);    SetPath(sh, 0, pathData);    return sh;}gxPath *GetPath(gxShape source, long contour, register gxPath *pathData){    NilShapeReturnNil(source);    NilParamReturnNil(pathData);    {   register gxPaths *tempData;        long index = GXGetShapeIndex(source, contour, 1);        long points = GXCountShapePoints(source, contour);        long size = GXGetPathParts(source, index, points, nil);                tempData = (gxPaths *) NewPtr(size);        NilParamReturnNil(tempData);        GXGetPathParts(source, index, points, tempData);        BlockMove(&tempData->contour[0], pathData, size - sizeof(long));        DisposePtr((Ptr) tempData);        return pathData;    }}gxPolygon *GetPolygon(gxShape source, long contour, register gxPolygon *polygonData){    NilShapeReturnNil(source);    NilParamReturnNil(polygonData);    {   register gxPolygons *tempData;        long index = GXGetShapeIndex(source, contour, 1);        long points = GXCountShapePoints(source, contour);        long size = GXGetPolygonParts(source, index, points, nil);            tempData = (gxPolygons *) NewPtr(size);        NilParamReturnNil(tempData);        GXGetPolygonParts(source, index, points, tempData);        BlockMove(&tempData->contour[0], polygonData, size - sizeof(long));        DisposePtr((Ptr) tempData);        return polygonData;    }}void SetPolygon(gxShape source, long contour, register const gxPolygon *polygonData){    NilShapeReturn(source);    NilParamReturn(polygonData);    {   long size = (long) &((gxPolygons *) 0)->contour[0].vector[polygonData->vectors];        register gxPolygons *tempData;                tempData = (gxPolygons *) NewPtr(size);        NilParamReturn(tempData);        BlockMove(polygonData, &tempData->contour[0], size - sizeof(long));        tempData->contours = 1;        if( contour )            GXSetPolygonParts(source, GXGetShapeIndex(source, contour, 1), GXCountShapePoints(source, contour), tempData, 0);        else            GXSetPolygons(source, tempData);        DisposePtr((Ptr) tempData);    }}void SetPath(gxShape source, long contour, register const gxPath *pathData){    NilShapeReturn(source);    NilParamReturn(pathData);    {   long size = ((long) &((gxPaths *) 0)->contour[0].vector[pathData->vectors]) + pathData->vectors / 32 * sizeof(long);        register gxPaths *tempData;            tempData = (gxPaths *) NewPtr(size);        NilParamReturn(tempData);        BlockMove(pathData, &tempData->contour[0], size - sizeof(long));        tempData->contours = 1;        if( contour )            GXSetPathParts(source, GXGetShapeIndex(source, contour, 1), GXCountShapePoints(source, contour), tempData, 0);        else            GXSetPaths(source, tempData);        DisposePtr((Ptr) tempData);    }}void DrawPolygon(const gxPolygon *polyData, gxShapeFill fill){    gxShape sh;    NilParamReturn(polyData);    sh = NewPolygon(polyData);    GXSetShapeFill(sh, fill);    GXDrawShape(sh);    GXDisposeShape(sh);}void DrawPath(const gxPath *pathData, gxShapeFill fill){    gxShape sh;    NilParamReturn(pathData);    sh = NewPath(pathData);    GXSetShapeFill(sh, fill);    GXDrawShape(sh);    GXDisposeShape(sh);}void SetShapeIndexPoint(gxShape source, long index, const gxPoint *data){    GXSetShapePoints(source, index, 1, data);}gxPoint *GetShapeIndexPoint(gxShape source, long index, gxPoint *data){    GXGetShapePoints(source, index, 1, data);    return data;}void SetShapeIndexControl(gxShape source, long index, long control){    NilShapeReturn(source);    if( GXGetShapeType(source) == gxPathType )     {   long pathData[6];            GXGetPathParts(source, index, 1, (gxPaths *)pathData);        if( control )            pathData[2] = 0x80000000;        else            pathData[2] = 0x00000000;        GXSetPathParts(source, index, 1, (gxPaths *)pathData, 0);    } else        GXPostGraphicsWarning(graphic_type_does_not_contain_control_bits);}long GetShapeIndexControl(gxShape source, long index, long *control){    NilShapeReturnNil(source);    IfErrorReturnNil(index < 1 || index > GXCountShapePoints(source, 0), index_out_of_range);    {   gxShapeType theType = GXGetShapeType(source);        long result = 0;            switch( theType )        {            case gxPathType:            {                long pathData[6];                GXGetPathParts(source, index, 1, (gxPaths *)pathData);                if( pathData[2] )                    result = true;                break;            }            case gxGlyphType:            {                long bits;                GXGetGlyphPositions(source, index, 1, &bits, nil);                if( bits )                    result = true;                break;            }            case gxCurveType:                if( index == 2 )                    result = 1;        }            if( control )            *control = result;        return result;    }}void InsertShape(gxShape source, long index, gxShape toAdd){    GXSetShapeParts(source, index, 0, toAdd, gxBreakLeftEdit + gxBreakRightEdit + gxRemoveDuplicatePointsEdit);}gxShape ExtractShape(gxShape source, long firstPoint, long numPoints){    gxShape newShape;    newShape = GXGetShapeParts(source, firstPoint, numPoints, nil);    if( newShape )        GXSetShapeParts(source, firstPoint, numPoints, nil, gxRemoveDuplicatePointsEdit);    return newShape;}void AddToShape(gxShape dest, gxShape add){    GXSetShapeParts(dest, 0, 0, add, gxBreakLeftEdit);}void ExtendShape(gxShape dest, gxShape add){    GXSetShapeParts(dest, 0, 0, add, 0);}#ifdef debugginggxShape NewShape2(gxShapeType typeID, long arg1, long arg2){    IfWarningReturnNil(typeID != gxPointType, point_expected);    return NewShapeMany(typeID, arg1, arg2);}gxShape NewShape4(gxShapeType typeID, long arg1, long arg2, long arg3, long arg4){    IfWarningReturnNil(typeID != gxLineType && typeID != gxRectangleType, line_or_rectangle_expected);    return NewShapeMany(typeID, arg1, arg2, arg3, arg4);}gxShape NewShape6(gxShapeType typeID, long arg1, long arg2, long arg3, long arg4, long arg5, long arg6){    IfWarningReturnNil(typeID != gxCurveType, curve_expected);    return NewShapeMany(typeID, arg1, arg2, arg3, arg4, arg5, arg6);}void SetShape2(register gxShape dest, long arg1, long arg2){    IfWarningReturn(GXGetShapeType(dest) != gxPointType, point_expected);    SetShapeMany(dest, arg1, arg2);}void SetShape4(register gxShape dest, long arg1, long arg2, long arg3, long arg4){    register gxShapeType typeID;    NilShapeReturn(dest);    typeID = GXGetShapeType(dest);    IfWarningReturn(typeID != gxLineType && typeID != gxRectangleType, line_or_rectangle_expected);    SetShapeMany(dest, arg1, arg2, arg3, arg4);}void SetShape6(register gxShape dest, long arg1, long arg2, long arg3, long arg4, long arg5, long arg6){    register gxShapeType typeID;    NilShapeReturn(dest);    typeID = GXGetShapeType(dest);    IfWarningReturn(typeID != gxCurveType, curve_expected);    SetShapeMany(dest, arg1, arg2, arg3, arg4, arg5, arg6);}#endifgxShape NewShapeMany(gxShapeType type, Fixed arg1, ...){    return GXNewShapeVector(type, &arg1);}void SetShapeMany(gxShape sourceShape, Fixed arg1, ...){    NilShapeReturn(sourceShape);    GXSetShapeVector(sourceShape, &arg1);}void CenterShape(gxShape target, gxRectangle *container){    gxRectangle shapeBounds;        NilShapeReturn(target);    NilParamReturn(container);    GXGetShapeBounds(target, 0, &shapeBounds);    GXMoveShape(target,   ((container->left + container->right) - (shapeBounds.left + shapeBounds.right))/2,                    ((container->top + container->bottom) - (shapeBounds.top + shapeBounds.bottom))/2);}void MoveShapeCenterTo(gxShape target, Fixed x, Fixed y){    gxPoint centerPt;   gxShapeAttribute oldAttributes = 0;       NilShapeReturn(target);    GXGetShapeCenter(target, 0, &centerPt);    if (GXGetShapeType(target) == gxLayoutType && (oldAttributes = GXGetShapeAttributes(target)) & gxMapTransformShape)    	GXSetShapeAttributes(target, oldAttributes & ~gxMapTransformShape);    GXMoveShape(target, x - centerPt.x, y - centerPt.y);    if (oldAttributes & gxMapTransformShape)    	GXSetShapeAttributes(target, oldAttributes);}void RotateShapeAboutCenter(gxShape target, Fixed degrees){    gxPoint centerPt;    NilShapeReturn(target);    GXGetShapeCenter(target, 0, &centerPt);    GXRotateShape(target, degrees, centerPt.x, centerPt.y);}void SkewShapeAboutCenter(gxShape target, Fixed xSkew, Fixed ySkew){    gxPoint centerPt;    NilShapeReturn(target);    GXGetShapeCenter(target, 0, &centerPt);    GXSkewShape(target, xSkew, ySkew, centerPt.x, centerPt.y);}void ScaleShapeAboutCenter(gxShape target, Fixed hScale, Fixed vScale){    gxPoint centerPt;    NilShapeReturn(target);    GXGetShapeCenter(target, 0, &centerPt);    GXScaleShape(target, hScale, vScale, centerPt.x, centerPt.y);}void SetShapeOpenPath(gxShape target){    long contours, i, index;    NilShapeReturn(target);#ifdef debugging    GXIgnoreGraphicsNotice(type_already_set);#endif    GXSetShapeType(target, gxPathType);#ifdef debugging    GXPopGraphicsNotice();    GXIgnoreGraphicsNotice(parameters_have_no_effect);#endif    GXSetShapeFill(target, gxOpenFrameFill);#ifdef debugging    GXPopGraphicsNotice();#endif    contours = GXCountShapeContours(target);    index = 0;    for (i = 1; i <= contours; i++) {        long points = GXCountShapePoints(target,i);        if (points) {            SetShapeIndexControl(target,index += 1,false);            SetShapeIndexControl(target,index += points-1,false);        }    }}/*******************//* drawing operations          *//*******************/static void CommonPaint(gxShape s, commonColor c){    NilShapeReturn(s);#ifdef debugging        GXIgnoreGraphicsNotice(color_already_set);#endif    SetShapeCommonColor(s,c);#ifdef debugging        GXPopGraphicsNotice();#endif    GXDrawShape(s);    GXDisposeShape(s);}void PaintRectangle(const gxRectangle *r, commonColor c){    CommonPaint(GXNewRectangle(r),c);}void PaintRectangle2(const gxPoint *pt1, const gxPoint *pt2, commonColor c){    CommonPaint(NewShape4(gxRectangleType, pt1->x, pt1->y, pt2->x, pt2->y),c);}void PaintRectangle4(Fixed left, Fixed top, Fixed right, Fixed bottom, commonColor c){    CommonPaint(NewShape4(gxRectangleType, left, top, right, bottom),c);}/*******************//* operations on geometries *//*******************/void GetPathsIndexPointControl(const gxPaths *pathData, long index, gxPoint **pt, long **controlPtr, long *controlMask){    NilParamReturn(pathData);    {   register long *pathWalker = (long *) pathData;        register short contours = *pathWalker++;        register short vectors;            while (contours && index > (vectors = *pathWalker++)) {            pathWalker += (vectors + 31 >> 5) + (vectors << 1);            contours--;            index -= vectors;            }        if (contours) {            index--;            if (controlPtr)                *controlPtr = &pathWalker[index >> 5];             if (controlMask)                *controlMask = 0x80000000 >> (index & 31);            pathWalker += vectors + 31 >> 5;            if (pt)                *pt = (gxPoint *) (pathWalker + (index << 1));        } else            GXPostGraphicsWarning(index_out_of_range_in_contour);    }}/**************************//* Get/GXSetBitmapParts utility routines *//**************************/gxShape GetBitmapPartsFromFixedBounds(gxShape source, const gxRectangle *bounds){    gxLongRectangle pixelBounds;    pixelBounds.top = FixedRound(bounds->top);          /* use = ((bounds->top + 0x00007fff) >> 16) if you want to include */    pixelBounds.left = FixedRound(bounds->left);            /* pixels whose centers touch the bounding gxRectangle on the top */    pixelBounds.bottom = FixedRound(bounds->bottom);        /* (the same applies for left, as well) */    pixelBounds.right = FixedRound(bounds->right);    return (GXGetBitmapParts(source, &pixelBounds));}void SetBitmapPartsFromFixedBounds(gxShape target, const gxRectangle *bounds, gxShape bitmapShape){    gxLongRectangle pixelBounds;    pixelBounds.top = FixedRound(bounds->top);          /* use = ((bounds->top + 0x00007fff) >> 16) if you want to include */    pixelBounds.left = FixedRound(bounds->left);            /* pixels whose centers touch the bounding gxRectangle on the top */    pixelBounds.bottom = FixedRound(bounds->bottom);    pixelBounds.right = FixedRound(bounds->right);    GXSetBitmapParts(target, &pixelBounds, bitmapShape);}