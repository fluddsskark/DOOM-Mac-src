/* gxColor matching library    by Cary Clark, Georgiann Delaney, Michael Fairman, Dave Good, Josh Horwich, Robert Johnson, Keith McGreggor, Oliver Steele, David Van Brink, Chris Yerga    Copyright 1987 - 1993 Apple Computer, Inc.  All rights reserved.        The below code and data is an example, intended to illustrate Graphics functionality.    It is not part of the Graphics system provided as part of Macintosh System Software.    Apple Computer, Inc. provides no liability, explicit or implied, for applications using this example.    The Apple Developer Technical Support group is not able to support this example.        The numbers included in this library are not endorsements of the products described.    The numbers have not been extensively tested to ensure their accuracy.      */#include "CMApplication.h"#include <Memory.h>#include "graphics libraries.h"/* data for the QMS Colorscript 100 / Four-color ribbon */static XYZColor QMS_Chroma[8] = {     {0x799d,    0x8000, 0x8b12},	/* white        0.3138, 0.3310, 100.00   */    {0x0000,    0x0000, 0x0000},    /* black        0.3138, 0.3310,  0.01    */    {0x2165,    0x102b, 0x028f},    /* red      0.5507, 0.3225, 18.57    */    {0x06cf,    0x13de, 0x08bb},    /* green        0.2342, 0.4732, 20.09    */    {0x0464,    0x02ee, 0x0fc5},    /* blue     0.1864, 0.1718,  5.68    */    {0x1618,    0x1da2, 0x54d7},    /* cyan     0.1728, 0.2523, 30.92    */    {0x25bc,    0x12c7, 0x1471},    /* magenta  0.4145, 0.2521, 22.58    */    {0x60bb,    0x6e87, 0x0d12}    /* yellow       0.4381, 0.4664, 84.14    */};static gxColorValue QMS_Samples[] = {     11, 11, 11, 11, 11, 11, 11, 0, 0,     0x0000, 0x19c7, 0x3c50, 0x5b22, 0x7c9e, 0xa3c2, 0xcb07, 0xe957, 0xf9e7, 0xfff8, 0xffff,    0x0000, 0x224d, 0x4587, 0x630b, 0x81a2, 0xa52b, 0xca22, 0xe885, 0xfa15, 0xff75, 0xffff,    0x0000, 0x21de, 0x4580, 0x65a7, 0x8709, 0xab42, 0xce34, 0xe964, 0xf943, 0xffa3, 0xffff,    0x0000, 0x2765, 0x4d63, 0x6bd9, 0x8ab2, 0xad21, 0xceb0, 0xe871, 0xf7e1, 0xffeb, 0xffff,    0x0000, 0x1e21, 0x3e3b, 0x5c1b, 0x7d63, 0xa2d0, 0xc6ba, 0xe287, 0xf466, 0xff89, 0xffff,    0x0000, 0x1f9d, 0x4247, 0x5e4f, 0x7d9e, 0xa44c, 0xcbbf, 0xe9a5, 0xf971, 0xfff1, 0xffff,    0x0000, 0x1ea4, 0x3b71, 0x56e9, 0x7703, 0x9d4f, 0xc4a7, 0xe46c, 0xf616, 0xfb0e, 0xffff };gxColorProfile CreateQMSColorProfile(void){/* note that just allocating a CMProfileRecord on the stack is asking for trouble, as it is a variable-sized structure. *//* When one puts the response curves into the record, previous stack frames get blown away, and things rapidly go *//* south from there (usually when we try to return from this function). Instead, temporarily allocating the space in *//* the heap keeps things intact. */	CMProfilePtr theProfile = (CMProfilePtr) NewPtr(sizeof(CMHeader)+sizeof(CMProfileChromaticities) + sizeof(IString) + 172);	long theSize;	IString *theString;	gxColorProfile theResult;		if (!theProfile)		return nil;		/* not enough memory for the buffer. Just give back 'default' instead. */		theProfile->header.CMMType = 'appl';	theProfile->header.applProfileVersion = kCMApplProfileVersion;	theProfile->header.dataType = cmykData;	theProfile->header.deviceType = printerDevice;	theProfile->header.deviceManufacturer = 0L;	theProfile->header.deviceModel = 0;	theProfile->header.deviceAttributes[0] = 0;	theProfile->header.deviceAttributes[1] = 0;	theProfile->header.flags = 0;	theProfile->header.options = CMPerceptualMatch;		/* the following instruction is 'cheating' - I know that the colors are laid out as white, black, red, etc. */	/* in the ColorSync profile structure. */	BlockMove(QMS_Chroma, &theProfile->header.white, sizeof(XYZColor) * 8);		BlockMove(QMS_Samples, &theProfile->response, 172);		/* This is 'cheating' as well. I know how large the response curves are */		theSize = sizeof(CMHeader) + sizeof(CMProfileChromaticities) + 172;	theProfile->header.profileNameOffset = theSize;		theString = (IString *) ((char *) theProfile + theSize);	theString->theScript = 0;	theString->theString[0] = 0;	/* no name at all - length 0 */	theSize += sizeof(IString);	theProfile->header.size = theSize;	theProfile->header.customDataOffset = theSize;		/* there really isn't any custom data, however */		theResult = GXNewColorProfile(theSize, (void *) theProfile);	DisposePtr((Ptr) theProfile);	return (theResult);}/* data for the Canon BJ820 ... forthcoming... */gxColorProfile CreateCanonColorProfile(void){    return nil;     /* for now */}/* returns a gxColorProfile with the current ColorSync system profile. ColorSync system profile is selected using the ColorSync *//* control panel. *//* Note that this routine assumes that ColorSync is installed. *//* Also note that this routine could easily be modified to create a CMProfileHandle -> gxColorProfile converter. */gxColorProfile CreateColorSyncSystemProfile(void){	CMError theError;	CMProfileHandle theSystemProfile;	gxColorProfile result;	theError = GetProfile(qdSystemDevice, 0, nil, &theSystemProfile);		/* Get the ColorSync system profile. */	if (theError || !theSystemProfile)		return nil;				/* in case something went wrong, just give back the default profile. */	HLock((Handle) theSystemProfile);		/* just in case we were put into the system heap and GX moves things in there. */	result = GXNewColorProfile((*theSystemProfile)->header.size, *theSystemProfile);		DisposeHandle((Handle) theSystemProfile);	return result;}