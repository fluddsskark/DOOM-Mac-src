/* graphics libraries:	debug library routines	by Cary Clark, Georgiann Delaney, Michael Fairman, Dave Good, Robert Johnson, Keith McGreggor, Oliver Steele, David Van Brink, Chris Yerga	Copyright 1987 - 1991 Apple Computer, Inc.  All rights reserved.	*/#include <Types.h>#include <Memory.h>#include "graphics debugging.h"#include "graphics libraries.h"#include "graphics errors.h"#ifdef __powerc	#include <MixedMode.h>#endif/*** The spaces below allow this file to becompared in its engineering versionside by side with the fileÒgraphics errors.hÓ, to ensurethat the two files are kept in sync. These extra spaces may be removedfor the shipping version. */static char *errorText[] ={	"out of memory",	"internal fatal error",	"no outline font found",	"not enough memory for graphics client heap",	"could not create backing store",		nil,	"internal error",	"internal font error",	"internal layout error",	"fragmented memory",	/* posted internally only */	"could not dispose backing store",	"unflattening interrupted by client",		"font cannot be changed",	"illegal font parameter",		nil,	"null font scaler context",	"null font scaler input",	"invalid font scaler context",	"invalid font scaler input",	"invalid font scaler font data",	"font scaler newblock failed",	"font scaler getfonttable failed",	"font scaler bitmap allocation failed",	"font scaler outline allocation failed",	"required font scaler table missing",	"unsupported font scaler outline format",	"unsupported font scaler stream format",	"unsupported font scaler font format",	"font scaler hinting error",	"font scaler rasterizer error",	"font scaler internal error",	"font scaler invalid matrix",	"font scaler fixed overflow",	"font scaler api version mismatch",	"font scaler streaming aborted",	"unknown font scaler error",	nil,	"parameter is nil",	"shape is nil",	"style is nil",	"transform is nil",	"ink is nil",	"transfer mode is nil",	"color is nil",	"color profile is nil",	"color set is nil",	"'spool procedure' is nil",	"tag is nil",	"type is nil",	"mapping is nil",	"invalid view device reference",	"invalid view group reference",	"invalid view port reference",		nil,	"number of contours exceeds implementation limit",	"number of points exceeds implementation limit",	"size of polygon exceeds implementation limit",	"size of path exceeds implementation limit",	"size of text exceeds implementation limit",	"size of bitmap exceeds implementation limit",	"number of colors exceeds implementation limit",	"procedure not reentrant",		/* the following errors are posted by the debuggging init only */	nil,		"functionality unimplemented",	"clip to frame shape unimplemented",	"illegal font storage type",	"illegal font storage reference",	"illegal font attributes",			"parameter out of range",	"inconsistent parameters",	"index is less than zero",	"index is less than one",	"count is less than zero",	"count is less than one",	"contour is less than zero",	"length is less than zero",		"invalid client reference",	"invalid graphics heap start pointer",	"invalid nongraphic globals pointer",		"color space out of range",		"pattern lattice out of range",	"frequency parameter out of range",	"tinting parameter out of range",	"method parameter out of range",	"space may not be indexed",		"glyph index too small",	"no glyphs added to font",	"glyph not added to font",	"point does not intersect bitmap",		"required font table not present",	"unknown font table format",		"shape fill not allowed",	"inverse fill face must set 'clip layer' flag",	"invalid transfer mode color space",	"color profile must be nil",	"bitmap pixel size must be 1",	"empty shape not allowed",	"'ignore platform shape' not allowed",	"nil style in glyph not allowed",	"complex glyph style not allowed",	"invalid mapping",		"cannot set item shapes to nil",	"cannot use original item shapes when growing picture",	"cannot add unspecified new glyphs",	"cannot dispose locked tag",	"cannot dispose locked shape",		"shape access not allowed",	"color set access restricted",	"color profile access restricted",	"tag access restricted",	"view device access restricted",	"graphic type does not have a structure",	"style run array does not match number of characters",	"rectangles cannot be inserted into",		"unknown graphics heap",	"graphics routine selector is obsolete",	"cannot set graphics client memory without setting size",	"graphics client memory too small",	"graphics client memory is already allocated",		"view port is a window",			"illegal type for shape",	"shape does not contain a bitmap",	"shape does not contain text",	"picture expected",	"bitmap is not resizable",	"shape may not be a bitmap",	"shape may not be a picture",	"graphic type does not contain points",	"graphic type does not have multiple contours",	"graphic type cannot be mapped",	"graphic type cannot be moved",	"graphic type cannot be scaled",	"graphic type cannot be rotated",	"graphic type cannot be skewed",	"graphic type cannot be reset",	"graphic type cannot be dashed",	"graphic type cannot be reduced",	"graphic type cannot be inset",	"shape cannot be inverted",	"shape does not have area",	"shape does not have length",	"first glyph advance must be absolute",	"picture cannot contain itself",	"view port cannot contain itself",	"cannot set unique items attribute when picture contains items",	"layer style cannot contain a face",	"layer glyph shape cannot contain nil styles",		"object wrong type",	"shape wrong type",	"style wrong type",	"ink wrong type",	"transform wrong type",	"device wrong type",	"port wrong type",		"shape cache wrong type",	"style cache wrong type",	"ink cache wrong type",	"transform cache wrong type",	"port cache wrong type",	"shape cache parent mismatch",	"style cache parent mismatch",	"ink cache parent mismatch",	"transform cache parent mismatch",	"port cache parent mismatch",	"invalid shape cache port",	"invalid shape cache device",	"invalid ink cache port",	"invalid ink cache device",	"invalid style cache port",	"invalid style cache device",	"invalid transform cache port",	"invalid transform cache device",	"recursive caches",		"invalid 'fill shape' owner count",	"recursive 'fill shapes'",	"indirect memory block too small",	"indirect memory block too large",	"unexpected nil pointer",	"bad address",	"no owners",	"invalid pointer",	"invalid seed",	"invalid frame seed",	"invalid text seed",	"invalid draw seed",	"bad private flags",	"invalid vector count",	"invalid contour count",	"bitmap ptr too small",	"bitmap ptr not aligned",	"bitmap row bytes negative",	"bitmap width negative",	"bitmap height negative",	"invalid pixel size",	"bitmap row bytes too small",	"bitmap row bytes not aligned",	"bitmap row bytes must be specified for user image buffer",	"invalid bit image file offset",	"invalid bit image owners",	"invalid bit image row bytes",	"invalid bit image internal flag",	"text bounds cache wrong size",	"text metrics cache wrong size",	"text index cache wrong size",	"glyph run count negative",	"glyph run count zero",	"glyph run counts do not sum to character count",	"glyph first advance bit set not allowed",	"glyph tangent vectors both zero",	"layout run length negative",	"layout run length zero",	"layout run level negative",	"layout run lengths do not sum to text length",	"bad shape in picture",	"bad style in picture",	"bad ink in picture",	"bad transform in picture",	"bad shape cache in picture",	"bad seed in picture",	"invalid picture count",	"bad 'text layer' count",	"bad shape fill in text face",	"bad style in text face",	"bad transform in text face",	"invalid matrix flag",	"transform clip missing",	"metrics wrong type",	"metrics point size probably bad",	"scalar block wrong type",	"scalar block parent mismatch",	"scalar block too small",	"scalar block too large",	"invalid metrics range",	"invalid metrics flags",	"metrics 'max width' probably bad",	"font wrong type",	"font wrong size",	"invalid font platform",	"invalid lookup range",	"invalid lookup platform",	"font not in font list",	"metrics not in metrics list",	"bad device private flags",	"bad device attributes",	"invalid device number",	"invalid device view group",	"invalid device bounds",	"invalid bitmap in device",	"color set wrong type",	"invalid color set view device owners",	"invalid color set color space",	"invalid color set count",	"color profile wrong type",	"invalid color profile flags",	"invalid color profile response count",	"backing free parent mismatch",	"backing store parent mismatch",					/* library errors */		nil,	"common colors not initialized",	"no open picture",	"picture already open",	"no open poly",	"poly already open",	"no open region",	"region already open",	"no active picture"};static char *warningText[] ={	"warning stack underflow",	"warning stack overflow",	"notice stack underflow",	"notice stack overflow",	"about to grow heap",	"about to unload objects",		nil,	"map shape out of range",	"move shape out of range",	"scale shape out of range",	"rotate shape out of range",	"skew shape out of range",	"map transform out of range",	"move transform out of range",	"scale transform out of range",	"rotate transform out of range",	"skew transform out of range",	"map points out of range",		nil,	"contour out of range",	"index out of range in contour",	"picture index out of range",	"color index requested not found",	"color set index out of range",	"index out of range",	"count out of range",	"length out of range",	"font table index out of range",	"font glyph index out of range",	"point out of range",	"profile response out of range",		nil,	"font scaler no output",	"font scaler fake metrics",	"font scaler fake linespacing",	"font scaler glyph substitution",	"font scaler no kerning applied",		"character substitution took place",	"unable to get bounds on multiple devices",	"font language not found",	"font not found during unflattening",		"unrecognized stream version",	"bad data in stream",			/* debugging init only */	nil,	"new shape contains invalid data",	"new tag contains invalid data",	"extra data passed was ignored",	"font table not found",	"font name not found",			"unable to traverse open contour that starts or ends off th",	"unable to draw open contour that starts or ends off the cu",	"cannot dispose default shape",	"cannot dispose default style",	"cannot dispose default ink",	"cannot dispose default transform",	"cannot dispose default color profile",	"cannot dispose default color set",	"shape direct attribute not set",			"point does not intersect port",	"cannot dispose non font",	"face override style font must match style",		"union of area and length returns area only",	"insufficient coordinate space for new device",		"shape passed has no bounds",	"tags of type flst removed",	"translator not installed on this grafport",	/* library warnings */	nil,	"no picture drawn",	"polygons have different size contours",	"graphic type cannot be specifed by four values",	"graphic type cannot be specifed by six values",	"point expected",	"line or rectangle expected",	"curve expected",	"graphic type does not contain control bits",	"request exceeds available data",	"extra data unread",	"no variable length user data saved"};static char *noticeText[] ={	"parameters have no effect",	"attributes already set",	"caps already set",	"clip already set",	"color already set",	"curve error already set",	"dash already set",	"default color profile already set",	"default ink already set",	"default transform already set",	"default shape already set",	"default style already set",	"dither already set",	"encoding already set",	"face already set",	"fill already set",	"font already set",	"font variations already set",	"glyph positions are already set",	"glyph tangents are already set",	"halftone already set",	"hit test already set",	"ink already set",	"join already set",	"justification already set",	"mapping already set",	"pattern already set",	"pen already set",	"style already set",	"tag already set",	"text attributes already set",	"text size already set",	"transfer already set",	"translator already installed on this grafport",	"transform already set",	"type already set",	"validation level already set",	"view ports already set",	"view port already in view group",	"view device already in view group",		"geometry unaffected",	"mapping unaffected",	"tags in shape ignored",	"shape already in primitive form",	"shape already in simple form",	"shape already broken",	"shape already joined",	"cache already cleared",		"shape not disposed",	"style not disposed",	"ink not disposed",	"transform not disposed",	"color set not disposed",	"color profile not disposed",	"font not disposed",		"glyph tangents have no effect",	"glyph positions determined by advance",	"transform view ports already set",		"'direct shape' attribute set as side effect",	"'lock shape' called as side effect",	"'lock tag' called as side effect",	"shapes unlocked as side effect",	"shape not locked",	"tag not locked",		"disposed dead caches",	"disposed live caches",	"low on memory",	"very low on memory",		"transform references disposed view port",	/* library notice */	nil,	"zero length string passed"};	#define errorTextSize	(sizeof(errorText)/sizeof(*errorText))	#define warningTextSize (sizeof(warningText)/sizeof(*warningText))	#define noticeTextSize	(sizeof(noticeText)/sizeof(*noticeText))struct debugLibraryGlobals{	char		**errorMessages;	char		**warningMessages;	char		**noticeMessages;	char		*fatalErrorMessage;	char		*errorMessage;	char		*validationMessage;	char		*warningMessage;	char		*noticeMessage;	char		*undefinedMessage;	gxUserErrorFunction		originalErrorFunction;	long					originalErrorReference;	gxUserWarningFunction	originalWarningFunction;	long					originalWarningReference;	gxUserNoticeFunction	originalNoticeFunction;	long					originalNoticeReference;};typedef struct debugLibraryGlobals debugLibraryGlobals;static debugLibraryGlobals messages = { errorText,								warningText, 								noticeText,								"FATAL GRAPHICS ERROR: ",								"GRAPHICS ERROR: ",								"VALIDATION ERROR: ",								"GRAPHICS WARNING: ",								"GRAPHICS NOTICE: ",								"ID = $xxxx (undefined)" };#define undefinedHexOffset 6	/* offset to "xxxx" above */#ifndef __powerc	#define UserFunctionPtr(x) (x)	#else	#define UserFunctionPtr(x) (gxUserErrorProcPtr)(& (x ## Descriptor))		RoutineDescriptor DisplayGraphicsWarningMessageDescriptor = BUILD_ROUTINE_DESCRIPTOR(uppgxUserWarningProcInfo, DisplayGraphicsWarningMessage);	RoutineDescriptor DisplayGraphicsErrorMessageDescriptor = BUILD_ROUTINE_DESCRIPTOR(uppgxUserErrorProcInfo, DisplayGraphicsErrorMessage);	RoutineDescriptor DisplayGraphicsNoticeMessageDescriptor = BUILD_ROUTINE_DESCRIPTOR(uppgxUserNoticeProcInfo, DisplayGraphicsNoticeMessage);#endif		void SetGraphicsLibraryErrors(void)	{		debugLibraryGlobals *context;		/*	allocate space for a new set of debug library globals and fill them in with the default values. note that allocating			memory for these globals allows this library to be used by several clients in the same application. it does mean that			this memory will be allocated and never freed, since there is no de-install routine for these error handlers... */		context = (debugLibraryGlobals *)NewPtr( sizeof(debugLibraryGlobals) );		BlockMove(&messages, context, sizeof(debugLibraryGlobals));		/* save the original warning and error functions */		context->originalWarningFunction = GXGetUserGraphicsWarning(&context->originalWarningReference);		context->originalErrorFunction = GXGetUserGraphicsError(&context->originalErrorReference);		/* set our new ones */		GXSetUserGraphicsWarning(UserFunctionPtr(DisplayGraphicsWarningMessage), (long)context);		GXSetUserGraphicsError(UserFunctionPtr(DisplayGraphicsErrorMessage), (long)context);	}	void SetGraphicsLibraryNotices(void)	{		debugLibraryGlobals *context;		/*	allocate space for a new set of debug library globals and fill them in with the default values. note that allocating			memory for these globals allows this library to be used by several clients in the same application. it does mean that			this memory will be allocated and never freed, since there is no de-install routine for this notice handler. */		context = (debugLibraryGlobals *)NewPtr( sizeof(debugLibraryGlobals) );		BlockMove(&messages, context, sizeof(debugLibraryGlobals));		/*** note that a stupid side-effect of SetGraphicsLibraryNotices and SetGraphicsLibraryErrors being			different functions is that we allocate TWO contexts for these message handlers... oh well... */		/* save the original notice functions */		context->originalNoticeFunction = GXGetUserGraphicsNotice(&context->originalNoticeReference);		/* set our new one */		GXSetUserGraphicsNotice(UserFunctionPtr(DisplayGraphicsNoticeMessage), (long)context);	}static char *LookupMessage(char **table, short size, short range, short IDwithinRange){	register char **message = table;	while (range--) {		while (*message++)			if (message-(char **) table > size)				return nil;	}	while (IDwithinRange--)		if (!*++message)			return nil;	return *message;}static char *InnerGraphicsErrorMessage(gxGraphicsError errorID, debugLibraryGlobals *messageTables){	if (errorID >= gxFirstAppError)		return nil;	else if (errorID >= gxFirstLibraryError)		return LookupMessage(messageTables->errorMessages, errorTextSize, 6, errorID - gxFirstLibraryError);	else if (errorID >= gxFirstSystemDebuggingError)		return LookupMessage(messageTables->errorMessages, errorTextSize, 5, errorID - gxFirstSystemDebuggingError);	else if (errorID >= gxFirstImplementationLimitError)		return LookupMessage(messageTables->errorMessages, errorTextSize, 4, errorID - gxFirstImplementationLimitError);	else if (errorID >= gxFirstParameterError)		return LookupMessage(messageTables->errorMessages, errorTextSize, 3, errorID - gxFirstParameterError);	else if (errorID >= gxFirstFontScalerError)		return LookupMessage(messageTables->errorMessages, errorTextSize, 2, errorID - gxFirstFontScalerError);	else if (errorID >= gxFirstNonfatalError)		return LookupMessage(messageTables->errorMessages, errorTextSize, 1, errorID - gxFirstNonfatalError);	else if (errorID >= gxFirstSystemError)		return LookupMessage(messageTables->errorMessages, errorTextSize, 0, errorID - gxFirstSystemError);	else		return nil;}char *GraphicsErrorMessage(gxGraphicsError errorID){	return InnerGraphicsErrorMessage(errorID, &messages);}static char *InnerGraphicsWarningMessage(gxGraphicsWarning warningID, debugLibraryGlobals *messageTables){	if (warningID >= gxFirstAppWarning)		return nil;	else if (warningID >= gxFirstLibraryWarning)		return LookupMessage(messageTables->warningMessages, warningTextSize, 5, warningID - gxFirstLibraryWarning);	else if (warningID >= gxFirstSystemDebuggingWarning)		return LookupMessage(messageTables->warningMessages, warningTextSize, 4, warningID - gxFirstSystemDebuggingWarning);	else if (warningID >= gxFirstFontScalerWarning)		return LookupMessage(messageTables->warningMessages, warningTextSize, 3, warningID - gxFirstFontScalerWarning);	else if (warningID >= gxFirstParameterOutOfRangeWarning)		return LookupMessage(messageTables->warningMessages, warningTextSize, 2, warningID - gxFirstParameterOutOfRangeWarning);	else if (warningID >= gxFirstResultOutOfRangeWarning)		return LookupMessage(messageTables->warningMessages, warningTextSize, 1, warningID - gxFirstResultOutOfRangeWarning);	else if (warningID >= gxFirstSystemWarning)		return LookupMessage(messageTables->warningMessages, warningTextSize, 0, warningID - gxFirstSystemWarning);	else		return nil;}char *GraphicsWarningMessage(gxGraphicsWarning warningID){	return InnerGraphicsWarningMessage(warningID, &messages);}static char *InnerGraphicsNoticeMessage(gxGraphicsNotice noticeID, debugLibraryGlobals *messageTables){	if (noticeID >= gxFirstAppNotice)		return nil;	else if (noticeID >= gxFirstLibraryNotice)		return LookupMessage(messageTables->noticeMessages, noticeTextSize, 1, noticeID - gxFirstLibraryNotice);	else if (noticeID >= gxFirstSystemNotice)		return LookupMessage(messageTables->noticeMessages, noticeTextSize, 0, noticeID - gxFirstSystemNotice);	else		return nil;}char *GraphicsNoticeMessage(gxGraphicsNotice noticeID){	return InnerGraphicsNoticeMessage(noticeID, &messages);}static char *HexToAscii(register long value, char *str, register short digits){	register char *end = str + digits;	register char *p = end;	while (--digits >= 0) {		register char nibble = '0' + (value & 0x0F);		if (nibble > '9') nibble += 'A' - '9' - 1;		*--p = nibble;		value >>= 4;	}	return end;}static void DisplayMessage(char *signalClass, long id, char *signalText, debugLibraryGlobals *messageTables){	char debugString[255];	register char *dst = debugString + 1;	register char *src;	char *hexPosition;	src = signalClass;	while ((*dst++ = *src++) != 0)		;	--dst;	src = signalText;	if (src == nil) {		src = messageTables->undefinedMessage;		hexPosition = dst + undefinedHexOffset;	}	while ((*dst++ = *src++) != 0) ;	*--dst = '.';	if (signalText == nil)		HexToAscii((unsigned long) id, hexPosition, 4);	debugString[0] = dst - debugString;	DebugStr((const unsigned char *) debugString);}void DisplayGraphicsErrorMessage(gxGraphicsError errorID, long context){	char buffer[255];	long thing;	long argNum;	debugLibraryGlobals *messageTables = (debugLibraryGlobals *)context;		if (GXGetValidationError(nil, (void **)&thing, &argNum)) {		char *walker = buffer;		char *copy = messageTables->validationMessage;				while ((*walker = *copy++) != 0)			++walker;		GXGetValidationError(walker, nil, nil);		while (*walker)			++walker;		*walker++ = '(';		*walker++ = '0';		*walker++ = 'x';		HexToAscii(thing, walker, 8);		walker += 8;		*walker++ = ')';		*walker++ = ' ';		*walker = 0;		DisplayMessage(buffer, errorID, InnerGraphicsErrorMessage(errorID, messageTables),					messageTables);	} else		DisplayMessage((errorID >= gxFirstFatalError && errorID <= gxLastFatalError) ? 			messageTables->fatalErrorMessage : messageTables->errorMessage,			errorID, InnerGraphicsErrorMessage(errorID, messageTables), messageTables);	/* pass the error on to the original error function */	if( messageTables->originalErrorFunction )		(*messageTables->originalErrorFunction)(errorID, messageTables->originalErrorReference);}void DisplayGraphicsWarningMessage(gxGraphicsWarning warningID, long context){	debugLibraryGlobals *messageTables = (debugLibraryGlobals *)context;	DisplayMessage(messageTables->warningMessage, warningID,				InnerGraphicsWarningMessage(warningID, messageTables), messageTables);	/* pass the warning on to the original warning function */	if( messageTables->originalWarningFunction )		(*messageTables->originalWarningFunction)(warningID, messageTables->originalWarningReference);}void DisplayGraphicsNoticeMessage(gxGraphicsNotice noticeID, long context){	debugLibraryGlobals *messageTables = (debugLibraryGlobals *)context;	DisplayMessage(messageTables->noticeMessage, noticeID,		InnerGraphicsNoticeMessage(noticeID, messageTables), messageTables);	/* pass the notice on to the original notice function */	if( messageTables->originalNoticeFunction )		(*messageTables->originalNoticeFunction)(noticeID, messageTables->originalNoticeReference);}