/* graphics libraries:	gxColor library	by Cary Clark, Georgiann Delaney, Michael Fairman, Dave Good, Robert Johnson, Keith McGreggor, Oliver Steele, David Van Brink, Chris Yerga	Copyright 1987 - 1993 Apple Computer, Inc.  All rights reserved.	*/#include "graphics libraries.h"gxSetColor commonColorList[] = {	sRGB(0xffff, 0xffff, 0xffff),	/* white */	sRGB(0,0,0),				/* black */	sRGB(0x7f7f,0x7f7f,0x7f7f),	/* gray */	sRGB(0xffff,0,0),			/* red */	sRGB(0,0xffff,0),			/* green */	sRGB(0,0,0xffff),			/* blue */	sRGB(0,0xffff,0xffff),		/* cyan */	sRGB(0xffff,0,0xffff),		/* magenta */	sRGB(0xffff,0xffff,0),		/* yellow */	sRGB(0xffff,0x7f7f,0),		/* orange */	sRGB(0x7f7f,0xffff,0),		/* chartreuse */	sRGB(0,0xffff,0x7f7f),		/* aqua */	sRGB(0,0x7f7f,0xffff),		/* slate ... bluegray */	sRGB(0x7f7f,0,0xffff),		/* purple */	sRGB(0xffff,0,0x7f7f),		/* maroon */	sRGB(0x5f5f,0x3f3f,0),		/* brown */	sRGB(0xffff,0x9f9f,0xafaf),	/* pink */	sRGB(0,0xffff,0xdfdf),		/* turquoise */	sRGB256(255,227,3),		/* cadmium lemon */	sRGB256(255,176,15),		/* cadmium light yellow */	sRGB256(255,168,36),		/* aureoline yellow */	sRGB256(255,168,18),		/* naples deep yellow */	sRGB256(255,153,18),		/* cadmium yellow */	sRGB256(255,122,10),		/* cadmium deep yellow */	sRGB256(255,97,3),		/* cadmium orange */	sRGB256(255,3,13),		/* cadmium light red */	sRGB256(227,18,48),		/* cadmium deep red */	sRGB256(227,18,48),		/* geranium lake */	sRGB256(227,38,54),		/* alizarin crimson */	sRGB256(227,54,56),		/* rose madder */	sRGB256(227,46,48),		/* madder deep lake */	sRGB256(219,41,41),		/* brown madder */	sRGB256(219,38,69),		/* permanent red violet */	sRGB256(145,33,158),		/* cobalt deep violet */	sRGB256(92,36,110),		/* ultramarine violet */	sRGB256(18,10,143),		/* ultramarine blue */	sRGB256(61,89,171),		/* cobalt blue */	sRGB256(3,145,194),		/* royal blue */	sRGB256(5,184,204),		/* cerulean blue */	sRGB256(3,168,157),		/* manganese blue */	sRGB256(8,46,84),			/* indigo */	sRGB256(0,199,140),		/* turquoise blue */	sRGB256(0,201,87),		/* emerald green */	sRGB256(10,201,43),		/* permanent green */	sRGB256(110,255,112),		/* viridian light */	sRGB256(61,145,64),		/* cobalt green */	sRGB256(97,179,41),		/* cinnabar green */	sRGB256(48,128,20),		/* sap green */	sRGB256(102,128,20),		/* chromium oxide green */	sRGB256(56,94,15),		/* terre-verte */	sRGB256(227,130,23),		/* yellow ochre */	sRGB256(227,112,26),		/* mars yellow */	sRGB256(199,97,20),		/* raw sienna */	sRGB256(150,69,20),		/* mars orange */	sRGB256(199,120,38),		/* gold ochre */	sRGB256(135,66,31),		/* browh ochre */	sRGB256(115,61,36),		/* deep ochre */	sRGB256(138,51,36),		/* burnt umber */	sRGB256(138,54,15),		/* burnt sienna */	sRGB256(255,125,64),		/* flesh */	sRGB256(255,87,33),		/* flesh ochre */	sRGB256(212,61,26),		/* english red */	sRGB256(212,26,31),		/* venetian red */	sRGB256(176,23,31),		/* indian red */	sRGB256(115,74,18),		/* raw umber */	sRGB256(3,61,13),			/* greenish umber */	sRGB256(94,38,5),			/* van dyck brown */	sRGB256(94,38,18),		/* sepia */	sRGB256(128,128,105),		/* warm grey */	sRGB256(128,138,135),		/* cold grey */	sRGB256(41,36,33),		/* ivory black */	sRGB256(46,71,59),		/* lamp black */	sRGB256(252,255,240),		/* titanium white */	sRGB256(252,242,255),		/* zinc white */	sRGB256(199,171,97),		/* pale gold */	sRGB256(199,156,48),		/* gold */	sRGB256(128,110,26),		/* old gold */	sRGB256(255,179,115),		/* pink gold */	sRGB256(255,224,143),		/* white gold */	sRGB256(189,189,74),		/* yellow gold */	sRGB256(204,212,112),		/* green gold */	sRGB256(212,201,143),		/* platinum */	sRGB256(207,209,179),		/* silver */	sRGB256(135,133,120),		/* antique silver */	sRGB256(181,209,188),		/* chrome */	sRGB256(140,158,150),		/* steel */	sRGB256(247,153,71),		/* copper */	sRGB256(176,84,15),		/* antique copper */	sRGB256(128,255,176),		/* oxidized copper */	sRGB256(140,115,36),		/* bronze */	sRGB256(176,161,59),		/* brass */	sRGB256(140,158,150),		/* iron */	sRGB256(171,59,20),		/* rusted iron */	sRGB256(64,54,43),		/* lead */	sRGB256(255,214,245),		/* fluorescent pink */	sRGB256(186,255,196),		/* fluorescent green */	sRGB256(214,240,255),		/* fluorescent blue */	sRGB256(255,247,161),		/* incadescent high */	sRGB256(255,232,107),		/* incadescent low */	sRGB256(191,207,255),		/* moonlight */	sRGB256(255,173,31),		/* sodium */	sRGB256(255,245,235),		/* daylight */	sRGB256(255,176,156),		/* dawn */	sRGB256(255,181,94),		/* afternoon */	sRGB256(255,163,86),		/* dusk */	sRGB256(208,163,196),		/* a shade of purple gray */	sRGB256(137,202,3),		/* Apple Green */	sRGB256(255,210,0),		/* Apple Yellow */	sRGB256(230,117,0),		/* Apple Orange */	sRGB256(163,34,58),		/* Apple Red */	sRGB256(99,0,116),		/* Apple Purple */	sRGB256(64,127,179)		/* Apple Blue */	};short commonColorCount = sizeof(commonColorList)/sizeof(commonColorList[0]);gxColorSet commonColorSet = nil;void InitCommonColors(void){	if (!commonColorSet)		commonColorSet = GXNewColorSet(gxRGBSpace, commonColorCount, commonColorList);}void DisposeCommonColors(void){	if (commonColorSet) {		GXDisposeColorSet(commonColorSet);		commonColorSet = nil;	}}gxColor *SetCommonColor(gxColor *dest, commonColor source){	gxRGBColor rgb;	long actualindex;		if (!commonColorSet)		InitCommonColors();		actualindex = (source - 1 & 511) % commonColorCount + 1;	if (actualindex < 1 || actualindex > commonColorCount) {#ifdef debugging	GXPostGraphicsError(parameter_out_of_range);#endif	actualindex = 0;	}	dest->element.indexed.set = commonColorSet;	dest->element.indexed.index = actualindex;	dest->space = gxIndexedSpace;	dest->profile = nil;		GXConvertColor(dest,gxRGBSpace, nil, nil);	rgb = dest->element.rgb;		if (source & dark) {		rgb.red >>= 1;		rgb.green   >>= 1;		rgb.blue	>>= 1;	}	if (source & light) {		rgb.red += 0xffff - rgb.red >> 1;		rgb.green   += 0xffff - rgb.green >> 1;		rgb.blue	+= 0xffff - rgb.blue >> 1;	}	if (source & warm) {		rgb.red -= 0xffff - rgb.red >> 2;		rgb.green   >>= 2;		rgb.green   = rgb.green + rgb.green + rgb.green;		rgb.blue	>>= 2;		rgb.blue	= rgb.blue + rgb.blue + rgb.blue;	}	if (source & greenish) {		rgb.green   -= 0xffff - rgb.green >> 2;		rgb.red >>= 2;		rgb.red = rgb.red + rgb.red + rgb.red;		rgb.blue	>>= 2;		rgb.blue	= rgb.blue + rgb.blue + rgb.blue;	}	if (source & cool) {		rgb.blue	-= 0xffff - rgb.blue >> 2;		rgb.red >>= 2;		rgb.red = rgb.red + rgb.red + rgb.red;		rgb.green   >>= 2;		rgb.green   = rgb.green + rgb.green + rgb.green;	}	if (source & grayish) {		rgb.red = 0x3f3f + (rgb.red >> 1); 		rgb.green   = 0x3f3f + (rgb.green >> 1);		rgb.blue	= 0x3f3f + (rgb.blue >> 1);	}		dest->element.rgb = rgb;	return dest;}commonColor GetCommonColor(const gxColor *source){	gxColor dst;		dst = *source;	GXConvertColor(&dst, gxIndexedSpace, commonColorSet, nil);	return dst.element.indexed.index;}void SetShapeCommonColor(gxShape dest, commonColor someColor){	gxColor c;		NilShapeReturn(dest);	GXSetShapeColor(dest, SetCommonColor(&c, someColor));}void SetInkCommonColor(gxInk dest, commonColor someColor){	gxColor c;		NilInkReturn(dest);	GXSetInkColor(dest, SetCommonColor(&c, someColor));}commonColor GetInkCommonColor(gxInk source){	gxColor c;		GXGetInkColor(source, &c);	return GetCommonColor(&c);}commonColor GetShapeCommonColor(gxShape source){	gxColor c;		GXGetShapeColor(source, &c);	return GetCommonColor(&c);}gxColorSpace GetShapeColorSpace(gxShape source){	if( GXGetShapeType(source) == gxBitmapType ) {		gxBitmap bits;		return GXGetBitmap(source, &bits, nil)->space;	} else {		gxColor old;		return GXGetShapeColor(source, &old)->space;	}}gxColorProfile GetShapeColorProfile(gxShape source){	if( GXGetShapeType(source) == gxBitmapType ) {		gxBitmap bits;		return GXGetBitmap(source, &bits, nil)->profile;	} else {		gxColor old;		return GXGetShapeColor(source, &old)->profile;	}}gxColorSet GetShapeColorSet(gxShape source){	if( GXGetShapeType(source) == gxBitmapType ) {		gxBitmap bits;		GXGetBitmap(source, &bits, nil);		return bits.set;	} else {		gxColor oldColor;		GXGetShapeColor(source, &oldColor);		if( oldColor.space == gxIndexedSpace )			return oldColor.element.indexed.set;		return nil;	}}gxColorSpace GetInkColorSpace(gxInk source){	gxColor oldColor;	return GXGetInkColor(source, &oldColor)->space;}gxColorProfile GetInkColorProfile(gxInk source){	gxColor oldColor;	return GXGetInkColor(source, &oldColor)->profile;}gxColorSet GetInkColorSet(gxInk source){	gxColor oldColor;	GXGetInkColor(source, &oldColor);	if( oldColor.space == gxIndexedSpace )		return oldColor.element.indexed.set;	return nil;}void SetShapeColorSpace(gxShape target, gxColorSpace space){	if( GXGetShapeType(target) == gxBitmapType ) {		gxBitmap bits;		GXGetBitmap(target, &bits, nil);		bits.space = space;		GXSetBitmap(target, &bits, nil);	} else {		gxColor oldColor;		GXGetShapeColor(target, &oldColor);		IfErrorReturn(space == gxIndexedSpace && oldColor.element.indexed.set == nil, colorSet_is_nil);		GXConvertColor(&oldColor, space, space == gxIndexedSpace ? oldColor.element.indexed.set : nil, oldColor.profile);		GXSetShapeColor(target, &oldColor);	}}void SetShapeColorProfile(gxShape target, gxColorProfile profile){	if( GXGetShapeType(target) == gxBitmapType ) {		gxBitmap bits;		GXGetBitmap(target, &bits, nil);		bits.profile = profile;		GXSetBitmap(target, &bits, nil);	} else {		gxColor oldColor;		GXGetShapeColor(target, &oldColor);		oldColor.profile = profile;		GXSetShapeColor(target, &oldColor);	}}void SetShapeColorSet(gxShape target, gxColorSet set){	if( GXGetShapeType(target) == gxBitmapType ) {		gxBitmap bits;		GXGetBitmap(target, &bits, nil);		bits.set = set;	/*** might want to check to see if the old gxColorSpace was not indexed, in which case we need to either post an error		or remap the gxBitmap to fit this new gxColorSet. We should also check the number of colors in this new set to see if		they match the old set and post a warning if there are less new colors than could be in the gxBitmap */		GXSetBitmap(target, &bits, nil);	} else {		gxColor oldColor;		GXGetShapeColor(target, &oldColor);		oldColor.space = gxIndexedSpace;		oldColor.element.indexed.set = set;		GXSetShapeColor(target, &oldColor);	}}void SetInkColorSpace(gxInk target, gxColorSpace space){	gxColor oldColor;	GXGetInkColor(target, &oldColor);	IfErrorReturn(space == gxIndexedSpace && oldColor.element.indexed.set == nil, colorSet_is_nil);	GXConvertColor(&oldColor, space, space == gxIndexedSpace ? oldColor.element.indexed.set : nil, oldColor.profile);	GXSetInkColor(target, &oldColor);}void SetInkColorProfile(gxInk target, gxColorProfile profile){	gxColor oldColor;	GXGetInkColor(target, &oldColor);	oldColor.profile = profile;	GXSetInkColor(target, &oldColor);}void SetInkColorSet(gxInk target, gxColorSet set){	gxColor oldColor;	GXGetInkColor(target, &oldColor);	oldColor.space = gxIndexedSpace;	oldColor.element.indexed.set = set;	GXSetInkColor(target, &oldColor);}gxColorSet GetViewDeviceColorSet(gxViewDevice source){	register gxShape bitmapShape = GXGetViewDeviceBitmap(source);	register gxColorSet result = GetShapeColorSet(bitmapShape);	if (result)		GXCloneColorSet(result);	GXDisposeShape(bitmapShape);	return result;}void SetViewDeviceColorSet(gxViewDevice target, gxColorSet set){	register gxShape bitmapShape = GXGetViewDeviceBitmap(target);	SetShapeColorSet(bitmapShape, set);/*** Should check for hardware devices and not allow you to change from a hardware direct device to an indexed device */	GXSetViewDeviceBitmap(target, bitmapShape);	GXDisposeShape(bitmapShape);}gxColorProfile GetViewDeviceColorProfile(gxViewDevice source){	register gxShape bitmapShape = GXGetViewDeviceBitmap(source);	register gxColorProfile result = GetShapeColorProfile(bitmapShape);	if (result)		GXCloneColorProfile(result);	GXDisposeShape(bitmapShape);	return result;}void SetViewDeviceColorProfile(gxViewDevice target, gxColorProfile profile){	register gxShape bitmapShape = GXGetViewDeviceBitmap(target);	SetShapeColorProfile(bitmapShape, profile);	GXSetViewDeviceBitmap(target, bitmapShape);	GXDisposeShape(bitmapShape);}static char colorSpaceComponentCounts[] = {	3,			/* rgb */	4,			/* rgba */	4,			/* cmyk */	3,3,				/* hsv, hls */	3,3,3,3,3,	/* cie & its parasites */	3,3,3,		/* yiq, other video */	1,2,				/* gray, grayAlpha */	3,3,				/* rgb16, rgb32 */	4,4,				/* argb16, argb32 */	4,4,				/* cmyk16, cmyk32 */	2,			/* grayAlpha */	1			/* indexed */};long GetColorSpaceComponents(gxColorSpace space){	return colorSpaceComponentCounts[space - 1];}void SetShapeRGB(gxShape target, gxColorValue red, gxColorValue green, gxColorValue blue){	gxColor c;		NilShapeReturn(target);	c.space = gxRGBSpace;	c.profile = nil;	c.element.rgb.red = red;	c.element.rgb.green = green;	c.element.rgb.blue = blue;	GXSetShapeColor(target, &c);}void SetInkRGB(gxInk target, gxColorValue red, gxColorValue green, gxColorValue blue){	gxColor c;		NilInkReturn(target);	c.space = gxRGBSpace;	c.profile = nil;	c.element.rgb.red = red;	c.element.rgb.green = green;	c.element.rgb.blue = blue;	GXSetInkColor(target, &c);}void SetShapeHSV(gxShape target, gxColorValue hue, gxColorValue saturation, gxColorValue value){	gxColor c;		NilShapeReturn(target);	c.space = gxHSVSpace;	c.profile = nil;	c.element.hsv.hue = hue;	c.element.hsv.saturation = saturation;	c.element.hsv.value = value;	GXSetShapeColor(target, &c);}void SetInkHSV(gxInk target, gxColorValue hue, gxColorValue saturation, gxColorValue value){	gxColor c;		NilInkReturn(target);	c.space = gxHSVSpace;	c.profile = nil;	c.element.hsv.hue = hue;	c.element.hsv.saturation = saturation;	c.element.hsv.value = value;	GXSetInkColor(target, &c);}void SetShapeGray(gxShape target, gxColorValue gray){	gxColor c;		NilShapeReturn(target);	c.space = gxGraySpace;	c.profile = nil;	c.element.gray = gray;	GXSetShapeColor(target, &c);}void SetInkGray(gxInk target, gxColorValue gray){	gxColor c;		NilInkReturn(target);	c.space = gxGraySpace;	c.profile = nil;	c.element.gray = gray;	GXSetInkColor(target, &c);}