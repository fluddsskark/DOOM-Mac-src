/* graphics libraries:     primitive flattening library routines   by Cary Clark, Georgiann Delaney, Michael Fairman, Dave Good, Robert Johnson, Keith McGreggor, Oliver Steele, David Van Brink, Chris Yerga   Copyright 1987 - 1991 Apple Computer, Inc.  All rights reserved.  */   #include <Memory.h>   #include <Errors.h>   #include <Files.h>#include "font routines.h"#include "graphics libraries.h"#include "scaler types.h"#include "storage library.h"/*   The following routine is an example of how to write a spooling procedure to   work with GXFlattenShape and GXUnflattenShape.  For writing, it stores the data in   a Handle which must be disposed of after the GXFlattenShape call.  When reading,   it expects the 'data' field of the gxSpoolBlock to have a handle to the data to be   unflattened.*/#define allocationIncrement   1024     /* the storage handle is grown by this amount */#ifdef __cplusplusextern "C" {#endifstatic long HandleSpoolProc(gxSpoolCommand command,  userSpool *block){   switch (command)   {      case gxOpenReadSpool:         block->size = 0;         block->position = 0;      break;      case gxOpenWriteSpool:         block->data = NewHandle(allocationIncrement);         block->size = allocationIncrement;         block->position = 0;      break;            case gxReadSpool:         BlockMove((*(char **) block->data) + block->position, block->spool.buffer, block->spool.count);         block->position += block->spool.count;      break;      case gxWriteSpool:      {  register long oldPosition;         oldPosition = block->position;         block->position += block->spool.count;         /* make sure there is at least enough room for one buffer size past current pointer */         if (block->position + block->spool.bufferSize > block->size)               {            block->size += block->spool.bufferSize;            HUnlock((Handle) block->data);            SetHandleSize((Handle) block->data, block->size);            HLock((Handle) block->data);         }         BlockMove(block->spool.buffer, (*(char **) block->data + oldPosition), block->spool.count);      }      break;            case gxCloseSpool:         SetHandleSize((Handle) block->data, block->position);      break;   }   return 0;}#ifdef __cplusplus}#endif/*   This routine spools to and from a file.  The file must have previously been created and opened,   and its refNum is expected to be in the refnum field of the block.*/static long FileSpoolProc(gxSpoolCommand command, userSpool *block){   short err;      switch (command) {      case gxOpenReadSpool:      break;      case gxOpenWriteSpool:      break;      case gxReadSpool:      {         long count = block->spool.count;         err = FSRead(block->reference, &count, block->spool.buffer);         IfDebug(err && err != eofErr, "\pFSRead failed");      } break;      case gxWriteSpool:      {         long count = block->spool.count;         err = FSWrite(block->reference, &count, block->spool.buffer);         IfDebug(err, "\pFSWrite failed");      } break;      case gxCloseSpool:      break;      default:         IfDebug(true, "\punexpected spool command");   }   return 0;}Handle ShapeToHandle(gxShape source){   userSpool block;      NilShapeReturnNil(source);#ifndef __powerc   block.spool.spoolProcedure = (gxSpoolProcPtr) HandleSpoolProc;#else   block.spool.spoolProcedure = NewgxSpoolProc(HandleSpoolProc);#endif   block.spool.buffer = nil;   block.spool.bufferSize = 0;   GXFlattenShape(source, gxFontListFlatten | gxFontGlyphsFlatten, &block.spool);#ifdef __powerc   DisposeRoutineDescriptor(block.spool.spoolProcedure);#endif   return (Handle) block.data;}gxShape HandleToShape(Handle source, long count, const gxViewPort portList[]){   userSpool block;   gxShape dest;   #ifndef __powerc      block.spool.spoolProcedure = (gxSpoolProcPtr) HandleSpoolProc;#else   block.spool.spoolProcedure = NewgxSpoolProc(HandleSpoolProc);#endif   block.spool.buffer = nil;   block.spool.bufferSize = 0;   block.data = source;   dest = GXUnflattenShape(&block.spool, count, portList);#ifdef __powerc   DisposeRoutineDescriptor(block.spool.spoolProcedure);#endif   return dest;}void ShapeToFRef(gxShape source, short refNum){	userSpool block;	NilShapeReturn(source);#ifndef __powerc		block.spool.spoolProcedure = (gxSpoolProcPtr) FileSpoolProc;#else	block.spool.spoolProcedure = NewgxSpoolProc(FileSpoolProc);#endif	block.reference = refNum;	block.spool.buffer = nil;	block.spool.bufferSize = 0;	GXFlattenShape(source,  gxFontListFlatten | gxFontGlyphsFlatten, &block.spool);#ifdef __powerc	DisposeRoutineDescriptor(block.spool.spoolProcedure);#endif}gxShape FRefToShape(short refNum, long count, const gxViewPort portList[]){	userSpool block;	gxShape dest;	#ifndef __powerc		block.spool.spoolProcedure = (gxSpoolProcPtr) FileSpoolProc;#else	block.spool.spoolProcedure = NewgxSpoolProc(FileSpoolProc);#endif	block.reference = refNum;	block.spool.buffer = nil;	block.spool.bufferSize = 0;	dest = GXUnflattenShape(&block.spool, count, portList);#ifdef __powerc	DisposeRoutineDescriptor(block.spool.spoolProcedure);#endif	return dest;}void ShapeToFile(gxShape source, Str255 fileName, short vRefNum, OSType creator, OSType fileType){	short refNum;	short err;		NilShapeReturn(source);	NilParamReturn(fileName);		if (creator == 0) creator = 'sLib';	if (fileType == 0) fileType = 'flat';	err = Create(fileName, vRefNum, creator, fileType);	if (err == dupFNErr) {		FSDelete(fileName, vRefNum);		err = Create(fileName, vRefNum, creator, fileType);	}	IfDebug(err, "\pCreate failed");	err = FSOpen(fileName, vRefNum, &refNum);	IfDebug(err, "\pFSOpen failed");	ShapeToFRef(source, refNum);	err = FSClose(refNum);	IfDebug(err, "\pFSClose failed");}gxShape FileToShape(Str255 fileName, short vRefNum, long count, const gxViewPort portList[]){	short refNum;	short err;	gxShape dest;		err = FSOpen(fileName, vRefNum, &refNum);	IfDebug(err, "\pFSOpen failed");	dest = FRefToShape(refNum, count, portList);	err = FSClose(refNum);	IfDebug(err, "\pFSClose failed");	return dest;}Handle FontToHandle(gxFont fontID, long glyphBits[]){   userSpool block;   scalerStream stream;   #ifndef __powerc      block.spool.spoolProcedure = (gxSpoolProcPtr) HandleSpoolProc;#else   block.spool.spoolProcedure = NewgxSpoolProc(HandleSpoolProc);#endif   block.spool.buffer = nil;   block.spool.bufferSize = 0;   stream.streamRefCon = fontID;   stream.types = type1StreamType;		// flattenedStreamType;   stream.action = downloadStreamAction;   stream.memorySize = 0;   stream.variationCount = selectAllVariations;   stream.variations = nil;   stream.info.font.encoding = 0;   stream.info.font.glyphBits = glyphBits;   stream.info.font.name = (char*)"\pSkia-ps";   GXFlattenFont(fontID, &stream, &block.spool);#ifdef __powerc   DisposeRoutineDescriptor(block.spool.spoolProcedure);#endif   return (Handle) block.data;}gxFont HandleToFont(Handle source){   /*    * GXNewFont does not copy the data in source, so you can't dispose    * of it until you have called GXDisposeFont().   */   return GXNewFont(gxHandleFontStorage, source, 0);}