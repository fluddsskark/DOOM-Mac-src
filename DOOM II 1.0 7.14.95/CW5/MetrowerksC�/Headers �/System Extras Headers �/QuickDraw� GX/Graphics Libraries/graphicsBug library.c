/* graphics libraries:    general library routines        by Cary Clark, Georgiann Delaney, Michael Fairman, Dave Good, Robert Johnson, Keith McGreggor, Oliver Steele, David Van Brink, Chris Yerga    Copyright 1987 - 1993 Apple Computer, Inc.  All rights reserved.    *//* this is so that we get the trap version of Gestalt */#ifndef SystemSevenOrLater	#define SystemSevenOrLater 1#endif    #include <GestaltEqu.h>#include <Processes.h>#include "math types.h"#include "graphics debugging.h"#include "graphicsBug library.h"// *** eventually, allow this to work both locally and over the network?// *** for remote debugging, lauch gBug on remote machine, and then use special menu item// to bring up PPCToolbox browser. Select one or more machines running graphics init to receive // errors from, or to set break points, etc.boolean SendMessageToGraphicsBug(long command, const char *string, unsigned long message, boolean waitForCompletion){    ProcessSerialNumber     skiaBugProcess;    OSErr               err;    struct graphicsBugParameters *blockPointer = nil;    EventRecord         theEvent;        {   LaunchParamBlockRec     launch;        DTPBRec             bugAp;        FSSpec              fileSpecification;                bugAp.ioNamePtr = nil;        bugAp.ioVRefNum = 0;        if ((err = PBDTGetPath(&bugAp)) != 0)            return false; /* error */        bugAp.ioNamePtr = fileSpecification.name;        bugAp.ioCompletion = nil;        bugAp.ioIndex = 0;        bugAp.ioFileCreator = creatorType;        err = PBDTGetAPPLSync(&bugAp);        if (err)            return false; /* error */        /* is the file already launched ? */        {   ProcessInfoRec processInfo;            FSSpec processSpec;                        processInfo.processName = nil;            processInfo.processAppSpec = &processSpec;            processInfo.processInfoLength = sizeof(processInfo);            skiaBugProcess.highLongOfPSN = 0;            skiaBugProcess.lowLongOfPSN = kNoProcess;            while (GetNextProcess(&skiaBugProcess) == noErr) {                if (GetProcessInformation(&skiaBugProcess, &processInfo) == noErr &&                    processInfo.processType == 'APPL' &&                    processInfo.processSignature == creatorType &&                    processInfo.processAppSpec->parID == bugAp.ioAPPLParID)                {                    goto doEvent;                }            }        }        launch.launchBlockID = extendedBlock;        launch.launchEPBLength = extendedBlockLen;        launch.launchFileFlags = 0;        launch.launchControlFlags = launchDontSwitch | launchContinue | launchNoFileFlags;        fileSpecification.vRefNum = 0;        fileSpecification.parID = bugAp.ioAPPLParID;        launch.launchAppSpec = &fileSpecification;        launch.launchAppParameters = nil;        err = LaunchApplication(&launch);        if (err)            return false; /* error */        if (launch.launchMinimumSize)  /* ap not already open */        {   register short counter = 4;                    do                WaitNextEvent(0, &theEvent, -1, nil);            while (--counter);        }        skiaBugProcess = launch.launchProcessSN;    }doEvent:#ifdef __APPLEEVENTS__    {   AEAddressDesc   targetAddress;        AppleEvent  theAppleEvent;        AppleEvent  replyEvent;            err = AECreateDesc(typeProcessSerialNumber, (Ptr)&skiaBugProcess, sizeof(skiaBugProcess), &targetAddress);        err = AECreateAppleEvent(kCoreEventClass, kAEOpenApplication, &targetAddress, kAutoGenerateReturnID,            kAnyTransactionID, &theAppleEvent);        err = AESend(&theAppleEvent, &replyEvent, kAENoReply | kAECanInteract | kAECanSwitchLayer, kAENormalPriority, kAEDefaultTimeout, nil, nil);        AEDisposeDesc(&theAppleEvent);                //  select the bottom of the window just in case it was pointing to the top        err = AECreateAppleEvent(bugEventClass, selectBugWindowPartEvent, &targetAddress, kAutoGenerateReturnID,            kAnyTransactionID, &theAppleEvent);        {   boolean selectTop = false;                        err = AEPutParamPtr(&theAppleEvent, chooseWindowPartBoolean, keyDirectObject, (Ptr)&selectTop, sizeof(selectTop));        }        err = AESend(&theAppleEvent, &replyEvent, kAENoReply | kAECanInteract | kAECanSwitchLayer, kAENormalPriority, kAEDefaultTimeout, nil, nil);        AEDisposeDesc(&theAppleEvent);                // create a second event that contains the error message and paste it into the window        err = AECreateAppleEvent(bugEventClass, pasteBugTextEvent, &targetAddress, kAutoGenerateReturnID,            kAnyTransactionID, &theAppleEvent);        {   Str255 quoted;            long length = strlen(str);            unsigned char *quotePtr = quoted;                        *quotePtr++ = '"';            BlockMove(str, quotePtr, length);            quotePtr += length;            if (num)            {   register int digit;                register int counter = 8;                                BlockMove(": 0", quotePtr, 3);                quotePtr += 3;                *quotePtr++ = 'X';                do {                    num = num << 4 | num >> 28;                    digit = num & 0xf;                    *quotePtr++ = digit > '9' ? digit - '9' + 'A' - 1 : digit + '0';                } while (--counter);            }            *quotePtr++ = '"';            *quotePtr++ = returnChar;            err = AEPutParamPtr(&theAppleEvent, errorString, keyDirectObject, (Ptr) quoted, quotePtr - quoted);        }        err = AESend(&theAppleEvent, &replyEvent, kAEWaitReply | kAECanInteract | kAECanSwitchLayer, kAENormalPriority, kAEDefaultTimeout, nil, nil);        AEDisposeDesc(&theAppleEvent);        AEDisposeDesc(&targetAddress);    }#else    {        if (GXGetGraphicsBugParametersPointer(&blockPointer))        {   char lastToggle;            long idleCount = 0;                        while (blockPointer->status <= graphicsBugRunning) {                if (lastToggle != blockPointer->toggle) {                    lastToggle = blockPointer->toggle;                    idleCount = 0;                } else {                    idleCount++;                    if (idleCount > maximumIdle)                        return false; /* timed out */                }                EventAvail(everyEvent, &theEvent);            }            {   register char *destStringPtr = blockPointer->string;                register const char *sourceStringPtr = string;                static char requestChars[] = "nwe";                                blockPointer->message = message;                if (command >= noticeMessage && command <= errorMessage) {                    *destStringPtr++ = 'g';                    *destStringPtr++ = requestChars[command];                } else if (sourceStringPtr) {                    if (command == debugMessage)                        *destStringPtr++ = '"';                    while (*sourceStringPtr)                        *destStringPtr++ = *sourceStringPtr++;                    if (command == debugMessage)                        *destStringPtr++ = '"';                }                blockPointer->command = executeCommand;            }            if (waitForCompletion) {                while (blockPointer->status) {                    if (lastToggle != blockPointer->toggle) {                        lastToggle = blockPointer->toggle;                        idleCount = 0;                    } else {                        idleCount++;                        if (idleCount > maximumIdle)                            return false;                    }                    EventAvail(everyEvent, &theEvent);                }            }        } else            return false;    }#endif    return true;}static boolean SendGraphicsBugMessage(const char *str, long message, long reference){    reference = 0;  /* so MPW will not complain */    if (SendMessageToGraphicsBug(debugMessage, str, message, true) == false) {        GXSetUserGraphicsDebug(nil, 0);        return false;    }    return true;}void DirectDebugMessageToGraphicsBug(void){    GXSetUserGraphicsDebug(SendGraphicsBugMessage, 0);}