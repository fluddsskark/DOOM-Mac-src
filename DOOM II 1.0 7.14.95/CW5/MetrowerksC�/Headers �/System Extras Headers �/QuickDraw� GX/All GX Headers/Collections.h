/*	File:		Collections.h	Copyright:	© 1984-1994 by Apple Computer, Inc., all rights reserved.	WARNING	This file was auto generated by the interfacer tool. Modifications	must be made to the master file.*/#ifndef __COLLECTIONMANAGER__#define __COLLECTIONMANAGER__#ifndef __TYPES__#include <Types.h>/*	#include <ConditionalMacros.h>								*//*	#include <MixedMode.h>										*//*		#include <Traps.h>										*/#endifenum  {	gestaltCollectionMgrVersion	= 'cltn'};enum  {	collectionItemLockedErr		= -5750,	collectionItemNotFoundErr	= -5751,	collectionIndexRangeErr		= -5752,	collectionVersionErr		= -5753};enum  {	dontWantTag					= 0L,	dontWantId					= 0L,	dontWantSize				= 0L,	dontWantAttributes			= 0L,	dontWantIndex				= 0L,	dontWantData				= 0L};enum  {	noCollectionAttributes		= 0x00000000,	allCollectionAttributes		= 0xFFFFFFFF,	userCollectionAttributes	= 0x0000FFFF,	defaultCollectionAttributes	= 0x40000000};enum  {	collectionUser0Bit			= 0,	collectionUser1Bit			= 1,	collectionUser2Bit			= 2,	collectionUser3Bit			= 3,	collectionUser4Bit			= 4,	collectionUser5Bit			= 5,	collectionUser6Bit			= 6,	collectionUser7Bit			= 7,	collectionUser8Bit			= 8,	collectionUser9Bit			= 9,	collectionUser10Bit			= 10,	collectionUser11Bit			= 11,	collectionUser12Bit			= 12,	collectionUser13Bit			= 13,	collectionUser14Bit			= 14,	collectionUser15Bit			= 15,	collectionReserved0Bit		= 16,	collectionReserved1Bit		= 17,	collectionReserved2Bit		= 18,	collectionReserved3Bit		= 19,	collectionReserved4Bit		= 20,	collectionReserved5Bit		= 21,	collectionReserved6Bit		= 22,	collectionReserved7Bit		= 23,	collectionReserved8Bit		= 24,	collectionReserved9Bit		= 25,	collectionReserved10Bit		= 26,	collectionReserved11Bit		= 27,	collectionReserved12Bit		= 28,	collectionReserved13Bit		= 29,	collectionPersistenceBit	= 30,	collectionLockBit			= 31};enum  {	collectionUser0Mask			= 1L << collectionUser0Bit,	collectionUser1Mask			= 1L << collectionUser1Bit,	collectionUser2Mask			= 1L << collectionUser2Bit,	collectionUser3Mask			= 1L << collectionUser3Bit,	collectionUser4Mask			= 1L << collectionUser4Bit,	collectionUser5Mask			= 1L << collectionUser5Bit,	collectionUser6Mask			= 1L << collectionUser6Bit,	collectionUser7Mask			= 1L << collectionUser7Bit,	collectionUser8Mask			= 1L << collectionUser8Bit,	collectionUser9Mask			= 1L << collectionUser9Bit,	collectionUser10Mask		= 1L << collectionUser10Bit,	collectionUser11Mask		= 1L << collectionUser11Bit,	collectionUser12Mask		= 1L << collectionUser12Bit,	collectionUser13Mask		= 1L << collectionUser13Bit,	collectionUser14Mask		= 1L << collectionUser14Bit,	collectionUser15Mask		= 1L << collectionUser15Bit,	collectionReserved0Mask		= 1L << collectionReserved0Bit,	collectionReserved1Mask		= 1L << collectionReserved1Bit,	collectionReserved2Mask		= 1L << collectionReserved2Bit,	collectionReserved3Mask		= 1L << collectionReserved3Bit,	collectionReserved4Mask		= 1L << collectionReserved4Bit,	collectionReserved5Mask		= 1L << collectionReserved5Bit,	collectionReserved6Mask		= 1L << collectionReserved6Bit,	collectionReserved7Mask		= 1L << collectionReserved7Bit,	collectionReserved8Mask		= 1L << collectionReserved8Bit,	collectionReserved9Mask		= 1L << collectionReserved9Bit,	collectionReserved10Mask	= 1L << collectionReserved10Bit,	collectionReserved11Mask	= 1L << collectionReserved11Bit,	collectionReserved12Mask	= 1L << collectionReserved12Bit,	collectionReserved13Mask	= 1L << collectionReserved13Bit,	collectionPersistenceMask	= 1L << collectionPersistenceBit,	collectionLockMask			= 1L << collectionLockBit};#define collectionManagerTrap 0xABF6typedef struct PrivateCollectionRecord *Collection;typedef long CollectionTag;typedef pascal OSErr (*CollectionFlattenProcPtr)(long size, void *data, void *refCon);enum {	uppCollectionFlattenProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(void*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(void*)))};#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr CollectionFlattenUPP;#define CallCollectionFlattenProc(userRoutine, size, data, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppCollectionFlattenProcInfo, (size), (data), (refCon))#define NewCollectionFlattenProc(userRoutine)		\		(CollectionFlattenUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppCollectionFlattenProcInfo, GetCurrentISA())#elsetypedef CollectionFlattenProcPtr CollectionFlattenUPP;#define CallCollectionFlattenProc(userRoutine, size, data, refCon)		\		(*(userRoutine))((size), (data), (refCon))#define NewCollectionFlattenProc(userRoutine)		\		(CollectionFlattenUPP)(userRoutine)#endiftypedef CollectionFlattenProcPtr CollectionFlattenProc;typedef pascal OSErr (*CollectionExceptionProcPtr)(Collection c, OSErr status);enum {	uppCollectionExceptionProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Collection)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(OSErr)))};#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr CollectionExceptionUPP;#define CallCollectionExceptionProc(userRoutine, c, status)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppCollectionExceptionProcInfo, (c), (status))#define NewCollectionExceptionProc(userRoutine)		\		(CollectionExceptionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppCollectionExceptionProcInfo, GetCurrentISA())#elsetypedef CollectionExceptionProcPtr CollectionExceptionUPP;#define CallCollectionExceptionProc(userRoutine, c, status)		\		(*(userRoutine))((c), (status))#define NewCollectionExceptionProc(userRoutine)		\		(CollectionExceptionUPP)(userRoutine)#endiftypedef CollectionExceptionProcPtr CollectionExceptionProc;#ifdef __cplusplusextern "C" {#endifextern pascal Collection NewCollection(void) TWOWORDINLINE(0x7000, 0xABF6);extern pascal void DisposeCollection(Collection) TWOWORDINLINE(0x7001, 0xABF6);extern pascal Collection CloneCollection(Collection) TWOWORDINLINE(0x7002, 0xABF6);extern pascal long CountCollectionOwners(Collection) TWOWORDINLINE(0x7003, 0xABF6);extern pascal Collection CopyCollection(Collection srcCollection, Collection dstCollection) TWOWORDINLINE(0x7004, 0xABF6);extern pascal long GetCollectionDefaultAttributes(Collection) TWOWORDINLINE(0x7005, 0xABF6);extern pascal void SetCollectionDefaultAttributes(Collection, long whichAttributes, long newAttributes) TWOWORDINLINE(0x7006, 0xABF6);extern pascal long CountCollectionItems(Collection) TWOWORDINLINE(0x7007, 0xABF6);extern pascal OSErr AddCollectionItem(Collection, CollectionTag, long id, long itemSize, void *itemData) TWOWORDINLINE(0x7008, 0xABF6);extern pascal OSErr GetCollectionItem(Collection, CollectionTag, long id, long *itemSize, void *itemData) TWOWORDINLINE(0x7009, 0xABF6);extern pascal OSErr RemoveCollectionItem(Collection, CollectionTag, long id) TWOWORDINLINE(0x700A, 0xABF6);extern pascal OSErr SetCollectionItemInfo(Collection, CollectionTag, long id, long whichAttributes, long newAttributes) TWOWORDINLINE(0x700B, 0xABF6);extern pascal OSErr GetCollectionItemInfo(Collection, CollectionTag, long id, long *index, long *itemSize, long *attributes) TWOWORDINLINE(0x700C, 0xABF6);extern pascal OSErr ReplaceIndexedCollectionItem(Collection, long index, long itemSize, void *itemData) TWOWORDINLINE(0x700D, 0xABF6);extern pascal OSErr GetIndexedCollectionItem(Collection, long index, long *itemSize, void *itemData) TWOWORDINLINE(0x700E, 0xABF6);extern pascal OSErr RemoveIndexedCollectionItem(Collection, long index) TWOWORDINLINE(0x700F, 0xABF6);extern pascal OSErr SetIndexedCollectionItemInfo(Collection, long index, long whichAttributes, long newAttributes) TWOWORDINLINE(0x7010, 0xABF6);extern pascal OSErr GetIndexedCollectionItemInfo(Collection, long index, CollectionTag *, long *id, long *itemSize, long *attributes) TWOWORDINLINE(0x7011, 0xABF6);extern pascal Boolean CollectionTagExists(Collection, CollectionTag) TWOWORDINLINE(0x7012, 0xABF6);extern pascal long CountCollectionTags(Collection) TWOWORDINLINE(0x7013, 0xABF6);extern pascal OSErr GetIndexedCollectionTag(Collection, long whichTag, CollectionTag *) TWOWORDINLINE(0x7014, 0xABF6);extern pascal long CountTaggedCollectionItems(Collection, CollectionTag) TWOWORDINLINE(0x7015, 0xABF6);extern pascal OSErr GetTaggedCollectionItem(Collection, CollectionTag, long whichItem, long *itemSize, void *itemData) TWOWORDINLINE(0x7016, 0xABF6);extern pascal OSErr GetTaggedCollectionItemInfo(Collection, CollectionTag, long whichItem, long *id, long *index, long *itemSize, long *attributes) TWOWORDINLINE(0x7017, 0xABF6);extern pascal void PurgeCollection(Collection, long whichAttributes, long matchingAttributes) TWOWORDINLINE(0x7018, 0xABF6);extern pascal void PurgeCollectionTag(Collection, CollectionTag) TWOWORDINLINE(0x7019, 0xABF6);extern pascal void EmptyCollection(Collection) TWOWORDINLINE(0x701A, 0xABF6);extern pascal OSErr FlattenCollection(Collection, CollectionFlattenProc, void *refCon) TWOWORDINLINE(0x701B, 0xABF6);extern pascal OSErr FlattenPartialCollection(Collection, CollectionFlattenProc, void *refCon, long whichAttributes, long matchingAttributes) TWOWORDINLINE(0x701C, 0xABF6);extern pascal OSErr UnflattenCollection(Collection, CollectionFlattenProc, void *refCon) TWOWORDINLINE(0x701D, 0xABF6);extern pascal CollectionExceptionProc GetCollectionExceptionProc(Collection) TWOWORDINLINE(0x701E, 0xABF6);extern pascal void SetCollectionExceptionProc(Collection, CollectionExceptionProc) TWOWORDINLINE(0x701F, 0xABF6);extern pascal Collection GetNewCollection(short collectionID) TWOWORDINLINE(0x7020, 0xABF6);extern pascal OSErr AddCollectionItemHdl(Collection aCollection, CollectionTag tag, long id, Handle itemData) TWOWORDINLINE(0x7021, 0xABF6);extern pascal OSErr GetCollectionItemHdl(Collection aCollection, CollectionTag tag, long id, Handle itemData) TWOWORDINLINE(0x7022, 0xABF6);extern pascal OSErr ReplaceIndexedCollectionItemHdl(Collection aCollection, long index, Handle itemData) TWOWORDINLINE(0x7023, 0xABF6);extern pascal OSErr GetIndexedCollectionItemHdl(Collection aCollection, long index, Handle itemData) TWOWORDINLINE(0x7024, 0xABF6);extern pascal OSErr FlattenCollectionToHdl(Collection aCollection, Handle flattened) TWOWORDINLINE(0x7025, 0xABF6);extern pascal OSErr UnflattenCollectionFromHdl(Collection aCollection, Handle flattened) TWOWORDINLINE(0x7026, 0xABF6);#ifdef __cplusplus}#endif#endif