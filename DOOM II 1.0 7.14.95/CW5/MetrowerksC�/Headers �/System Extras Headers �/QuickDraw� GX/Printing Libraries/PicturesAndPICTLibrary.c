/*	Libraries for dealing with pictures within PICTs	copyright © 1992 Apple Computer, Inc.	All rights reserved.			Routines in this library:		PictureToPICT 		- creates a PICT with an embedded picture shape*/#include <Types.h>#include <Quickdraw.h>#include <ToolUtils.h>#include <Memory.h>#include "graphics routines.h"#include "graphics toolbox.h"#include "math routines.h"#include "storage library.h"#include "offscreen library.h"#include "qd library.h"#include <PrintingLibraries.h>//-----------------------------------------------------------------------------// INTERNAL TYPEDEFS AND DEFINES//-----------------------------------------------------------------------------// IDs for the PicComments#define shapeSignature	'qdgx'#define shapeBegin		500#define shapeEnd		501// typedefs for the new PicCommentstypedef struct 	{	OSType		signature;		// always == shapeSignature	short		kind;			// always == shapeBegin	Rect		bounds;			// bounds of shape @ 72 dpi	char		data[1];		// flattened shape data, total size of record determines								// size	} ShapeBeginRecord, *ShapeBeginPtr, **ShapeBeginHdl;	typedef struct	{	OSType		signature;		// always == shapeSignature	short		kind;			// always == shapeEnd	} ShapeEndRecord, *ShapeEndPtr, **ShapeEndHdl;//-----------------------------------------------------------------------------PicHandle	PictureToPICT(gxShape theShape, Boolean simpleProxy)/*	This library routine turns a QuickDraw GXª shape into a QuickDraw PICT.	It does this using three steps:		1)  it emits a QuickDraw PicComment, and places the flattened GX data into			the comment.		2)	it converts the GX picture into a QuickDraw proxy.  It uses a rectangle			with an 'X' through it if simpleProxy is true.  Otherwise, it uses a 1 bit			bitmap rendition of the shape.		3)	it emits a QuickDraw PictComment, marking the end of the QuickDraw proxy.			The resulting PICT can be cut & pasted, or saved into a PICT file.  On a system	with QuickDraw GXª installed, the GX data will be used when printing.  	When printing on other systems, the QuickDraw proxy will be used.		The proxy is always used for display from within non-GX applications.*/{	gxGraphicsError		gxErr = noErr;	PicHandle			thePicture;	Rect				picRect;	ShapeBeginRecord	theBegin;	Handle				hBegin;	gxRectangle			shapeBounds;			// get the location of the shape	GXGetShapeDeviceBounds(theShape, 0, 0, &shapeBounds);		picRect.left 	= FixedToInt(shapeBounds.left);	picRect.top 	= FixedToInt(shapeBounds.top);	picRect.right 	= FixedToInt(shapeBounds.right);	picRect.bottom 	= FixedToInt(shapeBounds.bottom);	GlobalToLocal((Point*) &picRect.top);	GlobalToLocal((Point*) &picRect.bottom);			thePicture = OpenPicture(&picRect);	if (thePicture != nil)		{		// use a standard clipping and pen mode		ClipRect(&picRect);		PenNormal();				// flatten our shape out into a handle		hBegin = ShapeToHandle(theShape);		if (hBegin != nil)			{			// add the comment to the begining of the handle			theBegin.signature 	= shapeSignature;			theBegin.kind 		= shapeBegin;			theBegin.bounds 	= picRect;			Munger(hBegin, 0, nil, 0, &theBegin, sizeof(OSType) + sizeof(short) + sizeof(Rect) );			gxErr = MemError();					// store the shape/handle into the picture			PicComment(shapeBegin, GetHandleSize(hBegin), hBegin);			DisposHandle(hBegin);						// Send the dimensions of the shape at 72 dpi			PenMode(23);			FrameRect(&picRect);			PenNormal();			}		else			gxErr = MemError();			if (gxErr == noErr)			{			if (simpleProxy)				{				// our proxy is just a framed rect with an X through it				FrameRect(&picRect);				MoveTo(picRect.left, 	picRect.top);				LineTo(picRect.right, 	picRect.bottom);				MoveTo(picRect.right, 	picRect.top);				LineTo(picRect.left, 	picRect.bottom);				}			else				{				// our proxy is a bitmap of the GX object				gxBitmap		theBits;				gxShape			theBitmap;				theBits.width 		= picRect.right - picRect.left;				theBits.height 		= picRect.bottom - picRect.top;				theBits.pixelSize 	= 1;				theBits.rowBytes	= ((theBits.width + 31) >> 5) << 2;				theBits.image 		= NewPtrClear(theBits.height * theBits.rowBytes);				theBits.space 		= gxIndexedSpace;				theBits.set 		= nil;				theBits.profile 	= nil;								gxErr = MemError();				if (gxErr == noErr)					{					theBitmap = GXNewBitmap(&theBits, nil);					GXMoveTransformTo(GXGetShapeTransform(theBitmap), -shapeBounds.left, -shapeBounds.top);					GXGetGraphicsError(&gxErr);					if (gxErr == noErr)						{						BitMap		qdBits;												// put the shape into the bitmap						CopyToBitmaps(theBitmap, theShape);						ConvertToQDBitmap(&theBits, &qdBits);						GXGetGraphicsError(&gxErr);																								// now done with the bitmap						GXDisposeShape(theBitmap);						// CopyBits it into the picture						CopyBits(&qdBits, &qd.thePort->portBits, &qdBits.bounds, &picRect, srcOr, nil);												}											// and done with the image					DisposePtr(theBits.image);					}				}						// mark the end of our shape's proxy			PicComment(shapeEnd, 0, (Handle) nil);			}				ClosePicture();		}	else		gxErr = MemError();			// if we had a problem, return a nil picture	if ( ( gxErr != noErr ) && thePicture )		{		KillPicture(thePicture);		thePicture = nil;		}			return(thePicture);	} // PictureToPICT