/*	File:		DigitalSignature.h	Copyright:	© 1984-1993 by Apple Computer, Inc., all rights reserved.	WARNING	This file was auto generated by the interfacer tool. Modifications	must be made to the master file.*/#ifndef __DIGITALSIGNATURE__#define __DIGITALSIGNATURE__#ifndef __FILES__#include <Files.h>/*	#include <Types.h>											*//*		#include <ConditionalMacros.h>							*//*		#include <MixedMode.h>									*//*			#include <Traps.h>									*//*	#include <OSUtils.h>										*//*	#include <SegLoad.h>										*/#endif#ifndef __MEMORY__#include <Memory.h>#endif#ifndef __TYPES__#endif/* —————————————————————————— MACROS AND TRAP SELECTORS —————————————————————————— */#define __DigitalSignature(count, selector) = { 0x203C, count, selector, 0xAA5D}#define kSIGNewContext 1900#define kSIGDisposeContext 1901#define kSIGSignPrepare 1902#define kSIGSign 1903#define kSIGVerifyPrepare 1904#define kSIGVerify 1905#define kSIGDigestPrepare 1906#define kSIGDigest 1907#define kSIGProcessData 1908#define kSIGShowSigner 1909#define kSIGGetSignerInfo 1910#define kSIGGetCertInfo 1911#define kSIGGetCertNameAttributes 1912#define kSIGGetCertIssuerNameAttributes 1913#define kSIGFileIsSigned 2500#define kSIGSignFile 2501#define kSIGVerifyFile 2502/* values of SIGNameAttributeType */enum  {	kSIGCountryCode,	kSIGOrganization,	kSIGStreetAddress,	kSIGState,	kSIGLocality,	kSIGCommonName,	kSIGTitle,	kSIGOrganizationUnit,	kSIGPostalCode};typedef unsigned short SIGNameAttributeType;/* Certificate status codes returned in SIGCertInfo or SIGSignerInfo fromeither SIGGetCertInfo or SIGGetSignerInfo respectively. kSIGValid means thatthe certificate is currently valid. kSIGPending means the certificate iscurrently not valid - but will be.  kSIGExpired means the certificate hasexpired. A time is always associated with a SIGCertStatus.  In each case thetime has a specific interpretation.  When the status is kSIGValid the time iswhen the certificate will expire. When the status is kSIGPending the time iswhen the certificate will become valid. When the status is kSIGExpired the timeis when the certificate expired. In the SIGCertInfo structure, the startDateand endDate fields hold the appropriate date information.  In the SIGSignerInfostructure, this information is provided in the certSetStatusTime field. In theSIGSignerInfo struct, the status time is actually represented by the SIGSignatureStatusfield which can contain any of the types below. NOTE: The only time you will get a kSIGInvalid status is when it pertains to a SIGSignatureStatus field and only whenyou get a signature that was created after the certificates expiration date, somethingwe are not allowing on the Mac but that may not be restricted on other platforms. Also, it will not be possible to get a kSIGPending value for SIGSignatureStatus on the Mac butpossibly allowed by other platforms.*//* Values for SIGCertStatus or SIGSignatureStatus */enum  {	kSIGValid,	kSIGPending,	kSIGExpired,	kSIGInvalid};typedef unsigned short SIGCertStatus;typedef unsigned short SIGSignatureStatus;/* Gestalt selector code - returns toolbox version in low-order word */#define gestaltDigitalSignatureVersion 'dsig'/* Number of bytes needed for a digest record when using SIGDigest */#define kSIGDigestSize 16typedef Byte SIGDigestData[16], *SIGDigestDataPtr;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct SIGCertInfo {	unsigned long				startDate;	unsigned long				endDate;	SIGCertStatus				certStatus;	unsigned long				certAttributeCount;	unsigned long				issuerAttributeCount;	Str255						serialNumber;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct SIGCertInfo SIGCertInfo;typedef SIGCertInfo *SIGCertInfoPtr;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct SIGSignerInfo {	unsigned long				signingTime;	unsigned long				certCount;	unsigned long				certSetStatusTime;	SIGSignatureStatus			signatureStatus;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct SIGSignerInfo SIGSignerInfo;typedef SIGSignerInfo *SIGSignerInfoPtr;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct SIGNameAttributesInfo {	Boolean						onNewLevel;	SIGNameAttributeType		attributeType;	ScriptCode					attributeScript;	Str255						attribute;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct SIGNameAttributesInfo SIGNameAttributesInfo;typedef SIGNameAttributesInfo *SIGNameAttributesInfoPtr;typedef Ptr SIGContextPtr;typedef Ptr SIGSignaturePtr;/*Certificates are always in order. That is, the signers cert is always 0, theissuer of the signers cert is always 1 etc… to the number of certificates-1.You can use this constant for readability in your code.*/#define kSIGSignerCertIndex 0/*Call back procedure supplied by developer, return false to cancel the currentprocess.*/typedef pascal Boolean (*SIGStatusProcPtr)(void);enum {	uppSIGStatusProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))};#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr SIGStatusUPP;#define CallSIGStatusProc(userRoutine)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSIGStatusProcInfo)#define NewSIGStatusProc(userRoutine)		\		(SIGStatusUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSIGStatusProcInfo, GetCurrentISA())#elsetypedef SIGStatusProcPtr SIGStatusUPP;#define CallSIGStatusProc(userRoutine)		\		(*(userRoutine))()#define NewSIGStatusProc(userRoutine)		\		(SIGStatusUPP)(userRoutine)#endif/*Resource id's of standard signature icon suite, all sizes and colors are available.*/#define kSIGSignatureIconResID -16800#define kSIGValidSignatureIconResID -16799#define kSIGInvalidSignatureIconResID -16798/* ——————————————————————————————— CONTEXT CALLS ——————————————————————————————— *//*To use the Digital Signature toolbox you will need a SIGContextPtr.  To createa SIGContextPtr you simply call SIGNewContext and it will create and initializea context for you.  To free the memory occupied by the context and invalidateits internal data, call SIGDisposeContext. An initialized context has no notionof the type of operation it will be performing however, once you callSIGSignPrepare SIGVerifyPrepare, or SIGDigestPrepare, the contexts operationtype is set and to switch  to another type of operation will require creating anew context. Be sure to pass the same context to corresponding toolbox calls(ie SIGSignPrepare, SIGProcessData, SIGSign)  in other words mixing lets saysigning and verify calls with the same context is not allowed.*/#ifdef __cplusplusextern "C" {#endifextern pascal OSErr SIGNewContext(SIGContextPtr *context) FOURWORDINLINE(0x203C, 2, 1900, 0xAA5D);extern pascal OSErr SIGDisposeContext(SIGContextPtr context) FOURWORDINLINE(0x203C, 2, 1901, 0xAA5D);extern pascal OSErr SIGSignPrepare(SIGContextPtr context, const FSSpec *signerFile, ConstStr255Param prompt, Size *signatureSize) FOURWORDINLINE(0x203C, 8, 1902, 0xAA5D);extern pascal OSErr SIGSign(SIGContextPtr context, SIGSignaturePtr signature, SIGStatusUPP statusProc) FOURWORDINLINE(0x203C, 6, 1903, 0xAA5D);extern pascal OSErr SIGVerifyPrepare(SIGContextPtr context, SIGSignaturePtr signature, Size signatureSize, SIGStatusUPP statusProc) FOURWORDINLINE(0x203C, 8, 1904, 0xAA5D);extern pascal OSErr SIGVerify(SIGContextPtr context) FOURWORDINLINE(0x203C, 2, 1905, 0xAA5D);extern pascal OSErr SIGDigestPrepare(SIGContextPtr context) FOURWORDINLINE(0x203C, 2, 1906, 0xAA5D);extern pascal OSErr SIGDigest(SIGContextPtr context, SIGDigestData digest) FOURWORDINLINE(0x203C, 4, 1907, 0xAA5D);extern pascal OSErr SIGProcessData(SIGContextPtr context, const void *data, Size dataSize) FOURWORDINLINE(0x203C, 6, 1908, 0xAA5D);extern pascal OSErr SIGShowSigner(SIGContextPtr context, ConstStr255Param prompt) FOURWORDINLINE(0x203C, 4, 1909, 0xAA5D);extern pascal OSErr SIGGetSignerInfo(SIGContextPtr context, SIGSignerInfo *signerInfo) FOURWORDINLINE(0x203C, 4, 1910, 0xAA5D);extern pascal OSErr SIGGetCertInfo(SIGContextPtr context, unsigned long certIndex, SIGCertInfo *certInfo) FOURWORDINLINE(0x203C, 6, 1911, 0xAA5D);extern pascal OSErr SIGGetCertNameAttributes(SIGContextPtr context, unsigned long certIndex, unsigned long attributeIndex, SIGNameAttributesInfo *attributeInfo) FOURWORDINLINE(0x203C, 8, 1912, 0xAA5D);extern pascal OSErr SIGGetCertIssuerNameAttributes(SIGContextPtr context, unsigned long certIndex, unsigned long attributeIndex, SIGNameAttributesInfo *attributeInfo) FOURWORDINLINE(0x203C, 8, 1913, 0xAA5D);extern pascal OSErr SIGFileIsSigned(const FSSpec *fileSpec) FOURWORDINLINE(0x203C, 2, 2500, 0xAA5D);extern pascal OSErr SIGSignFile(SIGContextPtr context, Size signatureSize, const FSSpec *fileSpec, SIGStatusUPP statusProc) FOURWORDINLINE(0x203C, 8, 2501, 0xAA5D);extern pascal OSErr SIGVerifyFile(SIGContextPtr context, const FSSpec *fileSpec, SIGStatusUPP statusProc) FOURWORDINLINE(0x203C, 6, 2502, 0xAA5D);#ifdef __cplusplus}#endif#endif