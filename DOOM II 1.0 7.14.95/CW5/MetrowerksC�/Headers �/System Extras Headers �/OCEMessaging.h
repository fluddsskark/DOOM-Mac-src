/*	File:		OCEMessaging.h	Copyright:	© 1984-1993 by Apple Computer, Inc., all rights reserved.	WARNING	This file was auto generated by the interfacer tool. Modifications	must be made to the master file.*/#ifndef __OCEMESSAGING__#define __OCEMESSAGING__#ifndef __DIGITALSIGNATURE__#include "DigitalSignature.h"/*	#include <Files.h>											*//*		#include <Types.h>										*//*			#include <ConditionalMacros.h>						*//*			#include <MixedMode.h>								*//*				#include <Traps.h>								*//*		#include <OSUtils.h>									*//*		#include <SegLoad.h>									*//*	#include <Memory.h>											*/#endif#ifndef __FILES__#endif#ifndef	__OCE__#include "OCE.h"/*	#include <Aliases.h>										*//*		#include <AppleTalk.h>									*//*	#include <AppleEvents.h>									*//*		#include <Events.h>										*//*			#include <Quickdraw.h>								*//*				#include <QuickdrawText.h>						*//*					#include <IntlResources.h>					*//*		#include <EPPC.h>										*//*			#include <PPCToolBox.h>								*//*			#include <Processes.h>								*//*		#include <Notification.h>								*//*	#include <Script.h>											*/#endif#ifndef __OCEAUTHDIR__#include "OCEAuthDir.h"#endif#ifndef __TYPES__#endif/******************************************************************************//* Definitions common to OCEMessaging and to OCEMail. These relate to addressing,message ids and priorities, etc. *//* Values of IPMPriority */enum  {	kIPMAnyPriority				= 0,	kIPMNormalPriority			= 1,	kIPMLowPriority,	kIPMHighPriority};typedef Byte IPMPriority;/* Values of IPMAccessMode */enum  {	kIPMAtMark,	kIPMFromStart,	kIPMFromLEOM,	kIPMFromMark};typedef unsigned short IPMAccessMode;enum  {	kIPMUpdateMsgBit			= 4,	kIPMNewMsgBit				= 5,	kIPMDeleteMsgBit			= 6};/* Values of IPMNotificationType */enum  {	kIPMUpdateMsgMask			= 1 << kIPMUpdateMsgBit,	kIPMNewMsgMask				= 1 << kIPMNewMsgBit,	kIPMDeleteMsgMask			= 1 << kIPMDeleteMsgBit};typedef Byte IPMNotificationType;/* Values of IPMSenderTag */enum  {	kIPMSenderRStringTag,	kIPMSenderRecordIDTag};typedef unsigned short IPMSenderTag;enum  {	kIPMFromDistListBit			= 0,	kIPMDummyRecBit				= 1,	kIPMFeedbackRecBit 			= 2,	/* should be redirected to feedback queue */	kIPMReporterRecBit 			= 3,	/* should be redirected to reporter original queue */	kIPMBCCRecBit 				= 4		/* this recipient is blind to all recipients of message */};/* Values of OCERecipientOffsetFlags */enum  {	kIPMFromDistListMask		= 1 << kIPMFromDistListBit,	kIPMDummyRecMask			= 1 << kIPMDummyRecBit,	kIPMFeedbackRecMask			= 1 << kIPMFeedbackRecBit,	kIPMReporterRecMask			= 1 << kIPMReporterRecBit,	kIPMBCCRecMask				= 1 << kIPMBCCRecBit};typedef Byte OCERecipientOffsetFlags;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct OCECreatorType {	OSType						msgCreator;	OSType						msgType;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct OCECreatorType OCECreatorType;#define kIPMTypeWildCard 'ipmw'#define kIPMFamilyUnspecified 0#define kIPMFamilyWildCard 0x3F3F3F3FL						  /* '????' *//* well known signature */#define kIPMSignature			'ipms'	/* base type *//* well known message types */#define kIPMReportNotify		'rptn'	/* routing feedback *//* well known message block types */#define kIPMEnclosedMsgType		'emsg'	/* enclosed (nested) message */#define kIPMReportInfo			'rpti'	/* recipient information */#define kIPMDigitalSignature 	'dsig'	/* digital signature *//* Values of IPMMsgFormat */enum  {	kIPMOSFormatType			= 1,	kIPMStringFormatType		= 2};typedef unsigned short IPMMsgFormat;typedef Str32 IPMStringMsgType;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMMsgType {	IPMMsgFormat				format;	union {		OCECreatorType				msgOSType;		IPMStringMsgType			msgStrType;	}							theType;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMMsgType IPMMsgType;/*Following are the known extension values for IPM addresses handled by Apple.We define the definition of the entn extension below.*/enum  {	kOCEalanXtn					= 'alan',	kOCEentnXtn					= 'entn',		/* entn = entity name (aka DSSpec) */	kOCEaphnXtn					= 'aphn'};/*Following are the specific definitions for the extension for the standardOCEMail 'entn' addresses.  [Note, the actual extension is formatted as inIPMEntityNameExtension.]*//* entn extension forms */enum  {	kOCEAddrXtn					= 'addr',	kOCEQnamXtn					= 'qnam',	kOCEAttrXtn					= 'attr',		/* an attribute specification */	kOCESpAtXtn					= 'spat'		/* specific attribute */};/*Following are the specific definitions for standardOCEMail 'aphn' extension value.  All RStrings here are packed (e.g. truncated to length) and even padded (e.g.if length odd, then a pad byte (zero) should be introduced before the next field).The extension value is in the packed form of the following structure:	RString		phoneNumber;	RString		modemType;	Str32		queueuName;The body of phoneNumber compound RString is in the packed form of the following structure:	short 		subType;	RString 	countryCode;				// used when subType == kOCEUseHandyDial	RString		areaCode;					// used when subType == kOCEUseHandyDial	RString		phone;						// used when subType == kOCEUseHandyDial	RString		postFix;					// used when subType == kOCEUseHandyDial	RString		nonHandyDialString;			// used when subType == kOCEDontUseHandyDial*//* phoneNumber sub type constants */enum  {	kOCEUseHandyDial			= 1,	kOCEDontUseHandyDial		= 2};/* FORMAT OF A PACKED FORM RECIPIENT */#define OCEPackedRecipientHeader  \	unsigned short	dataLength;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct ProtoOCEPackedRecipient {	unsigned short				dataLength;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct ProtoOCEPackedRecipient ProtoOCEPackedRecipient;#define kOCEPackedRecipientMaxBytes (4096 - sizeof(ProtoOCEPackedRecipient))#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct OCEPackedRecipient {	unsigned short				dataLength;	Byte						data[(4096 - sizeof(ProtoOCEPackedRecipient))];};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct OCEPackedRecipient OCEPackedRecipient;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMEntnQueueExtension {	Str32						queueName;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMEntnQueueExtension IPMEntnQueueExtension;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endif/* kOCEAttrXtn */struct IPMEntnAttributeExtension {	AttributeType				attributeName;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMEntnAttributeExtension IPMEntnAttributeExtension;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endif/* kOCESpAtXtn */struct IPMEntnSpecificAttributeExtension {	AttributeCreationID			attributeCreationID;	AttributeType				attributeName;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMEntnSpecificAttributeExtension IPMEntnSpecificAttributeExtension;/* All IPM entn extensions fit within the following */#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMEntityNameExtension {	OSType						subExtensionType;	union {		IPMEntnSpecificAttributeExtension specificAttribute;		IPMEntnAttributeExtension	attribute;		IPMEntnQueueExtension		queue;	}							u;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMEntityNameExtension IPMEntityNameExtension;/* addresses with kIPMNBPXtn should specify this nbp type */#define kIPMWSReceiverNBPType "\pMsgReceiver"#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMMsgID {	unsigned long				id[4];};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMMsgID IPMMsgID;/* Values of IPMHeaderSelector */enum  {	kIPMTOC						= 0,	kIPMSender					= 1,	kIPMProcessHint				= 2,	kIPMMessageTitle			= 3,	kIPMMessageType				= 4,	kIPMFixedInfo				= 7};typedef Byte IPMHeaderSelector;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMSender {	IPMSenderTag				sendTag;	union {		RString						rString;		PackedRecordID				rid;	}							theSender;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMSender IPMSender;typedef DSSpec OCERecipient;/******************************************************************************//* Definitions specific to OCEMessaging */typedef unsigned long IPMContextRef;typedef unsigned long IPMQueueRef;typedef unsigned long IPMMsgRef;typedef unsigned long IPMSeqNum;typedef Str32 IPMProcHint;typedef Str32 IPMQueueName;typedef pascal void (*IPMNoteProcPtr)(IPMQueueRef queue, IPMSeqNum seqNum, IPMNotificationType notificationType, unsigned long userData);enum {	uppIPMNoteProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(IPMQueueRef)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(IPMSeqNum)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(IPMNotificationType)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(unsigned long)))};#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr IPMNoteUPP;#define CallIPMNoteProc(userRoutine, queue, seqNum, notificationType, userData)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppIPMNoteProcInfo, (queue), (seqNum), (notificationType), (userData))#define NewIPMNoteProc(userRoutine)		\		(IPMNoteUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppIPMNoteProcInfo, GetCurrentISA())#elsetypedef IPMNoteProcPtr IPMNoteUPP;#define CallIPMNoteProc(userRoutine, queue, seqNum, notificationType, userData)		\		(*(userRoutine))((queue), (seqNum), (notificationType), (userData))#define NewIPMNoteProc(userRoutine)		\		(IPMNoteUPP)(userRoutine)#endif#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMFixedHdrInfo {	unsigned short				version;	Boolean						authenticated;	Boolean						signatureEnclosed;		/*  digital signature enclosed */	unsigned long				msgSize;	IPMNotificationType			notification;	IPMPriority					priority;	unsigned short				blockCount;	unsigned short				originalRcptCount;		/*		original number of recipients */	unsigned long				refCon;					/*		Client defined data */	unsigned short				reserved;	UTCTime						creationTime;	IPMMsgID					msgID;	OSType						family;					/* family this msg belongs (e.g. mail) */};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMFixedHdrInfo IPMFixedHdrInfo;enum  {	kIPMDeliveryNotificationBit		= 0,	kIPMNonDeliveryNotificationBit  = 1,	kIPMEncloseOriginalBit			= 2,	kIPMSummaryReportBit			= 3,	kIPMOriginalOnlyOnErrorBit		= 4		/* modify enclose original to only on error */};enum  {	kIPMNoNotificationMask		= 0x00,	kIPMDeliveryNotificationMask = 1 << kIPMDeliveryNotificationBit,	kIPMNonDeliveryNotificationMask = 1 << kIPMNonDeliveryNotificationBit,	kIPMDontEncloseOriginalMask	= 0x00,	kIPMEncloseOriginalMask		= 1 << kIPMEncloseOriginalBit,	kIPMImmediateReportMask		= 0x00,	kIPMSummaryReportMask		= 1 << kIPMSummaryReportBit,	kIPMOriginalOnlyOnErrorMask	= 1 << kIPMOriginalOnlyOnErrorBit,	kIPMEncloseOriginalOnErrorMask = (kIPMOriginalOnlyOnErrorMask|kIPMEncloseOriginalMask)};/* standard Non delivery codes */enum  {	kIPMNoSuchRecipient				= 0x0001,	kIPMRecipientMalformed			= 0x0002,	kIPMRecipientAmbiguous			= 0x0003,	kIPMRecipientAccessDenied		= 0x0004,	kIPMGroupExpansionProblem		= 0x0005,	kIPMMsgUnreadable				= 0x0006,	kIPMMsgExpired					= 0x0007,	kIPMMsgNoTranslatableContent 	= 0x0008,	kIPMRecipientReqStdCont			= 0x0009,	kIPMRecipientReqSnapShot		= 0x000A,	kIPMNoTransferDiskFull			= 0x000B,	kIPMNoTransferMsgRejectedbyDest = 0x000C,	kIPMNoTransferMsgTooLarge		= 0x000D};/*************************************************************************//*This is the structure that will be returned by enumerate and getmsginfoThis definition is just to give you a template, the position of msgTypeis variable since this is a packed structure.  procHint and msgType arepacked and even length padded.*/#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMMsgInfo {	IPMSeqNum					sequenceNum;	unsigned long				userData;	unsigned short				respIndex;	Byte						padByte;	IPMPriority					priority;	unsigned long				msgSize;	unsigned short				originalRcptCount;	unsigned short				reserved;	UTCTime						creationTime;	IPMMsgID					msgID;	OSType						family;			/* family this msg belongs (e.g. mail) */	IPMProcHint					procHint;	IPMMsgType					msgType;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMMsgInfo IPMMsgInfo;typedef OCECreatorType IPMBlockType;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMTOC {	IPMBlockType				blockType;	long						blockOffset;	unsigned long				blockSize;	unsigned long				blockRefCon;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMTOC IPMTOC;/*The following structure is just to describe the layout of the SingleFilter.Each field should be packed and word aligned when passed to the IPM ToolBox.*/#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMSingleFilter {	IPMPriority					priority;	Byte						padByte;	OSType						family;			/* family this msg belongs (e.g. mail), '????' for all */	ScriptCode					script;			/* Language Identifier */	IPMProcHint					hint;	IPMMsgType					msgType;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMSingleFilter IPMSingleFilter;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMFilter {	unsigned short				count;	IPMSingleFilter				sFilters[1];};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMFilter IPMFilter;/*************************************************************************//*Following structures define the ÒstartÓ of a recipient report block and theelements of the array respectively.*/#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMReportBlockHeader {	IPMMsgID					msgID;	UTCTime						creationTime;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMReportBlockHeader IPMReportBlockHeader;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct OCERecipientReport {	unsigned short				rcptIndex;	OSErr						result;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct OCERecipientReport OCERecipientReport;typedef union IPMParamBlock IPMParamBlock;typedef IPMParamBlock *IPMParamBlockPtr;/*	IPMIOCompletionProcs cannot be written in or called from a high-level 	language without the help of mixed mode or assembly glue because they 	use the following parameter-passing convention:	typedef pascal void (*IPMIOCompletionProcPtr)(IPMParamBlockPtr paramBlock);		In:			=> 	paramBlock				A0.L		Out:			none*/enum  {	uppIPMIOCompletionProcInfo		= kRegisterBased|REGISTER_ROUTINE_PARAMETER(1,kRegisterA0,kFourByteCode)};#if USESROUTINEDESCRIPTORStypedef pascal void (*IPMIOCompletionProcPtr)(IPMParamBlockPtr paramBlock);typedef UniversalProcPtr IPMIOCompletionUPP;#define CallIPMIOCompletionProc(userRoutine, paramBlock)  \	CallUniversalProc((UniversalProcPtr)(userRoutine), uppIPMIOCompletionProcInfo, (paramBlock))#define NewIPMIOCompletionProc(userRoutine)  \	(IPMIOCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine),  \	uppIPMIOCompletionProcInfo, GetCurrentISA())#elsetypedef ProcPtr IPMIOCompletionUPP;#define NewIPMIOCompletionProc(userRoutine)  \	(IPMIOCompletionUPP)((userRoutine))#endif#define IPMParamHeader 							\	Ptr					qLink;					\	long				reservedH1;				\	long				reservedH2;				\	IPMIOCompletionUPP	ioCompletion;			\	OSErr				ioResult;				\	long				saveA5;					\	short				reqCode;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMOpenContextPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMContextRef				contextRef;		/* <--  Context reference to be used in further calls*/};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMOpenContextPB IPMOpenContextPB;typedef IPMOpenContextPB IPMCloseContextPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMCreateQueuePB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	long						filler1;	OCERecipient				*queue;	AuthIdentity				identity;		/* used only if queue is remote */	PackedRecordID				*owner;			/* used only if queue is remote */};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMCreateQueuePB IPMCreateQueuePB;/* For createqueue and deletequeue only queue and identity are used */typedef IPMCreateQueuePB IPMDeleteQueuePB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMOpenQueuePB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMContextRef				contextRef;	OCERecipient				*queue;	AuthIdentity				identity;	IPMFilter					*filter;	IPMQueueRef					newQueueRef;	IPMNoteUPP					notificationProc;	unsigned long				userData;	IPMNotificationType			noteType;	Byte						padByte;	long						reserved;	long						reserved2;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMOpenQueuePB IPMOpenQueuePB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMCloseQueuePB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMQueueRef					queueRef;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMCloseQueuePB IPMCloseQueuePB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMEnumerateQueuePB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMQueueRef					queueRef;	IPMSeqNum					startSeqNum;	Boolean						getProcHint;	Boolean						getMsgType;	short						filler;	IPMFilter					*filter;	unsigned short				numToGet;	unsigned short				numGotten;	unsigned long				enumCount;	Ptr							enumBuffer;		/* will be packed array of IPMMsgInfo */	unsigned long				actEnumCount;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMEnumerateQueuePB IPMEnumerateQueuePB;typedef IPMEnumerateQueuePB IPMChangeQueueFilterPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMDeleteMsgRangePB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMQueueRef					queueRef;	IPMSeqNum					startSeqNum;	IPMSeqNum					endSeqNum;	IPMSeqNum					lastSeqNum;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMDeleteMsgRangePB IPMDeleteMsgRangePB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMOpenMsgPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMQueueRef					queueRef;	IPMSeqNum					sequenceNum;	IPMMsgRef					newMsgRef;	IPMSeqNum					actualSeqNum;	Boolean						exactMatch;	Byte						padByte;	long						reserved;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMOpenMsgPB IPMOpenMsgPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMOpenHFSMsgPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	FSSpec						*hfsPath;	long						filler;	IPMMsgRef					newMsgRef;	long						filler2;	Byte						filler3;	long						reserved;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMOpenHFSMsgPB IPMOpenHFSMsgPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMOpenBlockAsMsgPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	unsigned long				filler;	IPMMsgRef					newMsgRef;	unsigned short				filler2[7];	unsigned short				blockIndex;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMOpenBlockAsMsgPB IPMOpenBlockAsMsgPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMCloseMsgPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	Boolean						deleteMsg;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMCloseMsgPB IPMCloseMsgPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMGetMsgInfoPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	IPMMsgInfo					*info;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMGetMsgInfoPB IPMGetMsgInfoPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMReadHeaderPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	unsigned short				fieldSelector;	long						offset;	unsigned long				count;	Ptr							buffer;	unsigned long				actualCount;	unsigned short				filler;	unsigned long				remaining;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMReadHeaderPB IPMReadHeaderPB;/*replyQueue works like recipient. [can no longer read it via ReadHeader]OriginalIndex is meaningless, rcptFlags are used seperately and there arecurrently none defined.*/#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMReadRecipientPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	unsigned short				rcptIndex;	long						offset;	unsigned long				count;	Ptr							buffer;	unsigned long				actualCount;	short						reserved;			/* must be zero */	unsigned long				remaining;	unsigned short				originalIndex;	OCERecipientOffsetFlags		recipientOffsetFlags;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMReadRecipientPB IPMReadRecipientPB;typedef IPMReadRecipientPB IPMReadReplyQueuePB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMGetBlkIndexPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	IPMBlockType				blockType;	unsigned short				index;	unsigned short				startingFrom;	IPMBlockType				actualBlockType;	unsigned short				actualBlockIndex;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMGetBlkIndexPB IPMGetBlkIndexPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMReadMsgPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	IPMAccessMode				mode;	long						offset;	unsigned long				count;	Ptr							buffer;	unsigned long				actualCount;	unsigned short				blockIndex;	unsigned long				remaining;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMReadMsgPB IPMReadMsgPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMVerifySignaturePB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	SIGContextPtr				signatureContext;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMVerifySignaturePB IPMVerifySignaturePB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMNewMsgPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	unsigned long				filler;	OCERecipient				*recipient;	OCERecipient				*replyQueue;	StringPtr					procHint;	unsigned short				filler2;	IPMMsgType					*msgType;	unsigned long				refCon;	IPMMsgRef					newMsgRef;	unsigned short				filler3;	long						filler4;	AuthIdentity				identity;	IPMSender					*sender;	unsigned long				internalUse;	unsigned long				internalUse2;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMNewMsgPB IPMNewMsgPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMNewHFSMsgPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	FSSpec						*hfsPath;	OCERecipient				*recipient;	OCERecipient				*replyQueue;	StringPtr					procHint;	unsigned short				filler2;	IPMMsgType					*msgType;	unsigned long				refCon;	IPMMsgRef					newMsgRef;	unsigned short				filler3;	long						filler4;	AuthIdentity				identity;	IPMSender					*sender;	unsigned long				internalUse;	unsigned long				internalUse2;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMNewHFSMsgPB IPMNewHFSMsgPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMNestMsgPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	unsigned short				filler[9];	unsigned long				refCon;	IPMMsgRef					msgToNest;	unsigned short				filler2;	long						startingOffset;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMNestMsgPB IPMNestMsgPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMNewNestedMsgBlockPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	OCERecipient				*recipient;	OCERecipient				*replyQueue;	StringPtr					procHint;	unsigned short				filler1;	IPMMsgType					*msgType;	unsigned long				refCon;	IPMMsgRef					newMsgRef;	unsigned short				filler2;	long						startingOffset;	AuthIdentity				identity;	IPMSender					*sender;	unsigned long				internalUse;	unsigned long				internalUse2;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMNewNestedMsgBlockPB IPMNewNestedMsgBlockPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMEndMsgPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	IPMMsgID					msgID;	RString						*msgTitle;	IPMNotificationType			deliveryNotification;	IPMPriority					priority;	Boolean						cancel;	Byte						padByte;	long						reserved;	SIGSignaturePtr				signature;	Size						signatureSize;	SIGContextPtr				signatureContext;	OSType						family;			/* family this msg belongs (e.g. mail) */												/* use kIPMFamilyUnspecified by default */};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMEndMsgPB IPMEndMsgPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMAddRecipientPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	OCERecipient				*recipient;	long						reserved;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMAddRecipientPB IPMAddRecipientPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMAddReplyQueuePB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	long						filler;	OCERecipient				*replyQueue;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMAddReplyQueuePB IPMAddReplyQueuePB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMNewBlockPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	IPMBlockType				blockType;	unsigned short				filler[5];	unsigned long				refCon;	unsigned short				filler2[3];	long						startingOffset;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMNewBlockPB IPMNewBlockPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct IPMWriteMsgPB {	Ptr							qLink;	long						reservedH1;	long						reservedH2;	IPMIOCompletionUPP			ioCompletion;	OSErr						ioResult;	long						saveA5;	short						reqCode;	IPMMsgRef					msgRef;	IPMAccessMode				mode;	long						offset;	unsigned long				count;	Ptr							buffer;	unsigned long				actualCount;	Boolean						currentBlock;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endiftypedef struct IPMWriteMsgPB IPMWriteMsgPB;#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifunion IPMParamBlock {	struct {		Ptr							qLink;		long						reservedH1;		long						reservedH2;		IPMIOCompletionUPP			ioCompletion;		OSErr						ioResult;		long						saveA5;		short						reqCode;	}							header;	IPMOpenContextPB			openContextPB;	IPMCloseContextPB			closeContextPB;	IPMCreateQueuePB			createQueuePB;	IPMDeleteQueuePB			deleteQueuePB;	IPMOpenQueuePB				openQueuePB;	IPMCloseQueuePB				closeQueuePB;	IPMEnumerateQueuePB			enumerateQueuePB;	IPMChangeQueueFilterPB		changeQueueFilterPB;	IPMDeleteMsgRangePB			deleteMsgRangePB;	IPMOpenMsgPB				openMsgPB;	IPMOpenHFSMsgPB				openHFSMsgPB;	IPMOpenBlockAsMsgPB			openBlockAsMsgPB;	IPMCloseMsgPB				closeMsgPB;	IPMGetMsgInfoPB				getMsgInfoPB;	IPMReadHeaderPB				readHeaderPB;	IPMReadRecipientPB			readRecipientPB;	IPMReadReplyQueuePB			readReplyQueuePB;	IPMGetBlkIndexPB			getBlkIndexPB;	IPMReadMsgPB				readMsgPB;	IPMVerifySignaturePB		verifySignaturePB;	IPMNewMsgPB					newMsgPB;	IPMNewHFSMsgPB				newHFSMsgPB;	IPMNestMsgPB				nestMsgPB;	IPMNewNestedMsgBlockPB		newNestedMsgBlockPB;	IPMEndMsgPB					endMsgPB;	IPMAddRecipientPB			addRecipientPB;	IPMAddReplyQueuePB			addReplyQueuePB;	IPMNewBlockPB				newBlockPB;	IPMWriteMsgPB				writeMsgPB;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif/*	Request codes */#define kIPMOpenContext 0x400#define kIPMCloseContext 0x401#define kIPMNewMsg 0x402#define kIPMAddRecipient 0x403#define kIPMNewBlock 0x404#define kIPMNewNestedMsgBlock 0x405#define kIPMNestMsg 0x406#define kIPMWriteMsg 0x407#define kIPMEndMsg 0x408#define kIPMOpenQueue 0x409#define kIPMCloseQueue 0x40A#define kIPMOpenMsg 0x40B#define kIPMCloseMsg 0x40C#define kIPMReadMsg 0x40D#define kIPMReadHeader 0x40E#define kIPMOpenBlockAsMsg 0x40F#define kIPMReadRecipient 0x410#define kIPMCreateQueue 0x411#define kIPMDeleteQueue 0x412#define kIPMEnumerateQueue 0x413#define kIPMChangeQueueFilter 0x414#define kIPMDeleteMsgRange 0x415#define kIPMOpenHFSMsg 0x417#define kIPMGetBlkIndex 0x418#define kIPMGetMsgInfo 0x419#define kIPMAddReplyQueue 0x41D#define kIPMNewHFSMsg 0x41E#define kIPMReadReplyQueue 0x421#define kIPMVerifySignature 0x422#ifdef __cplusplusextern "C" {#endifextern pascal OSErr IPMOpenContext(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x400, 0xAA5E);extern pascal OSErr IPMCloseContext(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x401, 0xAA5E);extern pascal OSErr IPMNewMsg(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x402, 0xAA5E);extern pascal OSErr IPMNewBlock(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x404, 0xAA5E);extern pascal OSErr IPMNewNestedMsgBlock(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x405, 0xAA5E);extern pascal OSErr IPMNestMsg(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x406, 0xAA5E);extern pascal OSErr IPMWriteMsg(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x407, 0xAA5E);extern pascal OSErr IPMEndMsg(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x408, 0xAA5E);extern pascal OSErr IPMOpenQueue(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x409, 0xAA5E);extern pascal OSErr IPMCloseQueue(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x40A, 0xAA5E);/* Always synchronous */extern pascal OSErr IPMVerifySignature(IPMParamBlockPtr paramBlock) FIVEWORDINLINE(0x7000, 0x1f00, 0x3F3C, 0x422, 0xAA5E);extern pascal OSErr IPMOpenMsg(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x40B, 0xAA5E);extern pascal OSErr IPMCloseMsg(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x40C, 0xAA5E);extern pascal OSErr IPMReadMsg(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x40D, 0xAA5E);extern pascal OSErr IPMReadHeader(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x40E, 0xAA5E);extern pascal OSErr IPMOpenBlockAsMsg(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x40F, 0xAA5E);extern pascal OSErr IPMNewHFSMsg(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x41E, 0xAA5E);extern pascal OSErr IPMReadRecipient(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x410, 0xAA5E);extern pascal OSErr IPMReadReplyQueue(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x421, 0xAA5E);extern pascal OSErr IPMCreateQueue(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x411, 0xAA5E);extern pascal OSErr IPMDeleteQueue(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x412, 0xAA5E);extern pascal OSErr IPMEnumerateQueue(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x413, 0xAA5E);extern pascal OSErr IPMChangeQueueFilter(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x414, 0xAA5E);extern pascal OSErr IPMDeleteMsgRange(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x415, 0xAA5E);extern pascal OSErr IPMAddRecipient(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x403, 0xAA5E);extern pascal OSErr IPMAddReplyQueue(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x41D, 0xAA5E);extern pascal OSErr IPMOpenHFSMsg(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x417, 0xAA5E);extern pascal OSErr IPMGetBlkIndex(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x418, 0xAA5E);extern pascal OSErr IPMGetMsgInfo(IPMParamBlockPtr paramBlock, Boolean async) THREEWORDINLINE(0x3F3C, 0x419, 0xAA5E);#ifdef __cplusplus}#endif/****************************************************************************************//* EXTERNAL ROUTINES */#ifndef __OCEMessaging#define __OCEMessaging(selector) = { 0x303C, selector, 0xAA5C}#endif#define kOCESizePackedRecipient 830#define kOCEPackRecipient 831#define kOCEUnpackRecipient 832#define kOCEStreamRecipient 833#define kOCEGetRecipientType 834#define kOCESetRecipientType 835#ifdef __cplusplusextern "C" {#endif/*Compute the space that a OCERecipient would take if it were in packedform.  [Note: does NOT even pad extensionSize, so you may get an odd #back out]Safe to pass dereferenced handle(s).*/extern pascal unsigned short OCESizePackedRecipient(const OCERecipient *rcpt) THREEWORDINLINE(0x303C, 830, 0xAA5C);/*Take an OCERecipient (scatter) and (gather) stream into the specifiedbuffer.  It is assumed that there is sufficient space in the buffer (that isOCESizePackedRecipient).  Safe to pass dereferenced handle(s).*/extern pascal unsigned short OCEPackRecipient(const OCERecipient *rcpt, void *buffer) THREEWORDINLINE(0x303C, 831, 0xAA5C);/*Take a packed OCERecipient and cast a the OCERecipient frame over it. ReturnsamBadDestId if it doesn't look like an OCERecipient. Safe to pass dereferencedhandle(s).*/extern pascal OSErr OCEUnpackRecipient(const void *buffer, OCERecipient *rcpt, RecordID *entitySpecifier) THREEWORDINLINE(0x303C, 832, 0xAA5C);/*Take an OCERecipient (scatter) and (gather) stream using the specifiedfunction.  Safe to pass dereferenced handle(s).  If streamer function returnsOCEError OCEStreamRecipient stops execution and passes the error back to the caller*/typedef pascal OSErr (*OCERecipientStreamer)(void *buffer, unsigned long count, Boolean eof, long userData);extern pascal OSErr OCEStreamRecipient(const OCERecipient *rcpt, OCERecipientStreamer stream, long userData, unsigned long *actualCount) THREEWORDINLINE(0x303C, 833, 0xAA5C);/* Get the OCERecipient's extensionType. Safe to pass dereferenced handle(s).*/extern pascal OSType OCEGetRecipientType(const CreationID *cid) THREEWORDINLINE(0x303C, 834, 0xAA5C);/*Set the OCERecipient's extensionType in the specified cid.  (Note: we do NOTcheck for a nil pointer).  If the extensionType is 'entn', the cid is assumedto be "valid" and is not touched.  Note: to properly handle non 'entn''s thisroutine must and will zero the high long (source) of the cid! Safe to passdereferenced handle(s).*/extern pascal void OCESetRecipientType(OSType extensionType, CreationID *cid) THREEWORDINLINE(0x303C, 835, 0xAA5C);#ifdef __cplusplus}#endif#endif