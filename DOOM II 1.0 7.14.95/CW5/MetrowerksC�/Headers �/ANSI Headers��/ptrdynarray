// ptrdynarray standard header#ifndef _PTRDYNARRAY_#define _PTRDYNARRAY_#include <dynarray>#if __MWERKS__#pragma options align=mac68k#endif  // template class ptrdynarraytemplate<class _T> class ptrdynarray : public dynarray<void *> {public: ptrdynarray()  : dynarray<void *>() {} ptrdynarray(size_t _N, capacity _C)  : dynarray<void *>(_N, _C) {} ptrdynarray(const ptrdynarray<_T>& _X)  : dynarray<void *>(_X) {} ptrdynarray(_T *_X, size_t _N = 1)  : dynarray<void *>((void *)_X, _N) {} ptrdynarray(_T **_S, size_t _N = 1)  : dynarray<void *>((void **)_S, _N) {} ptrdynarray<_T>& operator=(const ptrdynarray<_T>& _R)  {return ((ptrdynarray<_T>&)dynarray<void *>::   operator=((const dynarray<void *>&)_R)); } ptrdynarray<_T>& operator+=(const ptrdynarray<_T>& _R)  {return ((ptrdynarray<_T>&)dynarray<void *>::   operator+=((const dynarray<void *>&)_R)); } ptrdynarray<_T>& operator+=(_T *_R)  {return ((ptrdynarray<_T>&)dynarray<void *>::   operator+=((void *)_R)); } ptrdynarray<_T>& append(_T *_X, size_t _N = 1)  {return ((ptrdynarray<_T>&)dynarray<void *>::   append((void *)_X, _N)); } ptrdynarray<_T>& append(_T **_S, size_t _N = 1)  {return ((ptrdynarray<_T>&)dynarray<void *>::   append((void **)_S, _N)); } ptrdynarray<_T>& assign(_T *_X, size_t _N = 1)  {return ((ptrdynarray<_T>&)dynarray<void *>::   assign((void *)_X, _N)); } ptrdynarray<_T>& assign(_T **_S, size_t _N = 1)  {return ((ptrdynarray<_T>&)dynarray<void *>::   assign((void **)_S, _N)); } ptrdynarray<_T>& insert(size_t _P,  const ptrdynarray<_T>& _X)  {return ((ptrdynarray<_T>&)dynarray<void *>::   insert(_P, (const dynarray<void *>&)_X)); } ptrdynarray<_T>& insert(size_t _P, _T *_X, size_t _N = 1)  {return ((ptrdynarray<_T>&)dynarray<void *>::   insert(_P, (void *)_X, _N)); } ptrdynarray<_T>& insert(size_t _P, _T **_S, size_t _N = 1)  {return ((ptrdynarray<_T>&)dynarray<void *>::   insert(_P, (void **)_S, _N)); } ptrdynarray<_T>& remove(size_t _P = 0, size_t _N = NPOS)  {return ((ptrdynarray<_T>&)dynarray<void *>::   remove(_P, _N)); } ptrdynarray<_T>& sub_array(ptrdynarray<_T>& _X, size_t _P,  size_t _N = NPOS)  {return ((ptrdynarray<_T>&)dynarray<void *>::   sub_array(_X, _P, _N)); } void swap(ptrdynarray<_T>& _X)  {dynarray<void *>::swap(_X); } _T* get_at(size_t _P) const  {return ((_T *)dynarray<void *>::get_at(_P)); } void put_at(size_t _P, _T *_X)  {dynarray<void *>::put_at(_P, (void *)_X); } _T *& operator[](size_t _P)  {return ((_T *&)dynarray<void *>::operator[](_P)); } _T *const& operator[](size_t _P) const  {return ((_T *&)dynarray<void *>::operator[](_P)); } _T **base()  {return ((_T **)dynarray<void *>::base()); } const _T **base() const  {return ((const _T **)dynarray<void *>::base()); } size_t length() const  {return (dynarray<void *>::length()); } void resize(size_t _N)  {dynarray<void *>::resize(_N); } void resize(size_t _N, _T *_X)  {dynarray<void *>::resize(_N, (void *)_X); } size_t reserve() const  {return (dynarray<void *>::reserve()); } void reserve(size_t _N)  {dynarray<void *>::reserve(_N); } };  // template operatorstemplate<class _T> ptrdynarray<_T> operator+(const ptrdynarray<_T>& _L,  const ptrdynarray<_T>& _R) {return (ptrdynarray<_T>(_L) += _R); }template<class _T> ptrdynarray<_T> operator+(const ptrdynarray<_T>& _L, _T *_R) {return (ptrdynarray<_T>(_L) += _R); }template<class _T> ptrdynarray<_T> operator+(_T *_L, const ptrdynarray<_T>& _R) {return (ptrdynarray<_T>(_L) += _R); }#if __MWERKS__#pragma options align=reset#endif#endif/* * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED.  * Consult your license regarding permissions and restrictions. *//* Change log: *94Oct03 Version received from PlumHall *94Oct07 Inserted MW changes. */