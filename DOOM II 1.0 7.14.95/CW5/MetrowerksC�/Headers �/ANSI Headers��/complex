// complex standard header#ifndef _COMPLEX_#define _COMPLEX_#include <istream>#include <ostream>#define __STD_COMPLEX#if __MWERKS__#pragma options align=mac68k#endif		// class float_complexclass float_complex {public:	float_complex(float _R = 0, float _I = 0)		: _Re(_R), _Im(_I) {}	float_complex operator+=(float_complex _R)		{_Re += _R._Real(), _Im += _R._Imag();		return (*this); }	float_complex operator-=(float_complex _R)		{_Re -= _R._Real(), _Im -= _R._Imag();		return (*this); }	float_complex operator*=(float_complex);	float_complex operator/=(float_complex);	float _Real() const		{return (_Re); }	float _Imag() const		{return (_Im); }private:	float _Re, _Im;	};		// class double_complexclass double_complex {public:	double_complex(double _R = 0, double _I = 0)		: _Re(_R), _Im(_I) {}	double_complex operator+=(double_complex _R)		{_Re += _R._Real(), _Im += _R._Imag();		return (*this); }	double_complex operator-=(double_complex _R)		{_Re -= _R._Real(), _Im -= _R._Imag();		return (*this); }	double_complex operator*=(double_complex);	double_complex operator/=(double_complex);	double _Real() const		{return (_Re); }	double _Imag() const		{return (_Im); }private:	double _Re, _Im;	};		// class long_double_complexclass long_double_complex {public:	long_double_complex(long double _R = 0, long double _I = 0)		: _Re(_R), _Im(_I) {}	long_double_complex operator+=(long_double_complex _R)		{_Re += _R._Real(), _Im += _R._Imag();		return (*this); }	long_double_complex operator-=(long_double_complex _R)		{_Re -= _R._Real(), _Im -= _R._Imag();		return (*this); }	long_double_complex operator*=(long_double_complex);	long_double_complex operator/=(long_double_complex);	long double _Real() const		{return (_Re); }	long double _Imag() const		{return (_Im); }private:	long double _Re, _Im;	};		// type definitionstypedef float_complex _FC;typedef double_complex _DC;typedef long_double_complex _LDC;		// float_complex functionsinline float imag(_FC _X)	{return (_X._Imag()); }inline float real(_FC _X)	{return (_X._Real()); }inline _FC _float_complex(const _DC& _X)	{return (_FC((float)_X._Real(), (float)_X._Imag())); }inline _FC _float_complex(const _LDC& _X)	{return (_FC((float)_X._Real(), (float)_X._Imag())); }inline _FC operator+(_FC _L, _FC _R)	{return (_L += _R); }inline _FC operator+(_FC _L, float _R)	{return (_L += _R); }inline _FC operator+(float _L, _FC _R)	{return (_FC(_L) += _R); }inline _FC operator-(_FC _L, _FC _R)	{return (_L -= _R); }inline _FC operator-(_FC _L, float _R)	{return (_L -= _R); }inline _FC operator-(float _L, _FC _R)	{return (_FC(_L) -= _R); }inline _FC operator*(_FC _L, _FC _R)	{return (_L *= _R); }inline _FC operator*(_FC _L, float _R)	{return (_L *= _R); }inline _FC operator*(float _L, _FC _R)	{return (_FC(_L) *= _R); }inline _FC operator/(_FC _L, _FC _R)	{return (_L /= _R); }inline _FC operator/(_FC _L, float _R)	{return (_L /= _R); }inline _FC operator/(float _L, _FC _R)	{return (_FC(_L) /= _R); }inline _FC operator+(_FC _L)	{return (_L); }inline _FC operator-(_FC _L)	{return (_FC(-real(_L), -imag(_L))); }inline _Bool operator==(_FC _L, _FC _R)	{return (real(_L) == real(_R) && imag(_L) == imag(_R)); }inline _Bool operator==(_FC _L, float _R)	{return (real(_L) == _R && imag(_L) == 0); }inline _Bool operator==(float _L, _FC _R)	{return (_L == real(_R) && 0 == imag(_R)); }inline _Bool operator!=(_FC _L, _FC _R)	{return (!(_L == _R)); }inline _Bool operator!=(_FC _L, float _R)	{return (!(_L == _R)); }inline _Bool operator!=(float _L, _FC _R)	{return (!(_L == _R)); }istream& operator>>(istream&, _FC&);ostream& operator<<(ostream&, _FC);float abs(_FC);float arg(_FC);inline _FC conj(_FC _X)	{return (_FC(real(_X), -imag(_X))); }_FC cos(_FC);_FC cosh(_FC);_FC exp(_FC);_FC log(_FC);inline float norm(_FC _X)	{return (real(_X) * real(_X) + imag(_X) * imag(_X)); }_FC polar(float, float);_FC pow(_FC, _FC);_FC pow(_FC, float);_FC pow(_FC, int);_FC pow(float, _FC);_FC sin(_FC);_FC sinh(_FC);_FC sqrt(_FC);		// double_complex functionsinline double imag(_DC _X)	{return (_X._Imag()); }inline double real(_DC _X)	{return (_X._Real()); }inline _DC _double_complex(const _LDC& _X)	{return (_DC((double)_X._Real(), (double)_X._Imag())); }inline _DC operator+(_DC _L, _DC _R)	{return (_L += _R); }inline _DC operator+(_DC _L, double _R)	{return (_L += _R); }inline _DC operator+(double _L, _DC _R)	{return (_DC(_L) += _R); }inline _DC operator-(_DC _L, _DC _R)	{return (_L -= _R); }inline _DC operator-(_DC _L, double _R)	{return (_L -= _R); }inline _DC operator-(double _L, _DC _R)	{return (_DC(_L) -= _R); }inline _DC operator*(_DC _L, _DC _R)	{return (_L *= _R); }inline _DC operator*(_DC _L, double _R)	{return (_L *= _R); }inline _DC operator*(double _L, _DC _R)	{return (_DC(_L) *= _R); }inline _DC operator/(_DC _L, _DC _R)	{return (_L /= _R); }inline _DC operator/(_DC _L, double _R)	{return (_L /= _R); }inline _DC operator/(double _L, _DC _R)	{return (_DC(_L) /= _R); }inline _DC operator+(_DC _L)	{return (_L); }inline _DC operator-(_DC _L)	{return (_DC(-real(_L), -imag(_L))); }inline _Bool operator==(_DC _L, _DC _R)	{return (real(_L) == real(_R) && imag(_L) == imag(_R)); }inline _Bool operator==(_DC _L, double _R)	{return (real(_L) == _R && imag(_L) == 0); }inline _Bool operator==(double _L, _DC _R)	{return (_L == real(_R) && 0 == imag(_R)); }inline _Bool operator!=(_DC _L, _DC _R)	{return (!(_L == _R)); }inline _Bool operator!=(_DC _L, double _R)	{return (!(_L == _R)); }inline _Bool operator!=(double _L, _DC _R)	{return (!(_L == _R)); }istream& operator>>(istream&, _DC&);ostream& operator<<(ostream&, _DC);double abs(_DC);double arg(_DC);inline _DC conj(_DC _X)	{return (_DC(real(_X), -imag(_X))); }_DC cos(_DC);_DC cosh(_DC);_DC exp(_DC);_DC log(_DC);inline double norm(_DC _X)	{return (real(_X) * real(_X) + imag(_X) * imag(_X)); }_DC polar(double, double);_DC pow(_DC, _DC);_DC pow(_DC, double);_DC pow(_DC, int);_DC pow(double, _DC);_DC sin(_DC);_DC sinh(_DC);_DC sqrt(_DC);		// long_double_complex functionsinline long double imag(_LDC _X)	{return (_X._Imag()); }inline long double real(_LDC _X)	{return (_X._Real()); }inline _LDC operator+(_LDC _L, _LDC _R)	{return (_L += _R); }inline _LDC operator+(_LDC _L, long double _R)	{return (_L += _R); }inline _LDC operator+(long double _L, _LDC _R)	{return (_LDC(_L) += _R); }inline _LDC operator-(_LDC _L, _LDC _R)	{return (_L -= _R); }inline _LDC operator-(_LDC _L, long double _R)	{return (_L -= _R); }inline _LDC operator-(long double _L, _LDC _R)	{return (_LDC(_L) -= _R); }inline _LDC operator*(_LDC _L, _LDC _R)	{return (_L *= _R); }inline _LDC operator*(_LDC _L, long double _R)	{return (_L *= _R); }inline _LDC operator*(long double _L, _LDC _R)	{return (_LDC(_L) *= _R); }inline _LDC operator/(_LDC _L, _LDC _R)	{return (_L /= _R); }inline _LDC operator/(_LDC _L, long double _R)	{return (_L /= _R); }inline _LDC operator/(long double _L, _LDC _R)	{return (_LDC(_L) /= _R); }inline _LDC operator+(_LDC _L)	{return (_L); }inline _LDC operator-(_LDC _L)	{return (_LDC(-real(_L), -imag(_L))); }inline _Bool operator==(_LDC _L, _LDC _R)	{return (real(_L) == real(_R) && imag(_L) == imag(_R)); }inline _Bool operator==(_LDC _L, long double _R)	{return (real(_L) == _R && imag(_L) == 0); }inline _Bool operator==(long double _L, _LDC _R)	{return (_L == real(_R) && 0 == imag(_R)); }inline _Bool operator!=(_LDC _L, _LDC _R)	{return (!(_L == _R)); }inline _Bool operator!=(_LDC _L, long double _R)	{return (!(_L == _R)); }inline _Bool operator!=(long double _L, _LDC _R)	{return (!(_L == _R)); }istream& operator>>(istream&, _LDC&);ostream& operator<<(ostream&, _LDC);long double abs(_LDC);long double arg(_LDC);inline _LDC conj(_LDC _X)	{return (_LDC(real(_X), -imag(_X))); }_LDC cos(_LDC);_LDC cosh(_LDC);_LDC exp(_LDC);_LDC log(_LDC);inline long double norm(_LDC _X)	{return (real(_X) * real(_X) + imag(_X) * imag(_X)); }_LDC polar(long double, long double);_LDC pow(_LDC, _LDC);_LDC pow(_LDC, long double);_LDC pow(_LDC, int);_LDC pow(long double, _LDC);_LDC sin(_LDC);_LDC sinh(_LDC);_LDC sqrt(_LDC);#if __MWERKS__#pragma options align=reset#endif#endif/* * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED.  * Consult your license regarding permissions and restrictions. *//* Change log: *94June04 PlumHall baseline *94Oct07 Inserted MW changes. */