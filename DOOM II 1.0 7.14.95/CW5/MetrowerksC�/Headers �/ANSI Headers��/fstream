// fstream standard header#ifndef _FSTREAM_#define _FSTREAM_#include <istream>#include <ostream>#if __MWERKS__#pragma options align=mac68k#endif  // class filebufstruct _Filet;class filebuf : public streambuf {public: filebuf(_Filet *_F = 0)  {_Init(_F); } filebuf(ios::_Uninitialized)  : streambuf(ios::_Noinit) {} virtual ~filebuf(); _Bool is_open() const  {return ((_File != 0)); } filebuf *open(const char *, ios::openmode); filebuf *open(const char *_N, ios::open_mode _M)  {return (open(_N, (ios::openmode)_M)); } filebuf *close();protected: virtual int overflow(int = EOF); virtual int pbackfail(int = EOF); virtual int underflow(); virtual int uflow(); virtual int xsgetn(char *, int); virtual int xsputn(const char *, int); virtual streampos seekoff(streamoff, ios::seekdir,  ios::openmode = (ios::openmode)(ios::in | ios::out)); virtual streampos seekpos(streampos,  ios::openmode = (ios::openmode)(ios::in | ios::out)); virtual streambuf *setbuf(char *, int); virtual int sync(); _Filet *_Init(_Filet * = 0, _Bool = 0);private: _Bool _Closef; _Filet *_File; };  // class ifstreamclass ifstream : public istream {public: ifstream()  : ios(&_Fb), istream(&_Fb) {} ifstream(const char *_S, openmode _M = in)  : ios(&_Fb), istream(&_Fb) {_Fb.open(_S, _M); } virtual ~ifstream(); filebuf *rdbuf() const  {return ((filebuf *)&_Fb); } _Bool is_open() const  {return (_Fb.is_open()); } void open(const char *_S, openmode _M = in)  {if (_Fb.open(_S, _M) == 0)    setstate(failbit); } void open(const char *_S, open_mode _M)  {open(_S, (openmode)_M); } void close()  {if (_Fb.close() == 0)    setstate(failbit); }private: filebuf _Fb; };  // class ofstreamclass ofstream : public ostream {public: ofstream()  : ios(&_Fb), ostream(&_Fb) {} ofstream(const char *_S, openmode _M = out | trunc)  : ios(&_Fb), ostream(&_Fb) {_Fb.open(_S, _M); } virtual ~ofstream(); filebuf *rdbuf() const  {return ((filebuf *)&_Fb); } _Bool is_open() const  {return (_Fb.is_open()); } void open(const char *_S, openmode _M = out | trunc)  {if (_Fb.open(_S, _M) == 0)    setstate(failbit); } void open(const char *_S, open_mode _M)  {open(_S, (openmode)_M); } void close()  {if (_Fb.close() == 0)    setstate(failbit); }private: filebuf _Fb; };  // class stdiobufclass stdiobuf : public filebuf {public: stdiobuf(_Filet *_F)  : filebuf(_F), _Is_buffered(0) {} virtual ~stdiobuf(); _Bool buffered() const  {return (_Is_buffered); } void buffered(_Bool _F)  {_Is_buffered = _F; }private: _Bool _Is_buffered; };  // class istdiostreamclass istdiostream : public istream {public: istdiostream(_Filet *_F)  : ios(&_Fb), istream(&_Fb), _Fb(_F) {} virtual ~istdiostream(); stdiobuf *rdbuf() const  {return ((stdiobuf *)&_Fb); } _Bool buffered() const  {return (_Fb.buffered()); } void buffered(_Bool _F)  {_Fb.buffered(_F); }private: stdiobuf _Fb; };  // class ostdiostreamclass ostdiostream : public ostream {public: ostdiostream(_Filet *_F)  : ios(&_Fb), ostream(&_Fb), _Fb(_F) {} virtual ~ostdiostream(); stdiobuf *rdbuf() const  {return ((stdiobuf *)&_Fb); } _Bool buffered() const  {return (_Fb.buffered()); } void buffered(_Bool _F)  {_Fb.buffered(_F); }private: stdiobuf _Fb; };#if __MWERKS__#pragma options align=reset#endif#endif/* * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED.  * Consult your license regarding permissions and restrictions. *//* Change log: *94Oct03 Version received from PlumHall *94Oct07 Inserted MW changes. */