// bitstring standard header#ifndef _BITSTRING_#define _BITSTRING_#include <string>#if __MWERKS__#pragma options align=mac68k#endif		// class bitstringstring _Bitsxstr(istream&, size_t);class bitstring {public:	typedef unsigned long _T;	enum {_Nb = _BITS_BYTE * sizeof (_T)};	enum _Source {_Zeros = 0, _Ones = -1};	bitstring()		{_Tidy(); }	bitstring(unsigned long, size_t);	bitstring(const bitstring& _X, size_t _P = 0,		size_t _N = NPOS)		{_Tidy(), assign(_X, _P, _N); }	bitstring(const string&, size_t = 0, size_t = NPOS);	bitstring(_Source _S)		: _Ptr(0), _Src(_S), _Len(0), _Res(0) {}	~bitstring()		{_Tidy(1); }	bitstring& operator=(const bitstring& _R)		{return (assign(_R)); }	bitstring& operator+=(const bitstring& _R)		{return (append(_R)); }	bitstring& operator&=(const bitstring&);	bitstring& operator|=(const bitstring&);	bitstring& operator^=(const bitstring&);	bitstring& operator<<=(size_t);	bitstring& operator>>=(size_t);	bitstring& append(const bitstring&, size_t = 0,		size_t = NPOS);	bitstring& assign(const bitstring&, size_t = 0,		size_t = NPOS);	bitstring& insert(size_t, const bitstring&, size_t = 0,		size_t = NPOS);	bitstring& remove(size_t = 0, size_t = NPOS);	bitstring& replace(size_t, size_t, const bitstring&,		size_t = 0, size_t = NPOS);	bitstring& set();	bitstring& set(size_t, _Bool = 1);	bitstring& reset();	bitstring& reset(size_t _P)		{return (set(_P, 0)); }	bitstring& toggle();	bitstring& toggle(size_t);	string to_string() const;	size_t count() const;	size_t length() const		{return (_Len); }	size_t resize(size_t, _Bool = 0);	size_t trim()		{resize(rfind(1) + 1);		return (_Len); }	size_t find(_Bool, size_t = 0, size_t = NPOS) const;	size_t rfind(_Bool, size_t = 0, size_t = NPOS) const;	bitstring substr(size_t _P, size_t _N = NPOS) const		{return (bitstring(*this, _P, _N)); }	_Bool operator==(const bitstring&) const;	_Bool operator!=(const bitstring& _R) const		{return (!(*this == _R)); }	_Bool test(size_t) const;	_Bool any() const;	_Bool none() const		{return (!any()); }	bitstring operator<<(size_t _R) const		{return (bitstring(*this) <<= _R); }	bitstring operator>>(size_t _R) const		{return (bitstring(*this) >>= _R); }	bitstring operator~() const		{return (bitstring(*this).toggle()); }	_T _W(int _I) const		{return (_Ptr[_I]); }	_T _X(int _I, int _P) const		{int _L = _Len == 0 ? -1 : (_Len - 1) / _Nb;		return (_L < _I ?  _Src : _P == 0 ? _Ptr[_I]			: _L == _I ? _Ptr[_I] << _P			: _Ptr[_I] << _P | _Ptr[_I + 1] >> _Nb - _P); }private:	void _Copylr(const bitstring&, size_t, size_t, size_t);	void _Copyrl(const bitstring&, size_t, size_t, size_t);	_Bool _Grow(size_t, _Bool = 0);	void _Setl(size_t _L)		{_Len = _L, _L %= _Nb;		if (_L != 0)			_Ptr[(_Len - 1) / _Nb] &= ~(~(_T)0 >> _L); }	void _Tidy(_Bool = 0);	void _Xinv() const		{invalidargument("invalid bitstring char").raise(); }	void _Xlen() const		{lengtherror("bitstring too long").raise(); }	void _Xran() const		{outofrange("invalid bitstring position").raise(); }	_T *_Ptr, _Src;	size_t _Len, _Res;	};		// operatorsinline bitstring operator+(const bitstring& _L,	const bitstring& _R)	{return (bitstring(_L) += _R); }inline bitstring operator&(const bitstring& _L,	const bitstring& _R)	{return (bitstring(_L) &= _R); }inline bitstring operator|(const bitstring& _L,	const bitstring& _R)	{return (bitstring(_L) |= _R); }inline bitstring operator^(const bitstring& _L,	const bitstring& _R)	{return (bitstring(_L) ^= _R); }inline istream& operator>>(istream& _I, bitstring& _R)	{_R = _Bitsxstr(_I, NPOS - 1);	return (_I); }inline ostream& operator<<(ostream& _O, const bitstring& _R)	{return (_O << _R.to_string()); }#if __MWERKS__#pragma options align=reset#endif#endif/* * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED.  * Consult your license regarding permissions and restrictions. *//* Change log: *94June04 PlumHall baseline *94Oct07 Inserted MW changes. */