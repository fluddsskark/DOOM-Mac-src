// dynarray standard header#ifndef _DYNARRAY_#define _DYNARRAY_#include <exception>#if __MWERKS__#pragma options align=mac68k#endif  // template class dynarraytemplate<class _T> class dynarray {public: dynarray()  {_Tidy(); } dynarray(size_t _N, capacity _C)  {_Tidy(), _Res = _N;  if (_C == default_size)   _Grow(_N); } dynarray(const dynarray<_T>& _X)  {_Tidy(), _Grow(_X.length());  for (size_t _I = 0; _I < _Len; ++_I)   _Ptr[_I] = (_T)_X[_I]; } dynarray(const _T& _X, size_t _N = 1)  {_Tidy(), _Grow(_N, &_X); } dynarray(const _T *_S, size_t _N)  {if (_S == 0)   _Xinv();  _Tidy(), assign(_S, _N); } ~dynarray()  {_Tidy(1); } dynarray<_T>& operator=(const dynarray<_T>& _R)  {return (this == &_R ? *this   : assign(_R.base(), _R.length())); } dynarray<_T>& operator+=(const dynarray<_T>& _R)  {return (append(_R.base(), _R.length())); } dynarray<_T>& operator+=(const _T& _R)  {return (append(_R)); } dynarray<_T>& append(const _T& _X, size_t _N = 1)  {return (append(&_X, _N, 0)); } dynarray<_T>& append(const _T *_S, size_t _N = 1,  size_t _D = 1)  {if (NPOS - _Len <= _N)   _Xlen();  size_t _I = _Len;  for (_Grow(_N += _I); _I < _N; ++_I, _S += _D)   _Ptr[_I] = (_T)*_S;  return (*this); } dynarray<_T>& assign(const _T& _X, size_t _N = 1)  {return (assign(&_X, _N, 0)); } dynarray<_T>& assign(const _T *_S, size_t _N = 1,  size_t _D = 1)  {_Grow(_N, 0, 1);  for (size_t _I = 0; _I < _N; ++_I, _S += _D)   _Ptr[_I] = (_T)*_S;  return (*this); } dynarray<_T>& insert(size_t _P, const dynarray<_T>& _X)  {return (insert(_P, _X.base(), _X.length())); } dynarray<_T>& insert(size_t _P, const _T& _X, size_t _N = 1)  {return (insert(_P, &_X, _N, 0)); } dynarray<_T>& insert(size_t _P, const _T *_S, size_t _N = 1,  size_t _D = 1)  {if (_Len < _P)   _Xran();  if (NPOS - _Len <= _N)   _Xlen();  if (0 < _N)   {size_t _I = _Len - _P;   for (_Grow(_N + _Len); 0 < _I; )    --_I, _Ptr[_P + _N + _I] = _Ptr[_P + _I];   for (_I = 0; _I < _N; ++_I, _S += _D)    _Ptr[_P + _I] = (_T)*_S; }  return (*this); } dynarray<_T>& remove(size_t _P = 0, size_t _N = NPOS)  {if (_Len < _P)   _Xran();  if (_Len - _P < _N)   _N = _Len - _P;  if (0 < _N)   {size_t _M = _Len - _P - _N;   for (size_t _I = 0; _I < _M; ++_I)    _Ptr[_P + _I] = _Ptr[_P + _I + _N];   _Grow(_Len - _N); }  return (*this); } dynarray<_T>& sub_array(dynarray<_T>& _X, size_t _P,  size_t _N = NPOS)  {if (_Len < _P)   _Xran();  if (_Len - _P < _N)   _N = _Len - _P;  return (this == &_X ? (remove(_P + _N), remove(0, _P))   : _X.assign(&_Ptr[_P], _N)); } void swap(dynarray<_T>& _X)  {_T *_Tp = _Ptr; _Ptr = _X._Ptr, _X._Ptr = _Tp;  size_t _Tl = _Len; _Len = _X._Len, _X._Len = _Tl;  size_t _Tr = _Res; _Res = _X._Res, _X._Res = _Tr; } const _T& get_at(size_t _I) const  {if (_Len <= _I)   _Xran();  return (_Ptr[_I]); }  void put_at(size_t _I, const _T& _X)  {if (_Len <= _I)   _Xran();  _Ptr[_I] = (_T)_X; }  _T& operator[](size_t _I)  {return (_Ptr[_I]); }  const _T& operator[](size_t _I) const  {return (_Ptr[_I]); }  _T *base()  {return (_Len != 0 ? _Ptr : 0); } const _T *base() const  {return (_Len != 0 ? _Ptr : 0); } size_t length() const  {return (_Len); } void resize(size_t _N)  {_Grow(_N, 0, 1); } void resize(size_t _N, const _T& _X)  {_Grow(_N, &_X, 1); } size_t reserve() const  {return (_Res); } void reserve(size_t _R)  {if (_Ptr == 0)   _Res = _R; }private: void _Grow(size_t _N, const _T *_S = 0, _Bool _Trim = 0)  {size_t _Os = _Ptr == 0 ? 0 : _Res;  if (_N == 0)   {if (_Trim)    _Tidy(1); }  else if (_N == _Os || _N < _Os && !_Trim)   { }  else if (_N == NPOS)   _Xlen();  else   {size_t _I, _M = _Ptr == 0 && _N < _Res ? _Res : _N;   _T *_Np = new _T[_M];   if (_Np == 0)    _Nomemory();   _Res = _M, _M = _N < _Len ? _N : _Len;   for (_I = 0; _I < _M; ++_I)    _Np[_I] = _Ptr[_I];   if (_S != 0)    for (; _I < _Res; ++_I)     _Np[_I] = (_T)*_S;   _Tidy(1), _Ptr = _Np; }  _Len = _N; } void _Tidy(_Bool _Constructed = 0)  {if (_Constructed && _Ptr != 0)   delete[] _Ptr;  _Len = 0, _Ptr = 0, _Res = 0; } void _Xinv() const  {invalidargument("invalid dynarray argument").raise(); } void _Xlen() const  {lengtherror("dynarray too long").raise(); } void _Xran() const  {outofrange("invalid dynarray position").raise(); }  _T *_Ptr; size_t _Len, _Res; };  // template operatorstemplate<class _T> dynarray<_T> operator+(const dynarray<_T>& _L, const dynarray<_T>& _R) {return (dynarray<_T>(_L) += _R); }template<class _T> dynarray<_T> operator+(const dynarray<_T>& _L, const _T& _R) {return (dynarray<_T>(_L) += _R); }template<class _T> dynarray<_T> operator+(const _T& _L, const dynarray<_T>& _R) {return (dynarray<_T>(_L) += _R); }#if __MWERKS__#pragma options align=reset#endif#endif/* * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED.  * Consult your license regarding permissions and restrictions. */ /* Change log: *94Oct03 Version received from PlumHall *94Oct07 Inserted MW changes. *94Nov01mm Added explicit pointer casts of form (_T) in lines 22, 47, 55, 71, 103 and 143 */