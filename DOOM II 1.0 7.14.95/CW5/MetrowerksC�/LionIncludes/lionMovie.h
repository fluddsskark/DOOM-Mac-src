/************************************************************************************ *																																									* *	lionMovie.h																																			* *																																									* *	The "Lion Movie" header. Includes the #defines and structures for the						* *	Lion Movie compressor and player.																								* *																																									* *	Copyright (C) 1994 Lion Entertainment, Inc. All Rights Reserved Worldwide.			* *																																									* *	This material contains the valuable proprietary and trade secret								* *	information of Lion Entertainment, Inc. ("Lion") of Austin,	Texas,							* *	U.S.A..; No part of such information may be disclosed, used, reproduced,				* *	or transmitted in any form or by any means -- electronic, mechanical,						* *	or otherwise -- including: photocopying and recording in connection							* *	with any information storage or retrieval system, without permission in					* *	writing from Lion.																															* *																																									* *	Developed by Lion Entertainment.																								* *	Design & Programming by Douglas Grounds.																				* *																																									* *	Created				09/04/94																													* *																																									* ************************************************************************************/#ifndef __LIONMOVIE__#define __LIONMOVIE__#include <Sound.h>#include "Defs.h" // Library Error enumerations enum {		kLMErrNoErr = 0,		kLMErrNotInited,		kLMErrAlreadyInited,		kLMErrMovieStillPlaying,		kLMErrMovieFinished,		kLMErrParamErr,		kLMErrInternalErr,		kLMErrFileAccessErr,		kLMErrNotAMovieFile,		kLMErrBadFileVersion,		kLMErrNSFMem,		kLMErrSoundErr };/************ * *	Frame Image Definitions. * *	Notes. *	The Lion Movie data format is structured around saving the deltas *	between subsequent frames and then repeat-packing the deltas. *	The data format also supports a "skip" code, meaning that large, *	unchanged areas of a frame can be quickly "skipped". There is at *	least 1 "skip" code per row of an image. Graphics are always 8-bit, *	256 colors. * *	The following is an explanation of the encoding format. There is *	no header or other information associated with any frame, except *	the movie header itself (see below). * *	Encoding format: * *	ccc0 0000 *	0000 0000	End of line code: one of these will terminate each line, after *						the number of pixels per row are output (or fewer) *	001x xxxx	Short skip code: count of bytes to skip (+1) in low byte *	010x xxxx	Long skip code: count of bytes to skip << 8 + next byte (+1) *						is total skip bytes (max = 0x1F00 + (255 + 1)) (7936 + 256) = 8192 *	011x xxxx	Short raw code: count of literal bytes to copy (+1) in low byte *	100x xxxx	Long literal code: count of literal bytes to copy << 8) + next *						byte (+1) is total number of literal bytes following *	101x xxxx	Short repeat code: count (+1) of times to copy next byte *	110x xxxx	Long repeat code: count of times to copy << 8 + next byte (+1) *						is total number of times to repeat byte after that. * ************/ #define kEndOfLineCode				0x00 #define kShortSkipCode				0x20 #define kLongSkipCode				0x40 #define kShortLiteralCode		0x60 #define kLongLiteralCode			0x80 #define kShortRepeatCode			0xA0 #define kLongRepeatCode			0xC0 #define kCodeMask						0xE0 #define kShortDataMask				0x1F /************ * *	Play Buffer Structure. * *	Notes. *	The Lion Movie player alternately fills two 150K buffers with a combination *	of sound and graphics. These buffers are allocated as pointers, not as *	handles because we can't have the sound moving around, and the movie handle *	itself tracks the location within the data (maintaining an INDEX into the *	data) of the location of frames, both for sound and graphics. * *	The sound frame is always located at index 0 of the data and continues for *	n bytes, where n can be determined by the frequency and bytes/frame. The *	following table illustrates the size of the sound buffer: * *		Frequency			8-Bit				16-Bit * *		44100kHz			22,050			44,100 bytes *		22255kHz			11,128			22,255 bytes *		22050kHz			11,026			22,050 bytes *		11127kHz			 5,564			11,127 bytes *		11025kHz			 5,512			11,025 bytes * *	The graphic frames immediately follow the initial sound buffer and are not *	evenly padded, nor is there any padding between frames. Two "read" calls *	are issued to the hardware, the first for the sound and the second for *	as many graphic frames that should be read for the buffer. Note that each *	of the two buffers hold approximately 1/2 second of the movie, including *	both sound and graphics. * ************/   typedef struct { 		 		short											ioNProgress;					// Have we issued an i/o command? 		short											sndDoneFlag;					// Are we finished playing the sound? 		short											gfxDoneFlag;					// Are we finished imaging the graphics? 		 		IOParam										pb;										// Can have asynchronous calls pending 				SndDoubleBuffer						sndBuffHeader;				// Macintosh double-buffer header				unsigned char							movieData[1];					// Actually 150 * 1024 bytes in length,																										// and actually starts with 																										// "sndBuffHeader.dbSoundData[0]"		 } LMovieBuffer, *LMovieBufferPtr, **LMovieBufferHndl;/************ * *	Movie Frame. * ************/ enum  {		// Frame flags				frameIsSound = 1,		frameIsGraphic = 2,				frameInBuffer1 = 4,		frameInBuffer2 = 8,				frameLastSound = 0x10,		frameLastGfx = 0x20 };typedef struct{	tLong			frFlags;				// See above	tLong			frNdx;					// Index into buffers where frame was read (or -1L)	tLong			frByteSize;			// Number of bytes for the frame	tLong			frByteOffset;		// Location in the file	} LionMovieFrameHdr;/************ * *	Movie Header. * *	This header is located at the beginning of the movie file and is *	followed immediately by the color table. See Inside Macintosh for *	a description of the CTabHandle structure (CTable) that follows *	the header. The color table is followed immediately (no padding) *	by the frames in their indexed order. Note, however, that the *	frame headers are located in the file header, not with the frame's *	data. * ************/enum{	// For "movieFlags"	kMovieHasSound = 0x00000001,	kMovieLooped = 0x00000002,		kMovieSndDone = 0x00000004,	kMovieGfxDone = 0x00000008,		kMoviePrerolled = 0x00000010,		kMovieFirstFrameSkipped = 0x00000020,	kMovieSecondFrameSkipped = 0x00000040,		kMovieFullFrame = 0x00000080,		// For "soundType"	kSoundStereoType = 0x00000001,	kSoundMonoType = 0x00000002};typedef struct{	tLong			fileIdentifier;			// Always 'LMov'	tLong			fileVersion;				// 0x00010000 = Version 1	tLong			headerSize;					// Size of this header (in bytes)	tLong			numFrames;					// Number of frames in movie.	Fixed			frPerSec;						// Frames per second	tLong			movieFlags;		tWord			movieHeight;				// Height of movie (in pixels)	tWord			movieWidth;					// Width of movie (in pixels)	tUByte		fillColorNdx;				// Start with buffer this color.		CGrafPtr	offPort;						// Private to movie player	GDHandle	offDevice;					// Private to movie player	CGrafPtr	showPort;						// Destination window	Rect			showRect;						// Where in window		FSSpec		movieFSpec;					// File spec	short			movieFRef;					// Movie File reference	short			movieErr;						// Movie's current error condition		tLong			startTime;					// "TickCount" when the first frame was shown	tLong			nextFrameAt;				// "Time" to show next graphic frame	tLong			onFrame;						// Index into "frameInfo" for graphics	tLong			onGraphicFrame;			// Frames already displayed	tLong			frame2Read;					// Next frame to read into memory		tLong			largestBuffSize;		// Largest buffer size		SndChannelPtr	sndChannel;			// Sound channel	SndDoubleBufferHeaderPtr sdbHdrPtr;	tLong			soundBufferSize;		// Size of sound buffer	Fixed			soundFreq;					// Frequency, as in sound.h, i.e., rate44khz	tWord			soundFrameSize;			// Bits/frame, i.e., 8 for 8-bit sound.	tLong			soundNumFrames;			// Number of frames (total) for sound	tWord			soundType;					// Mono/Stereo?	tLong			cTableSize;					// Size of CTable that follows header (in bytes)																// Format is "CTabHandle" as on Macintosh.		LMovieBufferPtr			movieBuffers[2];		// Runtime buffers	LionMovieFrameHdr		frameInfo[1];				// Dynamically sized by "numFrames"} LionMovieHeader, *LionMovieHeaderPtr, **LionMovieHeaderHndl;typedef struct {	Boolean	oddAddr;	short framesPerSec;	short move;	long blitTime;	long	read;	long	scheduled;	long	actual;	long	sound;} TimingData;typedef TimingData TimingDataArr[kTimingDataLimit];/************ * *	Library Function Prototypes. * ************/  short LMovieInit (void); short LMoviesFinit (void);  short LMovieOpen (FSSpec *movieSpec, WindowPtr dstWind, Rect *dstRect,		Boolean fullScreen, short prerollBuffers, LionMovieHeaderHndl *movie); short LMovieClose (LionMovieHeaderHndl movie); short LMovieSetLoop (LionMovieHeaderHndl movieHdrH, Boolean loopMovie); short LMovieTask (LionMovieHeaderHndl movieHdrH); short LMovieStop (LionMovieHeaderHndl movieHdrH); short LMovieClose (LionMovieHeaderHndl movieHdrH); short LMovieGetErr (LionMovieHeaderHndl movieHdrH);#endif //__LIONMOVIE__