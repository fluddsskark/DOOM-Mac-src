/* *	CPlusLibPPC.cp		-	C++ Runtime Support Routines for Metrowerks C++ (PowerPC) * *	Copyright © 1993 metrowerks inc. All Rights Reserved. * */#include <CPlusLibPPC.h>	/*	private data		*/DestructorChain	*__global_destructor_chain;	/*	chain of global objects that need destruction	*/DestructorChain	*__local_destructor_chain;	/*	chain of local objects that need destruction	*/ 	/*	external references	*/extern "C" void __blockmove(void *to, void *from, size_t size);	/*	defined in Runtime.o	*//* *	__ptmf_cast	-	copy/cast a pointer-to-member-function * */PTMF *__ptmf_cast(long offset, const PTMF *ptmfrom, PTMF *ptmto){	ptmto->this_delta = ptmfrom->this_delta+offset;		if(ptmfrom->vtbl_offset >= 0L) {		//	virtual function pointer		ptmto->vtbl_offset = ptmfrom->vtbl_offset + offset;		ptmto->func_data.ventry_offset = ptmfrom->func_data.ventry_offset;	}	else {								//	nonvirtual function pointer		ptmto->vtbl_offset = -1L;		ptmto->func_data.func_addr = ptmfrom->func_data.func_addr;	}		return(ptmto);}/* *	__register_global_object	-	register a global object for later destruction * *	We add the object and its destructor to a chain of (global object,destructor) pairs. *	The standard termination routine will traverse this list and destroy all objects *	whenever/however an application terminates. * */ void *__register_global_object(void *object, ConstructorDestructor destructor, DestructorChain *regmem){	regmem->next = __global_destructor_chain;	regmem->destructor = destructor;	regmem->object = object;	__global_destructor_chain = regmem;	return(object);}/* *	__register_local_object	-	register a local object for later destruction * *	We add the object and its destructor to a chain of (local object,destructor) pairs. *	These local objects are destroyed at the end of a scope or as part of stack unwinding *	when an exception is thrown. * */ void *__register_local_object(void *object, ConstructorDestructor destructor, DestructorChain *regmem){	regmem->next = __local_destructor_chain;	regmem->destructor = destructor;	regmem->object = object;	__local_destructor_chain = regmem;	return(object);}/* *	__preregister_local_object	-	preregister a local object for later destruction * *	This function is used to register an object that will be constructed *	by a return statement. The result of this function will be passed to *	the function return temp memory argument. * */ void *__preregister_local_object(void *object, DestructorChain *regmem){	regmem->next = __local_destructor_chain;	regmem->object = 0;	regmem->destructor = (ConstructorDestructor) object;	//	kludge: but the object is not constructed	__local_destructor_chain = regmem;						//	until __reregister_local_object has been called	return(regmem);}/* *	__reregister_local_object	-	re-register a local object for later destruction * *	This function will register a preregistered local object for destruction. *	It will be called before a return object is initialized via return <x>; * */ void *__reregister_local_object(DestructorChain *regmem, ConstructorDestructor destructor){	regmem->object = regmem->destructor;	regmem->destructor = destructor;	return(regmem->object);}/* *	__destroy_local_objects	-	destroy some local objects * *	Call the destructor for every object in the local object chain up to (and *	including) 'lastregmem'. * */ void __destroy_local_objects(DestructorChain *lastregmem){	DestructorChain *chain;	void *object;		while ((chain = __local_destructor_chain) != 0) {		if ((object = chain->object) != 0)			(*chain->destructor)(object, -1);		__local_destructor_chain = chain->next;		if (chain == lastregmem)			break;	}}/* *	__destroy_local_objects_to	-	destroy some local objects * *	Call the destructor for every object in the local object chain up to (but *	NOT including) 'lastregmem'. * */ void __destroy_local_objects_to(DestructorChain *lastregmem){	DestructorChain *chain;	void *object;		while ((chain = __local_destructor_chain) != 0) {		if (chain == lastregmem)			break;		if ((object = chain->object) != 0)			(*chain->destructor)(object, -1);		__local_destructor_chain = chain->next;	}}/* *	__destroy_local_chain	-	destroy all local objects * *	Call the destructor for every object in the local object chain. * */ void __destroy_local_chain(void){	DestructorChain *chain;	void *object;		while ((chain = __local_destructor_chain) != 0) {		if ((object = chain->object) != 0)			(*chain->destructor)(object, -1);		__local_destructor_chain = chain->next;	}}/* *	__destroy_global_chain	-	destroy all global objects * *	Call the destructor for every object in the global object chain. * */ void __destroy_global_chain(void){	DestructorChain *chain;	void *object;		while ((chain = __global_destructor_chain) != 0) {		if ((object = chain->object) != 0)			(*chain->destructor)(object, -1);		__global_destructor_chain = chain->next;	}}/* *	__copy		-	copy 'size' bytes data from 'from' to 'to' * *	We return the pointer to the destination. If it is 0, no copy is performed. * */void *__copy(char *to, char *from, size_t size){	char *p;		if (to) {		if (size < 128) {			for (p = to; size--;)				*p++ = *from++;		}		else			__blockmove(to, from, size);	}		return(to);}/* *	__init_arr	-	initialize an array of objects * *	Given a pointer to space for an array of 'nobjects' elements of size 'objectsize', *	and space to store 'nobjects' and 'objectsize' (for later deletion), we call *	the given constructor for each object in the array. * */ void *__init_arr(void *memptr, ConstructorDestructor constructor, size_t objectsize, size_t nobjects){	char *p;		if ((p = (char *) memptr) != 0) {		((size_t *) p)[0] = objectsize;		((size_t *) p)[1] = nobjects;		p += 2 * sizeof(size_t);		if (constructor) {			for (; nobjects--; p += objectsize)				(*constructor)(p, 1);		}	}		return(memptr);}/* *	__new_arr	-	allocate and construct an array of objects * *	We allocate space for an array of 'nobjects' elements of size 'objectsize', and *	space to store 'nobjects' and 'objectsize' (for later deletion). Then we call *	the given constructor for each object in the array. * */ void *__new_arr(ConstructorDestructor constructor, size_t objectsize, size_t nobjects){	char *memptr, *p;		if ((memptr = (char *) ::operator new(2*sizeof(size_t) + nobjects*objectsize)) != 0) {		memptr += 2*sizeof(size_t);		((size_t *) memptr)[-2] = objectsize;		((size_t *) memptr)[-1] = nobjects;		if (constructor) {			for (p = memptr; nobjects--; p += objectsize)				(*constructor)(p, 1);		}	}		return(memptr);}/* *	__del_arr	-	destroy and deallocate an array of objects * *	We use the previously saved 'nobjects' and 'objectsize' values to call the *	destructor for each element of the array. Then we delete the space allocated *	to it. * */ void __del_arr(void *memptr, ConstructorDestructor destructor){	size_t nobjects, objectsize;	char *p;		if (memptr) {		if (destructor) {			objectsize = ((size_t *) memptr)[-2];			nobjects = ((size_t *) memptr)[-1];			for (p = (char *) memptr+objectsize*nobjects; nobjects--;)				(*destructor)(p -= objectsize, -1);		}		::delete (&((size_t *) memptr)[-2]);	}}/* *	__dc_arr	-	construct or destroy a statically allocated array of objects * *	We call the given constructor or destructor for each of 'nobjects' elements of size *	'objectsize' in a statically allocated array. * */ void __dc_arr(void *memptr, ConstructorDestructor constructordestructor, short objectsize, short nobjects){	char *p;		for (p = (char *) memptr; nobjects--; p += objectsize)		(*constructordestructor)(p, -1);}