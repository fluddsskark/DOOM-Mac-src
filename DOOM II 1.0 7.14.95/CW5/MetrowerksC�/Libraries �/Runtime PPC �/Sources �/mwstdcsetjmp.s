#	mwstdcsetjmp.s	-	setjmp() and longjmp() routines for Metrowerks C++ for PowerPC##	Copyright © 1993 metrowerks inc.  All Rights Reserved.###	THEORY OF OPERATION##	The runtime support routines __setjmp() and longjmp() support the C <setjmp.h>#	facilities.##	__setjmp() captures the state of the program in a jmp_buf data structure#	which has the following C definition:##		typedef struct jmp_buf {#			unsigned long	PC;			//	0: saved PC#			unsigned long	CR;			//	4: saved CR#			unsigned long	SP;			//  8: saved SP#			unsigned long	RTOC;		// 12: saved RTOC#			unsigned long	ldc;		// 16: saved __local_destructor_chain#			unsigned long	GPRs[19];	// 20: saved r13-r31#			double			FPRs[18];	// 96: saved fp14-fp31#			double			FPSCR;		//240: saved FPSCR#		} *jmp_buf;##	longjmp() restores the state, effecting a transfer back to the saved PC with#	appropriate registers, stack, TOC, etc.##	In <setjmp.h> the jmp_buf type must be defined as an array (per ANSI rules):##		typedef long jmp_buf[63];##	setjmp() and longjmp() are defined as follows:##		int __setjmp(jmp_buf env);#		#define setjmp(env) __setjmp(env)#		void longjmp(jmp_buf env, int val);###	BUILD INSTRUCTIONS##	To assemble this file:##		ppcasm mwstdcsetjmp.s -o mwstdcsetjmp.o##	The object file runtime.o can be added directly to any CodeWarriorª project.#		dialect	powerpc##	Assembler Equates#cr0		equ		0cr1		equ		1cr2		equ		2cr3		equ		3cr4		equ		4cr5		equ		5cr6		equ		6cr7		equ		7##	Extern Data#		import	__local_destructor_chain{RW}##	Public Data#		csect	__setjmp{DS}		export	__setjmp{DS}		dc.l	.__setjmp{PR}		dc.l	TOC{TC0}				csect	longjmp{DS}		export	longjmp{DS}		dc.l	.longjmp{PR}		dc.l	TOC{TC0}##	TOC pointers#		toc		tc		__local_destructor_chain{TC}, __local_destructor_chain{RW}#	__setjmp	-	C setjmp() routine##	On entry R3 points to a jmp_buf struct. On exit, R3 is 0.#		csect	.__setjmp{PR}		export	.__setjmp{PR}		mflr	r5		mfcr	r6		stw		r5,0(r3)		#	save PC (LR)		stw		r6,4(r3)		#	save CR		stw		SP,8(r3)		#	save SP		stw		RTOC,12(r3)		#	save RTOC		stmw	r13,20(r3)		#	save r13-r31		mffs	fp0		stfd	fp14,96(r3)		#	save fp14-fp31		stfd	fp15,104(r3)		stfd	fp16,112(r3)		stfd	fp17,120(r3)		stfd	fp18,128(r3)		stfd	fp19,136(r3)		stfd	fp20,144(r3)		stfd	fp21,152(r3)		stfd	fp22,160(r3)		stfd	fp23,168(r3)		stfd	fp24,176(r3)		stfd	fp25,184(r3)		stfd	fp26,192(r3)		stfd	fp27,200(r3)		stfd	fp28,208(r3)		lwz		r5,__local_destructor_chain{TC}(RTOC)		stfd	fp29,216(r3)		stfd	fp30,224(r3)		lwz		r5,0(r5)		stfd	fp31,232(r3)		stfd	fp0,240(r3)		#	save FPSCR		stw		r5,16(r3)		#	save __local_destructor_chain		li		r3,0		blr#	longjmp		-	C longjmp() routine##	On entry R3 points to a jmp_buf struct and R4 contains the return value.#	On exit, R3 contains 1 if R4 was 0, otherwise it contains the value from R4.#		csect	.longjmp{PR}		export	.longjmp{PR}		lwz		r5,0(r3)		lwz		r6,4(r3)		mtlr	r5				#	restore PC (LR)		mtcrf	255,r6			#	restore CR		lwz		SP,8(r3)		#	restore SP		lwz		RTOC,12(r3)		#	restore RTOC		lmw		r13,20(r3)		#	restore r13-r31		lfd		fp14,96(r3)		#	restore fp14-fp31		lfd		fp15,104(r3)		lfd		fp16,112(r3)		lfd		fp17,120(r3)		lfd		fp18,128(r3)		lfd		fp19,136(r3)		lfd		fp20,144(r3)		lfd		fp21,152(r3)		lfd		fp22,160(r3)		lfd		fp23,168(r3)		lfd		fp24,176(r3)		lfd		fp25,184(r3)		lfd		fp26,192(r3)		lfd		fp27,200(r3)		lfd		fp28,208(r3)		lwz		r5,16(r3)		#	restore __local_destructor_chain		lfd		fp29,216(r3)		lfd		fp30,224(r3)		lwz		r6,__local_destructor_chain{TC}(RTOC)		lfd		fp0,240(r3)		lfd		fp31,232(r3)		stw		r5,0(r6)		cmpwi	r4,0		mr		r3,r4		mtfsf	255,fp0			#	restore FPSCR		bnelr					#	return value in R4		li		r3,1			#	return 1		blr