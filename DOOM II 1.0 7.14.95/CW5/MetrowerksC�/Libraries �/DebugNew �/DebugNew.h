/* *  DebugNew.h * *  Copyright © 1993 metrowerks inc.  All rights reserved. *  *	A debugging layer over the standard operator new and delete *  to detect memory overwrites, incorrect deletes, and memory leaks. *  See DebugNew.doc for background and usage instructions. */ #ifndef DebugNew_H#define DebugNew_H#include <stddef.h>#define DEBUG_NEW_OFF		0	// disabled#define DEBUG_NEW_BASIC		1	// detect overwrites, heuristically detect bad deletes#define DEBUG_NEW_LEAKS		2	// all basic testing, plus memory leaks#ifndef DEBUG_NEW						// Default setting if not defined already. You can#define DEBUG_NEW	DEBUG_NEW_BASIC 	// define DEBUG_NEW as 0,1 or 2 in your prefix or elsewhere.#endif#if DEBUG_NEW == DEBUG_NEW_OFF  #define NEW new   #elif DEBUG_NEW == DEBUG_NEW_BASIC  #define NEW new   #elif DEBUG_NEW == DEBUG_NEW_LEAKS  #define NEW new(__FILE__, __LINE__)  void* operator new(size_t size, const char*, int);      			// Validate all allocated blocks, only available when leak checking is  			// enabled.  			  void  DebugNewValidateAllBlocks();#else#error DEBUG_NEW has an undefined value#endif	// Try to validate that a pointer points to a valid, uncorrupted block.	// Invokes error handler if validation fails. Will not work properly	// for C++ arrays. Does nothing when DebugNew is disabled	void DebugNewValidatePtr(void*);#if DEBUG_NEW >= DEBUG_NEW_BASIC	// this variable holds the number of active allocations	extern unsigned long gDebugNewAllocCount;	// this variable holds the total #bytes currently allocated via operator new(),	// not including DebugNew overhead.	extern unsigned long gDebugNewAllocCurr;	// this variable holds the maximum #bytes allocated at any given point in	// the program execution, not counting DebugNew overhead. Useful for	// memory tuning.	extern unsigned long gDebugNewAllocMax;	// this variable holds flags that control run-time behavior	// of DebugNew. The available flags are defined in the 	// following enum (only one currently).	extern unsigned long gDebugNewFlags;enum	  	// gDebugNewFlags bits, refer to DebugNew.doc for information{	dnDontFreeBlocks = 1	// don't release free blocks back to allocator,							// provides extended checking if leak checking enabled};	// Call to memory leak tracking status to a file called	// "leaks.log" in the application directory	void DebugNewReportLeaks();	// You can optionally provide an error handler to be called when	// errors are detected. The default routine just calls DebugStr.	// Call DebugNewSetErrorHandler to set handler, it returns the	// old handler.	typedef void (*DebugNewErrorHandler_t)(short);DebugNewErrorHandler_t	DebugNewSetErrorHandler(DebugNewErrorHandler_t newHandler);enum DebugNewError_t			// error codes passed to error handler{	dbgnewNullPtr,				// validate called with NULL pointer	dbgnewTooManyFrees,			// #deletes doesn't match #news, too many deletes	dbgnewPointerOutsideHeap,	// validate or free call for pointer outside application heap	dbgnewFreeBlock,			// validate or delete called for free block	dbgnewBadHeader,			// validate or delete called for block with bad header. 								// Bad ptr or overwritten header.	dbgnewBadTrailer,			// validate or delete called with block whose trailer was overwritten	dbgnewBlockNotInList,		// validate or delete called with block with valid header/trailer, 								// but block is not in block list (internal error?)	dbgnewFreeBlockOverwritten  // dnDontFreeBlocks was enabled, and a free block was								// modified. Usually indicates a write through a dangling pointer.};	#endif  // DEBUG_NEW >= DEBUG_NEW_BASIC#endif	// DebugNew_H