/* *	fp.h glue functions ... */#ifndef __FP__#include <fp.h>#endif#ifndef __SANE__#include <SANE.h>#endif#ifndef __STRINGS__#include <Strings.h>#endif#ifndef _ERRNO#include <errno.h>#endif#ifndef _STDLIB#include <stdlib.h>#endif#define	MINVAL		(*(long double *)(&__C__))		/*	2^-33		=	1.1641532182693481450E-10 *//* *	Local functions and globals ... */#if __MC68881__/* Trigonometric functions */static long double _cos(long double:__FP0):__FP0 = { 0xF200,0x001D };static long double _sin(long double:__FP0):__FP0 = { 0xF200,0x000E };static long double _tan(long double:__FP0):__FP0 = { 0xF200,0x000F };static long double _acos(long double:__FP0):__FP0 = { 0xF200,0x001C };static long double _asin(long double:__FP0):__FP0 = { 0xF200,0x000C };static long double _atan(long double:__FP0):__FP0 = { 0xF200,0x000A };/* Hyperbolic functions */static long double _cosh(long double:__FP0):__FP0 = { 0xF200,0x0019 };static long double _sinh(long double:__FP0):__FP0 = { 0xF200,0x0002 };static long double _tanh(long double:__FP0):__FP0 = { 0xF200,0x0009 };/* Exponential functions */static long double _exp(long double:__FP0):__FP0 = { 0xF200,0x0010 };static long double _ldexp(long double:__FP0,int:__D0):__FP0 = { 0xF200,0x4026 };static long double _log(long double:__FP0):__FP0 = { 0xF200,0x0014 };static long double _log10(long double:__FP0):__FP0 = { 0xF200,0x0015 };static long double fgetexp(long double:__FP0):__FP0 = { 0xF200,0x001E };static long double fgetman(long double:__FP0):__FP0 = { 0xF200,0x001F };/* Power and absolute value functions */static long double _fabs(long double:__FP0):__FP0 = { 0xF200,0x0018 };static long double _sqrt(long double:__FP0):__FP0 = { 0xF200,0x0004 };/* Nearest integer functions */static long double fint(long double:__FP0):__FP0 = { 0xF200,0x0001 };static long double fintrz(long double:__FP0):__FP0 = { 0xF200,0x0003 };static long	FSetRound(long:__D0) = { 0xF200,0x9000 };static long FGetRound(void):__D0 = { 0xF200,0xB000 };static void FRoundUp(void){	long l;	l=FGetRound(); l=(l&0xFFFFFFCF)|0x30; FSetRound(l);}static void FRoundDown(void){	long l;	l=FGetRound(); l=(l&0xFFFFFFCF)|0x20; FSetRound(l);}/* Remainder functions */static long double _fmod(long double:__FP0,long double:__FP1):__FP0 = { 0xF200,0x0421 };static short __C__[6] 			=	{ 0x3fde,0x0000,0x8000,0x0000,0x0000,0x0000 };static short __inf__[6]			=	{ 0x7FFF,0x0000,0x0000,0x0000,0x0000,0x0000 };#elsestatic short __C__[5]			=	{ 0x3fde,0x8000,0x0000,0x0000,0x0000 };static short __inf__[5]			=	{ 0x7FFF,0x0000,0x0000,0x0000,0x0000 };static pascal void MyRemainder(extended80 *,extended80 *) = { 0x3F3C,0x000C,0xA9EB };#endifstatic void MyCopySign(long double *xp,register long double *yp){	*(short *)yp&=0x7FFF; if(*(short *)xp<0) *(short *)yp|=0x8000;}/********************************************************************************                                Constants                                     ********************************************************************************/const double_t pi = 3.14159265358979323846;static const double_t log2_10 = 3.321928094887362348;/********************************************************************************                            Trigonometric functions                           ********************************************************************************/double_t cos ( double_t x ){#if __MC68881__	return(_cos(x));#else	/* SANE */	extended80 x80=x;	Cos(&x80);	return(x80);#endif}double_t sin ( double_t x ){#if __MC68881__	return(_sin(x));#else	/* SANE */	extended80 x80=x;	Sin(&x80);	return(x80);#endif}double_t tan ( double_t x ){#if __MC68881__	return(_tan(x));#else	/* SANE */	extended80 x80=x;	Tan(&x80);	return(x80);#endif}double_t acos ( double_t x ){#if __MC68881__	if(x<-1 || x>1) { errno=EDOM; return(0); }	return(_acos(x));#else	/* SANE */	if(x<-1 || x>1) { errno=EDOM; return(0); }	return(2*atan(sqrt((1-x)/(1+x))));#endif}double_t asin ( double_t x ){#if __MC68881__	if(x<-1 || x>1) { errno=EDOM; return(0); }	return(_asin(x));#else	/* SANE */	extended80 y;	if (x<-1 || x>1) { errno=EDOM; return(0); }	y=x; Abs(&y); if (y<=MINVAL) return(x);	if (y>0.5) { y=1-y; y=2*y-y*y; } else y=1-y*y; 	return(atan(x/sqrt(y)));#endif}double_t atan ( double_t x ){#if __MC68881__	return(_atan(x));#else	/* SANE */	extended80 x80=x;	Atan(&x80);	return(x80);#endif}double_t atan2 ( double_t y, double_t x ){	double_t z;	z=atan(y/x);	if(x<0) { if(y<0) z-=pi; else z+=pi; }	return(z);}/********************************************************************************                              Hyperbolic functions                            ********************************************************************************/double_t cosh ( double_t x ){#if __MC68881__	return(_cosh(x));#else	/* SANE */	extended80 y=x;	y=0.5*exp(fabs(y));	return(y+0.25/y);#endif}double_t sinh ( double_t x ){#if __MC68881__	return(_sinh(x));#else	/* SANE */	extended80 y, x80=x;	y=x; Abs(&y); if(y<=MINVAL) return(x);	Exp1(&y); y+=y/(1+y); y*=0.5;	MyCopySign(&x80,&y);	return(y);#endif}double_t tanh ( double_t x ){#if __MC68881__	return(_tanh(x));#else	/* SANE */	extended80 y,x80=x;	y=x; Abs(&y);	if(y>MINVAL) { y*=-2; Exp1(&y); y=-y/(2+y); }	MyCopySign(&x80,&y);	return(y);#endif}//  asinh, acosh, atanh are taken from Apple Numerics Manual, 2nd Ed., p74.double_t asinh(double_t x){	double_t y;		y = fabs(x);	if (y > MINVAL) y = log1p(y + y/(1.0/y + sqrt(1 + 1/(y*y))));	MyCopySign(&x,&y);	return(y);}double_t acosh(double_t x){	double_t y;		y = sqrt(x - 1.0);	return log1p(y*(y + sqrt(x + 1.0)));}double_t atanh(double_t x){	double_t y;		y = fabs(x);	if (y > 1.164e-10) y = 0.5*log1p(2.0*(y/(1.0 - y)));	MyCopySign(&x,&y);	return(y);}/********************************************************************************                              Exponential functions                           ********************************************************************************/double_t exp ( double_t x ){#if __MC68881__	return(_exp(x));#else	/* SANE */	extended80 x80=x;	Exp(&x80);	return(x80);#endif}double_t expm1  ( double_t x ){	extended80 x80;#if __MC68881__	extended96 x96=x;	x96tox80(&x96,&x80);#else	/* SANE */	x80=x;#endif	Exp1(&x80);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	/* SANE */	return(x80);#endif}double_t exp2  ( double_t x ){	extended80 x80;#if __MC68881__	extended96 x96=x;	x96tox80(&x96,&x80);#else	/* SANE */	x80=x;#endif	Exp2(&x80);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	/* SANE */	return(x80);#endif}double_t frexp ( double_t x, int *exponent ){#if __MC68881__	if(x==0) { *exponent=0; return(0); }	*exponent=(int)fgetexp(x)+1; return(fgetman(x)/2);#else	/* SANE */	long n;	extended80 x80=x, y;	if(x == 0) { *exponent=0; return(0); }	y=fabs(x); Log2(&y); n=y; y-=n; y=pow(2,y);	if(y>=1) { y=y/2; n++; } else if(y<0.5 && y!=0.0) { y+=y; n--; }	*exponent=n;	MyCopySign(&x80,&y);	return(y);#endif}double_t ldexp ( double_t x, int n ){#if __MC68881__	return(_ldexp(x,n));#else	/* SANE */	extended x80=x;	short sn=n;	Scalb(&sn,&x80);	return(x80);#endif}double_t log ( double_t x ){#if __MC68881__	if(x<0) errno=EDOM;	return(_log(x));#else	/* SANE */	extended80 x80=x;	if(x<0) errno=EDOM;	Ln(&x80);	return(x80);#endif}double_t log2 ( double_t x ){	extended80 x80;#if __MC68881__	extended96 x96=x;	x96tox80(&x96,&x80);#else	/* SANE */	x80=x;#endif	Log2(&x80);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	/* SANE */	return(x80);#endif}double_t log1p ( double_t x ){	extended80 x80;#if __MC68881__	extended96 x96=x;	x96tox80(&x96,&x80);#else	/* SANE */	x80=x;#endif	Ln1(&x80);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	/* SANE */	return(x80);#endif}double_t log10 ( double_t x ){#if __MC68881__	if(x<0) errno=EDOM;	return(_log10(x));#else	/* SANE */	extended80 x80=x;	if(x<0) errno=EDOM;	Log2(&x80); x80/=log2_10;	return(x80);#endif}double_t logb ( double_t x ){	extended80 x80;#if __MC68881__	extended96 x96=x;	x96tox80(&x96,&x80);#else	/* SANE */	x80=x;#endif	Logb(&x80);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	/* SANE */	return(x80);#endif}long double modfl ( long double x, long double *iptrl ){	return(modf(x, iptrl));}double_t    modf  ( double_t x, double_t *iptr ){#if __MC68881__	*iptr=fintrz(x); return(x-*iptr);#else	/* SANE */	extended80	x80=x;	Tint(&x80); *iptr=x80;	return(x-x80);#endif}float       modff ( float x, float *iptrf ){	double_t x_flt, result;	result  = modf(x, &x_flt);	*iptrf = x_flt;	return(result);}double_t scalb ( double_t x, long int n ){	short scale;	extended80 x80;#if __MC68881__	extended96 x96=x;	x96tox80(&x96,&x80);#else	/* SANE */	x80=x;#endif	if (n > 32767) scale =  32767;	else if (n < -32768) scale = -32768;	else scale = n;	Scalb(&scale,&x80);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	return(x80);#endif}/********************************************************************************                     Power and absolute value functions                       ********************************************************************************/double_t fabs ( double_t x ){#if __MC68881__	return(_fabs(x));#else	/* SANE */	extended80 x80=x;	Abs(&x80); return(x80);#endif}double_t hypot ( double_t x, double_t y ){	long int fpclassx = __fpclassify(x);	long int fpclassy = __fpclassify(y);	if (fpclassx == FP_SNAN || fpclassx == FP_QNAN ||		fpclassy == FP_SNAN || fpclassy == FP_QNAN)		return(x + y);	return(sqrt(x*x + y*y));}double_t pow   ( double_t x, double_t y ){	extended80	x80,y80;	double_t iptr;#if __MC68881__	extended96	x96=x, y96=y;	x96tox80(&x96,&x80);	x96tox80(&y96,&y80);#else	/* SANE */	x80=x;y80=y;#endif	if(x==0) { if(y<=0) errno=EDOM; return(0); }	if(y==0) return(1);	if((x<0) && modf(y,&iptr)) { errno=EDOM; return(0);}	Power(&y80,&x80);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	/* SANE */	return(x80);#endif}double_t sqrt  ( double_t x ){#if __MC68881__	if (x < 0) { errno=EDOM; return(0); }	return(_sqrt(x));#else	/* SANE */	extended80 x80=x;	if (x < 0) { errno=EDOM; return(0); }	Sqrt(&x80); return(x80);#endif}/********************************************************************************                        Gamma and Error functions                             ********************************************************************************/#if __MC68881__extern double_t __FPUerf(double_t);extern double_t __FPUerfc(double_t);extern double_t __FPUgamma(double_t);extern double_t __FPUlgamma(double_t);#elseextern double_t __nonFPUerf(double_t);extern double_t __nonFPUerfc(double_t);extern double_t __nonFPUgamma(double_t);extern double_t __nonFPUlgamma(double_t);#endifdouble_t erf  ( double_t x ){#if __MC68881__	return(__FPUerf(x));#else	return(__nonFPUerf(x));#endif}double_t erfc ( double_t x ){#if __MC68881__	return(__FPUerfc(x));#else	return(__nonFPUerfc(x));#endif}double_t gamma ( double_t x ){#if __MC68881__	return(__FPUgamma(x));#else	return(__nonFPUgamma(x));#endif}double_t lgamma ( double_t x ){#if __MC68881__	return(__FPUlgamma(x));#else	return(__nonFPUlgamma(x));#endif}/********************************************************************************                        Nearest integer functions                             ********************************************************************************/double_t ceil  ( double_t x ){#if __MC68881__	long round;	double_t temp;	round=FGetRound(); FRoundUp();	temp=fint(x);	FSetRound(round); return(temp);#else	/* SANE */	Environment	env_old,env_new;	extended80 x80=x;	GetEnvironment(&env_old);	env_new=0x2000;		/*	Round Upward */	SetEnvironment(&env_new);	Rint(&x80);	SetEnvironment(&env_old);	return(x80);#endif}double_t floor ( double_t x ){#if __MC68881__	long round;	double_t temp;	round=FGetRound(); FRoundDown();	temp=fint(x);	FSetRound(round); return(temp);#else	/* SANE */	Environment	env_old,env_new;	extended80 x80=x;	GetEnvironment(&env_old);	env_new=0x4000;				/*	Round Downward */	SetEnvironment(&env_new);	Rint(&x80);	SetEnvironment(&env_old);	return(x80);#endif}double_t rint ( double_t x ){	extended80 x80;#if __MC68881__	extended96 x96=x;	x96tox80(&x96,&x80);#else	/* SANE */	x80=x;#endif	Rint(&x80);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	/* SANE */	return(x80);#endif}double_t nearbyint ( double_t x ){	return(rint(x));}long int rinttol ( double_t x ){	return((long)rint(x));}double_t round ( double_t x ){	short env=0;	double_t temp,y;	SetEnvironment((Environment *)&env);	temp=rint(x);	GetEnvironment((Environment *)&env);	if (env & (((short)16) << 8)) {		y=0.5+fabs(x);		MyCopySign(&x,&y);		temp=floor(y);	}	return(temp);}long int roundtol ( double_t x ){	return((long)round(x));}int      trunc ( double_t x ){	return((int)x);}/********************************************************************************                            Remainder functions                               ********************************************************************************/double_t fmod ( double_t x, double_t y ){#if __MC68881__	return((_fmod)(x,y));#else	/* SANE */	extended80 z,x80=x,y80=y;	Abs(&y80); z=x80; MyRemainder(&y80,&z);	if(x80>0 && z<0) z+=y80;	else if(x80<0 && z>0) z-=y80;	return(z);#endif}double_t remainder ( double_t x, double_t y ){	short quotient;	extended80 x80, y80;#if __MC68881__	extended96 x96=x, y96=y;	x96tox80(&x96,&x80);	x96tox80(&y96,&y80);#else	/* SANE */	x80=x; y80=y;#endif	Remainder(&y80,&x80,&quotient);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	/* SANE */	return(x80);#endif}double_t remquo    ( double_t x, double_t y, int *quo ){	short quotient;	extended80 x80, y80;#if __MC68881__	extended96 x96=x, y96=y;	x96tox80(&x96,&x80);	x96tox80(&y96,&y80);#else	/* SANE */	x80=x; y80=y;#endif	Remainder(&y80,&x80,&quotient);	/* Fill in the quo parameter */	if (quotient>=0)		/* return only lower 7 quotient bits (????) */		*quo = ((long)quotient) & 0x7fL;	else		*quo = -((-((long)quotient)) & 0x7fL);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	/* SANE */	return(x80);#endif}/********************************************************************************                             Auxiliary functions                              ********************************************************************************/double_t copysign ( double_t x, double_t y ){	MyCopySign(&y,&x); return(x);}long double nanl ( const char *tagp ){	return(NaN(strtol(tagp, NULL, 0)));}double      nan  ( const char *tagp ){	return(nanl(tagp));}float       nanf ( const char *tagp ){	return(nanl(tagp));}long double nextafterl ( long double x, long double y ){	extended80 x80, y80;#if __MC68881__	extended x96=x, y96=y;	x96tox80(&x96,&x80);	x96tox80(&y96,&y80);#else	/* SANE */	x80=x; y80=y;#endif	NextExtended(&x80,&y80);#if __MC68881__	x80tox96(&y80,&y96); return(y96);#else	/* SANE */	return(y80);#endif}double      nextafterd ( double x, double y ){	double temp=x;	NextDouble(&temp,&y);	return(temp);}float       nextafterf ( float x, float y ){	float temp=x;	NextFloat(&temp,&y);	return(temp);}/********************************************************************************                      Max, Min and Positive Difference                        ********************************************************************************/double_t fdim ( double_t x, double_t y ){	if (__isnan(x)) return(x);	if (__isnan(y)) return(y);	if (x > y)  return(x-y);  else return(+0.0);}double_t fmax ( double_t x, double_t y ){	if (__isnan(x) && __isnan(y)) return(x);	if (__isnan(x)) return(y);	else if (__isnan(y)) return(x);	return((x>=y) ? x : y);}double_t fmin ( double_t x, double_t y ){	if (__isnan(x) && __isnan(y)) return(x);	if (__isnan(x)) return(y);	else if (__isnan(y)) return(x);	return((x<=y) ? x : y);}/********************************************************************************                              Internal prototypes                             ********************************************************************************/long int __fpclassify  ( long double x ){	NumClass fpclass;	extended80 x80;#if __MC68881__	extended96 x96=x;	x96tox80(&x96,&x80);#else	/* SANE */	x80=x;#endif	ClassExtended(&x80,&fpclass);	return(fpclass-1);	/* SANE is one off from fp */}long int __fpclassifyd ( double x ){	NumClass fpclass;	double temp=x;	ClassDouble(&temp,&fpclass);	return(fpclass-1);	/* SANE is one off from fp */}long int __fpclassifyf ( float x ){	NumClass fpclass;	float temp=x;	ClassFloat(&temp,&fpclass);	return(fpclass-1);	/* SANE is one off from fp */}long int __isnormal  ( long double x ){	return(__fpclassify(x) == FP_NORMAL);}long int __isnormald ( double x ){	return(__fpclassifyd(x) == FP_NORMAL);}long int __isnormalf ( float x ){	return(__fpclassifyf(x) == FP_NORMAL);}long int __isfinite  ( long double x ){	long int fpclass = __fpclassify(x);	return ((fpclass==FP_ZERO) ||			(fpclass==FP_NORMAL) ||			(fpclass==FP_SUBNORMAL));}long int __isfinited ( double x ){	long int fpclass = __fpclassifyd(x);	return ((fpclass==FP_ZERO) ||			(fpclass==FP_NORMAL) ||			(fpclass==FP_SUBNORMAL));}long int __isfinitef ( float x ){	long int fpclass = __fpclassifyf(x);	return ((fpclass==FP_ZERO) ||			(fpclass==FP_NORMAL) ||			(fpclass==FP_SUBNORMAL));}long int __isnan  ( long double x ){	long int fpclass = __fpclassify(x);	return((fpclass==FP_SNAN) || (fpclass==FP_QNAN));}long int __isnand ( double x ){	long int fpclass = __fpclassifyd(x);	return((fpclass==FP_SNAN) || (fpclass==FP_QNAN));}long int __isnanf ( float x ){	long int fpclass = __fpclassifyf(x);	return((fpclass==FP_SNAN) || (fpclass==FP_QNAN));}long int __signbit  ( long double x ){	extended80 x80;#if __MC68881__	extended x96=x;	x96tox80(&x96,&x80);#else	x80=x;#endif	return(SignNum(x80));}long int __signbitd ( double x ){	return(__signbit(x));}long int __signbitf ( float x ){	return(__signbit(x));}double_t __inf ( void ){	return(*(double_t *)__inf__);}/********************************************************************************                              Non NCEG extensions                             ********************************************************************************//********************************************************************************                              Financial functions                             ********************************************************************************/double_t compound ( double_t rate, double_t periods ){	extended80 rate80, periods80, result80;#if __MC68881__	extended96 rate96=rate, periods96=periods, result96;	x96tox80(&rate96,&rate80);	x96tox80(&periods96,&periods80);#else	rate80=rate, periods80=periods;#endif	Compound(&rate80,&periods80,&result80);#if __MC68881__	x80tox96(&result80,&result96); return(result96);#else	return(result80);#endif}double_t annuity ( double_t rate, double_t periods ){	extended80 rate80, periods80, result80;#if __MC68881__	extended96 rate96=rate, periods96=periods, result96;	x96tox80(&rate96,&rate80);	x96tox80(&periods96,&periods80);#else	rate80=rate, periods80=periods;#endif	Annuity(&rate80, &periods80, &result80);#if __MC68881__	x80tox96(&result80,&result96); return(result96);#else	return(result80);#endif}/********************************************************************************                              Random function                                 ********************************************************************************/double_t randomx ( double_t *x ){	extended80 x80;#if __MC68881__	extended96 x96=*x;	x96tox80(&x96,&x80);#else	x80=*x;#endif	RandomX(&x80);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	return(x80);#endif}/********************************************************************************                              Relational operator                             ********************************************************************************/relop relation ( double_t x, double_t y ){	extended80 x80, y80;#if __MC68881__	extended96 x96=x, y96=y;	x96tox80(&x96,&x80);	x96tox80(&y96,&y80);#else	x80=x, y80=y;#endif	return(Relation(&y80, &x80));}/********************************************************************************                         Binary to decimal conversions                        ********************************************************************************/void num2dec ( const decform *f, double_t x, decimal *d ){#if __MC68881__	extended80 x80;	extended96 x96=x;	x96tox80(&x96,&x80);#else	extended80 x80=x;#endif		Num2Dec((DecForm *)f, &x80, (Decimal *)d);}double_t dec2num ( const decimal *d ){	extended80 x80;#if __MC68881__	extended96 x96;#endif	Dec2Num((Decimal *)d,&x80);#if __MC68881__	x80tox96(&x80,&x96); return(x96);#else	return(x80);#endif}void dec2str ( const decform *f, const decimal *d, char *s ){	Dec2Str((DecForm *)f,(Decimal *)d,(StringPtr)s);	p2cstr((unsigned char *)s);}void str2dec ( const char *s, short *ix, decimal *d, short *vp ){	*vp = *vp << 8;	/* since pascal puts the boolean byte in the upper byte */	CStr2Dec((char *)s,ix,(Decimal *)d,(Boolean *)vp);	*vp = *vp >> 8;	/* since pascal puts the boolean byte in the upper byte */}double dec2d ( const decimal *d ){	return((double)dec2num(d));}float dec2f ( const decimal *d ){	return((float)dec2num(d));}short int dec2s ( const decimal *d ){	return((short)dec2num(d));}long int dec2l  ( const decimal *d ){	return((long)dec2num(d));}