/*	File:		CGlue.c	Contains:	Sources for C glue to toolbox routines.				These functions use C calling conventions and need to be 				recompiled for each compiler.  	Written by:	Nick Kledzik	Copyright:	© 1993-1994 by Apple Computer, Inc., all rights reserved.	Change History (most recent first):		 <2>	 8/28/94	ngk		Fix warning in SC.		 <1>	 8/28/94	ngk		Test C<->Pascal string routines.		 							Fix misuses of 'const'.		 <0>	  7/5/94	ngk		factored out from glue sources.*/ #if __MWERKS__#pragma pointers_in_D0		//	required for c-style toolbox glue function: c2pstr and p2cstr							//	the inverse operation (pointers_in_A0) is performed at the end ...#endif//	Generate this as near code calls ...#pragma near_code// were defining the C glue here, so we need to force it to be in the headers#define CGLUESUPPORTED 1/*******************************  Strings ******************************/#include <Strings.h>char *p2cstr(StringPtr aStr){	return (char *) P2CStr(aStr);}StringPtr c2pstr(char *aStr){ 	return C2PStr(aStr);}#include <Types.h>////	CopyPascalStringToC converts the source pascal string to a destination//	C string as it copies. //static void CopyPascalStringToC(ConstStr255Param src, char* dst){	if ( src != NULL )	{		short   length  = *src++;			while ( length > 0 ) 		{			*dst++ = *(char*)src++;			--length;		}	}	*dst = '\0';}////	CopyCStringToPascal converts the source C string to a destination//	pascal string as it copies. The dest string will//	be truncated to fit into an Str255 if necessary.//  If the C String pointer is NULL, the pascal string's length is set to zero//static void CopyCStringToPascal(const char* src, Str255 dst){	short 	length  = 0;		// handle case of overlapping strings	if ( (void*)src == (void*)dst )	{		unsigned char*		curdst = &dst[1];		unsigned char		thisChar;						thisChar = *(const unsigned char*)src++;		while ( thisChar != '\0' ) 		{			unsigned char	nextChar;						// use nextChar so we don't overwrite what we are about to read			nextChar = *(const unsigned char*)src++;			*curdst++ = thisChar;			thisChar = nextChar;						if ( ++length >= 255 )				break;		}	}	else if ( src != NULL )	{		unsigned char*		curdst = &dst[1];		short 				overflow = 255;		// count down so test it loop is faster		register char		temp;			// Can't do the K&R C thing of Òwhile (*s++ = *t++)Ó because it will copy trailing zero		// which might overrun pascal buffer.  Instead we use a temp variable.		while ( (temp = *src++) != 0 ) 		{			*(char*)curdst++ = temp;							if ( --overflow <= 0 )				break;		}		length = 255 - overflow;	}	dst[0] = length;}//// StrLen is only used in this file and is not exported. It provides the//	same functionality of strlen in the standard C library, but we do not//	want to have to depend on the StdCLib for linking//static unsigned short StrLen(const char* str){	unsigned short count = 0;		while (*str++) count++;	return count;}/*******************************  Controls ****************************/#include <Controls.h>ControlHandle newcontrol(WindowPtr theWindow, const Rect* boundsRect, const char* title, 						Boolean visible, short value, short min, short max, short procID, long refCon){	Str255 pString;		CopyCStringToPascal(title, pString);	return NewControl(theWindow, (Rect*)boundsRect, pString, 			visible, value, min, max, procID, refCon);}void setcontroltitle(ControlHandle theControl, const char* title){	Str255 pString;	CopyCStringToPascal(title, pString);	SetControlTitle(theControl, pString);}void getcontroltitle(ControlHandle theControl, char* title){	Str255 pString;	GetControlTitle(theControl, pString);	CopyPascalStringToC(pString, title);}short testcontrol(ControlHandle theControl, Point *thePt){	return TestControl(theControl, *thePt);}short findcontrol(Point *thePoint, WindowPtr theWindow, ControlHandle *theControl){	return FindControl(*thePoint, theWindow, theControl);}short trackcontrol(ControlHandle theControl, Point *thePoint, ControlActionUPP action){	return TrackControl(theControl, *thePoint, action);}void dragcontrol(ControlHandle theControl, Point *startPt, const Rect* limitRect, 				const Rect* slopRect, short axis){	DragControl(theControl, *startPt, limitRect, slopRect, axis);}/*******************************  Devices ****************************/#include <Devices.h>OSErr opendriver(const char* driverName, short *refNum){	Str255 pString;	CopyCStringToPascal(driverName, pString);	return OpenDriver(pString, refNum);}short opendeskacc(const char* deskAccName){	Str255 pString;		CopyCStringToPascal(deskAccName, pString);	return OpenDeskAcc(pString);}/*******************************  Dialogs ****************************/#include <Dialogs.h>DialogPtr newdialog(void *wStorage, const Rect *boundsRect, const char *title, Boolean visible, 					short procID, WindowPtr behind, Boolean goAwayFlag, long refCon, Handle itmLstHndl){	Str255 pString;	CopyCStringToPascal(title, pString);	return NewDialog(wStorage, boundsRect, pString, visible,			procID, behind, goAwayFlag, refCon, itmLstHndl);}DialogPtr newcolordialog(void *dStorage, const Rect *boundsRect, const char* title, 						Boolean visible, short procID, WindowPtr behind, 						Boolean goAwayFlag, long refCon, Handle items){	Str255 pString;	CopyCStringToPascal(title, pString);	return NewColorDialog(dStorage, boundsRect, pString, visible,			procID, behind, goAwayFlag, refCon, items);}void paramtext(const char* param0, const char* param1, const char* param2, const char* param3){	Str255 pString0, pString1, pString2, pString3;		CopyCStringToPascal(param0, pString0);	CopyCStringToPascal(param1, pString1);	CopyCStringToPascal(param2, pString2);	CopyCStringToPascal(param3, pString3);	ParamText(pString0, pString1, pString2, pString3);}void getdialogitemtext(Handle item, char *text){	Str255 pString;	GetDialogItemText(item, pString);	CopyPascalStringToC(pString, text);}void setdialogitemtext(Handle item, const char* text){	Str255 pString;	CopyCStringToPascal(text, pString);	SetDialogItemText(item, pString);}short finddialogitem(DialogPtr theDialog, Point *thePt){	return FindDialogItem(theDialog, *thePt);}/*******************************  DiskInit ****************************/#include <DiskInit.h>OSErr dibadmount(Point *where, long evtMessage){	return DIBadMount(*where, evtMessage);}OSErr dizero(short drvnum, const char* volName){	Str255 pString;	CopyCStringToPascal(volName, pString);	return DIZero(drvnum, pString);}/*******************************  Files ****************************/#include <Files.h>OSErr getvinfo(short drvNum, char* volName, short *vRefNum, long *freeBytes){	if ( volName == NULL ) 	{		// I don't know if it is legal for volName to be NULL, but if it is don't use CopyCStringToPascal		return GetVInfo(drvNum, NULL, vRefNum, freeBytes);	}	else	{		OSErr 	result;		Str255	pString;				result =  GetVInfo(drvNum, pString, vRefNum, freeBytes);		CopyPascalStringToC(pString, volName);		return result;	}}OSErr fsopen(const char* fileName, short vRefNum, short *refNum){	if ( fileName == NULL)	{		// I don't know if it is legal for filename to be NULL, but if it is don't use CopyCStringToPascal		return FSOpen(NULL, vRefNum, refNum);			}	else	{		Str255 pString;			CopyCStringToPascal(fileName, pString);		return FSOpen(pString, vRefNum, refNum);	}}OSErr getfinfo(const char* fileName, short vRefNum, FInfo *fndrInfo){	if ( fileName == NULL)	{		// I don't know if it is legal for filename to be NULL, but if it is don't use CopyCStringToPascal		return GetFInfo(NULL, vRefNum, fndrInfo);			}	else	{		Str255 pString;			CopyCStringToPascal(fileName, pString);		return GetFInfo(pString, vRefNum, fndrInfo);	}}OSErr getvol(char* volName, short *vRefNum){	if ( volName == NULL)	{		// I don't know if it is legal for volName to be NULL, but if it is don't use CopyCStringToPascal		return GetVol(NULL, vRefNum);			}	else	{		Str255 pString;		OSErr result;			result = GetVol(pString, vRefNum);		CopyPascalStringToC(pString, volName);		return result;	}}OSErr setvol(const char* volName, short vRefNum){	if ( volName == NULL)	{		// set by vRefNum		return SetVol(NULL, vRefNum);			}	else	{		Str255 pString;			// set by name		CopyCStringToPascal(volName, pString);		return SetVol(pString, vRefNum);	}}OSErr unmountvol(const char* volName, short vRefNum){	if ( volName == NULL)	{		// unmount by vRefNum		return UnmountVol(NULL, vRefNum);			}	else	{		Str255 pString;		// Note: at one time this function would see if the volName was a zero length string.		// If so, it would cast away the const and return the volName returned by UnmountVol		CopyCStringToPascal(volName, pString);		return UnmountVol(pString, vRefNum);	}}OSErr eject(const char* volName, short vRefNum){	if ( volName == NULL)	{		// unmount by vRefNum		return Eject(NULL, vRefNum);			}	else	{		Str255 pString;		// Note: at one time this function would see if the volName was a zero length string.		// If so, it would cast away the const and return the volName returned by Eject		CopyCStringToPascal(volName, pString);		return Eject(pString, vRefNum);	}}OSErr flushvol(const char* volName, short vRefNum){	if ( volName == NULL)	{		// I don't know if it is legal for volName to be NULL, but if it is don't use CopyCStringToPascal		return FlushVol(NULL, vRefNum);			}	else	{		Str255 pString;			CopyCStringToPascal(volName, pString);		return FlushVol(pString, vRefNum);	}}OSErr create(const char* fileName, short vRefNum, OSType creator, OSType fileType){	if ( fileName == NULL)	{		// I don't know if it is legal for fileName to be NULL, but if it is don't use CopyCStringToPascal		return Create(NULL, vRefNum, creator, fileType);	}	else	{		Str255 pString;			CopyCStringToPascal(fileName, pString);		return Create(pString, vRefNum, creator, fileType);	}}OSErr fsdelete(const char* fileName, short vRefNum){	if ( fileName == NULL)	{		// I don't know if it is legal for fileName to be NULL, but if it is don't use CopyCStringToPascal		return FSDelete(NULL, vRefNum);	}	else	{		Str255 pString;			CopyCStringToPascal(fileName, pString);		return FSDelete(pString, vRefNum);	}}OSErr openrf(const char* fileName, short vRefNum, short *refNum){	if ( fileName == NULL)	{		// I don't know if it is legal for fileName to be NULL, but if it is don't use CopyCStringToPascal		return OpenRF(NULL, vRefNum, refNum);	}	else	{		Str255 pString;			CopyCStringToPascal(fileName, pString);		return OpenRF(pString, vRefNum, refNum);	}}OSErr fsrename(const char* oldName, short vRefNum, const char* newName){	Str255 pString1, pString2;	StringPtr oldPtr = pString1;	StringPtr newPtr = pString2;		if ( oldName == NULL )								oldPtr = NULL;	else 		CopyCStringToPascal(oldName, pString1);		if ( newName == NULL )				newPtr = NULL;	else 		CopyCStringToPascal(newName, pString2);		return Rename(oldPtr, vRefNum, newPtr);}OSErr setfinfo(const char* fileName, short vRefNum, const FInfo *fndrInfo){	if ( fileName == NULL)	{		// I don't know if it is legal for fileName to be NULL, but if it is don't use CopyCStringToPascal		return SetFInfo(NULL, vRefNum, fndrInfo);	}	else	{		Str255 pString;			CopyCStringToPascal(fileName, pString);		return SetFInfo(pString, vRefNum, fndrInfo);	}}OSErr setflock(const char* fileName, short vRefNum){	if ( fileName == NULL)	{		// I don't know if it is legal for fileName to be NULL, but if it is don't use CopyCStringToPascal		return SetFLock(NULL, vRefNum);	}	else	{		Str255 pString;			CopyCStringToPascal(fileName, pString);		return SetFLock(pString, vRefNum);	}}OSErr rstflock(const char* fileName, short vRefNum){	if ( fileName == NULL)	{		// I don't know if it is legal for fileName to be NULL, but if it is don't use CopyCStringToPascal		return RstFLock(NULL, vRefNum);	}	else	{		Str255 pString;			CopyCStringToPascal(fileName, pString);		return RstFLock(pString, vRefNum);	}}/*******************************  Fonts ****************************/#include <Fonts.h>void getfnum(const char* theName, short *familyID){	Str255 pString;		CopyCStringToPascal(theName, pString);	GetFNum(pString, familyID);}void getfontname(short familyID, char *theName){	Str255 pString;		GetFontName(familyID, pString);	CopyPascalStringToC(pString, theName);}/*******************************  Lists ****************************/#include <Lists.h>void laddtocell(const Ptr dataPtr, short dataLen, Cell *theCell, ListHandle lHandle){	LAddToCell(dataPtr, dataLen, *theCell, lHandle);}void lcellsize(Point *cSize, ListHandle lHandle){	LCellSize(*cSize, lHandle);}Boolean lclick(Point *pt, short modifiers, ListHandle lHandle){	return LClick(*pt, modifiers, lHandle);}void lclrcell(Cell *theCell, ListHandle lHandle){ 	LClrCell(*theCell, lHandle);}void ldraw(Cell *theCell, ListHandle lHandle){	LDraw(*theCell, lHandle);}void lgetcelldatalocation(short *offset, short *len, Cell *theCell, ListHandle lHandle){	LGetCellDataLocation( offset, len, *theCell, lHandle);}void lgetcell(Ptr dataPtr, short *dataLen, Cell *theCell, ListHandle lHandle){	LGetCell(dataPtr,  dataLen, *theCell, lHandle);}ListHandle  lnew(Rect *rView, Rect *dataBounds, Point *cSize, short theProc, 	WindowPtr theWindow, Boolean drawIt, Boolean HasGrow, Boolean ScrollHoriz, 	Boolean ScrollVert){	return LNew(rView, dataBounds, *cSize, theProc, theWindow, drawIt, HasGrow, ScrollHoriz, ScrollVert);}void lrect(Rect *cellRect, Cell *theCell, ListHandle lHandle){	LRect( cellRect, *theCell, lHandle);}void lsetcell(const Ptr dataPtr, short dataLen, Cell *theCell, ListHandle lHandle){	LSetCell(dataPtr, dataLen, *theCell, lHandle);}void lsetselect(Boolean setIt, Cell *theCell, ListHandle lHandle){	LSetSelect(setIt, *theCell, lHandle);}/*******************************  Menus ****************************/#include <Menus.h>MenuHandle newmenu(short menuID, const char *menuTitle){	Str255 pString;	CopyCStringToPascal(menuTitle, pString);	return NewMenu(menuID, pString);}void getmenuitemtext(MenuHandle menu, short item, char *itemString){		Str255 pString;	GetMenuItemText(menu, item, pString);	CopyPascalStringToC(pString, itemString);}void appendmenu(MenuHandle menu, const char *data){	Str255 pString;	CopyCStringToPascal(data, pString);	AppendMenu(menu, pString);}void insertmenuitem(MenuHandle theMenu, const char *itemString, short afterItem){	Str255 pString;	CopyCStringToPascal(itemString, pString);	InsertMenuItem(theMenu, pString, afterItem);}long menuselect(const Point *startPt){	return MenuSelect(*startPt);}void setmenuitemtext(MenuHandle menu, short item, const char *itemString){	Str255 pString;	CopyCStringToPascal(itemString, pString);	SetMenuItemText(menu, item, pString);}/*******************************  Quickdraw ****************************/#include <Quickdraw.h>void drawstring(const char* s){	Str255 pString;		CopyCStringToPascal(s, pString);	DrawString(pString);}short stringwidth(const char* s){	Str255 pString;		CopyCStringToPascal(s, pString);	return StringWidth(pString);}Boolean ptinrect(const Point *pt, const Rect *r){	return PtInRect(*pt, r);		}void pt2rect(const Point *pt1, const Point *pt2, Rect *destRect){	Pt2Rect(*pt1, *pt2, (Rect*)destRect);		}void pttoangle(const Rect *r, const Point *pt, short *angle){	PtToAngle(r, *pt, angle); 						}Boolean ptinrgn(const Point *pt, RgnHandle rgn){	return PtInRgn(*pt, rgn);}void addpt(const Point *src, Point *dst){	AddPt(*src, dst);}void subpt(const Point *src, Point *dst){	SubPt(*src, dst);}Boolean equalpt(const Point *pt1, const Point *pt2){	return EqualPt(*pt1, *pt2);}void stuffhex(void* thingPtr, const char* s){	Str255 pString;		CopyCStringToPascal(s, pString);	StuffHex(thingPtr, pString);}void stdtext(short count, const void *textAddr, const Point *number, const Point *denom){	StdText(count, (Ptr)textAddr, *number, *denom);}void stdline(const Point *newPt){	StdLine(*newPt);}/*******************************  Resources ****************************/#include <Resources.h>short openrfperm(const char* fileName, short vRefNum, char permission){	Str255 pString;		CopyCStringToPascal(fileName, pString);	return OpenRFPerm(pString, vRefNum, permission);}short openresfile(const char* fileName){	Str255 pString;		CopyCStringToPascal(fileName, pString);	return OpenResFile(pString);}void createresfile(const char* fileName){	Str255 pString;		CopyCStringToPascal(fileName, pString);	CreateResFile(pString);}void getresinfo(Handle theResource, short *theID, ResType *theType, char *name){	Str255	pString;		GetResInfo(theResource, theID, theType, pString);	CopyPascalStringToC(pString, name);}void setresinfo(Handle theResource, short theID, const char* name){	Str255 pString;		CopyCStringToPascal(name, pString);	SetResInfo(theResource, theID, pString);}void addresource(Handle theResource, ResType theType, short theID, const char* name){	Str255 pString;		CopyCStringToPascal(name, pString);	AddResource(theResource, theType, theID, pString);}Handle getnamedresource(ResType theType, const char* name){	Str255 pString;		CopyCStringToPascal(name, pString);	return GetNamedResource(theType, pString);}Handle get1namedresource(ResType theType, const char* name){	Str255 pString;		CopyCStringToPascal(name, pString);	return GetNamedResource(theType, pString);}/*******************************  StandardFile ****************************/#include <StandardFile.h>void sfpputfile(Point *where, const char* prompt, const char* origName, DlgHookUPP dlgHook,				SFReply *reply, short dlgID, ModalFilterUPP filterProc){	Str255 pString1, pString2;	CopyCStringToPascal(prompt, pString1);	CopyCStringToPascal(origName, pString2);	SFPPutFile(*where, pString1, pString2, dlgHook, reply, dlgID, filterProc);}void sfgetfile(Point *where, const char* prompt, FileFilterUPP fileFilter,			short numTypes, SFTypeList typeList, DlgHookUPP dlgHook, SFReply *reply){	Str255 pString;	CopyCStringToPascal(prompt, pString);	SFGetFile(*where, pString, fileFilter, numTypes, typeList, dlgHook, reply);}void sfpgetfile(Point *where, const char* prompt, FileFilterUPP fileFilter,				short numTypes, SFTypeList typeList, DlgHookUPP dlgHook, SFReply *reply,				short dlgID, ModalFilterUPP filterProc){	Str255 pString;	CopyCStringToPascal(prompt, pString);	SFPGetFile(*where, pString, fileFilter, numTypes, typeList, 			dlgHook, reply, dlgID, filterProc);}void sfputfile(Point *where, const char* prompt, const char* origName, DlgHookUPP dlgHook, 				SFReply *reply){	Str255 pString1, pString2;		CopyCStringToPascal(prompt, pString1);	CopyCStringToPascal(origName, pString2);	SFPutFile(*where, pString1, pString2, dlgHook, reply);}/*******************************  TextEdit ****************************/#include <TextEdit.h>void teclick(Point *pt, Boolean fExtend, TEHandle h){	TEClick(*pt, fExtend, h);}/*******************************  TextUtils ****************************/#include <TextUtils.h>#include <Traps.h>#if !CFMSYSTEMCALLS #pragma parameter __D0 Trap0xA03C(__A0, __A1, __D0)pascal long Trap0xA03C(const void* text1, const void* text2, long lengths) = 0xA03C; #pragma parameter __D0 Trap0xA23C(__A0, __A1, __D0)pascal long Trap0xA23C(const void* text1, const void* text2, long lengths) = 0xA03C; #pragma parameter __D0 Trap0xA43C(__A0, __A1, __D0)pascal long Trap0xA43C(const void* text1, const void* text2, long lengths) = 0xA03C; #pragma parameter __D0 Trap0xA63C(__A0, __A1, __D0)pascal long Trap0xA63C(const void* text1, const void* text2, long lengths) = 0xA03C;  #pragma parameter __D0 Trap0xA050(__A0, __A1, __D0)pascal short Trap0xA050(const void* text1, const void* text2, long lengths) = 0xA050; #pragma parameter __D0 Trap0xA250(__A0, __A1, __D0)pascal short Trap0xA250(const void* text1, const void* text2, long lengths) = 0xA050; #pragma parameter __D0 Trap0xA450(__A0, __A1, __D0)pascal short Trap0xA450(const void* text1, const void* text2, long lengths) = 0xA050; #pragma parameter __D0 Trap0xA650(__A0, __A1, __D0)pascal short Trap0xA650(const void* text1, const void* text2, long lengths) = 0xA050;  #pragma parameter Trap0xA054(__A0, __D0)pascal void Trap0xA054(const void* text, short length) = 0xA054; #pragma parameter Trap0xA254(__A0, __D0)pascal void Trap0xA254(const void* text, short length) = 0xA254; #endifBoolean equalstring(const char* text1, const char* text2, Boolean caseSens, Boolean diacSens){	unsigned short			trapWord	= _CmpString;	long					lengths	= ((unsigned long)(StrLen(text1) & 0x0000FFFF) << 16) | 										(StrLen(text2) & 0x0000FFFF);		if (!diacSens)		trapWord |= 0x0200;	/* set bit 9 to ignore diacritical marks */	if (caseSens)		trapWord |= 0x0400; /* set bit 10 to indicate case sensitivity */	{		long	result;				switch ( trapWord )		{		case 0xA03C:			result = Trap0xA03C(text1, text2, lengths);			break;		case 0xA23C:			result = Trap0xA23C(text1, text2, lengths);			break;		case 0xA43C:			result = Trap0xA43C(text1, text2, lengths);			break;		case 0xA63C:			result = Trap0xA63C(text1, text2, lengths);			break;		}		return ( ! result );	}}void upperstring(char* text, Boolean diacSens){	unsigned short trapWord = _UprString;	unsigned short length	= StrLen(text);		if (!diacSens)		trapWord |= 0x0200;	/* set bit 9 to ignore diacritical marks */	if ( trapWord == 0xA054 )		Trap0xA054(text, length);	else		Trap0xA254(text, length);}short relstring(const char* text1, const char* text2, Boolean caseSens, Boolean diacSens){	unsigned short 	trapWord	= _RelString;	short			result;	long			lengths		= ((unsigned long)(StrLen(text1) & 0x0000FFFF) << 16) | 									(StrLen(text2) & 0x0000FFFF);		if (!diacSens)		trapWord |= 0x0200;	/* set bit 9 to ignore diacritical marks */	if (caseSens)		trapWord |= 0x0400; /* set bit 10 to indicate case sensitivity */	switch ( trapWord )	{	case 0xA050:		result = Trap0xA050(text1, text2, lengths);		break;	case 0xA250:		result = Trap0xA250(text1, text2, lengths);		break;	case 0xA450:		result = Trap0xA450(text1, text2, lengths);		break;	case 0xA650:		result = Trap0xA650(text1, text2, lengths);		break;	}	return result;}void setstring(StringHandle theString, const char* strNew){	Str255 pString;		CopyCStringToPascal(strNew, pString);	SetString(theString, pString);}StringHandle newstring(const char* theString){	Str255 pString;		CopyCStringToPascal(theString, pString);	return NewString(pString);}void getindstring(char *theString, short strListID, short index){	Str255 pString;	GetIndString(pString, strListID, index);	CopyPascalStringToC(pString, theString);}short iucompstring(const char* aStr, const char* bStr){	return CompareText(aStr, bStr, StrLen(aStr), StrLen(bStr), NULL);}short iuequalstring(const char* aStr, const char* bStr){	return IdenticalText(aStr, bStr, StrLen(aStr), StrLen(bStr), NULL);}short iucomppstring(const char* aStr, const char* bStr, Handle intlHandle){	return CompareText(aStr, bStr, StrLen(aStr), StrLen(bStr), intlHandle);}short iuequalpstring(const char* aStr, const char* bStr, Handle intlHandle){	return IdenticalText(aStr, bStr, StrLen(aStr), StrLen(bStr), intlHandle);}short iustringorder(const char* aStr, const char* bStr, 					ScriptCode aScript, ScriptCode bScript, 					LangCode aLang, LangCode bLang){	return TextOrder(aStr, bStr, StrLen(aStr), StrLen(bStr), aScript, bScript, aLang, bLang);}void stringtonum(const char* theString, long *theNum){	Str255 pString;		CopyCStringToPascal(theString, pString);	StringToNum(pString, theNum);}void numtostring(long theNum, char *theString){	Str255	pString;			NumToString(theNum, pString);	CopyPascalStringToC(pString, theString);}void iudatestring(long dateTime, DateForm longFlag, char *result){	Str255	pString;		DateString(dateTime, longFlag, pString, NULL);	CopyPascalStringToC(pString, result);}void iudatepstring(long dateTime, DateForm longFlag, char *result, Handle intlHandle){	Str255	pString;			DateString(dateTime, longFlag, pString, intlHandle);	CopyPascalStringToC(pString, result);}void iutimestring(long dateTime, Boolean wantSeconds, char *result){	Str255	pString;			TimeString(dateTime, wantSeconds, pString, NULL);	CopyPascalStringToC(pString, result);}void iutimepstring(long dateTime, Boolean wantSeconds, char *result, Handle intlHandle){	Str255	pString;			TimeString(dateTime, wantSeconds, pString, intlHandle);	CopyPascalStringToC(pString, result);}void iuldatestring(LongDateTime *dateTime, DateForm longFlag, char *result, Handle intlHandle){	Str255	pString;			LongDateString(dateTime, longFlag, pString, intlHandle);	CopyPascalStringToC(pString, result);}void iultimestring(LongDateTime *dateTime, Boolean wantSeconds, char *result, Handle intlHandle){	Str255	pString;		LongTimeString(dateTime, wantSeconds, pString, intlHandle);	CopyPascalStringToC(pString, result);}/*******************************  Windows ****************************/#include <Windows.h>void setwtitle(WindowPtr theWindow, const char* title){	Str255 pString;		CopyCStringToPascal(title, pString);	SetWTitle(theWindow, pString);}Boolean trackgoaway(WindowPtr theWindow, Point *thePt){	return TrackGoAway(theWindow, *thePt);}short findwindow(Point *thePoint, WindowPtr *theWindow){	return FindWindow(*thePoint, theWindow);}void getwtitle(WindowPtr theWindow, char *title){	Str255 pString;	GetWTitle(theWindow, pString);	CopyPascalStringToC(pString, title);}long growwindow(WindowPtr theWindow, Point *startPt, const Rect *bBox){	return GrowWindow(theWindow, *startPt, bBox);}WindowPtr newwindow(void *wStorage, const Rect *boundsRect, const char* title, Boolean visible, 					short theProc, WindowPtr behind, Boolean goAwayFlag, long refCon){	Str255 pString;		CopyCStringToPascal(title, pString);	return NewWindow(wStorage, boundsRect, pString, visible, theProc,						behind, goAwayFlag, refCon);}WindowPtr newcwindow(void *wStorage, const Rect *boundsRect, const char *title, 					Boolean visible, short procID, WindowPtr behind, Boolean goAwayFlag, long refCon){	Str255 pString;		CopyCStringToPascal(title, pString);	return NewCWindow(wStorage, boundsRect, pString, visible, procID,						behind, goAwayFlag, refCon);}long pinrect(const Rect *theRect, Point *thePt){	return PinRect(theRect, *thePt);	}Boolean trackbox(WindowPtr theWindow, Point *thePt, short partCode){	return TrackBox(theWindow, *thePt, partCode);}long draggrayrgn(RgnHandle theRgn, Point *startPt, const Rect *boundsRect, 				const Rect *slopRect, short axis, DragGrayRgnUPP actionProc){	return DragGrayRgn(theRgn, *startPt, boundsRect, slopRect, axis, actionProc);}void dragwindow(WindowPtr theWindow, Point *startPt, const Rect *boundsRect){	DragWindow(theWindow, *startPt, boundsRect);}#if __MWERKS__#pragma pointers_in_A0		//	required for c-style toolbox glue function: c2pstr and p2cstr							//	the inverse operation (pointers_in_A0) is performed at the end ...#endif