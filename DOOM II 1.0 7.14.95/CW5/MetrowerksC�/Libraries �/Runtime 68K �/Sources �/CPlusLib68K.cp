/************************************************************************//*	Project...:	C++ and ANSI-C Compiler Environment						*//*	Name......:	CPlusLib.c												*//*	Purpose...:	C++ specific runtime functions							*//*  Copyright.: ©Copyright 1994 by metrowerks inc. All rights reserved. *//************************************************************************/#include <Types.h>#include <Assembler.h>#include <stdlib.h>#include <CPlusLib68K.h>long			__ptmf_null[3];				//	a NULL pointer to member/************************************************************************//* Purpose..: Test if a pointer to function member is != 0				*//* Input....: pointer to function member								*//* Return...: 0: is zero; 1: is not zero								*//************************************************************************/asm long __ptmf_test(const void *ptmf){	move.l	4(sp),a0	//	ptr_to_function_member	tst.l	(a0)+		//	test if *ptr_to_function_member == { 0L,0L,0L }	bne.s	L9	tst.l	(a0)+	bne.s	L9	tst.l	(a0)+	bne.s	L9	moveq	#0,d0	rtsL9:	moveq	#1,d0	rts}/************************************************************************//* Purpose..: Test if two pointers to function member are equal			*//* Input....: two pointers to function members							*//* Return...: 1: *ptmf1!=*ptmf2; 0: *ptmf1==*ptmf2						*//************************************************************************/asm long __ptmf_cmpr(const void *ptmf1,const void *ptmf2){	move.l	4(sp),a0		//	*ptmf1 	move.l	8(sp),a1		//	*ptmf2	cmpm.l	(a0)+,(a1)+	bne.s	L9		cmpm.l	(a0)+,(a1)+	bne.s	L9		cmpm.l	(a0)+,(a1)+	bne.s	L9		moveq	#0,d0	rtsL9:	moveq	#1,d0	rts}/************************************************************************//* Purpose..: Call a member function through a pointer to member		*//* Input....: (a0: pointer to this )									*//* Input....: (a1: pointer to pointer to function member struct)		*//* Input....: (all other arguments on stack)							*//* Return...: ---														*//************************************************************************/asm void __ptmf_call(...){	add.l	struct(MemberFuncPointerType.this_delta)(a1),a0		//	adjust *this	tst.l	struct(MemberFuncPointerType.vtbl_offset)(a1)	blt.s	directcall	move.l	struct(MemberFuncPointerType.vtbl_offset)(a1),-(sp)	move.l	struct(MemberFuncPointerType.func_data.ventry_offset)(a1),-(sp)	move.l	a0,a1			//	load *this to a1	add.l	(sp)+,a1		//	add offset of vtableptr to a1	move.l	(a1),a1			//	load vtableptr to a1	add.l	(sp)+,a1		//	add vtable entry offset to a1	add.l	4(a1),a0		//	adjust *this by vtable entry offset	move.l	(a1),a1			//	get function address from vtable entry	jmp		(a1)directcall:	move.l	struct(MemberFuncPointerType.func_data.func_addr)(a1),a1	jmp		(a1)}/************************************************************************//* Purpose..: Call a member function through a pointer to member		*//* Input....: (a0: pointer to this )									*//* Input....: (a1: pointer to pointer to function member struct)		*//* Input....: (all other arguments on stack)							*//* Return...: ---														*//************************************************************************/asm void __ptmf_scall(...){	tst.l	struct(MemberFuncPointerType.vtbl_offset)(a1)	blt.s	directcall	move.l	struct(MemberFuncPointerType.vtbl_offset)(a1),-(sp)	move.l	struct(MemberFuncPointerType.func_data.ventry_offset)(a1),-(sp)	move.l	a0,a1			//	load *this to a1	add.l	(sp)+,a1		//	add offset of vtableptr to a1	move.l	(a1),a1			//	load vtableptr to a1	add.l	(sp)+,a1		//	add vtable entry offset to a1	move.l	(a1),a1			//	get function address from vtable entry	jmp		(a1)directcall:	move.l	struct(MemberFuncPointerType.func_data.func_addr)(a1),a1	jmp		(a1)}/************************************************************************//* Purpose..: This function will copy/cast a pointer to func member		*//* Input....: offset delta to apply	to pointer to function member		*//* Input....: pointer to original pointer to function member			*//* Input....: pointer to destiniation pointer to function member		*//* Return...: pointer to destiniation pointer to function member		*//************************************************************************/void *__ptmf_cast(long offset,const void *ptmfrom,void *ptmto){	((MemberFuncPointerType *)ptmto)->this_delta=((MemberFuncPointerType *)ptmfrom)->this_delta+offset;	if(((MemberFuncPointerType *)ptmfrom)->vtbl_offset>=0L)	{	//	virtual function pointer		((MemberFuncPointerType *)ptmto)->vtbl_offset=((MemberFuncPointerType *)ptmfrom)->vtbl_offset+offset;		((MemberFuncPointerType *)ptmto)->func_data.ventry_offset=((MemberFuncPointerType *)ptmfrom)->func_data.ventry_offset;	}	else	{	//	nonvirtual function pointer		((MemberFuncPointerType *)ptmto)->vtbl_offset=-1L;		((MemberFuncPointerType *)ptmto)->func_data.func_addr=((MemberFuncPointerType *)ptmfrom)->func_data.func_addr;	}	return(ptmto);}/************************************************************************//*	Purpose..: 	Register a global object for later destruction			*//*	Input....:	pointer to global object								*//*	Input....:	pointer to destructor function							*//*	Input....:	pointer to global registration structure				*//*	Return...:	pointer to global object (pass thru)					*//************************************************************************/void *__register_global_object(void *object,void *destructor,void *regmem){	((DestructorChain *)regmem)->next=__global_destructor_chain;	((DestructorChain *)regmem)->destructor=destructor;	((DestructorChain *)regmem)->object=object;	__global_destructor_chain=(DestructorChain *)regmem;	return(object);}/************************************************************************//*	Purpose..: 	Register a local object for later destruction			*//*	Input....:	pointer to local object									*//*	Input....:	pointer to destructor function							*//*	Input....:	pointer to local registration structure					*//*	Return...:	pointer to local object (pass thru)						*//************************************************************************/void *__register_local_object(void *object,void *destructor,void *regmem){	((DestructorChain *)regmem)->next=__local_destructor_chain;	((DestructorChain *)regmem)->destructor=destructor;	((DestructorChain *)regmem)->object=object;	__local_destructor_chain=(DestructorChain *)regmem;	return(object);}/************************************************************************//*	Purpose..: 	Pre register a local object for later destruction		*//*	Input....:	pointer to local object									*//*	Input....:	pointer to local registration structure					*//*	Return...:	pointer to local registration structure	(pass thru)		*//************************************************************************/void *__preregister_local_object(void *object,void *regmem){////	Note:	This function is used to register an object that will be constructed//			by a return statement. The result of this function will be passed to//			the function return temp memory argument.//	((DestructorChain *)regmem)->next=__local_destructor_chain;	((DestructorChain *)regmem)->object=0L;				//	kludge: but the object is not constructed	((DestructorChain *)regmem)->destructor=object;		//	until __reregister_local_object has been called	__local_destructor_chain=(DestructorChain *)regmem;	return(regmem);}/************************************************************************//*	Purpose..: 	Register a local object for later destruction			*//*	Input....:	pointer to local registration structure					*//*	Return...:	pointer to local object									*//************************************************************************/void *__reregister_local_object(void *regmem,void *destructor){////	Note:	This function will register a preregistered local object for destruction.//			It will be called before a return object is initialized via return <x>;//	((DestructorChain *)regmem)->object=((DestructorChain *)regmem)->destructor;	((DestructorChain *)regmem)->destructor=destructor;	return(((DestructorChain *)regmem)->object);}/************************************************************************//*	Purpose..: 	Destroy some constructed local objects					*//*	Input....:	pointer to last destroyed objects registration struct 	*//*	Return...:	---														*//************************************************************************/void __destroy_local_objects(void *lastregmem){	DestructorChain		*ldc;	while((ldc=__local_destructor_chain)!=0L)	{		__local_destructor_chain=__local_destructor_chain->next;		if(ldc->object)		{			((void (*)(void *:__A0,short))ldc->destructor)(ldc->object,-1);		}		if((void *)ldc==lastregmem) break;	}}/************************************************************************//*	Purpose..: 	Destroy some constructed local objects					*//*	Input....:	pointer to first not destroyed obj registration struct 	*//*	Return...:	---														*//************************************************************************/void __destroy_local_objects_to(void *lastregmem){	DestructorChain		*ldc;	while((ldc=__local_destructor_chain)!=0L)	{		if((void *)ldc==lastregmem) break;		__local_destructor_chain=__local_destructor_chain->next;		if(ldc->object)		{			((void (*)(void *:__A0,short))ldc->destructor)(ldc->object,-1);		}	}}/************************************************************************//* Purpose..: Destroy all constructed local objects						*//* Input....: pointer to chain											*//* Return...: ---														*//************************************************************************/void __destroy_local_chain(void){	DestructorChain		*ldc;	while((ldc=__local_destructor_chain)!=0L)	{		__local_destructor_chain=__local_destructor_chain->next;		if(ldc->object)		{			((void (*)(void *:__A0,short))ldc->destructor)(ldc->object,-1);		}	}}/************************************************************************//*	Purpose..: 	Copy data												*//*	Input....:	pointer to destination (can be 0L: no copy)				*//*	Input....:	pointer to source										*//*	Input....:	number of bytes to copy									*//*	Return...:	pointer to destination (or 0L)							*//************************************************************************/void *__copy(void *to,void *from,size_t size){	char *f,*t;	if(to) for(f=(char *)from,t=(char *)to; size>0; size--) *t++=*f++;	return to;}/************************************************************************//*	Purpose..: 	Initialize an array of objects							*//*	Input....:	pointer to allocated memory (+8 bytes) (0L: error)		*//*	Input....:	pointer to default constructor function	(if any)		*//*	Input....:	size of one object										*//*	Input....:	number of objects										*//*	Return...:	pointer to first object									*//************************************************************************/void *__init_arr(void *memptr,void *constructor,size_t object_size,size_t nobjects){	char	*ptr;//	Theory of operation:////	Allocate space for: two size_t objects and nobjects*object_size objects;//	Store number of allocated object and size of one object at the beginnig of the allocated block;//	Call constructor (if any) to initialize object memory;//	return pointer to first object;	if((ptr=(Ptr)memptr)!=0L)	{		*(size_t *)ptr=object_size;		*(size_t *)(ptr+sizeof(size_t))=nobjects;		ptr+=sizeof(size_t)*2;		if(constructor)		{			char	*p;			size_t	i;			for(i=0,p=ptr; i<nobjects; i++,p+=object_size)			{				((void (*)(void *:__A0,short))constructor)(p,1);			}		}	}	return(ptr);}/************************************************************************//*	Purpose..: 	Construct an array of objects							*//*	Input....:	pointer to default constructor function	(if any)		*//*	Input....:	size of one object										*//*	Input....:	number of objects										*//*	Return...:	pointer to first object									*//************************************************************************/void *__new_arr(void *constructor,size_t object_size,size_t nobjects){	char	*ptr;//	Theory of operation:////	Allocate space for: two size_t objects and nobjects*object_size objects;//	Store number of allocated object and size of one object at the begining of the allocated block;//	Call constructor (if any) to initialize object memory;//	return pointer to first object;	if((ptr=(Ptr)::operator new(2*sizeof(size_t)+object_size*nobjects))!=0L)	{		*(size_t *)ptr=object_size;		*(size_t *)(ptr+sizeof(size_t))=nobjects;		ptr+=sizeof(size_t)*2;		if(constructor)		{			char	*p;			size_t	i;			for(i=0,p=ptr; i<nobjects; i++,p+=object_size)			{				((void (*)(void *:__A0,short))constructor)(p,1);			}		}	}	return(ptr);}/************************************************************************//*	Purpose..: 	Delete an array of objects								*//*	Input....:	pointer to first object	(can be 0L)						*//*	Input....:	pointer to destructor function (if any)					*//*	Return...:	---														*//************************************************************************/void __del_arr(void *memptr,void *destructor){	if(memptr)	{		if(destructor)		{			size_t	i,objects,objectsize;			char	*p;			objectsize=*(size_t *)((Ptr)memptr-2*sizeof(size_t));			objects=*(size_t *)((Ptr)memptr-sizeof(size_t));			p=(char *)memptr+objectsize*objects;			for(i=0; i<objects; i++)			{				p-=objectsize;				((void (*)(void *:__A0,short))destructor)(p,-1);			}		}		::delete ((char *)memptr-2*sizeof(size_t));	}}/************************************************************************//*	Purpose..: 	Construct/destruct an array of objects					*//*	Input....:	pointer to memory location								*//*	Input....:	pointer to constructor/destructor function				*//*	Input....:	size of object											*//*	Input....:	number of objects										*//*	Return...:	---														*//************************************************************************/void __dc_arr(void *mem,void *con_des,short object_size,short objects){	while(objects-->0)	{		((void (*)(void *:__A0,short))con_des)(mem,-1);		*((char **)&mem)+=object_size;	}}