/****************************************************************//* Purpose..:	MULTI Segment DRVR startup-module		*//*								*//****************************************************************/#include <Types.h>#include <Memory.h>#include <Devices.h>#include <Resources.h>#include <Assembler.h>typedef struct	DRVRHeader {	short		drvrFlags;	short		drvrDelay;	short		drvrEventMask;	short		drvrMenuID;	short		drvrOpenOffset;	short		drvrPrimeOffset;	short		drvrControlOffset;	short		drvrStatusOffset;	short		drvrCloseOffset;	unsigned char	drvrname[32];}	DRVRHeader;#pragma	nearcode		// this module is not yet relocated when loadedasm void main(void){	ds.b	sizeof(DRVRHeader)dOpen:	moveq	#0,d0	bra.s	startdPrime:	moveq	#1,d0	bra.s	start1drCtrl:	moveq	#2,d0	bra.s	start1dStat:	moveq	#3,d0	bra.s	start1dClose:	moveq	#4,d0start0:	movem.l	a1/a4,-(sp)	// save data segment pointer (will be set in main resource)	move.w	d0,-(sp)	// dispatch code	move.l	a1,-(sp)	// device control entry	move.l	a0,-(sp)	// parameter block	move.l	struct(DCtlEntry.dCtlStorage)(a1),d0	bne.s	st0	bsr	setupst0:	move.l	d0,a0	move.l	(a0),a0	jsr	(a0)		// and jump to main resource	lea	10(sp),sp	// cleanup stack	movem.l	(sp)+,a4/a1	// restore data segment pointer	btst	#6,struct(DCtlEntry.dCtlFlags)(a1)	bne.s	doret		// dNeedLock is set ( do not dispose DRIVER code)	tst.w	d0	bne.s	doret		// returncode != noErr ( do not dispose DRIVER code)	move.l	struct(DCtlEntry.dCtlStorage)(a1),-(sp)	move.l	struct(DCtlEntry.dCtlStorage)(a1),-(sp)	_ReleaseResource	move.l	(sp)+,a0//Anderson added the 5 lines below the next line because you don't want to dispose twice//	_DisposHandle   	// this line was here before Anderson commented it out	cmpi.w  %resNotFound,0x0A60	bne.s   IsResource	clr.w   0x0A60  	// clear ResErr in case someone is checking (like Jasik)	_DisposeHandleIsResource:	moveq	#0,d0doret:	rts			// Open and Close are always immediatestart:	move.l	a4,-(sp)	// save data segment pointer (will be set in main resource)	move.w	d0,-(sp)	// dispatch code	move.l	a1,-(sp)	// device control entry	move.l	a0,-(sp)	// parameter block	move.l	struct(DCtlEntry.dCtlStorage)(a1),d0	bne.s	st1	bsr	setupst1:	move.l	d0,a0	move.l	(a0),a0	jsr	(a0)		// and jump to main resource	lea	10(sp),sp	// cleanup stack	move.l	(sp)+,a4	// restore data segment pointer	rts			// Open and Close are always immediatestart1:	movem.l	a0-a1/a4,-(sp)	move.w	d0,-(sp)	// dispatch code	move.l	a1,-(sp)	// device control entry	move.l	a0,-(sp)	// parameter block	move.l	struct(DCtlEntry.dCtlStorage)(a1),d0	bne.s	st2	bsr	setupst2:	move.l	d0,a0	move.l	(a0),a0	jsr	(a0)		// and jump to main resource	lea	10(sp),sp	// cleanup stack	movem.l	(sp)+,a0-a1/a4	// restore registers	cmp.w	#1,d0		// main returns 1 if async request cannot be completed	beq.s	uncomp	btst	#1,struct(IOParam.ioTrap)(a0)	// test if this was an immed TRAP	bne.s	end//Anderson copied the next line from StartupA4.c because JIODone is an undefined label	move.l	0x08FC,-(sp)	// JIODone//	move.l	JIODone,-(sp)end:	rtsuncomp:	moveq	#0,d0	rtssetup:	move.l	a1,a4		// we have to setup the dCtlStorage handle with our resource	move.w	struct(DCtlEntry.dCtlRefNum)(a4),d0	not.w	d0	lsl.w	#5,d0	ori.w	#0xC000,d0	subq.l	#4,sp	move.l	#'DRVc',-(sp)	move.w	d0,-(sp)		_GetResource	move.l	(sp)+,d0	beq.s	error	move.l	d0,struct(DCtlEntry.dCtlStorage)(a4)	move.l	d0,a0	_MoveHHi	move.l	struct(DCtlEntry.dCtlStorage)(a4),a0	_HLock	move.l	a4,a1	move.l	struct(DCtlEntry.dCtlStorage)(a4),d0	rtserror:	moveq	#15,d0	_SysError	_ExitToShell}