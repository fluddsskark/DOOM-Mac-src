/****************************************************************//* Purpose..:	The Application startup-module					*//*		C/C++ runtime function definitions						*//*																*//* Created..:	21.Sept.1990									*//****************************************************************///#define JASIK	0			// 1: custom startup for Jasik's debugger#pragma	near_code			// this module is not yet relocated when loadedchar		qd[206];		// storage space for Quickdraw globals 206 bytes#define qd	QD			// kludge for stupid QuickDraw.h header	#include <Types.h>#include <Memory.h>#include <Resources.h>#include <Assembler.h>//#include <LoMemGlobals.h>#include <stdlib.h>#include <CPlusLib68K.h>			// this is standard C !!!#include "StartupLib.h"			// this is standard C !!!#undef qd				// kludge for stupid QuickDraw.h header	#define	DATAPTR	A5			// register used to address near dataextern far int main(void);		// this is the user main() called by __startup__()extern far void __InitCode__(void);	// this is data init code called by __startup__()extern Boolean	LoadTrap:0x012D;	// if TRUE call debugger when LoadSeg is calledstruct	SegmentLoadCallbacks __segcallbacks;void	(*__exit_proc__)(void);		// pointer to function called on exitstatic	pascal void	__LoadSeg__(void);	// forwardstatic	pascal void	__UnloadSeg__(Ptr);	// forwardstatic	void		__Relocate__(void);	// forwardDestructorChain	*__global_destructor_chain;	// chain of global objects that need destructionDestructorChain	*__local_destructor_chain;	// chain of local objects that need destructionstatic Boolean	__flushinstruction__;	// flush instruction cache if setstatic Ptr	__CODE1Base__;		// base address of CODE segment 1 for quick referencestatic long	__oldLoadSeg__;		// old LoadSeg Trap Addressstatic long	__oldUnloadSeg__;	// old UnloadSeg Trap Addressstatic long	__oldExitToShell__;	// old ExitToShell Trap Address#if JASIK#include "RTLib.h"typedef struct JasikRecord {	ProcPtr	Post_Load_Proc;	ProcPtr	preUnLoad_Proc;	ProcPtr	Del_MMU_Prot_Proc;	ProcPtr	Set_MMU_Prot_Proc;} JasikRecord;static JasikRecord	jasikrecord;static void		jasikdispatch(short selector:__D0);static RTState		rtstate;#endif#ifdef MPWSTARTUP/* for MPW we need to really do a Unrelocate */static	void		__Unrelocate__(void);				// forward		void		__cleanupandexit__(long status);	// forwardextern	far	int		__MPWFixupMain__(void);				// this calls main() for MPW/* MPW Globals *///  Integrated Environment (MPW) Globalsextern long		StandAlone;		// a long, 0 if in shell, 1 if standaloneextern long		errno;			// a long, error number; set on unsuccessful I/O callsextern short	MacOSErr;		// a word;  set along with errno if appropriate//  Integrated Environment Routinesvoid _DataInit(void);			// this is stubbed out because we don't use MPW's _DataInitvoid __CplusInit(void);			// this is stubbed out because we don't use MPW's CplusInit// _RTInit is from MPW's Runtime.o see IntEnv.a// your tool MUST call this routine on startupextern int	_RTInit(long returnaddress, long *argc, long **argv, long **envp, long ispascal);extern void _mpwexit(long status);// our globals to hold some parameters.static char	**__MPWenvp;static char	**__MPWargv;static long	__MPWargc;static long	__MPWStandalone;static long	__MPWReturnAddress;// _RTInit is from MPW's Runtime.o see IntEnv.aextern int _RTInit(long returnaddress, long *argc, long **argv, long **envp, long ispascal);#endif /*MPWSTARTUP*//****************************************************************//* Purpose..: The Startup routine for Applications		*//* Input....: ---						*//* Returns..: ---						*//****************************************************************/asm void __Startup__(void);asm void __Startup__(void){	/* this must be the first code module in link file */functionstart:#if JASIK	sub.w	#sizeof(JasikRecord),sp	clr.l	struct(JasikRecord.Post_Load_Proc)(sp)	clr.l	struct(JasikRecord.preUnLoad_Proc)(sp)	clr.l	struct(JasikRecord.Del_MMU_Prot_Proc)(sp)	clr.l	struct(JasikRecord.Set_MMU_Prot_Proc)(sp)	move.l	0x38,a0	cmp.w	#0x487A,(a0)	bne.s	nojas	pea	(sp)	moveq	#27,d0	trap	#7	move.l	struct(JasikRecord.Del_MMU_Prot_Proc)(sp),a0	jsr	(a0)		// disable MMU protectionnojas:#endif	subq.l	#4,sp		/* get the CODE Resource 0 */	move.l	#'CODE',-(sp)	clr.w	-(sp)	_GetResource	move.l	(sp),d0		/* keep handle on stack for later ReleaseResource */	beq	error	movea.l	d0,a0	movea.l	(a0),a0	move.l	(a0)+,d7	/* d7:data bytes above DATAPTR */	move.l	(a0),d6		/* d6:data bytes below DATAPTR */#ifdef MPWSTARTUP	/* mpw loaded this resource and left it purgable */	move.l (sp)+,a0	_HPurge#else	_ReleaseResource	/* handle was still on stack */#endif	moveq	#0,d0		/* clear data below DATAPTR */	movea.l	DATAPTR,a0	suba.l	d6,a0	bra	loop1eloop1:	move.b	d0,(a0)+loop1e:	cmpa.l	DATAPTR,a0	blt	loop1	lea	32+8(DATAPTR),a0	/* clear data above DATAPTR */	lea	0(DATAPTR,d7.l),a1	bra	loop2eloop2:	move.b	d0,(a0)+loop2e:	cmpa.l	a1,a0	blt	loop2	subq.l	#4,sp		/* get the DATA Resource 0 */	move.l	#'DATA',-(sp)	clr.w	-(sp)	_GetResource	movea.l	(sp),a0		/* keep handle on stack for later ReleaseResource */	move.l	a0,d0	beq	error	movea.l	(a0),a2		/* now store init data into data area */loop3:	bsr	getlongfroma2	/* number of bytes to transfer */	beq	loop3e	move.l	d0,d3	bsr	getlongfroma2	/* data offset from DATAPTR */		movea.l	a2,a0		/* a0:sourcePtr */	lea	0(DATAPTR,d0.l),a1	/* a1:destPtr */	move.l	d3,d0		/* d0:countBytes */	adda.l	d0,a2		/* setup a2 for next init block */	_BlockMove	bra	loop3loop3e:	_ReleaseResource#if JASIK	move.l	struct(JasikRecord.Post_Load_Proc)(sp),jasikrecord.Post_Load_Proc	move.l	struct(JasikRecord.preUnLoad_Proc)(sp),jasikrecord.preUnLoad_Proc	move.l	struct(JasikRecord.Del_MMU_Prot_Proc)(sp),jasikrecord.Del_MMU_Prot_Proc	move.l	struct(JasikRecord.Set_MMU_Prot_Proc)(sp),jasikrecord.Set_MMU_Prot_Proc	moveq	#struct(JasikRecord.Set_MMU_Prot_Proc),d0	jsr	jasikdispatch#endif	lea	functionstart-4,a0	move.l	a0,__CODE1Base__	/* store the base address of CODE segment 1 in CODE1Base */	move.l	DATAPTR,a0		/* relocate the data segment */	moveq	#0,d0	jsr	__Relocate__	move.l	__CODE1Base__,a0	/* relocate the main code segment */	moveq	#1,d0	jsr	__Relocate__	clr.b	__flushinstruction__	move.w	#_Unimplemented,d0	_GetToolTrapAddress	move.l	a0,-(a7)	move.w	#_HWPriv,d0	_GetOSTrapAddress	cmpa.l	(a7)+,a0	beq.s	dontflush	move.b	#true,__flushinstruction__	_FlushInstructionCachedontflush:#ifndef MPWSTARTUP	move.w	#_LoadSeg,D0		// LoadSeg	_GetToolTrapAddress	move.l	A0,__oldLoadSeg__	move.w	#_UnLoadSeg,D0		// UnloadSeg	_GetToolTrapAddress	move.l	A0,__oldUnloadSeg__	move.w	#_ExitToShell,D0	// ExitToShell	_GetToolTrapAddress	move.l	A0,__oldExitToShell__	move.w	#_LoadSeg,D0		// LoadSeg	lea	__LoadSeg__,A0	_SetToolTrapAddress	move.w	#_UnLoadSeg,D0		// UnloadSeg	lea	__UnloadSeg__,A0	_SetToolTrapAddress	move.w	#_ExitToShell,D0	// ExitToShell	lea	__ExitToShell__,A0	_SetToolTrapAddress	jsr	__InitCode__		// data init code	clr.l	-(sp)			// fake dummy argv	clr.l	-(sp)			// fake dummy argc (works for 16 and 32 bit ints)	jsr	main			// start user main	addq.l	#8,sp	move.l	__exit_proc__,d0	// Call exit function	beq.s	skip_exit_proc	move.l	d0,a0	jsr	(a0)skip_exit_proc:	jsr	__destroy_global_chain	// destroy global objects__ExitToShell__:	move.l	CurrentA5,a5		// Cleanup	move.w	#_ExitToShell,D0	// restore ExitToShell	move.l	__oldExitToShell__,A0	_SetToolTrapAddress	move.w	#_LoadSeg,D0		// restore LoadSeg	move.l	__oldLoadSeg__,A0	_SetToolTrapAddress	move.w	#_UnLoadSeg,D0		// restore UnloadSeg	move.l	__oldUnloadSeg__,A0	_SetToolTrapAddresserror:	_ExitToShell#else /* MPWSTARTUP */	move.l	(a7),__MPWReturnAddress	// save MPW's return address (this also works for standalone apps)	jsr	__InitCode__		// data init code/* this is the code to setup MPW *//* note that the stack must be where it was when this routine was first called. */	movea.l	(a7),a0			// copy MPW's return address	move.l	#0,-(a7)		// setup for C strings	pea		__MPWenvp		// get the environment pointer	pea		__MPWargv		// get argv from MPW	pea		__MPWargc		// get argc from MPW	move.l	a0,-(a7)		// push original return address	jsr		_RTInit			// call MPW's Runtime Init.	move.l	d0,__MPWStandalone	// record if we are standalone or not		move.l	__MPWenvp,-(sp)	// pass envp	move.l	__MPWargv,-(sp)	// pass argv	move.l	__MPWargc,-(sp)	// pass argc// pass int argc as 4 byte and let MPW ANSI (*i).68K.Lib fix it up//	jsr		main			// start user main	jsr		__MPWFixupMain__		lea		12(sp),sp	move.l	__exit_proc__,d0	// Call exit function	beq.s	skip_exit_proc	move.l	d0,a0	jsr	(a0)skip_exit_proc:	jsr	__destroy_global_chain	// destroy global objectserror:	move.l	#0,-(sp)	jsr		__cleanupandexit__	// unrelocate our selfs and exit	rts  						// just in case.#endif /* MPWSTARTUP */getlongfroma2:				// read the long word at (a2) into d0	move.b	(a2)+,d0	lsl.w	#8,d0	move.b	(a2)+,d0	lsl.l	#8,d0	move.b	(a2)+,d0	lsl.l	#8,d0	move.b	(a2)+,d0	tst.l	d0	rts}#if JASIK/****************************************************************//* Purpose..: Dispatch to jasik functions			*//* Input....: dispatch selector (in register D0)		*//* Returns..: ---						*//****************************************************************/asm void jasikdispatch(short selector:__D0){	lea	jasikrecord,a0	move.l	0(a0,d0.w),d0	beq.s	end	move.l	d0,a0	jsr	(a0)end:	rts}#endif/************************************************************************//* Purpose..: Destroy all constructed global objects			*//* Input....: ---							*//* Return...: ---							*//************************************************************************/asm void __destroy_global_chain(void){L0:	move.l	__global_destructor_chain,d0	beq.s	L9	move.l	d0,a1L1:	move.w	#-1,-(sp)	move.l	struct(DestructorChain.object)(a1),a0	move.l	struct(DestructorChain.destructor)(a1),a1	jsr	(a1)	addq.w	#2,sp	move.l	__global_destructor_chain,a1	move.l	struct(DestructorChain.next)(a1),a1	move.l	a1,__global_destructor_chain	bne.s	L1L9:	rts}/****************************************************************//* Purpose..: Load a segment into memory and relocate it	*//* Input....: (sp) has the address of jumptable entry		*//* Returns..: does not return directly				*//****************************************************************/asm pascal void __LoadSeg__(void){#ifdef MPWSTARTUP	moveq	#15,d0	_SysError	rts#else#if JASIK	move.l	sp,rtstate.fSP	movem.l	d0-d7/a0-a6,rtstate.fRegisters#endif	movem.l	d0-d2/a0-a2,-(sp)	/* save registers */	subq.l	#2,24(sp)		/* adjust return address */	movea.l	24(sp),a2		/* a2: base address of jumptable enty */	move.l	__segcallbacks.PreLoadSeg,d0	beq.s	nopreload	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,spnopreload:#if JASIK	move.l	a2,rtstate.fJTAddr	move.w	struct(JumpTableEntry.segment)(a2),rtstate.fSegNo	move.l	#'CODE',rtstate.fSegType	moveq	#struct(JasikRecord.Del_MMU_Prot_Proc),d0	jsr	jasikdispatch#endif	st	ResLoad	subq.l	#4,sp			// get the CODE Resource nretryload:	move.l	#'CODE',-(sp)	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	_GetResource	move.l	(sp),d0	bne.s	noerr	move.l	__segcallbacks.LoadSegErr,d0	bne.s	loaderrcallback	moveq	#15,d0	_SysErrorloaderrcallback:	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,sp	bra	retryloadnoerr:	tst.b	0x0BB2			// SegHiEnable	beq.s	nohi	move.l	d0,a0			/* move the code resource to high memory */	_MoveHHinohi:	move.l	(sp),a0			/* and lock it there */	_HLock	move.l	(sp)+,a0		/* get the striped address of code segment */	movea.l	(a0),a0	move.l	a0,d0	_StripAddress	move.l	d0,a0	move.l	a0,-(sp)		/* save address */	move.w	struct(JumpTableEntry.segment)(a2),d0	jsr	__Relocate__		/* relocate the new segment */	movea.l	(sp)+,a0		/* a0: address of segment */	movea.l	DATAPTR,a1		/* a1: address of first jumptable entry */	add.l	4(a0),a1	move.w	2(a0),d0		/* number of jumptable entries */	bra.s	loopeloop:	move.l	struct(JumpTableEntry.jumpaddress)(a1),d1	add.l	a0,d1	move.w	#0x4EF9,struct(JumpTableEntry.jumpinstruction)(a1)	move.l	d1,struct(JumpTableEntry.jumpaddress)(a1)	add.w	#sizeof(struct JumpTableEntry),a1loope:	dbf	d0,loop	tst.b	__flushinstruction__	beq.s	dontflush	_FlushInstructionCachedontflush:	move.l	__segcallbacks.PostLoadSeg,d0	beq.s	nopostload	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,spnopostload:#if JASIK	move.w	#kVersion16bit,rtstate.fVersion	move.l	#32000,rtstate.fSegSize	// not the correct size !!!	move.b	#true,rtstate.fSegInCore	clr.b	rtstate.fReserved1	clr.w	rtstate.fOSErr	clr.l	rtstate.fReserved2	move.l	jasikrecord.Post_Load_Proc,d0	beq.s	nojas	move.l	d0,a0	pea	rtstate	jsr	(a0)	moveq	#struct(JasikRecord.Set_MMU_Prot_Proc),d0	jsr	jasikdispatchnojas:#endif	movem.l	(sp)+,d0-d2/a0-a2	/* restore registers */	tst.b	LoadTrap	beq.s	notrap	_Debuggernotrap:	rts				/* return to new address */#endif /* MPWSTARTUP */}/****************************************************************//* Purpose..: Unload a segment from memory			*//*		this function replaces the _UnloadSeg trap !!!	*//* Input....: routine address on stack				*//* Returns..: ---						*//****************************************************************/pascal asm void __UnloadSeg__(Ptr routineAddr){#ifdef MPWSTARTUP	moveq	#15,d0	_SysError	rts#else#if JASIK	move.l	sp,rtstate.fSP	movem.l	d0-d7/a0-a6,rtstate.fRegisters#endif	move.l	a2,-(sp)		/* save a2 register */	move.l	8(sp),a2		/* a2:address of function (jtentry !!!) */	cmp.w	#0x4EF9,struct(JumpTableEntry.jumpinstruction)(a2)	bne	end			/* return if file is not in loaded state */	cmp.w	#2,struct(JumpTableEntry.segment)(a2)	blt	end			/* only segments >=2 can be unloaded */#if JASIK	move.l	a2,rtstate.fJTAddr	move.w	struct(JumpTableEntry.segment)(a2),rtstate.fSegNo	move.l	#'CODE',rtstate.fSegType	move.w	#kVersion16bit,rtstate.fVersion	move.l	#32000,rtstate.fSegSize	// not the correct size !!!	move.b	#true,rtstate.fSegInCore	clr.b	rtstate.fReserved1	clr.w	rtstate.fOSErr	clr.l	rtstate.fReserved2	move.l	jasikrecord.preUnLoad_Proc,d0	beq.s	nojas	pea	rtstate	move.l	d0,a0	jsr	(a0)	moveq	#struct(JasikRecord.Del_MMU_Prot_Proc),d0	jsr	jasikdispatchnojas:#endif	subq.l	#4,sp			/* get the CODE Resource n */	move.l	#'CODE',-(sp)	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	_GetResource	move.l	(sp),d0	beq	dontflush	move.l	d0,a0	//	restore jumptable to unloaded state 	move.l	DATAPTR,a1		/* a1: address of jumptable */	move.l	(a0),a0			/* dereference handle to code resource */	move.l	a0,d1			/* d1: base adress of code resource */	add.w	(a0),a1			/* add jumptable offset */	move.w	2(a0),d0		/* d0: number of jumptable entries */	bra.s	loopeloop:	move.w	#0xA9F0,struct(JumpTableEntry.jumpinstruction)(a1)	sub.l	d1,struct(JumpTableEntry.jumpaddress)(a1)	add.w	#sizeof(struct JumpTableEntry),a1loope:	dbf	d0,loop	_ReleaseResource#if JASIK	moveq	#struct(JasikRecord.Set_MMU_Prot_Proc),d0	jsr	jasikdispatch#endif	tst.b	__flushinstruction__	beq.s	dontflush	_FlushInstructionCachedontflush:	move.l	__segcallbacks.PostUnloadSeg,d0	beq.s	end	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,spend:	move.l	(sp)+,a2		/* restore a2 register */	move.l	(sp)+,(sp)		/* pop return address */	rts#endif /* MPWSTARTUP */}/****************************************************************//* Purpose..: Relocate code/data references of segment		*//* Input....: a0.l: Pointer to current segment			*//* Input....: d0.w: number of segment (0:DATA)			*//* Returns..: ---						*//****************************************************************/static asm void __Relocate__(void){	move.l	a2,-(sp)	move.l	a0,a2		/* a2:base address of relocated segment */	move.w	d0,-(sp)	subq.l	#4,sp		/* get the XREF Resource we need */retryload:	move.l	#'XREF',-(sp)	move.w	d0,-(sp)	_GetResource	movea.l	(sp),a0		/* keep handle on stack for later ReleaseResource */	move.l	a0,d0	bne.s	noerror	move.l	__segcallbacks.LoadSegErr,d0	bne.s	loaderrcallback	moveq	#15,d0	_SysErrorloaderrcallback:	move.l	d0,a0	move.w	4(sp),-(sp)	jsr	(a0)	addq.l	#2,sp	bra	retryloadnoerror:	move.l	(a0),a0	move.l	(a0)+,d0	/* relocate references to DATA segment */	move.l	DATAPTR,d2	bsr	reloc	move.l	(a0)+,d0	/* relocate references to CODE segment 1 */	move.l	__CODE1Base__,d2	bsr	reloc	move.l	(a0)+,d0	/* relocate references to same CODE segment */	move.l	a2,d2	bsr	reloc	_ReleaseResource	addq.l	#2,sp	move.l	(sp)+,a2	rtsreloop:	move.l	(a0)+,d1	/* relocate d0 entries */	add.l	d2,0(a2,d1.l)reloc:	subq.l	#1,d0	bge	reloop	rts}#ifdef MPWSTARTUP/****************************************************************//* Purpose..: Unrelocate code/data references of segment	*//*            Exactly like Relocate except a SUB instead of ADD	*//* Input....: a0.l: Pointer to current segment			*//* Input....: d0.w: number of segment (0:DATA)			*//* Returns..: ---						*//****************************************************************/static asm void __Unrelocate__(void){	move.l	a2,-(sp)	move.l	a0,a2		/* a2:base address of relocated segment */	move.w	d0,-(sp)	subq.l	#4,sp		/* get the XREF Resource we need */retryload:	move.l	#'XREF',-(sp)	move.w	d0,-(sp)	_GetResource	movea.l	(sp),a0		/* keep handle on stack for later ReleaseResource */	move.l	a0,d0	bne.s	noerror	move.l	__segcallbacks.LoadSegErr,d0	bne.s	loaderrcallback	moveq	#15,d0	_SysErrorloaderrcallback:	move.l	d0,a0	move.w	4(sp),-(sp)	jsr	(a0)	addq.l	#2,sp	bra	retryloadnoerror:	move.l	(a0),a0	move.l	(a0)+,d0	/* relocate references to DATA segment */	move.l	DATAPTR,d2	bsr	reloc	move.l	(a0)+,d0	/* relocate references to CODE segment 1 */	move.l	__CODE1Base__,d2	bsr	reloc	move.l	(a0)+,d0	/* relocate references to same CODE segment */	move.l	a2,d2	bsr	reloc	_ReleaseResource	addq.l	#2,sp	move.l	(sp)+,a2	rtsreloop:	move.l	(a0)+,d1	/* relocate d0 entries */	sub.l	d2,0(a2,d1.l)reloc:	subq.l	#1,d0	bge	reloop	rts}/****************************************************************//* Purpose..: Unrelocate our selves before returning to MPW		*//* Input....: None												*//* Returns..: D0=0												*//****************************************************************/asm void __cleanupandexit__(long status){	move.l	__CODE1Base__,a0	/* relocate the main code segment */	moveq	#1,d0	jsr	__Unrelocate__	jmp	_mpwexit		/* Return to MPW */}/****************************************************************//* Purpose..: This stub is here because MPW's RTInit calls it	*//* 			  and MetroWerks does it's own Data Initialization	*//* Input....: None												*//* Returns..: D0=0												*//****************************************************************/asm void _DataInit(void){	moveq	#0,d0	rts}/****************************************************************//* Purpose..: This stub is here because MPW's RTInit calls it	*//* 			  and MetroWerks does it's own.						*//* Input....: None												*//* Returns..: D0=0												*//****************************************************************/asm void __CplusInit(void){	rts}#endif /* MPWSTARTUP */#include "StartupCommon.c"