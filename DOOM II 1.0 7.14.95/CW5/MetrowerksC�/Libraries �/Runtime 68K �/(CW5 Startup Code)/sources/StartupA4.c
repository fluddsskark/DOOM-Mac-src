/****************************************************************//* Purpose..:	The CodeResource startup-module			*//*		Has all c-runtime function definitions		*//* Created..:	09. Nov. 1991					*//* Modified..:	12. Oct. 1994					*//****************************************************************/#include <Types.h>#include <Memory.h>#include <Devices.h>#include <Resources.h>#include <Assembler.h>#include <stdlib.h>#include <Errors.h>#include <CPlusLib68K.h>// 'objd' resource IDs:// 0:	application startup// 1:	code resource startup (single segment)// 2:	code resource startup (multi segment)// 3:	DRVR startup (single segment)// 4:	DRVR startup (multi segment)// 5:	application startup (Jasik version)#pragma	near_code			// all code references must be 16-bit PC relative#pragma far_data	off		// all data references must be 16-bit A4 relative#define SINGLECODE	0		// to link startup code for a single segment code resource#define MULTICODE	1		// to link startup code for a multi segment code resource#define LIBCODE		2		// to link the custom startup library#define	STARTUP		MULTICODE	// the code model to link#define DRIVER		1		// a driver is generated when this flag is setextern void main(void);			// this is the user main() called by __Startup__()extern void __Startup__(void);		// code resource/DRVR startup codeextern long SetCurrentA4(void);		// setup the A4 data pointer (and return old A4 in D0)DestructorChain	*__global_destructor_chain;	// chain of global objects that need destructionDestructorChain	*__local_destructor_chain;	// chain of local objects that need destruction#if STARTUP==SINGLECODE/****************************************************************//* Purpose..: Startup code for single segment code resources	*//* Input....: ---						*//* Returns..: ---						*//****************************************************************/#if DRIVERtypedef struct DRVRHeader {	short		drvrFlags;	short		drvrDelay;	short		drvrEventMask;	short		drvrMenuID;	short		drvrOpenOffset;	short		drvrPrimeOffset;	short		drvrControlOffset;	short		drvrStatusOffset;	short		drvrCloseOffset;	unsigned char	drvrname[32];}	DRVRHeader;asm void __Startup__(void)	// Note: this must be the first code module in link file!{	ds.b	sizeof(DRVRHeader)dOpen:	moveq	#0,d0	bra.s	startdPrime:	moveq	#1,d0	bra.s	start1drCtrl:	moveq	#2,d0	bra.s	start1dStat:	moveq	#3,d0	bra.s	start1dClose:	moveq	#4,d0start:	move.l	a4,-(sp)	// save data segment pointer	move.w	d0,-(sp)	// dispatch code	move.l	a1,-(sp)	// device control entry	move.l	a0,-(sp)	// parameter block	jsr	SetCurrentA4	// setup data segment pointer (A4)	jsr	main		// and jump to main	lea	10(sp),sp	// cleanup stack	move.l	(sp)+,a4	// restore data segment pointer	rts			// Open and Close are always immediatestart1:	movem.l	a0-a1/a4,-(sp)	move.w	d0,-(sp)	// dispatch code	move.l	a1,-(sp)	// device control entry	move.l	a0,-(sp)	// parameter block	jsr	SetCurrentA4	// setup data segment pointer (A4)	jsr	main		// and jump to main	lea	10(sp),sp	// cleanup stack	movem.l	(sp)+,a0-a1/a4	// restore registers	cmp.w	#1,d0		// main returns 1 if async request cannot be completed	beq.s	uncomp	btst	#1,struct(IOParam.ioTrap)(a0)	// test if this was an immed TRAP	bne.s	end	move.l	0x08FC,-(sp)	// JIODoneend:	rtsuncomp:	moveq	#0,d0	rts}#else	// DRIVERasm void __Startup__(void)		// Note: this must be the first code module in link file!{	bra.s	__Startupcode__		// 0	standard macintosh code resource header	dc.w	0			// 2	dc.l	'XXXX'			// 4	code resource type	dc.w	0			// 8	code resource id	dc.w	0			// 10	code resource version number__Startupcode__:	jmp	main}#endif	// DRIVER#elif STARTUP==MULTICODE || STARTUP==LIBCODE/****************************************************************//* Purpose..: Startup code for multi segment code resources	*//* Input....: ---						*//* Returns..: ---						*//****************************************************************/struct JumpTableEntry {			// jumptable entry data structure	short	jumpinstruction;	// instruction: jmp routine or jsr __LoadSeg__ 	long	jumpaddress;		// absolute address of rountine or __LoadSeg__	short	segment;		// routines segment number	long	offset;			// offset of routine in segment};struct SegmentHeader {			// header of a code resource segment	long	jtoffset;		// A4 offset of this segments jump table	long	jtentries;		// number of entries in this segments jump table	long	xrefoffset;		// offset of xref data in this segment	char	code[];			// the code};long	__codereftype__  = '000c';	// resource type used for code resource segmentsshort	__maincodexnum__ = 12345;	// resource id used for main code resource segmentPtr	__CODEBase__;			// base address of main code resource segmentBoolean	__flushinstruction__;		// true: flush instruction cacheextern void __SetupMainRsrc__(void *:__D0);	// forward function declaration#if STARTUP!=LIBCODEasm void __Startup__(void)		// Note: this must be the first code module in link file!{#if DRIVERstart:	jsr	SetCurrentA4		// setup A4 so that we can address global data					// (registers are saved in DRVR stub)	move.l	8(sp),a1		// get the id of this code resources 	move.w	struct(DCtlEntry.dCtlRefNum)(a1),d0	not.w	d0	lsl.w	#5,d0	ori.w	#0xC000,d0	move.w	d0,__maincodexnum__	// and store it#else	// DRIVERstart:	bra.s	setup			// 0	standard macintosh code resource header	dc.w	0			// 2	dc.l	'XXXX'			// 4	code resource type	dc.w	0			// 8	code resource id	dc.w	0			// 10	code resource version numbersetup:	movem.l	d0-d2/a0/a1/a4,-(sp)	// save registers	jsr	SetCurrentA4		// setup A4 so that we can address global data#endif	// DRIVER	lea	start,a0		// pass a pointer to the start	move.l	a0,d0			// of this function in register D0	_StripAddress	jsr	__SetupMainRsrc__	// relocate main code resource#if !DRIVER	movem.l	(sp)+,d0-d2/a0/a1/a4	// restore registers#endif	// !DRIVER	jmp	main			// and jump to main}#endif	// STARTUP!=LIBCODE////	the following code is part of all multi segment code resources/DRVRs///****************************************************************//* Purpose..: Setup A4 Register (data frame pointer)		*//* Input....: ---						*//* Returns..: value of old a4					*//****************************************************************/asm long __GetMainXRef__(void);asm long __GetMainXRef__(void){	lea	__Startup__,A0		// load segment start address to A0	add.l	#0x12345678,A0		// add XREF segment offset to A0 (will be patched by linker)	move.l	A0,D0	_StripAddress			// strip address	rts}/****************************************************************//* Purpose..: Relocate code/data references of a segment	*//* Input....: pointer to relocation data			*//* Input....: pointer to segments base address			*//* Input....: pointer to relocation base address		*//* Returns..: pointer to end of relocation data			*//****************************************************************/typedef union GetData {	char	raw[4];	short	word;	long	lword;}	GetData; static char *__relocate_compr(char *ptr,char *segment,long relocbase){	GetData	data;	long	offset,relocations;	char	c;	data.raw[0]=*ptr++; data.raw[1]=*ptr++; data.raw[2]=*ptr++; data.raw[3]=*ptr++;	relocations=data.lword;	for(offset=0L; relocations>0; relocations--)	{		c=*ptr++;		if(c&0x80)		{	//	8-bit signed delta			c<<=1; offset+=c;		}		else		{			data.raw[0]=c; data.raw[1]=*ptr++;			if(c&0x40)			{	//	15-bit unsigned delta								offset+=(short)(data.word<<2)>>1;			}			else			{	//	direct signed 31-bit offset				data.raw[2]=*ptr++; data.raw[3]=*ptr++;				offset=(data.lword<<2)>>1;			}		}		*(long *)(segment+offset)+=relocbase;	}	return ptr;}/****************************************************************//* Purpose..: Relocate the main code resource and setup globals	*//* Input....: pointer to the start of this code resource	*//* Returns..: ---						*//****************************************************************/extern asm void __SetupMainRsrc__(void *ptr:__D0){	movem.l	a2/d3,-(sp)		// save registers	move.l	d0,a2			// a2:	segment pointer	move.l	__CODEBase__,d0		// check if the code resource has already	move.l	a2,d3			// been relocated for it's current address	sub.l	d0,d3			// d3:	(current address)-(relocation address)	beq	ret			// return if relocation delta == 0	tst.l	d0			// first time check	bne.s	reloc	clr.b	__flushinstruction__	// setup __flushinstruction__ global	move.w	#_Unimplemented,d0	_GetToolTrapAddress	move.l	a0,-(a7)	move.w	#_HWPriv,d0	_GetOSTrapAddress	cmpa.l	(a7)+,a0	sne	d0	neg.b	d0	move.b	d0,__flushinstruction__reloc:	move.l	d3,-(sp)		// push relocation delta	move.l	a2,-(sp)		// push pointer to segment base address	jsr	__GetMainXRef__	move.l	d0,-(sp)		// push pointer to relocation data	jsr	__relocate_compr		lea	12(sp),a7		// remove arguments from stack	move.l	a2,__CODEBase__		// store new code base pointer (relocation address)	tst.b	__flushinstruction__	// flush instruction cache	beq.s	ret	_FlushInstructionCacheret:	movem.l	(sp)+,a2/d3		// restore registers	rts}/****************************************************************//* Purpose..: Load a segment into memory and relocate it	*//* Input....: (sp) has the address of jumptable entry		*//* Returns..: does not return directly				*//****************************************************************/pascal asm void __LoadSeg__(void);pascal asm void __LoadSeg__(void){	movem.l	d0-d2/a0-a3,-(sp)	// save registers	subq.l	#6,28(sp)		// adjust return address	movea.l	28(sp),a2		// a2: base address of jumptable entry	subq.l	#4,sp			// get the CODE Resource segment	move.l	__codereftype__,-(sp)	move.w	struct(JumpTableEntry.segment)(a2),d0	add.w	__maincodexnum__,d0	move.w	d0,-(sp)	_GetResource	move.l	(sp),d0	bne	ldok	moveq	#dsLoadErr,d0	_SysErrorldok:	move.l	d0,a0			// move the code resource to high memory	_MoveHHi	move.l	(sp),a0			// and lock it there	_HLock	move.l	(sp)+,a0		// get the striped address of code segment	movea.l	(a0),a0	move.l	a0,d0	_StripAddress	move.l	d0,a3			// a3: segment base address//	relocate references to main segment	move.l	__CODEBase__,-(sp)	// push pointer to relocation base address	move.l	a3,-(sp)		// push pointer to segment base address	move.l	a3,d0	add.l	struct(SegmentHeader.xrefoffset)(a3),d0	move.l	d0,-(sp)		// push pointer to relocation data	jsr	__relocate_compr	//	relocate references to same segment	move.l	a3,-(sp)		// push pointer to relocation base address	move.l	a3,-(sp)		// push pointer to segment base address	move.l	a3,d0	move.l	a0,-(sp)		// push pointer to relocation data	jsr	__relocate_compr		lea	24(sp),sp		// remove arguments from stack//	setup jumptable	movea.l	a4,a1					// a1: address of first jumptable entry	add.l	struct(SegmentHeader.jtoffset)(a3),a1	move.l	struct(SegmentHeader.jtentries)(a3),d0	// number of jumptable entriesloop:	move.w	#0x4EF9,struct(JumpTableEntry.jumpinstruction)(a1)	move.l	struct(JumpTableEntry.offset)(a1),d1	add.l	a3,d1	move.l	d1,struct(JumpTableEntry.jumpaddress)(a1)	add.w	#sizeof(struct JumpTableEntry),a1	subq.l	#1,d0	bgt.s	loop	tst.b	__flushinstruction__	beq.s	dontflush	_FlushInstructionCachedontflush:	movem.l	(sp)+,d0-d2/a0-a3	// restore registers	rts				// return to new address}/****************************************************************//* Purpose..: Unload a segment from memory			*//*		this function replaces the _UnloadSeg trap !!!	*//* Input....: routine address on stack				*//* Returns..: ---						*//****************************************************************/pascal asm void UnloadA4Seg(void *routineAddr){	movem.l	a2/a3,-(sp)		// save a2 registers	move.l	12(sp),a2		// a2: address of function's jtentry	cmp.w	#0x4EF9,struct(JumpTableEntry.jumpinstruction)(a2)	bne	end			// return if file is not in loaded state// recover code resource handle	move.l	struct(JumpTableEntry.jumpaddress)(a2),a0	sub.l	struct(JumpTableEntry.offset)(a2),a0	_RecoverHandle	tst.w	0x0220			// MemErr	bne.s	end	move.l	a0,-(sp)		// save handle	move.l	(a0),a3			// a3: segment base address// restore jumptable to unloaded state	lea	__LoadSeg__,a1	move.l	a1,d1			// d1: address of __LoadSeg__ routine	move.l	a4,a1			// a1: address of jumptable	add.l	struct(SegmentHeader.jtoffset)(a3),a1	// add jumptable offset	move.l	struct(SegmentHeader.jtentries)(a3),d0	// number of jumptable entriesloop:	move.w	#0x4EB9,struct(JumpTableEntry.jumpinstruction)(a1)	move.l	d1,struct(JumpTableEntry.jumpaddress)(a1)	add.w	#sizeof(struct JumpTableEntry),a1	subq.l	#1,d0	bgt.s	loop//	unrelocate references to main segment	move.l	__CODEBase__,-(sp)	// push pointer to relocation base address	neg.l	(a7)	move.l	a3,-(sp)		// push pointer to segment base address	move.l	a3,d0	add.l	struct(SegmentHeader.xrefoffset)(a3),d0	move.l	d0,-(sp)		// push pointer to relocation data	jsr	__relocate_compr	//	unrelocate references to same segment	move.l	a3,-(sp)		// push pointer to relocation base address	neg.l	(a7)	move.l	a3,-(sp)		// push pointer to segment base address	move.l	a3,d0	move.l	a0,-(sp)		// push pointer to relocation data	jsr	__relocate_compr		lea	24(sp),sp		// remove arguments from stack//	unlock code resource and make it purgeable 	move.l	(sp),a0	_HUnlock	move.l	(sp)+,a0	_HPurge	tst.b	__flushinstruction__	beq.s	dontflush	_FlushInstructionCachedontflush:end:	movem.l	(sp)+,a2/a3		// restore registers	move.l	(sp)+,(sp)		// pop return address	rts}#endif	// STARTUP==MULTICODE || STARTUP==LIBCODE////	the following code is part of all code resources///****************************************************************//* Purpose..: Setup A4 Register (data frame pointer)		*//* Input....: ---						*//* Returns..: value of old a4					*//****************************************************************/asm long SetCurrentA4(void){	lea	__Startup__,A0		// load segment start address to A0	add.l	#0x12345678,A0		// add data segment offset to A0 (will be patched by linker)	move.l	A0,D0	_StripAddress			// strip address	exg	A4,D0			// return old A4 register value	rts}/************************************************************************//* Purpose..: Destroy all constructed global objects			*//* Input....: ---							*//* Return...: ---							*//************************************************************************/asm void __destroy_global_chain(void){L0:	move.l	__global_destructor_chain,d0	beq.s	L9	move.l	d0,a1L1:	move.w	#-1,-(sp)	move.l	struct(DestructorChain.object)(a1),a0	move.l	struct(DestructorChain.destructor)(a1),a1	jsr	(a1)	addq.w	#2,sp	move.l	__global_destructor_chain,a1	move.l	struct(DestructorChain.next)(a1),a1	move.l	a1,__global_destructor_chain	bne.s	L1L9:	rts}#include "StartupCommon.c"