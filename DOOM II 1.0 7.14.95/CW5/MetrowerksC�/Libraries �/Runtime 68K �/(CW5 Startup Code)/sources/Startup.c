/****************************************************************//* Purpose..:	The Application startup-module			*//*		C/C++ runtime function definitions		*//*								*//* Created..:	21.Sept.1990					*//****************************************************************/#define JASIK		1		// 1: custom startup for Jasik's debugger#define RELEASE		0		// 1: release XREF/CODE resources#define COMPRESS	1		// 1: compressed DATA and XREF resources// 'objd' resource IDs:// 0:	application startup// 1:	code resource startup (single segment)// 2:	code resource startup (multi segment)// 3:	DRVR startup (single segment)// 4:	DRVR startup (multi segment)// 5:	application startup (Jasik version)#pragma	near_code			// all code references must be 16-bit PC relative#pragma far_data	off		// all data references must be 16-bit A4 relativechar		qd[206];		// storage space for Quickdraw globals 206 bytes#define qd	QD			// kludge for stupid QuickDraw.h header	#include <Types.h>#include <Errors.h>#include <Memory.h>#include <Resources.h>#include <Assembler.h>#include <stdlib.h>#include <CPlusLib68K.h>#include "StartupLib.h"#undef qd				// kludge for stupid QuickDraw.h header	#define	DATAPTR	A5			// register used to address near dataextern far int	main(void);		// this is the user main() called by __startup__()extern far void	__InitCode__(void);	// this is data init code called by __startup__()extern Boolean	LoadTrap:0x012D;	// if TRUE call debugger when LoadSeg is calledextern char	__4byteints__;		// true: 4-byte ints; false 2-byte intsstatic	pascal void	__LoadSeg__(void);				// forwardstatic	pascal void	__UnloadSeg__(Ptr);				// forwardstatic	void		__Relocate__(void);				// forward#if !RELEASEstatic	void		__UnRelocate__(void);				// forward#endif#if COMPRESSstatic char *__relocate_compr(char *ptr,char *segment,long relocbase);	// forwardstatic void __decompress_data(char *ptr,char *datasegment);		// forward#endifstruct	SegmentLoadCallbacks __segcallbacks;void	(*__exit_proc__)(void);		// pointer to function called on exitDestructorChain	*__global_destructor_chain;	// chain of global objects that need destructionDestructorChain	*__local_destructor_chain;	// chain of local objects that need destructionstatic Boolean	__flushinstruction__;	// flush instruction cache if setstatic Ptr	__CODE1Base__;		// base address of CODE segment 1 for quick referencestatic long	__oldLoadSeg__;		// old LoadSeg Trap Addressstatic long	__oldUnloadSeg__;	// old UnloadSeg Trap Addressstatic long	__oldExitToShell__;	// old ExitToShell Trap Address#if JASIK#include "RTLib.h"typedef struct JasikRecord {	ProcPtr	Post_Load_Proc;	ProcPtr	preUnLoad_Proc;	ProcPtr	Del_MMU_Prot_Proc;	ProcPtr	Set_MMU_Prot_Proc;} JasikRecord;static JasikRecord	jasikrecord;static void		jasikdispatch(short selector:__D0);static RTState		rtstate;#endif/****************************************************************//* Purpose..: The Startup routine for Applications		*//* Input....: ---						*//* Returns..: ---						*//****************************************************************/asm void __Startup__(void);asm void __Startup__(void){	/* this must be the first code module in link file */functionstart:	suba.l	a6,a6	//	helps the stack crawl#if JASIK	sub.w	#sizeof(JasikRecord),sp	clr.l	struct(JasikRecord.Post_Load_Proc)(sp)	clr.l	struct(JasikRecord.preUnLoad_Proc)(sp)	clr.l	struct(JasikRecord.Del_MMU_Prot_Proc)(sp)	clr.l	struct(JasikRecord.Set_MMU_Prot_Proc)(sp)	move.l	0x38,a0	cmp.w	#0x487A,(a0)	bne.s	nojas	pea	(sp)	moveq	#27,d0	trap	#7	move.l	struct(JasikRecord.Del_MMU_Prot_Proc)(sp),a0	jsr	(a0)		// disable MMU protectionnojas:#endif	subq.l	#4,sp		/* get the CODE Resource 0 */	move.l	#'CODE',-(sp)	clr.w	-(sp)	_GetResource	move.l	(sp),d0		/* keep handle on stack for later ReleaseResource */	beq	error	movea.l	d0,a0	movea.l	(a0),a0	move.l	(a0)+,d7	/* d7:data bytes above DATAPTR */	move.l	(a0),d6		/* d6:data bytes below DATAPTR */	_ReleaseResource	/* handle was still on stack */	moveq	#0,d0		/* clear data below DATAPTR */	movea.l	DATAPTR,a0	suba.l	d6,a0	bra	loop1eloop1:	move.b	d0,(a0)+loop1e:	cmpa.l	DATAPTR,a0	blt	loop1	lea	32+8(DATAPTR),a0	/* clear data above DATAPTR */	lea	0(DATAPTR,d7.l),a1	bra	loop2eloop2:	move.b	d0,(a0)+loop2e:	cmpa.l	a1,a0	blt	loop2	subq.l	#4,sp		/* get the DATA Resource 0 */	move.l	#'DATA',-(sp)	clr.w	-(sp)	_GetResource	movea.l	(sp),a0		/* keep handle on stack for later ReleaseResource */	move.l	a0,d0	beq	error#if COMPRESS	move.l	DATAPTR,-(sp)	move.l	(a0),-(sp)	jsr	__decompress_data	addq.l	#8,sp	_ReleaseResource#else	movea.l	(a0),a2		/* now store init data into data area */loop3:	bsr	getlongfroma2	/* number of bytes to transfer */	beq	loop3e	move.l	d0,d3	bsr	getlongfroma2	/* data offset from DATAPTR */		movea.l	a2,a0		/* a0:sourcePtr */	lea	0(DATAPTR,d0.l),a1	/* a1:destPtr */	move.l	d3,d0		/* d0:countBytes */	adda.l	d0,a2		/* setup a2 for next init block */	_BlockMove	bra	loop3loop3e:	_ReleaseResource#endif#if JASIK	move.l	struct(JasikRecord.Post_Load_Proc)(sp),jasikrecord.Post_Load_Proc	move.l	struct(JasikRecord.preUnLoad_Proc)(sp),jasikrecord.preUnLoad_Proc	move.l	struct(JasikRecord.Del_MMU_Prot_Proc)(sp),jasikrecord.Del_MMU_Prot_Proc	move.l	struct(JasikRecord.Set_MMU_Prot_Proc)(sp),jasikrecord.Set_MMU_Prot_Proc	moveq	#struct(JasikRecord.Set_MMU_Prot_Proc),d0	jsr	jasikdispatch#endif	lea	functionstart-4,a0	move.l	a0,__CODE1Base__	/* store the base address of CODE segment 1 in CODE1Base */	move.l	DATAPTR,a0		/* relocate the data segment */	moveq	#0,d0	jsr	__Relocate__	move.l	__CODE1Base__,a0	/* relocate the main code segment */	moveq	#1,d0	jsr	__Relocate__	clr.b	__flushinstruction__	move.w	#_Unimplemented,d0	_GetToolTrapAddress	move.l	a0,-(a7)	move.w	#_HWPriv,d0	_GetOSTrapAddress	cmpa.l	(a7)+,a0	beq.s	dontflush	move.b	#true,__flushinstruction__	_FlushInstructionCachedontflush:	move.w	#_LoadSeg,D0		// LoadSeg	_GetToolTrapAddress	move.l	A0,__oldLoadSeg__	move.w	#_UnLoadSeg,D0		// UnloadSeg	_GetToolTrapAddress	move.l	A0,__oldUnloadSeg__	move.w	#_ExitToShell,D0	// ExitToShell	_GetToolTrapAddress	move.l	A0,__oldExitToShell__	move.w	#_LoadSeg,D0		// LoadSeg	lea	__LoadSeg__,A0	_SetToolTrapAddress	move.w	#_UnLoadSeg,D0		// UnloadSeg	lea	__UnloadSeg__,A0	_SetToolTrapAddress	move.w	#_ExitToShell,D0	// ExitToShell	lea	__ExitToShell__,A0	_SetToolTrapAddress	jsr	__InitCode__		// data init code	pea	argv			// fake dummy argv	tst.b	__4byteints__	beq.s	int161	clr.w	-(sp)			// fake dummy argc 32-bit intint161:	clr.w	-(sp)			// fake dummy argc 16-bit int	jsr	main			// call user main	addq.l	#6,sp	tst.b	__4byteints__	beq.s	int162	addq.l	#2,spint162:	move.l	__exit_proc__,d0	// Call exit function	beq.s	skip_exit_proc	move.l	d0,a0	jsr	(a0)skip_exit_proc:	jsr	__destroy_global_chain	// destroy global objects__ExitToShell__:	move.l	0x0904,a5		// CurrentA5	move.w	#_ExitToShell,D0	// restore ExitToShell	move.l	__oldExitToShell__,A0	_SetToolTrapAddress	move.w	#_LoadSeg,D0		// restore LoadSeg	move.l	__oldLoadSeg__,A0	_SetToolTrapAddress	move.w	#_UnLoadSeg,D0		// restore UnloadSeg	move.l	__oldUnloadSeg__,A0	_SetToolTrapAddresserror:	_ExitToShellargv:	dc.l	0#if !COMPRESSgetlongfroma2:				// read the long word at (a2) into d0	move.b	(a2)+,d0	lsl.w	#8,d0	move.b	(a2)+,d0	lsl.l	#8,d0	move.b	(a2)+,d0	lsl.l	#8,d0	move.b	(a2)+,d0	tst.l	d0	rts#endif}#if JASIK/****************************************************************//* Purpose..: Dispatch to jasik functions			*//* Input....: dispatch selector (in register D0)		*//* Returns..: ---						*//****************************************************************/asm void jasikdispatch(short selector:__D0){	lea	jasikrecord,a0	move.l	0(a0,d0.w),d0	beq.s	end	move.l	d0,a0	jsr	(a0)end:	rts}#endif/************************************************************************//* Purpose..: Destroy all constructed global objects			*//* Input....: ---							*//* Return...: ---							*//************************************************************************/asm void __destroy_global_chain(void){L0:	move.l	__global_destructor_chain,d0	beq.s	L9	move.l	d0,a1L1:	move.w	#-1,-(sp)	move.l	struct(DestructorChain.object)(a1),a0	move.l	struct(DestructorChain.destructor)(a1),a1	jsr	(a1)	addq.w	#2,sp	move.l	__global_destructor_chain,a1	move.l	struct(DestructorChain.next)(a1),a1	move.l	a1,__global_destructor_chain	bne.s	L1L9:	rts}/****************************************************************//* Purpose..: Load a segment into memory and relocate it	*//* Input....: (sp) has the address of jumptable entry		*//* Returns..: does not return directly				*//****************************************************************/asm pascal void __LoadSeg__(void){#if JASIK	move.l	sp,rtstate.fSP	movem.l	d0-d7/a0-a6,rtstate.fRegisters#endif	movem.l	d0-d2/a0-a2,-(sp)	/* save registers */	subq.l	#2,24(sp)		/* adjust return address */	movea.l	24(sp),a2		/* a2: base address of jumptable enty */	move.l	__segcallbacks.PreLoadSeg,d0	beq.s	nopreload	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,spnopreload:#if JASIK	move.l	a2,rtstate.fJTAddr	move.w	struct(JumpTableEntry.segment)(a2),rtstate.fSegNo	move.l	#'CODE',rtstate.fSegType	moveq	#struct(JasikRecord.Del_MMU_Prot_Proc),d0	jsr	jasikdispatch#endif	st	0x0A5E			// ResLoad	subq.l	#4,sp			// get the CODE Resource nretryload:	move.l	#'CODE',-(sp)	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	_GetResource	move.l	(sp),d0	bne.s	noerr	move.l	__segcallbacks.LoadSegErr,d0	bne.s	loaderrcallback	moveq	#dsLoadErr,d0	_SysErrorloaderrcallback:	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,sp	bra	retryloadnoerr:	tst.b	0x0BB2			// SegHiEnable	beq.s	nohi	move.l	d0,a0			/* move the code resource to high memory */	_MoveHHinohi:	move.l	(sp),a0			/* and lock it there */	_HLock	move.l	(sp)+,a0		/* get the striped address of code segment */	movea.l	(a0),a0	move.l	a0,d0	_StripAddress	move.l	d0,a0	move.l	a0,-(sp)		/* save address */	move.w	struct(JumpTableEntry.segment)(a2),d0	jsr	__Relocate__		/* relocate the new segment */	movea.l	(sp)+,a0		/* a0: address of segment */	movea.l	DATAPTR,a1		/* a1: address of first jumptable entry */	add.l	4(a0),a1	move.w	2(a0),d0		/* number of jumptable entries */	bra.s	loopeloop:	move.l	struct(JumpTableEntry.jumpaddress)(a1),d1	add.l	a0,d1	move.w	#0x4EF9,struct(JumpTableEntry.jumpinstruction)(a1)	move.l	d1,struct(JumpTableEntry.jumpaddress)(a1)	add.w	#sizeof(struct JumpTableEntry),a1loope:	dbf	d0,loop	tst.b	__flushinstruction__	beq.s	dontflush	_FlushInstructionCachedontflush:	move.l	__segcallbacks.PostLoadSeg,d0	beq.s	nopostload	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,spnopostload:#if JASIK	move.w	#kVersion16bit,rtstate.fVersion	move.l	#32000,rtstate.fSegSize	// not the correct size !!!	move.b	#true,rtstate.fSegInCore	clr.b	rtstate.fReserved1	clr.w	rtstate.fOSErr	clr.l	rtstate.fReserved2	move.l	jasikrecord.Post_Load_Proc,d0	beq.s	nojas	move.l	d0,a0	pea	rtstate	jsr	(a0)	moveq	#struct(JasikRecord.Set_MMU_Prot_Proc),d0	jsr	jasikdispatchnojas:#endif	movem.l	(sp)+,d0-d2/a0-a2	/* restore registers */	tst.b	LoadTrap	beq.s	notrap	_Debuggernotrap:	rts				/* return to new address */}/****************************************************************//* Purpose..: Unload a segment from memory			*//*		this function replaces the _UnloadSeg trap !!!	*//* Input....: routine address on stack				*//* Returns..: ---						*//****************************************************************/pascal asm void __UnloadSeg__(Ptr routineAddr){#if JASIK	move.l	sp,rtstate.fSP	movem.l	d0-d7/a0-a6,rtstate.fRegisters#endif	move.l	a2,-(sp)		/* save a2 register */	move.l	8(sp),a2		/* a2:address of function (jtentry !!!) */	cmp.w	#0x4EF9,struct(JumpTableEntry.jumpinstruction)(a2)	bne	end			/* return if file is not in loaded state */	cmp.w	#2,struct(JumpTableEntry.segment)(a2)	blt	end			/* only segments >=2 can be unloaded */#if JASIK	move.l	a2,rtstate.fJTAddr	move.w	struct(JumpTableEntry.segment)(a2),rtstate.fSegNo	move.l	#'CODE',rtstate.fSegType	move.w	#kVersion16bit,rtstate.fVersion	move.l	#32000,rtstate.fSegSize	// not the correct size !!!	move.b	#true,rtstate.fSegInCore	clr.b	rtstate.fReserved1	clr.w	rtstate.fOSErr	clr.l	rtstate.fReserved2	move.l	jasikrecord.preUnLoad_Proc,d0	beq.s	nojas	pea	rtstate	move.l	d0,a0	jsr	(a0)	moveq	#struct(JasikRecord.Del_MMU_Prot_Proc),d0	jsr	jasikdispatchnojas:#endif	subq.l	#4,sp			/* get the CODE Resource n */	move.l	#'CODE',-(sp)	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	_GetResource	move.l	(sp),d0	beq	dontflush	move.l	d0,a0	//	restore jumptable to unloaded state 	move.l	DATAPTR,a1		/* a1: address of jumptable */	move.l	(a0),a0			/* dereference handle to code resource */	move.l	a0,d1			/* d1: base adress of code resource */	add.l	4(a0),a1		/* add jumptable offset */	move.w	2(a0),d0		/* d0: number of jumptable entries */	bra.s	loopeloop:	move.w	#0xA9F0,struct(JumpTableEntry.jumpinstruction)(a1)	sub.l	d1,struct(JumpTableEntry.jumpaddress)(a1)	add.w	#sizeof(struct JumpTableEntry),a1loope:	dbf	d0,loop#if RELEASE	_ReleaseResource#else	move.w	struct(JumpTableEntry.segment)(a2),d0	move.l	(sp),a0	move.l	(a0),a0	jsr	__UnRelocate__	tst.w	d0	beq.s	lpur0	_ReleaseResource	bra.s	lpur1lpur0:	move.l	(sp),a0	_HUnlock	move.l	(sp)+,a0	_HPurgelpur1:#endif#if JASIK	moveq	#struct(JasikRecord.Set_MMU_Prot_Proc),d0	jsr	jasikdispatch#endif	tst.b	__flushinstruction__	beq.s	dontflush	_FlushInstructionCachedontflush:	move.l	__segcallbacks.PostUnloadSeg,d0	beq.s	end	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,spend:	move.l	(sp)+,a2		/* restore a2 register */	move.l	(sp)+,(sp)		/* pop return address */	rts}#if COMPRESS/****************************************************************//* Purpose..: Decompress the DATA resource			*//* Input....: pointer to DATA resource data			*//* Input....: pointer to A5 resource				*//* Returns..: ---						*//****************************************************************/typedef union GetData {	char	raw[4];	short	word;	long	lword;}	GetData; ////	Pack Patterns:////	0x1xxx xxxx: <raw data>		x+1 (1..128)	raw data bytes//	0x01xx xxxx:			x+1 (1..64)		<x> 0x00 data bytes//	0x001x xxxx: yyyy yyyy		x+2 (2..33)		<x> <y> data bytes//	0x0001 xxxx:			x+1 (1..16)		<x> 0xFF data bytes//	0x0000 0001:			pattern: 0x00000000FFFFXXXX//	0x0000 0010:			pattern: 0x00000000FFXXXXXX//	0x0000 0011:			pattern: 0xA9F00000XXXX00XX//	0x0000 0100:			pattern: 0xA9F000XXXXXX00XX//	0x0000 0000:	end of data//static void __decompress_data(char *ptr,char *datasegment){	GetData	ldata;	int	i,data;	char	*to,c;	for(i=0; i<3; i++)	{		ldata.raw[0]=*ptr++; ldata.raw[1]=*ptr++; ldata.raw[2]=*ptr++; ldata.raw[3]=*ptr++;		to=datasegment+ldata.lword;		while(1)		{			data=*ptr++;			if(data&0x80)			{	//	decompress (x&0x7f)+1 raw data bytes				data&=0x7F; do *to++=*ptr++; while(--data>=0); continue;			}			if(data&0x40)			{	//	decompress (x&0x3f)+1 0x00 data bytes//				data&=0x3F; c=0x00; goto cloop;				to+=(data&0x3F)+1; continue;	//	data is already initilized to 0x00			}			if(data&0x20)			{	//	decompress (x&0x1f)+2 repeating data bytes				data=(data&0x1F)+1; c=*ptr++; goto cloop;			}			if(data&0x10)			{	//	decompress (x&0x0f)+1 0xFF data bytes				data&=0x0F; c=0xFF;			cloop:	do *to++=c; while(--data>=0); continue;			}			switch(data)			{			case 0x00: break;//			case 0x01: *to++=0x00; *to++=0x00; *to++=0x00; *to++=0x00; *to++=0xFF; *to++=0xFF; *to++=*ptr++; *to++=*ptr++; continue;//			case 0x02: *to++=0x00; *to++=0x00; *to++=0x00; *to++=0x00; *to++=0xFF; *to++=*ptr++; *to++=*ptr++; *to++=*ptr++; continue;//			case 0x03: *to++=0xA9; *to++=0xF0; *to++=0x00; *to++=0x00; *to++=*ptr++; *to++=*ptr++; *to++=0x00; *to++=*ptr++; continue;//			case 0x04: *to++=0xA9; *to++=0xF0; *to++=0x00; *to++=*ptr++; *to++=*ptr++; *to++=*ptr++; *to++=0x00; *to++=*ptr++; continue;			case 0x01: to+=4; *to++=0xFF; *to++=0xFF; *to++=*ptr++; *to++=*ptr++; continue;			case 0x02: to+=4; *to++=0xFF; *to++=*ptr++; *to++=*ptr++; *to++=*ptr++; continue;			case 0x03: *to++=0xA9; *to++=0xF0; to+=2; *to++=*ptr++; *to++=*ptr++; to++; *to++=*ptr++; continue;			case 0x04: *to++=0xA9; *to++=0xF0; to++; *to++=*ptr++; *to++=*ptr++; *to++=*ptr++; to++; *to++=*ptr++; continue;			default:   SysError(dsLoadErr);			}			break;		}	}}/****************************************************************//* Purpose..: Relocate code/data references of a segment	*//* Input....: pointer to relocation data			*//* Input....: pointer to segments base address			*//* Input....: pointer to reloaction base address		*//* Returns..: pointer to end of releocation data		*//****************************************************************/static char *__relocate_compr(char *ptr,char *segment,long relocbase){	GetData	data;	long	offset,relocations;	char	c;	data.raw[0]=*ptr++; data.raw[1]=*ptr++; data.raw[2]=*ptr++; data.raw[3]=*ptr++;	relocations=data.lword;	for(offset=0L; relocations>0; relocations--)	{		c=*ptr++;		if(c&0x80)		{	//	8-bit signed delta			c<<=1; offset+=c;		}		else		{			data.raw[0]=c; data.raw[1]=*ptr++;			if(c&0x40)			{	//	15-bit unsigned delta								offset+=(short)(data.word<<2)>>1;			}			else			{	//	direct signed 31-bit offset				data.raw[2]=*ptr++; data.raw[3]=*ptr++;				offset=(data.lword<<2)>>1;			}		}		*(long *)(segment+offset)+=relocbase;	}	return ptr;}#endif/****************************************************************//* Purpose..: Relocate code/data references of segment		*//* Input....: a0.l: Pointer to current segment			*//* Input....: d0.w: number of segment (0:DATA)			*//* Returns..: ---						*//****************************************************************/static asm void __Relocate__(void){	move.l	a2,-(sp)	move.l	a0,a2		/* a2:base address of relocated segment */	move.w	d0,-(sp)	subq.l	#4,sp		/* get the XREF Resource we need */retryload:	move.l	#'XREF',-(sp)	move.w	d0,-(sp)	_GetResource	movea.l	(sp),a0		/* keep handle on stack for later ReleaseResource */	move.l	a0,d0	bne.s	noerror	move.l	__segcallbacks.LoadSegErr,d0	bne.s	loaderrcallback	moveq	#dsLoadErr,d0	_SysErrorloaderrcallback:	move.l	d0,a0	move.w	4(sp),-(sp)	jsr	(a0)	addq.l	#2,sp	bra	retryloadnoerror:	move.l	(a0),a0#if COMPRESS	move.l	DATAPTR,-(a7)		// relocate references to DATA segment	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__relocate_compr	move.l	__CODE1Base__,-(a7)	// relocate references to CODE segment 1	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__relocate_compr	move.l	a2,-(a7)		// relocate references to same CODE segment	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__relocate_compr	lea	36(a7),a7		// remove c function arguments#if RELEASE	_ReleaseResource#else	move.l	(sp)+,a0	_HPurge#endif	addq.l	#2,sp	move.l	(sp)+,a2	rts		#else					// old relocation	move.l	(a0),a0	move.l	(a0)+,d0		// relocate references to DATA segment	move.l	DATAPTR,d2	bsr	reloc	move.l	(a0)+,d0		// relocate references to CODE segment 1	move.l	__CODE1Base__,d2	bsr	reloc	move.l	(a0)+,d0		// relocate references to same CODE segment	move.l	a2,d2	bsr	reloc#if RELEASE	_ReleaseResource#else	move.l	(sp)+,a0	_HPurge#endif	addq.l	#2,sp	move.l	(sp)+,a2	rtsreloop:	move.l	(a0)+,d1		// relocate d0 entries	add.l	d2,0(a2,d1.l)reloc:	subq.l	#1,d0	bge	reloop	rts#endif}#if !RELEASE/****************************************************************//* Purpose..: Unrelocate code/data references of segment	*//* Input....: a0.l: Pointer to current segment			*//* Input....: d0.w: number of segment (0:DATA)			*//* Returns..: ---						*//****************************************************************/static asm void __UnRelocate__(void){	move.l	a2,-(sp)	move.l	a0,a2		/* a2:base address of relocated segment */	subq.l	#4,sp		/* get the XREF Resource we need */retryload:	move.l	#'XREF',-(sp)	move.w	d0,-(sp)	_GetResource	movea.l	(sp),a0		/* keep handle on stack for later ReleaseResource */	move.l	a0,d0	bne.s	noerror	move.l	(sp)+,a2	moveq	#-1,d0			// error return	rtsnoerror:	move.l	(a0),a0#if COMPRESS	move.l	DATAPTR,-(a7)		// relocate references to DATA segment	neg.l	(a7)	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__relocate_compr	move.l	__CODE1Base__,-(a7)	// relocate references to CODE segment 1	neg.l	(a7)	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__relocate_compr	move.l	a2,-(a7)		// relocate references to same CODE segment	neg.l	(a7)	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__relocate_compr	lea	36(a7),a7		// remove c function arguments	move.l	(sp)+,a0	_HPurge	move.l	(sp)+,a2	moveq	#0,d0	rts		#else					// old relocation	move.l	(a0),a0	move.l	(a0)+,d0		// relocate references to DATA segment	move.l	DATAPTR,d2	bsr	reloc	move.l	(a0)+,d0		// relocate references to CODE segment 1	move.l	__CODE1Base__,d2	bsr	reloc	move.l	(a0)+,d0		// relocate references to same CODE segment	move.l	a2,d2	bsr	reloc	move.l	(sp)+,a0	_HPurge	move.l	(sp)+,a2	moveq	#0,d0	rtsreloop:	move.l	(a0)+,d1		// relocate d0 entries	sub.l	d2,0(a2,d1.l)reloc:	subq.l	#1,d0	bge	reloop	rts#endif}#endif#include "StartupCommon.c"