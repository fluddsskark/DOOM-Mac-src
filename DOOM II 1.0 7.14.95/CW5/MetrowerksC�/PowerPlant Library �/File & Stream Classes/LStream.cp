// ===========================================================================//	LStream.cp						©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	Abstract class defining an ordered sequence of bytes#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LStream.h>#include <UMemoryMgr.h>#ifndef __MEMORY__#include <Memory.h>#endifconst	Int32	length_NilBlock = -1;// ---------------------------------------------------------------------------//		¥ LStream// ---------------------------------------------------------------------------//	Default ConstructorLStream::LStream(){#ifndef qNeoAccess	mMarker = 0;	mLength = 0;#endif}// ---------------------------------------------------------------------------//		¥ ~LStream// ---------------------------------------------------------------------------//	DestructorLStream::~LStream(){}// ---------------------------------------------------------------------------//		¥ SetMarker// ---------------------------------------------------------------------------//	Place the Read/Write Marker at an offset from a specified position////	inFromWhere can be streamFrom_Start, streamFrom_End, or streamFrom_MarkervoidLStream::SetMarker(	Int32		inOffset,	EStreamFrom	inFromWhere){#ifdef qNeoAccess	Int32	newMarker = getMark();#else	Int32	newMarker = mMarker;#endif	switch (inFromWhere) {			case streamFrom_Start:			newMarker = inOffset;			break;					case streamFrom_End:			newMarker = GetLength() - inOffset;			break;					case streamFrom_Marker:			newMarker += inOffset;			break;	}		if (newMarker < 0) {				// marker must be between 0 and		newMarker = 0;					// Length+1, inclusive	} else if (newMarker > GetLength()) {		newMarker = GetLength() + 1;	}	#ifdef qNeoAccess	CNeoStream::setMark(newMarker);#else	mMarker = newMarker;#endif}// ---------------------------------------------------------------------------//		¥ GetMarker// ---------------------------------------------------------------------------//	Return the Read/Write Marker position////	Position is a byte offset from the start of the StreamInt32LStream::GetMarker() const{#ifdef qNeoAccess	return CNeoStream::getMark();#else	return mMarker;#endif}// ---------------------------------------------------------------------------//		¥ SetLength// ---------------------------------------------------------------------------//	Set the length, in bytes, of the StreamvoidLStream::SetLength(	Int32	inLength){#ifdef qNeoAccess	CNeoStream::setLength(inLength);#else	mLength = inLength;#endif}// ---------------------------------------------------------------------------//		¥ GetLength// ---------------------------------------------------------------------------//	Return the length, in bytes, of the StreamInt32LStream::GetLength() const{#ifdef qNeoAccess	return CNeoStream::getLength();#else	return mLength;#endif}// ---------------------------------------------------------------------------//		¥ WriteData// ---------------------------------------------------------------------------//	Write data from a buffer to a Stream////	Return the number of bytes actually written, which may be less than the//	number requested if an error occurred////	Subclasses must override this function to support writingInt32LStream::WriteData(	const void	*inBuffer,	Int32		inByteCount){	return 0;		// ??? Error - WriteData undefined}// ---------------------------------------------------------------------------//		¥ ReadData// ---------------------------------------------------------------------------//	Read data from a Stream to a buffer////	Return the number of bytes actually read, which may be less than the//	number requested if an error occurred////	Subclasses must override this function to support readingInt32LStream::ReadData(	void	*outBuffer,	Int32	inByteCount){	return 0;		// ??? Error - ReadData undefined}// ---------------------------------------------------------------------------//		¥ PeekData// ---------------------------------------------------------------------------//	Read data from a Stream to a buffer, without moving the Marker////	Return the number of bytes actually read, which may be less than the//	number requested if an error occurredInt32LStream::PeekData(	void	*outBuffer,	Int32	inByteCount){	Int32	currentMarker = GetMarker();	Int32	bytesRead = ReadData(outBuffer, inByteCount);	SetMarker(currentMarker, streamFrom_Start);	return bytesRead;}// ---------------------------------------------------------------------------//		¥ WritePtr// ---------------------------------------------------------------------------//	Write a Toolbox Ptr block to a Stream////	A Ptr block is written as a 4-byte count (size of the Ptr),//	followed by the contents of the Ptr block////	Returns the number of bytes writtenInt32LStream::WritePtr(	Ptr		inPtr){	Int32	bytesWritten = 0;	if (inPtr != nil) {		Int32	ptrLength = GetPtrSize(inPtr);		bytesWritten = WriteData(&ptrLength, sizeof(Int32));		bytesWritten += WriteData(inPtr, ptrLength);			} else {		Int32	flag = length_NilBlock;		bytesWritten = WriteData(&flag, sizeof(Int32));	}			return bytesWritten;}// ---------------------------------------------------------------------------//		¥ ReadPtr// ---------------------------------------------------------------------------//	Read data from a Stream into a newly created Ptr block////	A Ptr block is stored in a Stream as a 4-byte count (size of the Ptr),//	followed by the contents of the Ptr block////	Returns the number of bytes readInt32LStream::ReadPtr(	Ptr		&outPtr){	Int32	ptrLength;	Int32	bytesRead = ReadData(&ptrLength, sizeof(Int32));		outPtr = nil;	if (ptrLength != length_NilBlock) {		outPtr = NewPtr(ptrLength);		ThrowIfMemFail_(outPtr);		bytesRead += ReadData(outPtr, ptrLength);	}		return bytesRead;}// ---------------------------------------------------------------------------//		¥ WriteHandle// ---------------------------------------------------------------------------//	Write a Toolbox Handle block to a Stream////	A Handle block is written as a 4-byte count (size of the Handle),//	followed by the contents of the Handle block////	Returns the number of bytes writtenInt32LStream::WriteHandle(	Handle	inHandle){	Int32	bytesWritten = 0;	if (inHandle != nil) {		Int32	handleLength = GetHandleSize(inHandle);		bytesWritten = WriteData(&handleLength, sizeof(Int32));				StHandleLocker	lockMe(inHandle);		bytesWritten += WriteData(*inHandle, handleLength);		} else {		Int32	flag = length_NilBlock;		bytesWritten = WriteData(&flag, sizeof(Int32));	}		return bytesWritten;}// ---------------------------------------------------------------------------//		¥ ReadHandle// ---------------------------------------------------------------------------//	Read data from a Stream into a newly created Handle block////	A Handle block is stored in a Stream as a 4-byte count (size of the//	Handle), followed by the contents of the Handle block////	Returns the number of bytes readInt32LStream::ReadHandle(	Handle	&outHandle){	Int32	handleLength;	Int32	bytesRead = ReadData(&handleLength, sizeof(Int32));		outHandle = nil;	if (handleLength != length_NilBlock) {		outHandle = NewHandle(handleLength);		ThrowIfMemFail_(outHandle);		StHandleLocker	lockMe(outHandle);		bytesRead += ReadData(*outHandle, handleLength);	}		return bytesRead;}// ---------------------------------------------------------------------------//		¥ WritePString// ---------------------------------------------------------------------------//	Write a Pascal string to a Stream////	Returns the number of bytes writtenInt32LStream::WritePString(	ConstStr255Param	inString){	return WriteData(inString, inString[0] + 1);}// ---------------------------------------------------------------------------//		¥ ReadPString// ---------------------------------------------------------------------------//	Read a Pascal string from a Stream////	Returns the number of bytes readInt32LStream::ReadPString(	Str255	outString){	ReadData(outString, 1);	return ReadData(outString+1, outString[0]) + 1;}// ===========================================================================//	¥ Functions for NeoAccess// ===========================================================================#ifdef qNeoAccessOSTypeLStream::getStreamType() const{	return kNeoFileStreamType;}voidLStream::readChunk(	void			*aBuffer,	const long		aLength,	const NeoTag	aTag){}voidLStream::writeChunk(	const void		*aBuffer,	const long		aLength,	const NeoTag	aTag){}#endif // qNeoAccess