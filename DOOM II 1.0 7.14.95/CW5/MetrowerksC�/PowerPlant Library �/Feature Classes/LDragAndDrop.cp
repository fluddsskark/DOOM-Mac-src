// ===========================================================================//	LDragAndDrop.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	Abstract class for an area of a Window which supports Drag and Drop//	using the Drag Manager. Normally, you will use this class as a mix-in//	base class for a LPane subclass. However, this class does not depend//	on any other classes, so you can use it independently as a "wrapper"//	class for the Drag Manager.////	Usage Note: This class defines, but does not install, call back//	routines for custom send data, input, and drawing hooks. If you//	wish to use these hooks, you must install them by calling//		SetDragSendProc, SetDragInputProc, or SetDragDrawingProc//	yourself.#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LDragAndDrop.h>#include <LView.h>#include <LDynamicArray.h>#include <UEnvironment.h>#ifndef __GESTALTEQU__#include <GestaltEqu.h>#endifDragTrackingHandlerUPP	LDropArea::sDragTrackingProc;DragReceiveHandlerUPP	LDropArea::sDragReceiveProc;LDynamicArray*			LDropArea::sDropAreaList;LDropArea*				LDropArea::sCurrentDropArea;Boolean					LDropArea::sDragHasLeftSender;// ---------------------------------------------------------------------------//		¥ LDropArea// ---------------------------------------------------------------------------//	ConstructorLDropArea::LDropArea(	WindowPtr	inWindow){	mDragWindow = inWindow;	mCanAcceptCurrentDrag = false;	mIsHilited = false;		if (DragAndDropIsPresent()) {		InstallHandlers();		AddDropArea(this, inWindow);	}}// ---------------------------------------------------------------------------//		¥ ~LDropArea// ---------------------------------------------------------------------------//	DestructorLDropArea::~LDropArea(){	if (DragAndDropIsPresent()) {		RemoveDropArea(this, mDragWindow);	}}// ---------------------------------------------------------------------------//		¥ DragAndDropIsPresent [static]// ---------------------------------------------------------------------------//	Returns whether DragAndDrop is implemented on the running SystemBooleanLDropArea::DragAndDropIsPresent(){	return UEnvironment::HasGestaltAttribute(gestaltDragMgrAttr,											 gestaltDragMgrPresent);}// ---------------------------------------------------------------------------//		¥ FocusDropArea// ---------------------------------------------------------------------------//	Set up local coordinate system and clipping region for a DropArea////	The Drag Manager sets the port to the Window containing the drop//	rectangle. However, it doesn't know anything about the local coordinates//	and clipping region.voidLDropArea::FocusDropArea(){}// ---------------------------------------------------------------------------//		¥ HiliteDropArea// ---------------------------------------------------------------------------//	Hilite a DropArea to indicate that it can accept the current Drag////	Subclasses should override this function to create a region//	representing the drop area and call ShowDragHilite().voidLDropArea::HiliteDropArea(	DragReference	inDragRef){	mIsHilited = false;}// ---------------------------------------------------------------------------//		¥ EnterDropArea// ---------------------------------------------------------------------------//	A Drag is entering a DropArea. This call will be followed by a//	corresponding LeaveDropArea call (when the Drag moves out of the//	DropArea or after the Drag is received by this DropArea).////	If the DropArea can accept the Drag and the Drag is coming from outside//	the DropArea, hilite the DropAreavoidLDropArea::EnterDropArea(	DragReference	inDragRef,	Boolean			inDragHasLeftSender){	if (inDragHasLeftSender) {		FocusDropArea();		mIsHilited = true;		HiliteDropArea(inDragRef);	}}// ---------------------------------------------------------------------------//		¥ LeaveDropArea// ---------------------------------------------------------------------------//	A Drag is leaving a DropArea. This call will have been preceded by//	a corresponding EnterDropArea call.////	Remove hiliting of the DropArea if necessaryvoidLDropArea::LeaveDropArea(	DragReference	inDragRef){	if (mIsHilited) {		FocusDropArea();		::HideDragHilite(inDragRef);		mIsHilited = false;	}	mCanAcceptCurrentDrag = false;}// ---------------------------------------------------------------------------//		¥ InsideDropArea// ---------------------------------------------------------------------------//	Track a Drag while it is inside a DropArea. This function is called//	repeatedly while an acceptable Drag is inside a DropArea.////	Subclasses may override to provide additional visual feedback during//	a Drag, such as indicating an insertion pointvoidLDropArea::InsideDropArea(	DragReference	inDragRef){}// ---------------------------------------------------------------------------//		¥ DragIsAcceptable// ---------------------------------------------------------------------------//	Return whether a DropArea can accept the specified Drag////	A Drag is acceptable if all items in the Drag are acceptableBooleanLDropArea::DragIsAcceptable(	DragReference	inDragRef){	Boolean	isAcceptable = true;		Uint16	itemCount;	::CountDragItems(inDragRef, &itemCount);		for (Uint16 item = 1; item <= itemCount; item++) {		ItemReference	itemRef;		::GetDragItemReferenceNumber(inDragRef, item, &itemRef);				isAcceptable = ItemIsAcceptable(inDragRef, itemRef);		if (!isAcceptable) {			break;				// Stop looping upon finding an		}						//   unaccepatable item	}		return isAcceptable;}// ---------------------------------------------------------------------------//		¥ ItemIsAcceptable// ---------------------------------------------------------------------------//	Return whether a Drag item is acceptable////	You should override this function to check for the flavor types that//	your subclass supports. Here is what the function body would be for//	a DropArea that accepts only 'TEXT' data:////		FlavorFlags		theFlags;//		return (GetFlavorFlags(inDragRef, inItemRef, 'TEXT', &theFlags)//					== noErr);////	This function requests the FlavorFlags for the 'TEXT' flavor.//	GetFlavorFlags() returns "badDragFlavorType" if the flavor is not//	present. It returns "noErr" if the flavor is present.////	To accept more than one flavor, make a call to GetFlavorFlags() for//	each flavor. For example, to accept 'TEXT', 'PICT', and 'snd ':////		FlavorFlags		theFlags;//		OSErr			err;//		err = GetFlavorFlags(inDragRef, inItemRef, 'TEXT', &theFlags);//		if (err == noErr) return true;////		err = GetFlavorFlags(inDragRef, inItemRef, 'PICT', &theFlags);//		if (err == noErr) return true;////		err = GetFlavorFlags(inDragRef, inItemRef, 'snd ', &theFlags);//		return (err == noErr);////	This function checks for each acceptable flavor, exiting immediately//	upon finding an acceptable flavor.BooleanLDropArea::ItemIsAcceptable(	DragReference	inDragRef,	ItemReference	inItemRef){	return false;}// ---------------------------------------------------------------------------//		¥ DoDragReceive// ---------------------------------------------------------------------------//	Receive the items from a completed Drag and Drop////	This function gets called after items are dropped into a DropArea.//	The drag contains items that are acceptable, as defined by the//	DragIsAcceptable() and ItemIsAcceptable() member functions.////	This function repeatedly calls ReceiveDragItem for each item in the drag.//	Override if you want to process the dragged items all at once.voidLDropArea::DoDragReceive(	DragReference	inDragRef){	DragAttributes	dragAttrs;	::GetDragAttributes(inDragRef, &dragAttrs);		Uint16	itemCount;				// Number of Items in Drag	::CountDragItems(inDragRef, &itemCount);		for (Uint16 item = 1; item <= itemCount; item++) {		ItemReference	itemRef;		::GetDragItemReferenceNumber(inDragRef, item, &itemRef);				Rect	itemBounds;			// Get bounds of Item in Local coords		LView::OutOfFocus(nil);		FocusDropArea();		::GetDragItemBounds(inDragRef, itemRef, &itemBounds);		::GlobalToLocal(&topLeft(itemBounds));		::GlobalToLocal(&botRight(itemBounds));				ReceiveDragItem(inDragRef, dragAttrs, itemRef, itemBounds);	}}// ---------------------------------------------------------------------------//		¥ ReceiveDragItem// ---------------------------------------------------------------------------//	Process an Item which has been dragged into a DropArea////	This function gets called once for each Item contained in a completed//	Drag. The Item will have returned true from ItemIsAcceptable().////	The DropArea is focused upon entry and inItemBounds is specified//	in the local coordinates of the DropArea.////	Override this function if the DropArea can accept dropped Items.//	You may want to call GetFlavorData and GetFlavorDataSize if there//	is information associated with the dragged Item.voidLDropArea::ReceiveDragItem(	DragReference	inDragRef,	DragAttributes	inDragAttrs,	ItemReference	inItemRef,	Rect			&inItemBounds)	// In Local coordinates{}// ---------------------------------------------------------------------------//		¥ DoDragSendData// ---------------------------------------------------------------------------//	Send the data associated with a particular drag item////	This function gets called if you installed the optional DragSendDataProc//	for this DropArea. In which case you should override this function//	to provide the requested data by calling SetDragItemFlavorData.voidLDropArea::DoDragSendData(	FlavorType		inFlavor,	ItemReference	inItemRef,	DragReference	inDragRef){}// ---------------------------------------------------------------------------//		¥ DoDragInput// ---------------------------------------------------------------------------//	Modify the state of the mouse and modifier keys during a drag////	This function gets called if you installed the optional DragInputProc//	for this DropArea.voidLDropArea::DoDragInput(	Point			*ioMouse,	Int16			*ioModifiers,	DragReference	inDragRef){}// ---------------------------------------------------------------------------//		¥ DoDragDrawing// ---------------------------------------------------------------------------//	Draw the items for a drag in progress////	This function gets called if you installed the optional DragDrawingProc//	for this DropArea.voidLDropArea::DoDragDrawing(	DragRegionMessage	inMessage,	RgnHandle			inShowRgn,	Point				inShowOrigin,	RgnHandle			inHideRgn,	Point				inHideOrigin,	DragReference 		inDragRef){}// ===========================================================================// ¥ Static Functions										Static Functions ¥// ===========================================================================// ---------------------------------------------------------------------------//		¥ InstallHandlers// ---------------------------------------------------------------------------//	Install Tracking and Receive Handlers for the Drag Manager////	We use a single Tracking handler and a single Receive handler for//	all Drag and Drop operations. With the Drag Manager, you can register//	handlers globally or for specific windows. With PowerPlant, we//	want to have separate handlers for each Pane that supports drag and//	drop. Therefore, this class maintains a list of all drag and drop//	Panes and dispatches calls to the proper Panes.voidLDropArea::InstallHandlers(){	OSErr	err;	if (sDragTrackingProc == nil) {		sDragTrackingProc = NewDragTrackingHandlerProc(HandleDragTracking);		err = ::InstallTrackingHandler(sDragTrackingProc, nil, nil);		ThrowIfOSErr_(err);	}		if (sDragReceiveProc == nil) {		sDragReceiveProc = NewDragReceiveHandlerProc(HandleDragReceive);		err = ::InstallReceiveHandler(sDragReceiveProc, nil, nil);		ThrowIfOSErr_(err);	}		if (sDropAreaList == nil) {		sDropAreaList = new LDynamicArray(sizeof(SDropAreaEntry));	}}// ---------------------------------------------------------------------------//		¥ AddDropArea// ---------------------------------------------------------------------------//	Add a DropArea to the list maintained by this ClassvoidLDropArea::AddDropArea(	LDropArea	*inDropArea,	WindowPtr		inMacWindow){	SDropAreaEntry	theEntry;	theEntry.theDropArea = inDropArea;	theEntry.theMacWindow = inMacWindow;		sDropAreaList->InsertItemsAt(1, arrayIndex_Last, &theEntry);}// ---------------------------------------------------------------------------//		¥ RemoveDropArea// ---------------------------------------------------------------------------//	Remove a DropArea to the list maintained by this ClassvoidLDropArea::RemoveDropArea(	LDropArea	*inDropArea,	WindowPtr	inMacWindow){	SDropAreaEntry	theEntry;	theEntry.theDropArea = inDropArea;	theEntry.theMacWindow = inMacWindow;		sDropAreaList->Remove(&theEntry);}// ---------------------------------------------------------------------------//		¥ FindDropArea// ---------------------------------------------------------------------------//	Return the DropArea in the specified window containing the specified//	point (in global coords) and which can receive the Drag////	Returns nil if no DropArea meets the requirements.LDropArea*LDropArea::FindDropArea(	WindowPtr		inMacWindow,	Point			inGlobalPt,	DragReference	inDragRef){		// Search DropArea List from back to front for a DropArea		// that is in the window and that contains the point.		// We search from back to front because nested DropAreas		// are usually added after the surrounding DropArea. Searching		// back to front should gives us the most deeply nested DropArea.	LDropArea	*theDropArea = nil;	Int32	count = sDropAreaList->GetCount();		for (Int32 i = count; i > 0; i--) {		SDropAreaEntry	theEntry;		sDropAreaList->FetchItemAt(i, &theEntry);				if ( (theEntry.theMacWindow == inMacWindow) &&			 (theEntry.theDropArea)->PointInDropArea(inGlobalPt) &&			 (theEntry.theDropArea)->DragIsAcceptable(inDragRef) ) {			theDropArea = theEntry.theDropArea;			break;		}	}		return theDropArea;}// ---------------------------------------------------------------------------//		¥ InTrackingWindow// ---------------------------------------------------------------------------//	Track a Drag while it is inside a WindowvoidLDropArea::InTrackingWindow(	WindowPtr		inMacWindow,	DragReference	inDragRef){									// Get mouse location in Port coords									// for inMacWindow	Point	mouseLoc;	::GetDragMouse(inDragRef, &mouseLoc, nil);										// Get DropArea that contains the mouse	LDropArea *theDropArea = FindDropArea(inMacWindow, mouseLoc, inDragRef);		if (theDropArea == nil) {		// Mouse is not in a DropArea		if (sCurrentDropArea != nil) {										// Mouse left former DropArea			sCurrentDropArea->LeaveDropArea(inDragRef);			sDragHasLeftSender = true;		}		sCurrentDropArea = nil;			} else {						// Mouse is in a DropArea that can									//   accept the current Drag		theDropArea->mCanAcceptCurrentDrag = true;				if (theDropArea == sCurrentDropArea) {										// In Same drop area			theDropArea->InsideDropArea(inDragRef);			} else {						// Entering new drop area			if (sCurrentDropArea != nil) {										// Leaving old drop area				sCurrentDropArea->LeaveDropArea(inDragRef);			}						sDragHasLeftSender = true;			sCurrentDropArea = theDropArea;			theDropArea->EnterDropArea(inDragRef, sDragHasLeftSender);			theDropArea->InsideDropArea(inDragRef);		}		}}// ===========================================================================// ¥ Static Callback Functions					   Static Callback Functions ¥// ===========================================================================// ---------------------------------------------------------------------------//		¥ HandleDragTracking// ---------------------------------------------------------------------------//	Drag Manager callback for tracking a drag in progresspascal OSErrLDropArea::HandleDragTracking(	DragTrackingMessage	inMessage,	WindowPtr			inMacWindow,	void				*inRefCon,	DragReference		inDragRef){	OSErr	err = noErr;	Try_ {		GrafPtr	savePort;		GetPort(&savePort);				switch (inMessage) {					case dragTrackingEnterHandler: {				DragAttributes	dragAttr;				::GetDragAttributes(inDragRef, &dragAttr);				sDragHasLeftSender = (dragAttr & dragHasLeftSenderWindow);				break;			}							case dragTrackingEnterWindow:				break;							case dragTrackingInWindow:				InTrackingWindow(inMacWindow, inDragRef);				break;							case dragTrackingLeaveWindow:				if (sCurrentDropArea != nil) {					sCurrentDropArea->LeaveDropArea(inDragRef);					sDragHasLeftSender = true;				}				sCurrentDropArea = nil;				LView::OutOfFocus(nil);		// DragMgr can change current Port				break;							case dragTrackingLeaveHandler:				break;		}				SetPort(savePort);		LView::OutOfFocus(nil);	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}// ---------------------------------------------------------------------------//		¥ HandleDragReceive// ---------------------------------------------------------------------------//	Drag Manager callback for receiving a successful droppascal OSErrLDropArea::HandleDragReceive(	WindowPtr		inMacWindow,	void			*inRefCon,	DragReference	inDragRef){	OSErr	err = noErr;	Try_ {		if ( (sCurrentDropArea != nil) &&			sCurrentDropArea->mCanAcceptCurrentDrag ) {			GrafPtr	savePort;			GetPort(&savePort);			LView::OutOfFocus(nil);			sCurrentDropArea->DoDragReceive(inDragRef);			SetPort(savePort);			LView::OutOfFocus(nil);		} else {			err = dragNotAcceptedErr;		}	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}// ---------------------------------------------------------------------------//		¥ HandleDragSendData// ---------------------------------------------------------------------------//	Drag Manager callback for sending the data for an item that is part//	of an accepted drag and droppascal OSErrLDropArea::HandleDragSendData(	FlavorType		inFlavor,	void			*inRefCon,	ItemReference	inItemRef,	DragReference	inDragRef){	OSErr	err = noErr;	Try_ {		((LDropArea*) inRefCon)->DoDragSendData(inFlavor, inItemRef,													inDragRef);	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}// ---------------------------------------------------------------------------//		¥ HandleDragInput// ---------------------------------------------------------------------------//	Drag Manager callback for manipulating the mouse and modifier keys//	during a dragpascal OSErrLDropArea::HandleDragInput(	Point			*ioMouse,	Int16			*ioModifiers,	void			*inRefCon,	DragReference	inDragRef){	OSErr	err = noErr;	Try_ {		((LDropArea*) inRefCon)->DoDragInput(ioMouse, ioModifiers,													inDragRef);	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}// ---------------------------------------------------------------------------//		¥ HandleDragDrawing// ---------------------------------------------------------------------------//	Drag Manager callback for drawing the items during a dragpascal OSErrLDropArea::HandleDragDrawing(	DragRegionMessage	inMessage,	RgnHandle			inShowRgn,	Point				inShowOrigin,	RgnHandle			inHideRgn,	Point				inHideOrigin,	void				*inRefCon,	DragReference		inDragRef){	OSErr	err = noErr;	Try_ {		((LDropArea*) inRefCon)->DoDragDrawing(inMessage,												inShowRgn, inShowOrigin,												inHideRgn, inHideOrigin,												inDragRef);	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}// ===========================================================================// ¥ LDragAndDrop												LDragAndDrop ¥// ===========================================================================//	Mix-in class for adding Drag and Drop support to a Pane// ---------------------------------------------------------------------------//		¥ LDragAndDrop// ---------------------------------------------------------------------------//	Constructor////		inMacWindow is the Toolbox window containing the DragAndDrop.//		It may be nil if the DragAndDrop is not in a window (e.g.,//		if printing the DragAndDrop).////		inPane is the PowerPlant Pane associated with the DragAndDrop.//		The drop area of the DragAndDrop is the Frame of the Pane.LDragAndDrop::LDragAndDrop(	WindowPtr	inMacWindow,	LPane		*inPane)		: LDropArea(inMacWindow){	mPane = inPane;}// ---------------------------------------------------------------------------//		¥ PointInDropArea// ---------------------------------------------------------------------------//	Return whether a Point, in Global coords, is inside a DropAreaBooleanLDragAndDrop::PointInDropArea(	Point	inPoint){	mPane->GlobalToPortPoint(inPoint);	return mPane->IsHitBy(inPoint.h, inPoint.v);}// ---------------------------------------------------------------------------//		¥ FocusDropArea// ---------------------------------------------------------------------------//	Set up local coordinate system and clipping region for a DropAreavoidLDragAndDrop::FocusDropArea(){	mPane->FocusDraw();}// ---------------------------------------------------------------------------//		¥ HiliteDropArea// ---------------------------------------------------------------------------//	Hilite a DropArea to indicate that it can accept the current Drag////	For a DragAndDrop, the drop area is the Frame of its associated//	Pane inset by one pixel to account for the border which usually//	surrounds a Drop-capable Pane.voidLDragAndDrop::HiliteDropArea(	DragReference	inDragRef){	Rect	dropRect;	mPane->CalcLocalFrameRect(dropRect);	::InsetRect(&dropRect, 1, 1);	RgnHandle	dropRgn = ::NewRgn();	::RectRgn(dropRgn, &dropRect);	::ShowDragHilite(inDragRef, dropRgn, true);	::DisposeRgn(dropRgn);}