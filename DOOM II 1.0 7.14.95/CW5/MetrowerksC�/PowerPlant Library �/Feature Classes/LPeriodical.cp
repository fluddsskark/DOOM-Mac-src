// ===========================================================================//	LPeriodical.cp					й1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	A building block class for objects that want to received a function//	call at regular intervals////	ее Queues//	This class maintains two static queues: Idler and Repeater. You//	add/remove Periodicals from these queues using StartIdling/StopIdling//	and StartRepeating/StopRepeating.////	Calling DevoteTimeToIdlers/DevoteTimeToRepeaters calls the SpendTime//	function for each Periodical in the respective Queue.////	It is up to the caller (Client) to determine the meaning of each//	Queue and when to devote time to the Periodicals in them. The//	PowerPlant LApplication class devotes time to Idlers at Null Event//	time, and devotes time to Repeaters after every event.////	ее Derived Classes//	Classes derived from LPeriodical must define a SpendTime function, as//	this is a pure virtual function in LPeriodical.#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LPeriodical.h>#include <LList.h>#include <LListIterator.h>// === Static Members ===LList*	LPeriodical::sIdlerQ = nil;LList*	LPeriodical::sRepeaterQ = nil;// ---------------------------------------------------------------------------//		е LPeriodical// ---------------------------------------------------------------------------//	Default constructorLPeriodical::LPeriodical(){}// ---------------------------------------------------------------------------//		е ~LPeriodical// ---------------------------------------------------------------------------//	DestructorLPeriodical::~LPeriodical(){	StopIdling();	StopRepeating();}// ---------------------------------------------------------------------------//		е StartIdling// ---------------------------------------------------------------------------//	Put Periodical in the Idler queuevoidLPeriodical::StartIdling(){	if (sIdlerQ == nil) {			// Create queue if it doesn't exist		sIdlerQ = new LList;	}									// Add to end of Idler queue if it isn't									//   already in there	if (sIdlerQ->FetchIndexOf(&this) == arrayIndex_Bad) {		sIdlerQ->InsertItemsAt(1, arrayIndex_Last, &this);	}}// ---------------------------------------------------------------------------//		е StopIdling// ---------------------------------------------------------------------------//	Remove Periodical from the Idler queuevoidLPeriodical::StopIdling(){	if (sIdlerQ != nil) {		sIdlerQ->Remove(&this);	}}// ---------------------------------------------------------------------------//		е DevoteTimeToIdlers// ---------------------------------------------------------------------------//	Call SpendTime function for each Periodical in the Idler queuevoidLPeriodical::DevoteTimeToIdlers(	const EventRecord	&inMacEvent){	if (sIdlerQ != nil) {		LListIterator iterator(*sIdlerQ, iterate_FromStart);		LPeriodical	*theIdler;		while (iterator.Next(&theIdler)) {			theIdler->SpendTime(inMacEvent);		}	}}// ---------------------------------------------------------------------------//		е StartRepeating// ---------------------------------------------------------------------------//	Put Periodical in the Repeater queuevoidLPeriodical::StartRepeating(){	if (sRepeaterQ == nil) {		// Create queue if it doesn't exist		sRepeaterQ = new LList;	}									// Add to end of Repeater queue if it									//   isn't already in there	if (sRepeaterQ->FetchIndexOf(&this) == arrayIndex_Bad) {		sRepeaterQ->InsertItemsAt(1, arrayIndex_Last, &this);	}}// ---------------------------------------------------------------------------//		е StopRepeating// ---------------------------------------------------------------------------//	Remove Periodical from the Repeater queuevoidLPeriodical::StopRepeating(){	if (sRepeaterQ != nil) {		sRepeaterQ->Remove(&this);	}}// ---------------------------------------------------------------------------//		е DevoteTimeToRepeaters// ---------------------------------------------------------------------------//	Call SpendTime function for each Periodical in the Repeater queuevoidLPeriodical::DevoteTimeToRepeaters(	const EventRecord &inMacEvent){	if (sRepeaterQ != nil) {		LListIterator iterator(*sRepeaterQ, iterate_FromStart);		LPeriodical	*theRepeater;		while (iterator.Next(&theRepeater)) {			theRepeater->SpendTime(inMacEvent);		}	}}