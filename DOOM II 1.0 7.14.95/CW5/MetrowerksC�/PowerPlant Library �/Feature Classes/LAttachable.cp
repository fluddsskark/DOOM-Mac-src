// ===========================================================================//	LAttachable.cp					©1994 Metrowerks Inc. All rights reserved.// ===========================================================================//	Abstract class for an object which has an associated list of Attachments//	that can be executed on demand.#include <LAttachable.h>#include <LAttachment.h>#include <LList.h>#include <LListIterator.h>// ---------------------------------------------------------------------------//		¥ LAttachable// ---------------------------------------------------------------------------//	Default ConstructorLAttachable::LAttachable(){	mAttachments = nil;}// ---------------------------------------------------------------------------//		¥ ~LAttachable// ---------------------------------------------------------------------------//	DestructorLAttachable::~LAttachable(){	RemoveAllAttachments();}// ---------------------------------------------------------------------------//		¥ AddAttachment// ---------------------------------------------------------------------------//	Add an Attachment to an Attachable before another Attachment////	Specify "nil" for inBefore to add at the end////	If inOwnsAttachment is true, the Attachable assumes ownership of the//	Attachment and will delete the Attachment when the Attachable itself//	is deletedvoidLAttachable::AddAttachment(	LAttachment	*inAttachment,	LAttachment	*inBefore,	Boolean		inOwnsAttachment){	if (mAttachments == nil) {		// Create list if it doesn't exist		mAttachments = new LList;	}										// Find place to insert new Attachment	Int32	atIndex = arrayIndex_Last;	if (inBefore != nil) {		atIndex = mAttachments->FetchIndexOf(&inAttachment);		if (atIndex == arrayIndex_Bad) {			SignalPStr_("\pAttachment not found");			atIndex = arrayIndex_Last;		}	}		mAttachments->InsertItemsAt(1, atIndex, &inAttachment);		if (inOwnsAttachment) {		inAttachment->SetOwnerHost(this);	}}// ---------------------------------------------------------------------------//		¥ RemoveAttachment// ---------------------------------------------------------------------------//	Remove an Attachment from an Attachable////	If this Attachable is the owner of the Attachment, the Attachment's//	owner is set to nil, and the caller should assume control of//	the Attachment.voidLAttachable::RemoveAttachment(	LAttachment	*inAttachment){	if (mAttachments != nil) {		mAttachments->Remove(&inAttachment);		if (inAttachment->GetOwnerHost() == this) {			inAttachment->SetOwnerHost(nil);		}	}}// ---------------------------------------------------------------------------//		¥ RemoveAllAttachments// ---------------------------------------------------------------------------//	Remove all Attachments from an Attachable////	All Attachments owned by this Attachable are deletedvoidLAttachable::RemoveAllAttachments(){	if (mAttachments != nil) {		LListIterator	iterator(*mAttachments, iterate_FromStart);		LAttachment		*theAttachment;		while (iterator.Next(&theAttachment)) {			if (theAttachment->GetOwnerHost() == this) {				delete theAttachment;			}		}			delete mAttachments;		mAttachments = nil;	}}// ---------------------------------------------------------------------------//		¥ ExecuteAttachments// ---------------------------------------------------------------------------//	Tell all associated Attachments to execute themselvesBooleanLAttachable::ExecuteAttachments(	MessageT		inMessage,	void			*ioParam){	Boolean	executeHost = true;	if (mAttachments != nil) {		LListIterator	iterator(*mAttachments, iterate_FromStart);		LAttachment		*theAttachment;		while (iterator.Next(&theAttachment)) {			executeHost &= theAttachment->Execute(inMessage, ioParam);		}	}		return executeHost;}