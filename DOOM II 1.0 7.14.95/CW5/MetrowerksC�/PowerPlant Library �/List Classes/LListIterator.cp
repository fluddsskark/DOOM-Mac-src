// ===========================================================================//	LListIterator.cp				©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	Generic Iterator class. A ListIterator is associated with a single//	IteratedList object. ListIterator will "do the right thing" if the//	List changes during iteration. You can add items, remove items,//	or even delete the List itself.////	Construction://		LListIterator(LIteratedList &inList, Int32 inPosition);//			Associate iterator with inList, and set the current item//			to inPosition.//			  You may use iterate_FromStart or iterate_FromEnd for//			inPosition, or you may specify an exact item number.//			//	Setting Current Item://		void	ResetTo(Int32 inPosition);//			Set current item to the specified index. Interprets inPosition//			the same as the above constructor.////	Traversing the List://		Boolean Current(void *outItem);//		Boolean Next(void *outItem);//		Boolean Previous(void *outItem);//			Returns false if the item does not exist; otherwise, returns//			true and sets outItem to the appropriate item.////		These functions use a void* pointer parameter to pass back the item//		and a Boolean return value to indicate nonexistent items. The caller//		must be sure that outItem points to a buffer that is large enough//		to hold the entire item.////	Examples://		{		// Iterating from beginning to end of myList//			LListIterator iterator(myList, iterate_FromStart);//			while (iterator.Next(&theItem)) {//				... do something with theItem ...//			}//		}////		{		// Iterating from end to beginning of myList//			LListIterator iterator(myList, iterate_FromEnd);//			while (iterator.Previous(&theItem)) {//				... do something with theItem ...//			}//		}////		{		// Start iterating after a specific item in myList//			LListIterator iterator(myList, myList->FetchIndexOf(&myItem));//			while (iterator.Next(&theItem)) {//				... do something with theItem ...//			}//		}////	Why Iterators?//		You could just access the List directly://			Int32 i = 0;//			while (myList->FetchItemAt(++i, &theItem)) {//				... do something with theItem ...//			}////		This works fine as long as you don't insert or remove any items//		from myList from within the while loop (or during an asynchronous//		routine which could get called during the loop). Accessing by//		direct index number is ambiguous when the number of items in the//		list changes.////		However, the relative references "next and "previous" are valid//		even when the list changes.////		The Iterator is a separate class from the List so that you can//		have multiple, simultaneous Iterators for the same List. For//		example, here is a way to remove duplicates from a List:////		{//			LListIterator outer(myList, iterate_FromStart);//			while (outer.Next(&testItem)) {//				LListIterator searcher(myList, myList->FetchIndexOf(&testItem));//				while (searcher.Next(&searchItem)) {//					if (testItem == searchItem) {//						myList->Remove(searchItem);//					}//				}//			}//		}////		The outer Iterator starts from the beginning of myList. The searcher//		Iterator starts after the position of the current item in the//		outer Iterator and removes any item that matches that item. Each//		Iterator moves properly to the next item in the List, even when//		an item is removed.#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LListIterator.h>// === Special List indexes ===	// Value for ListIndex_BeforeStart must be zero. However, values	// for ListIndex_AfterEnd and ListIndex_Removed are arbitrary	// flags (any negative value will do). We use values separated by	// 2 as a safety precaution, so we can't accidently move from one	// flag to another by adding one (a common operation on indexes).const Int32	ListIndex_BeforeStart	= 0;	// 0 is before 1, the first indexconst Int32	ListIndex_AfterEnd		= -2;	// Moved past end of listconst Int32	ListIndex_Removed		= -4;	// Current item was removedconst Int32 ListIndex_ListDied		= -6;	// List was deleted// ---------------------------------------------------------------------------//	LListIterator// ---------------------------------------------------------------------------//	Construct Iterator for a List starting at a particular positionLListIterator::LListIterator(	LIteratedList	&inList,	Int32			inPosition)		: mList(inList){	mNextIterator = nil;	mCurrIndex = ListIndex_BeforeStart;	inList.AttachIterator(this);	ResetTo(inPosition);}// ---------------------------------------------------------------------------//	~LListIterator// ---------------------------------------------------------------------------//	DestructorLListIterator::~LListIterator(){	if (mCurrIndex != ListIndex_ListDied) {		mList.DetachIterator(this);	}}// ---------------------------------------------------------------------------//	CalcNextIndex// ---------------------------------------------------------------------------//	Calculate mNextIndex value based on value of mCurrIndexvoidLListIterator::CalcNextIndex(){									// Do nothing if already after end	if (mCurrIndex != ListIndex_AfterEnd) {									// Next is one after the current		mNextIndex = mCurrIndex + 1;		if (mNextIndex > mList.GetCount()) {									// We have gone past the end of the List			mNextIndex = ListIndex_AfterEnd;		}	}}// ---------------------------------------------------------------------------//	ResetTo// ---------------------------------------------------------------------------//	Reset the current item to the specified index value////	The constants iterate_FromStart and iterate_FromEnd are recognized.//	If inPosition is past the end of the List, Iterator resets to last item.//	If inPosition in before start of the List, Iterator resets to first item.voidLListIterator::ResetTo(	Int32	inPosition){	if (mCurrIndex == ListIndex_ListDied) {		return;	}									// Set current item	if (inPosition == iterate_FromEnd || inPosition > mList.GetCount()) {									// Position is past end of list		mCurrIndex = ListIndex_AfterEnd;	} else if (inPosition <= ListIndex_BeforeStart) {									// Position is before start of list		mCurrIndex = ListIndex_BeforeStart;	} else {		mCurrIndex = inPosition;	// 1 <= inPosition <= numItems	}	CalcNextIndex();}// ---------------------------------------------------------------------------//	Current// ---------------------------------------------------------------------------//	Access current item in a List////	Returns true if the current item exists and passes back a reference//	to the current item////	Returns false if the current item does not exist, which happens when://		- Current item was deleted//		- Current item is past end of list//		- Current item is before beginning of list//		- List was deletedBooleanLListIterator::Current(	void	*outItem){	if (mCurrIndex == ListIndex_ListDied) {		return false;	}	return mList.FetchItemAt(mCurrIndex, outItem);}// ---------------------------------------------------------------------------//	Next// ---------------------------------------------------------------------------//	Access next item in a List////	Returns true if the next item exists (not currently at end of list) and//	passes back a reference to the next item////	Returns false if currently at the end of the list (outItem is unchanged)BooleanLListIterator::Next(	void	*outItem){	if (mCurrIndex == ListIndex_ListDied) {		return false;	}	mCurrIndex = mNextIndex;		// Move to next item	CalcNextIndex();	return Current(outItem);}// ---------------------------------------------------------------------------//	Previous// ---------------------------------------------------------------------------//	Access previous item in a List////	Returns true if the previous item exists and returns a reference to//	that item////	Returns false if currently at the beginning of the list//	(outItem is unchanged)BooleanLListIterator::Previous(	void	*outItem){	if (mCurrIndex == ListIndex_ListDied) {		return false;	}	if (mCurrIndex == ListIndex_Removed) {									// Current item was removed									// Previous is the one before the next		mCurrIndex = mNextIndex - 1;		if (mNextIndex == ListIndex_AfterEnd) {									// Next is after end, so previous is									//   the last item			mCurrIndex = mList.GetCount();		}			} else if (mCurrIndex == ListIndex_AfterEnd) {									// Previous is last item		mCurrIndex = mList.GetCount();											// Do nothing if at beginning	} else if (mCurrIndex != ListIndex_BeforeStart) {		mCurrIndex--;				// Previous is one before current	}	CalcNextIndex();		return Current(outItem);}// ---------------------------------------------------------------------------//	SetNextIterator// ---------------------------------------------------------------------------voidLListIterator::SetNextIterator(	LListIterator	*inIterator){	mNextIterator = inIterator;}// ---------------------------------------------------------------------------//	GetNextIterator// ---------------------------------------------------------------------------LListIterator*LListIterator::GetNextIterator(){	return mNextIterator;}// ---------------------------------------------------------------------------//	ListDied// ---------------------------------------------------------------------------//	List associated with this Iterator has been deletedvoidLListIterator::ListDied(){	mCurrIndex = ListIndex_ListDied;	mNextIndex = ListIndex_ListDied;}// ---------------------------------------------------------------------------//	ItemsInserted// ---------------------------------------------------------------------------//	Items have been inserted into the List at the specified indexvoidLListIterator::ItemsInserted(	Int32	inCount,	Int32	inAtIndex){	if (inAtIndex <= mCurrIndex) {	// Inserted before current item		mCurrIndex += inCount;	}	CalcNextIndex();}// ---------------------------------------------------------------------------//	ItemsRemoved// ---------------------------------------------------------------------------//	Items starting at the specified index have been removed from the ListvoidLListIterator::ItemsRemoved(	Int32	inCount,	Int32	inAtIndex){	if (inAtIndex <= mCurrIndex) {	// Removed before or at current item				if ((inAtIndex + inCount) < mCurrIndex) {									// All removed items are before the									//   current item			mCurrIndex -= inCount;			CalcNextIndex();					} else {					// Current item has been removed			mNextIndex = inAtIndex;			if (mNextIndex > mList.GetCount()) {				mNextIndex = ListIndex_AfterEnd;			}			mCurrIndex = ListIndex_Removed;		}	}}