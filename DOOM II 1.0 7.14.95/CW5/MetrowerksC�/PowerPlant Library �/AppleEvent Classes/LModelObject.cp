// ===========================================================================//	LModelObject.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	Mix-in class for supporting the Apple Event Object Model. Subclasses of//	LModelObject represent Apple Event Object defined by the Apple Event//	Registry.////	=== Functions to Override ===////	Usually Override://		GetModelKind////	To Respond to Events://		HandleAppleEvent////	To Support Elements://		CountSubModels//		GetSubModelByPosition//		GetSubModelByName//		GetPositionOfSubModel//		HandleCreateElementEvent////	To Support Properties://		GetAEProperty//		SetAEProperty#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LModelObject.h>#include <LModelProperty.h>#include <UAppleEventsMgr.h>#include <UExtractFromAEDesc.h>#ifndef __AEOBJECTS__#include <AEObjects.h>#endif#ifndef __AERegistry__#include <AERegistry.h>#endif#ifndef __AEOBJECTPACKING__#include <AEPackObject.h>#endif//	¥ Class VariablesLModelObject*	LModelObject::sDefaultModel = nil;// ---------------------------------------------------------------------------//		¥ LModelObject// ---------------------------------------------------------------------------//	Default ConstructorLModelObject::LModelObject(){	mSuperModel = nil;}// ---------------------------------------------------------------------------//		¥ LModelObject(LModelObject*)// ---------------------------------------------------------------------------//	Construct a ModelObject with a specified SuperModelLModelObject::LModelObject(	LModelObject	*inSuperModel){	mSuperModel = inSuperModel;		if (mSuperModel != nil) {		mSuperModel->AddSubModel(this);	}}// ---------------------------------------------------------------------------//		¥ ~LModelObject// ---------------------------------------------------------------------------//	DestructorLModelObject::~LModelObject(){	if (mSuperModel != nil) {		mSuperModel->RemoveSubModel(this);	}}// ---------------------------------------------------------------------------//		¥ GetModelKind// ---------------------------------------------------------------------------//	Return the AppleEvent Class ID of a ModelObject////	Subclasses whose Class ID is not "typeNull" must override this functionDescTypeLModelObject::GetModelKind() const{	return typeNull;}// ---------------------------------------------------------------------------//		¥ IsLazy// ---------------------------------------------------------------------------//	Return whether a ModelObject is "lazy", meaning that it is a transient//	object created solely for the purpose of handling an AppleEvent, after//	which it should be deleted.////	This implementation returns "false". Lazy subclasses should override//	to return "true".BooleanLModelObject::IsLazy() const{	return false;}// ---------------------------------------------------------------------------//		¥ AddSubModel// ---------------------------------------------------------------------------//	Notify a ModelObject that is has a new SubModel////	This implementation does nothing. Subclasses should override if they//	want to maintain information about their SubModelsvoidLModelObject::AddSubModel(	LModelObject	*inSubModel){}// ---------------------------------------------------------------------------//		¥ RemoveSubModel// ---------------------------------------------------------------------------//	Notify a ModelObject that a SubModel is being deleted////	This implementation does nothing. Subclasses should override if they//	want to maintain information about their SubModelsvoidLModelObject::RemoveSubModel(	LModelObject	*inSubModel){}// ---------------------------------------------------------------------------//		¥ CountSubModels// ---------------------------------------------------------------------------//	Return number of SubModels of the specified type////	Subclasses which have SubModels ("elements" in AppleEvent terminology)//	must override this functionInt32LModelObject::CountSubModels(	DescType	inModelID) const{	return 0;}// ---------------------------------------------------------------------------//		¥ GetModelToken// ---------------------------------------------------------------------------//	Get a Token for the specified Model(s)////	This function dispatches a call to an accessor using a specific//	means of identification (key form). You will rarely override this.voidLModelObject::GetModelToken(	DescType		inModelID,	DescType		inKeyForm,	const AEDesc	&inKeyData,	AEDesc			&outToken) const{	switch (inKeyForm) {				case formAbsolutePosition: {			Int32	subCount = CountSubModels(inModelID);			if (subCount <= 0) {				ThrowOSErr_(errAENoSuchObject);			}						Int32	subPosition = 0;			if (inKeyData.descriptorType == typeAbsoluteOrdinal) {							switch (**(DescType**) inKeyData.dataHandle) {									case kAEFirst:						subPosition = 1;						break;											case kAEMiddle:						subPosition = (subCount + 1) / 2;						break;											case kAELast:						subPosition = subCount;						break;											case kAEAny:						subPosition = ((Uint16) Random() % (Uint16) subCount)										+ 1;						break;											case kAEAll:						subPosition = position_AllSubModels;						break;				}						} else {					// Interpret keyData as a number				UExtractFromAEDesc::TheInt32(inKeyData, subPosition);														// Make sure position is within range				if ( (subPosition > subCount)  ||					 (subPosition < -subCount) ||					 (subPosition == 0) ) {					ThrowOSErr_(errAENoSuchObject);				}								if (subPosition < 0) {	// Negative position counts back from										//   end, with -1 being the last item					subPosition += subCount + 1;				}			}						if (subPosition == position_AllSubModels) {				GetAllSubModels(inModelID, outToken);			} else {				GetSubModelByPosition(inModelID, subPosition, outToken);			}			break;		}					case formName: {			Str255	subModelName;			UExtractFromAEDesc::ThePString(inKeyData, subModelName);			GetSubModelByName(inModelID, subModelName, outToken);			break;		}					case formUniqueID:			GetSubModelByUniqueID(inModelID, inKeyData, outToken);			break;					case formRelativePosition: {			OSType	relativePosition;			UExtractFromAEDesc::TheEnum(inKeyData, relativePosition);			GetModelByRelativePosition(inModelID, relativePosition, outToken);			break;		}					default:			GetSubModelByComplexKey(inModelID, inKeyForm, inKeyData,									outToken);			break;	}}// ---------------------------------------------------------------------------//		¥ GetSubModelByPosition// ---------------------------------------------------------------------------//	Pass back a Token for the SubModel(s) of the specified type at the//	specified position (1 being the first).////	Subclasses which have SubModels that can be specified by position//	must override this function.voidLModelObject::GetSubModelByPosition(	DescType		inModelID,	Int32			inPosition,	AEDesc			&outToken) const{	ThrowOSErr_(errAENoSuchObject);}// ---------------------------------------------------------------------------//		¥ GetSubModelByName// ---------------------------------------------------------------------------//	Pass back a Token for the SubModel(s) of the specified type with the//	specified name////	Subclasses which have SubModels that can be specified by name//	must override this function.voidLModelObject::GetSubModelByName(	DescType		inModelID,	Str255			inName,	AEDesc			&outToken) const{	ThrowOSErr_(errAENoSuchObject);}// ---------------------------------------------------------------------------//		¥ GetSubModelByUniqueID// ---------------------------------------------------------------------------//	Pass back a Token for the SubModel(s) of the specified type with the//	specified unique ID////	Subclasses which have SubModels that can be specified by unique ID//	must override this function. It is up to you to decide what//	constitutes a unique ID.voidLModelObject::GetSubModelByUniqueID(	DescType		inModelID,	const AEDesc	&inKeyData,	AEDesc			&outToken) const{	ThrowOSErr_(errAENoSuchObject);}// ---------------------------------------------------------------------------//		¥ GetModelByRelativePosition// ---------------------------------------------------------------------------//	Pass back a Token for the Model of the specified type at the specified//	relative position ("before" or "after" this ModelObject).////	This function handles the case where the Model to get is of the same//	kind as this ModelObject by getting the position of this ModelObject,//	then getting the ModelObject at the position before or after it.//	For example, to get the "paragraph after this paragraph", we get the//	position of the is paragraph, add one, then get the paragraph at//	that position.////	Subclass should override this function to implement a more efficient//	way to get the next or previous item, or to handle the case where the//	object to get is a different kind of object. For example, to be able//	to get the "table after this paragraph".voidLModelObject::GetModelByRelativePosition(	DescType		inModelID,	OSType			inRelativePosition,	AEDesc			&outToken) const{	if (inModelID == GetModelKind()) {		LModelObject	*theSuper = mSuperModel;		if (theSuper == nil) {			theSuper = GetDefaultModel();		}			Int32	thePosition =					theSuper->GetPositionOfSubModel(inModelID, this);		if (inRelativePosition == kAENext) {			thePosition += 1;			if (thePosition > theSuper->CountSubModels(inModelID)) {				ThrowOSErr_(errAENoSuchObject);			}					} else if (inRelativePosition == kAEPrevious) {			thePosition -= 1;			if (thePosition <= 0) {				ThrowOSErr_(errAENoSuchObject);			}					} else {			ThrowOSErr_(errAEParamMissed);		}				theSuper->GetSubModelByPosition(inModelID, thePosition, outToken);			} else {		ThrowOSErr_(errAENoSuchObject);	}}// ---------------------------------------------------------------------------//		¥ GetSubModelByComplexKey// ---------------------------------------------------------------------------//	Pass back a Token for the SubModel(s) of the specified type identified//	by a complex key. Complex keys are formRange, formTest, and formWhose.////	Subclasses which support complex keys for identifying SubModels must//	override this function.voidLModelObject::GetSubModelByComplexKey(	DescType		inModelID,	DescType		inKeyForm,	const AEDesc	&inKeyData,	AEDesc			&outToken) const{	ThrowOSErr_(errAENoSuchObject);}// ---------------------------------------------------------------------------//		¥ GetAllSubModels// ---------------------------------------------------------------------------//	Pass back a Token list for all SubModels of the specified type////	This function uses a brute force approach://		Get the count of items//		Get Token for each item in order and add it to the list////	Override this function if a ModelObject can create this Token list//	in a more efficient manner.voidLModelObject::GetAllSubModels(	DescType		inModelID,	AEDesc			&outToken) const{	LModelObject	*theSuper = mSuperModel;	if (theSuper == nil) {		theSuper = GetDefaultModel();	}	Int32	subCount = theSuper->CountSubModels(inModelID);	if (subCount > 0) {		OSErr	err = ::AECreateList(nil, 0, false, &outToken);		ThrowIfOSErr_(err);				for (Int32 i = 1; i <= subCount; i++) {			AEDesc	subToken;			GetSubModelByPosition(inModelID, i, subToken);			err = ::AEPutDesc(&outToken, 0, &subToken);			ThrowIfOSErr_(err);			::AEDisposeDesc(&subToken);		}			} else {		ThrowOSErr_(errAENoSuchObject);	}}// ---------------------------------------------------------------------------//		¥ GetPositionOfSubModel// ---------------------------------------------------------------------------//	Return the absolute position of the specified SubModel, with 1 being//	the first////	Subclasses which have SubModels that can be identified by position//	must override this functionInt32LModelObject::GetPositionOfSubModel(	DescType			inModelID,	const LModelObject	*inSubModel) const{	ThrowOSErr_(errAENoSuchObject);	return 0;}// ---------------------------------------------------------------------------//		¥ CompareToModel// ---------------------------------------------------------------------------//	Return result of comparing this ModelObject with another one////	Subclasses must override this method to support accessing objects//	by selection criteria, commonly called "whose" clauses.//		For example:  get all words equal to word 1BooleanLModelObject::CompareToModel(	DescType		inComparisonOperator,	LModelObject	*inCompareModel) const{	ThrowOSErr_(errAEEventNotHandled);	return false;}	// ---------------------------------------------------------------------------//		¥ CompareToDescriptor// ---------------------------------------------------------------------------//	Return result of comparing this ModelObject with Descriptor data////	Subclasses must override this method to support accessing objects//	by selection criteria, commonly called "whose" clauses.//		For example:  get all words that contain "foo"BooleanLModelObject::CompareToDescriptor(	DescType		inComparisonOperator,	const AEDesc	&inCompareDesc) const{	ThrowOSErr_(errAEEventNotHandled);	return false;}// ---------------------------------------------------------------------------//		¥ GetModelProperty// ---------------------------------------------------------------------------//	Return a ModelProperty object representing the specified property////	This implementation always creates a LModelProperty object for the//	specificied property (although the property may not really exist).//	For nonexistent properties, a later attempt to get or set the property//	value will pass back an error.////	Subclasses which have Properties may wish to override to report an//	error for nonexistent Properties.//	Usually, your function will be of the form:////		switch (inProperty) {////			case pName:		// a case for each property of a ModelObject//			case pColor://			case pFont://							// Create ModelProperty for the specified//							// property of this object//				return new LModelProperty(inProperty, this);//				break;////			default://							// Error, unknown property. Do something.//				break;//		}LModelProperty*LModelObject::GetModelProperty(	DescType	inProperty){	return (new LModelProperty(inProperty, this));}// ---------------------------------------------------------------------------//		¥ CompareObject// ---------------------------------------------------------------------------//	Return the result of comparing a property of this ModelObject with//	another object////	Subclasses must override this method to support accessing objects by//	selection criteria on their properties, commonly called "whose" clauses.//		For example:  get all words whose point size is less than 12 BooleanLModelObject::CompareProperty(	DescType		inPropertyID,	DescType		inComparisonOperator,	const AEDesc	&inCompareObjectOrDesc) const{	ThrowOSErr_(errAEEventNotHandled);	return false;}// ---------------------------------------------------------------------------//		¥ MakeSpecifier// ---------------------------------------------------------------------------//	Make an Object Specifier for a ModelObject////	This is a helper function that uses recursion to call MakeSelfSpecifier//	for a ModelObject and all its SuperModels. You will not need to//	override this function.voidLModelObject::MakeSpecifier(	AEDesc	&outSpecifier) const{	StAEDescriptor		superSpecifier;		if (mSuperModel != nil) {		mSuperModel->MakeSpecifier(superSpecifier.mDesc);	}		MakeSelfSpecifier(superSpecifier.mDesc, outSpecifier);}// ---------------------------------------------------------------------------//		¥ MakeSelfSpecifier// ---------------------------------------------------------------------------//	Make an Object Specifier for a ModelObject////	This function creates a specifier using the absolute position of//	a ModelObject within its SuperModel.////	Override this function for subclasses which can't be specified by//	absolute position or for which another means of identification//	(for example, by name) is more appropriate or that don't have//	a SuperModel (access from null container).voidLModelObject::MakeSelfSpecifier(	AEDesc	&inSuperSpecifier,	AEDesc	&outSelfSpecifier) const{		// Find position of this ModelObject within its SuperModel		// Error if SuperModel does not exist or if SuperModel		// can't return a valid position for this object	if (mSuperModel == nil) {		ThrowOSErr_(errAEEventNotHandled);	}	Int32	modelIndex = mSuperModel->GetPositionOfSubModel(										GetModelKind(), this);	if (modelIndex == 0) {		ThrowOSErr_(errAEEventNotHandled);	}		StAEDescriptor	absPosKeyData;	OSErr	err = ::CreateOffsetDescriptor(modelIndex, &absPosKeyData.mDesc);	ThrowIfOSErr_(err);		err = ::CreateObjSpecifier(GetModelKind(), &inSuperSpecifier,			formAbsolutePosition, &absPosKeyData.mDesc, false,			&outSelfSpecifier);	ThrowIfOSErr_(err);}// ---------------------------------------------------------------------------//		¥ HandleAppleEvent// ---------------------------------------------------------------------------//	Respond to an AppleEvent. This is the default handler for AppleEvents//	that do not have a specific handler.////	Subclasses must override this function to support AppleEvents other//	than Create Element, Get Data, and Set Data, which have specific//	handlers (declared below).voidLModelObject::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	ThrowOSErr_(errAEEventNotHandled);}// ---------------------------------------------------------------------------//		¥ HandleCreateElementEvent// ---------------------------------------------------------------------------//	Respond to a Create Element AppleEvent (called "make new" in AppleScript).//	The parameters specify the Class ID for the new element, and where to//	insert the new element in relation to a target object. Also, the//	AppleEvent record may contain additional parameters that specify//	initial values for the new element.////	Subclasses which have SubModels which can be dynamically created should//	override this function. Return a pointer to the newly created SubModel.//	The calling function takes care of putting an object specifier for//	this new SubModel in the AppleEvent reply. LModelObject*LModelObject::HandleCreateElementEvent(	DescType			inElemClass,	DescType			inInsertPosition,	LModelObject		*inTargetObject,	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply){	ThrowOSErr_(errAEEventNotHandled);	return nil;}// ---------------------------------------------------------------------------//		¥ Finalize// ---------------------------------------------------------------------------//	This function gets called after an AppleEvent involving a ModelObject//	has been handled////	Subclasses should override this function if they need to clean up//	after themselvesvoidLModelObject::Finalize(){	if (IsLazy()) {		delete this;	}}// ---------------------------------------------------------------------------//		¥ GetAEProperty// ---------------------------------------------------------------------------//	Return a descriptor for the specified Property////	Subclasses which have Properties must override this functionvoidLModelObject::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	ThrowOSErr_(errAEUnknownObjectType);}// ---------------------------------------------------------------------------//		¥ SetAEProperty// ---------------------------------------------------------------------------//	Set a Property using data from a descriptor////	Subclasses which have modifiable Properties must override this functionvoidLModelObject::SetAEProperty(	DescType		inProperty,	const AEDesc	&inValue,	AEDesc&			outAEReply){	ThrowOSErr_(errAEUnknownObjectType);}// ---------------------------------------------------------------------------//		¥ GetSuperModel// ---------------------------------------------------------------------------//	Return the SuperModel (container) of a ModelObjectLModelObject*LModelObject::GetSuperModel(){	return mSuperModel;}// ---------------------------------------------------------------------------//		¥ SendSelfAE// ---------------------------------------------------------------------------//	Send an AppleEvent to the current process with this ModelObject as//	the direct parametervoidLModelObject::SendSelfAE(	AEEventClass	inEventClass,	AEEventID		inEventID,	Boolean			inExecute){	AppleEvent	theAppleEvent;	UAppleEventsMgr::MakeAppleEvent(inEventClass, inEventID, theAppleEvent);	StAEDescriptor	modelSpec;	MakeSpecifier(modelSpec.mDesc);	OSErr err = AEPutParamDesc(&theAppleEvent, keyDirectObject,								&modelSpec.mDesc);	ThrowIfOSErr_(err);	UAppleEventsMgr::SendAppleEvent(theAppleEvent, inExecute);}// ===========================================================================// ¥ Static Member Functions						 Static Member Functions ¥// ===========================================================================// ---------------------------------------------------------------------------//	DefaultModel// ---------------------------------------------------------------------------////	The DefaultModel responds to all AppleEvents not directed at any//	specific object. It also represents the "null" container and the//	top container in the AppleEvent Object Model container hierarchy.//	In most cases, the DefaultModel will be the "Application" object.////	If you do not use a PowerPlant class that automatically sets the//	DefaultModel (such as one of the Application-type classes), you//	must create a class that handles the DefaultModel's responsibilities//	and set the DefaultModel appropriately.LModelObject*LModelObject::GetDefaultModel(){	return sDefaultModel;}voidLModelObject::SetDefaultModel(	LModelObject	*inModel){	sDefaultModel = inModel;}// ---------------------------------------------------------------------------//		¥ PutInToken// ---------------------------------------------------------------------------//	Place the pointer to a ModelObject within a Token. Tokens are used//	when resolving an AppleEvent object specifiervoidLModelObject::PutInToken(	LModelObject	*inModel,	AEDesc			&outToken){	if (inModel == nil) {		ThrowOSErr_(errAENoSuchObject);			} else {		SModelToken		theToken;		theToken.modelObject = inModel;		OSErr	err = ::AECreateDesc(type_ModelToken, &theToken,								sizeof(SModelToken), &outToken);		ThrowIfOSErr_(err);	}}// ---------------------------------------------------------------------------//		¥ GetModelFromToken// ---------------------------------------------------------------------------//	Return the ModelObject represented by a Token Descriptor recordLModelObject*LModelObject::GetModelFromToken(	const AEDesc	&inToken){	LModelObject*	theModel = nil;			// Token Descriptor fields:		//		descriptorType - Kind of the ModelObject		//		dataHandle     - Contains Ptr to ModelObject		if (inToken.descriptorType == typeNull) {			// Special case for the default ModelObject		theModel = GetDefaultModel();			} else if (inToken.descriptorType == type_ModelToken) {		theModel = (**((SModelTokenH) inToken.dataHandle)).modelObject;			} else {		ThrowOSErr_(errAEUnknownObjectType);	}		return theModel;}