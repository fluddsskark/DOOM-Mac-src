// ===========================================================================//	LModelDirector.cp				©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	A wrapper class for AppleEvent handlers and the AE Object Support Library////	You should only create one object of this class. This object handles//	all callbacks from the AppleEvent Manager. It either handles the callback//	itself, or calls a member function for the LModelObject that is the//	target of an AppleEvent.////	The callback functions are static functions that call a virtual member//	function of LModelDirector. You can override these functions in a//	subclass of LModelDirector to change how AppleEvent callbacks are//	handled.#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LModelDirector.h>#include <LModelObject.h>#include <LModelProperty.h>#include <UAppleEventsMgr.h>#ifndef __AEREGISTRY__#include <AERegistry.h>#endif#ifndef __AEOBJECTS__#include <AEObjects.h>#endif#ifndef __AEOBJECTPACKING__#include <AEPackObject.h>#endif// === Static Member Variables ===LModelDirector*	LModelDirector::sModelDirector;// ---------------------------------------------------------------------------//		¥ LModelDirector// ---------------------------------------------------------------------------//	Default ConstructorLModelDirector::LModelDirector(){	sModelDirector = this;	UAppleEventsMgr::Initialize();	AEObjectInit();}LModelDirector::LModelDirector(	LModelObject	*inDefaultModel){	sModelDirector = this;	LModelObject::SetDefaultModel(inDefaultModel);	UAppleEventsMgr::Initialize();	AEObjectInit();	InstallCallBacks();}// ---------------------------------------------------------------------------//		¥ ~LModelDirector// ---------------------------------------------------------------------------//	DestructorLModelDirector::~LModelDirector(){}// ---------------------------------------------------------------------------//		¥ InstallCallBacks// ---------------------------------------------------------------------------//	Install handler and callback functions used by the AppleEvent Manager//		and the Object Support Library//	Call this function only once (usually at the beginning of the program)voidLModelDirector::InstallCallBacks(){	OSErr	err;			// Generic handler for all AppleEvents		UAppleEventsMgr::InstallAEHandlers(			NewAEEventHandlerProc(LModelDirector::AppleEventHandler));			// Specific handler for Open AppleEvent		err = ::AEInstallEventHandler(kCoreEventClass, kAEOpen,			NewAEEventHandlerProc(LModelDirector::OpenOrPrintEventHandler),			ae_Open, false);	ThrowIfOSErr_(err);			// Specific handler for Print AppleEvent		err = ::AEInstallEventHandler(kCoreEventClass, kAEPrint,			NewAEEventHandlerProc(LModelDirector::OpenOrPrintEventHandler),			ae_Print, false);	ThrowIfOSErr_(err);			// Specific handler for CreateElement AppleEvent		err = ::AEInstallEventHandler(kAECoreSuite, kAECreateElement,			NewAEEventHandlerProc(LModelDirector::CreateElementEventHandler),			ae_CreateElement, false);	ThrowIfOSErr_(err);				// Generic accessor for Model Objects			err = ::AEInstallObjectAccessor(typeWildCard, typeWildCard, 				NewOSLAccessorProc(LModelDirector::ModelObjectAccessor),				0, false);	ThrowIfOSErr_(err);			// Accessor for List of Model Objects			err = ::AEInstallObjectAccessor(typeWildCard, typeAEList, 				NewOSLAccessorProc(LModelDirector::ModelObjectListAccessor),				0, false);	ThrowIfOSErr_(err);				// Accessor for Model Properties			err = ::AEInstallObjectAccessor(cProperty, typeWildCard,				NewOSLAccessorProc(LModelDirector::ModelPropertyAccessor),				0, false);	ThrowIfOSErr_(err);				// Accessor for List of Model Properties			err = ::AEInstallObjectAccessor(cProperty, typeAEList,				NewOSLAccessorProc(LModelDirector::ModelPropertyListAccessor),				0, false);	ThrowIfOSErr_(err);			err = ::AESetObjectCallbacks(				NewOSLCompareProc(LModelDirector::OSLCompareObjects),				NewOSLCountProc(LModelDirector::OSLCountObjects),				NewOSLDisposeTokenProc(LModelDirector::OSLDisposeToken),				nil,		// GetMarkToken				nil,		// Mark				nil,		// AdjustMarks				nil);		// GetErrDesc	ThrowIfOSErr_(err);}// ---------------------------------------------------------------------------//		¥ HandleAppleEvent// ---------------------------------------------------------------------------//	Respond to an AppleEvent////	This generic handler directs the AppleEvent to the ModelObject//	specified by the keyDirectObject parameter. If the keyDirectObject//	parmater does not exist or is not an object specifier, the default//	model handles the AppleEvent.////	You must install a separate handler for AppleEvents where the//	keyDirectObject parameter has a different meaning.voidLModelDirector::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outReply,	long				inRefCon){	OSErr	err;	AEDesc	theResult = {typeNull, nil};										// Get optional direct object parameter	StAEDescriptor	directObj;	directObj.GetOptionalParamDesc(inAppleEvent, keyDirectObject,									typeWildCard);										if (directObj.mDesc.descriptorType != typeObjectSpecifier) {				// Direct object is not an ospec, so let the default model			// handle the AppleEvent			(LModelObject::GetDefaultModel())->			HandleAppleEvent(inAppleEvent, outReply, theResult, inRefCon);			} else {			// Direct object is an ospec. Resolve it into ModelObject(s)			AEDesc	theToken;		err = ::AEResolve(&directObj.mDesc, kAEIDoMinimum, &theToken);		ThrowIfOSErr_(err);				ProcessTokenizedEvent(inAppleEvent, theToken, theResult,								outReply, inRefCon);				::AEDisposeDesc(&theToken);	}										// Put result code(s) in Reply	if (theResult.descriptorType != typeNull) {		err = ::AEPutParamDesc(&outReply, keyAEResult, &theResult);		::AEDisposeDesc(&theResult);		ThrowIfOSErr_(err);	}}// ---------------------------------------------------------------------------//		¥ HandleOpenOrPrintEvent// ---------------------------------------------------------------------------//	Respond to an Open or Print AppleEvent////	Open an Print AppleEvents require a special handler because the//	keyDirectObject parameter can specify an object that does not yet//	exist. This will happen, for example, when opening a file//	which is not already open.voidLModelDirector::HandleOpenOrPrintEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outReply,	long				inRefCon){	OSErr	err;	Boolean	useDefaultModel = true;	AEDesc	theResult = {typeNull, nil};	AEDesc	directObjToken;										// Get direct object parameter	StAEDescriptor	directObj;	directObj.GetParamDesc(inAppleEvent, keyDirectObject, typeWildCard);										if (directObj.mDesc.descriptorType == typeObjectSpecifier) {									// Resolve specifier to a ModelObject											err = ::AEResolve(&directObj.mDesc, kAEIDoMinimum, &directObjToken);		useDefaultModel = (err == errAENoSuchObject);		if (!useDefaultModel && (err != noErr)) ThrowOSErr_(err);	}			if (useDefaultModel) {			// Direct object parameter not present									//   or is not an object specifier		(LModelObject::GetDefaultModel())->			HandleAppleEvent(inAppleEvent, outReply, theResult, inRefCon);			} else {						// Process this event using the Token									//   representing the direct direct		ProcessTokenizedEvent(inAppleEvent, directObjToken, theResult,								outReply, inRefCon);		::AEDisposeDesc(&directObjToken);	}										// Put result code(s) in Reply	if (theResult.descriptorType != typeNull) {		err = ::AEPutParamDesc(&outReply, keyAEResult, &theResult);		::AEDisposeDesc(&theResult);		ThrowIfOSErr_(err);	}}// ---------------------------------------------------------------------------//		¥ HandleCreateElementEvent// ---------------------------------------------------------------------------//	Respond to a CreateElement AppleEvent////	CreateElement requires a special handler because it does not have//	a keyDirectObject parameter that specifies a target ModelObject which//	should respond to the event. The target ModelObject for this event//	is the SuperModel for the element to create.voidLModelDirector::HandleCreateElementEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outReply,	long				inRefCon){	OSErr		err;	DescType	elemClass;	DescType	insertPosition;							Size		theSize;			// Get ClassID of element to create	DescType	theType;	err = ::AEGetParamPtr(&inAppleEvent, keyAEObjectClass, typeType,							&theType, (Ptr) &elemClass, sizeof(DescType),							&theSize);	ThrowIfOSErr_(err);									// The "insert here" parameter is supposed be required. However,		// it seems reasonable to let it be optional and use the		// beginning of the Application as the default location.	LModelObject	*elemContainer = LModelObject::GetDefaultModel();	LModelObject	*targetObject = nil;	StAEDescriptor	insertDesc;	insertDesc.GetOptionalParamDesc(inAppleEvent, keyAEInsertHere,										typeInsertionLoc);		if (insertDesc.mDesc.descriptorType == typeInsertionLoc) {																					// Coerce insert location into an AERecord so we can			// more easily extract the information				StAEDescriptor	insertAERec;		err = ::AECoerceDesc(&insertDesc.mDesc, typeAERecord,								&insertAERec.mDesc);		ThrowIfOSErr_(err);					// Extract position at which to insert the new element				err = ::AEGetKeyPtr(&insertAERec.mDesc, keyAEPosition,						typeEnumeration, &theType, (Ptr) &insertPosition,						sizeof(DescType), &theSize);		ThrowIfOSErr_(err);			// Extract target object to which position refers				StAEDescriptor	insertTarget;		err = ::AEGetKeyDesc(&insertAERec.mDesc, keyAEObject, typeWildCard,						&insertTarget.mDesc);		ThrowIfOSErr_(err);				if (insertTarget.mDesc.descriptorType == typeObjectSpecifier) {							// Target is an ospec. Resolve it to find the				// corresponding ModelObject.							AEDesc	insertToken;			err = ::AEResolve(&insertTarget.mDesc, kAEIDoMinimum,								&insertToken);			ThrowIfOSErr_(err);							targetObject = LModelObject::GetModelFromToken(insertToken);			::AEDisposeDesc(&insertToken);						switch (insertPosition) {							case kAEBefore:		// For these positions, the insert target				case kAEAfter:		// specifies an object in the same				case kAEReplace:	// container as that in which to create									// the new element					elemContainer = targetObject->GetSuperModel();					break;									case kAEBeginning:	// For these position, the insert target				case kAEEnd:		// is the container in which to create									// the new element					elemContainer = targetObject;					break;									default:					ThrowOSErr_(errAEEventNotHandled);					break;			}					} else if (insertTarget.mDesc.descriptorType != typeNull) {			ThrowOSErr_(errAETypeError);		}	}				// Let container object create new element of the specified		// class at the specified position		LModelObject	*element = elemContainer->HandleCreateElementEvent(									elemClass, insertPosition,									targetObject, inAppleEvent, outReply);				// The AppleEvents Registry specifies that an object specifier		// for the new element be returned as the keyAEResult parameter		// in the Reply to the AppleEvent										if (element != nil) {		StAEDescriptor	elementDesc;		element->MakeSpecifier(elementDesc.mDesc);		::AEPutKeyDesc(&outReply, keyAEResult, &elementDesc.mDesc);		element->Finalize();	}}voidLModelDirector::ProcessTokenizedEvent(	const AppleEvent	&inAppleEvent,	AEDesc				&inDirectObjToken,	AEDesc				&outResult,	AppleEvent			&outReply,	long				inRefCon){	LModelObject	*theResponder;	if (inDirectObjToken.descriptorType != typeAEList) {				// Direct object is a single ModelObject			theResponder = LModelObject::GetModelFromToken(inDirectObjToken);		theResponder->HandleAppleEvent(inAppleEvent, outReply, outResult,										inRefCon);			} else {			// Direct object is a list of ModelObjects											// Create list for result codes		OSErr	err = ::AECreateList(nil, 0, false, &outResult);		ThrowIfOSErr_(err);				Int32	itemCount;		// Find number of items in the list		err = ::AECountItems(&inDirectObjToken, &itemCount);		ThrowIfOSErr_(err);				for (Int32 i = 1; i <= itemCount; i++) {								// Let each ModelObject in the list								// respond to the AppleEvent			AEDesc		itemDesc;			AEKeyword	itemKeyword;			err = ::AEGetNthDesc(&inDirectObjToken, i, typeWildCard,								&itemKeyword, &itemDesc);			ThrowIfOSErr_(err);						theResponder = LModelObject::GetModelFromToken(itemDesc);			::AEDisposeDesc(&itemDesc);						AEDesc	resultDesc = {typeNull, nil};			theResponder->HandleAppleEvent(inAppleEvent, outReply,											resultDesc, inRefCon);											// Store result code in result list			if (resultDesc.descriptorType != typeNull) {				err = ::AEPutDesc(&outResult, 0, &resultDesc);				::AEDisposeDesc(&resultDesc);				ThrowIfOSErr_(err);			}		}	}}// ---------------------------------------------------------------------------//		¥ AccessModelObject// ---------------------------------------------------------------------------//	Get Token for ModelObject////	Part of the OSL object resolution process. Given a Token for a//	Container and a key description of some objects, make a Token//	for those objects.voidLModelDirector::AccessModelObject(	const DescType	inDesiredClass,	const AEDesc	&inContainerToken,	const DescType	inContainerClass,	const DescType	inKeyForm,	const AEDesc	&inKeyData,	AEDesc			&outToken,	long			inRefCon){	LModelObject	*theContainer = LModelObject::GetModelFromToken(inContainerToken);	theContainer->GetModelToken(inDesiredClass, inKeyForm, inKeyData,									outToken);}voidLModelDirector::AccessModelObjectList(	const DescType	inDesiredClass,	const AEDesc	&inContainerToken,	const DescType	inContainerClass,	const DescType	inKeyForm,	const AEDesc	&inKeyData,	AEDesc			&outToken,	long			inRefCon){	OSErr	err;									// Create list for result codes	err = ::AECreateList(nil, 0, false, &outToken);	ThrowIfOSErr_(err);		Int32	itemCount;				// Get number of items in list	err = ::AECountItems(&inContainerToken, &itemCount);	ThrowIfOSErr_(err);										// Access each item in the list	for (Int32 i = 1; i <= itemCount; i++) {		AEDesc		containerDesc;		AEKeyword	theKeyword;				err = ::AEGetNthDesc(&inContainerToken, i, typeWildCard,								&theKeyword, &containerDesc);		ThrowIfOSErr_(err);				LModelObject* container = LModelObject::GetModelFromToken(containerDesc);				AEDesc		subModelDesc;		container->GetModelToken(inDesiredClass, inKeyForm, inKeyData,								subModelDesc);										if (subModelDesc.descriptorType != typeAEList) {			err = ::AEPutDesc(&outToken, 0, &subModelDesc);			ThrowIfOSErr_(err);					} else {					Int32	subCount;			err = ::AECountItems(&subModelDesc, &subCount);			ThrowIfOSErr_(err);						for (Int32 j = 1; j <= subCount; j++) {				AEDesc		subItem;				AEKeyword	subKeyword;								err = ::AEGetNthDesc(&subModelDesc, j, typeWildCard,								&subKeyword, &subItem);				ThrowIfOSErr_(err);								err = ::AEPutDesc(&outToken, 0, &subItem);				ThrowIfOSErr_(err);								::AEDisposeDesc(&subItem);			}		}				::AEDisposeDesc(&containerDesc);	}}// ---------------------------------------------------------------------------//		¥ AccessModelProperty// ---------------------------------------------------------------------------//	Make a Token for a Property of a ModelObect////	Part of the OSL object resolution process. Given a Token for a//	Container and a key description of a Property, make a Token//	for that Property.voidLModelDirector::AccessModelProperty(	const DescType	inDesiredClass,	const AEDesc	&inContainerToken,	const DescType	inContainerClass,	const DescType	inKeyForm,	const AEDesc	&inKeyData,	AEDesc			&outToken,	long			inRefCon){								// Key must specify a Property ID by Type	if (inKeyForm != formPropertyID) ThrowOSErr_(errAEBadKeyForm);	if (inKeyData.descriptorType != typeType) ThrowOSErr_(errAETypeError);		LModelObject*	theContainer = LModelObject::GetModelFromToken(inContainerToken);		DescType 		propertyID = **(DescType**)(inKeyData.dataHandle);		LModelObject::PutInToken(theContainer->GetModelProperty(propertyID),							outToken);}voidLModelDirector::AccessModelPropertyList(	const DescType	inDesiredClass,	const AEDesc	&inContainerToken,	const DescType	inContainerClass,	const DescType	inKeyForm,	const AEDesc	&inKeyData,	AEDesc&			outToken,	long			inRefCon){								// Key must specify a Property ID by Type	if (inKeyForm != formPropertyID) ThrowOSErr_(errAEBadKeyForm);	if (inKeyData.descriptorType != typeType) ThrowOSErr_(errAETypeError);		DescType 		propertyID = **(DescType**)(inKeyData.dataHandle);									// Create list for result codes	OSErr	err = ::AECreateList(nil, 0, false, &outToken);	ThrowIfOSErr_(err);		Int32	propCount;	err = ::AECountItems(&inContainerToken, &propCount);	ThrowIfOSErr_(err);		for (Int32 i = 1; i <= propCount; i++) {		AEDesc		modelDesc;		AEKeyword	modelKeyword;				err = ::AEGetNthDesc(&inContainerToken, i, typeWildCard,								&modelKeyword, &modelDesc);		ThrowIfOSErr_(err);				AEDesc	propDesc;		LModelObject::PutInToken(			LModelObject::GetModelFromToken(modelDesc)->GetModelProperty(propertyID),			propDesc);					::AEDisposeDesc(&modelDesc);				err = ::AEPutDesc(&outToken, 0, &propDesc);		::AEDisposeDesc(&propDesc);		ThrowIfOSErr_(err);	}}// ---------------------------------------------------------------------------//		¥ DisposeToken// ---------------------------------------------------------------------------//	A Token is no longer neededvoidLModelDirector::DisposeToken(	AEDesc		&inToken){	if (inToken.dataHandle == nil) {		return;			} else if (inToken.descriptorType != typeAEList) {			LModelObject::GetModelFromToken(inToken)->Finalize();			} else {				Int32	itemCount;		OSErr	err = ::AECountItems(&inToken, &itemCount);		ThrowIfOSErr_(err);				for (Int32 i = 1; i <= itemCount; i++) {			AEDesc		modelToken;			AEKeyword	modelKeyword;						err = ::AEGetNthDesc(&inToken, i, typeWildCard, &modelKeyword,									&modelToken);			ThrowIfOSErr_(err);						LModelObject::GetModelFromToken(modelToken)->Finalize();			::AEDisposeDesc(&modelToken);		}	}		::AEDisposeDesc(&inToken);}// ---------------------------------------------------------------------------//		¥ CompareObjects// ---------------------------------------------------------------------------//	Pass back the result of comparing one object with anothervoidLModelDirector::CompareObjects(	DescType		inComparisonOperator,	const AEDesc	&inBaseObject,	const AEDesc	&inCompareObjectOrDesc,	Boolean			&outResult){		// Base Object compares itself to the other object			LModelObject	*theModel = LModelObject::GetModelFromToken(inBaseObject);		if (inCompareObjectOrDesc.descriptorType == type_ModelToken) {								// Other "object" is another ModelObject		outResult = theModel->CompareToModel(inComparisonOperator,					LModelObject::GetModelFromToken(inCompareObjectOrDesc));									} else {					// Other "object" is a Descriptor		outResult = theModel->CompareToDescriptor(inComparisonOperator,								inCompareObjectOrDesc);	}}// ---------------------------------------------------------------------------//		¥ CountObjects// ---------------------------------------------------------------------------//	Pass back the number of objects of the desiredClass that are in the//	specified container objectvoidLModelDirector::CountObjects(	DescType		inDesiredClass,	DescType		inContainerClass,	const AEDesc	&inContainer,	Int32			&outCount){	LModelObject	*theModel = LModelObject::GetModelFromToken(inContainer);	outCount = theModel->CountSubModels(inDesiredClass);}// ===========================================================================// ¥ Static CallBack Functions					   Static CallBack Functions ¥// ===========================================================================// ---------------------------------------------------------------------------//		¥ AppleEventHandler// ---------------------------------------------------------------------------//	Generic CallBack function for all AppleEventspascal OSErrLModelDirector::AppleEventHandler(	const AppleEvent	*inAppleEvent,	AppleEvent			*outAEReply,	long				inRefCon){	OSErr	err = noErr;		Try_ {		sModelDirector->HandleAppleEvent(*inAppleEvent, *outAEReply, inRefCon);	}		Catch_(inErr) {		err = inErr;	} EndCatch_	return err;}// ---------------------------------------------------------------------------//		¥ OpenOrPrintEventHandler// ---------------------------------------------------------------------------//	CallBack function for Open or Print AppleEvents	pascal OSErrLModelDirector::OpenOrPrintEventHandler(	const AppleEvent	*inAppleEvent,	AppleEvent			*outAEReply,	long				inRefCon){	OSErr	err = noErr;		Try_ {		sModelDirector->HandleOpenOrPrintEvent(*inAppleEvent, *outAEReply,							inRefCon);	}		Catch_(inErr) {		err = inErr;	} EndCatch_	return err;}// ---------------------------------------------------------------------------//		¥ CreateElementEventHandler// ---------------------------------------------------------------------------//	CallBack function for CreateElement AppleEvent	pascal OSErrLModelDirector::CreateElementEventHandler(	const AppleEvent	*inAppleEvent,	AppleEvent			*outAEReply,	long				inRefCon){	OSErr	err = noErr;		Try_ {		sModelDirector->HandleCreateElementEvent(*inAppleEvent, *outAEReply,							inRefCon);	}		Catch_(inErr) {		err = inErr;	} EndCatch_	return err;}pascal OSErrLModelDirector::ModelObjectAccessor(	DescType		inDesiredClass,	const AEDesc	*inContainerToken,	DescType		inContainerClass,	DescType		inKeyForm,	const AEDesc	*inKeyData,	AEDesc*			outToken,	long			inRefCon){	OSErr	err = noErr;		Try_ {		sModelDirector->AccessModelObject(inDesiredClass,									*inContainerToken, inContainerClass,									inKeyForm, *inKeyData,									*outToken, inRefCon);	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}pascal OSErrLModelDirector::ModelObjectListAccessor(	DescType		inDesiredClass,	const AEDesc	*inContainerToken,	DescType		inContainerClass,	DescType		inKeyForm,	const AEDesc	*inKeyData,	AEDesc*			outToken,	long			inRefCon){	OSErr	err = noErr;		Try_ {		sModelDirector->AccessModelObjectList(inDesiredClass,									*inContainerToken, inContainerClass,									inKeyForm, *inKeyData,									*outToken, inRefCon);	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}pascal OSErrLModelDirector::ModelPropertyAccessor(	DescType		inDesiredClass,	const AEDesc	*inContainerToken,	DescType		inContainerClass,	DescType		inKeyForm,	const AEDesc	*inKeyData,	AEDesc*			outToken,	long			inRefCon){	OSErr	err = noErr;		Try_ {		sModelDirector->AccessModelProperty(inDesiredClass,									*inContainerToken, inContainerClass,									inKeyForm, *inKeyData,									*outToken, inRefCon);	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}pascal OSErrLModelDirector::ModelPropertyListAccessor(	DescType		inDesiredClass,	const AEDesc	*inContainerToken,	DescType		inContainerClass,	DescType		inKeyForm,	const AEDesc	*inKeyData,	AEDesc*			outToken,	long			inRefCon){	OSErr	err = noErr;		Try_ {		sModelDirector->AccessModelPropertyList(inDesiredClass,									*inContainerToken, inContainerClass,									inKeyForm, *inKeyData,									*outToken, inRefCon);	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}pascal OSErrLModelDirector::OSLDisposeToken(	AEDesc		*inToken){	OSErr	err = noErr;		Try_ {		sModelDirector->DisposeToken(*inToken);	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}pascal OSErrLModelDirector::OSLCompareObjects(	DescType		inComparisonOperator,	const AEDesc	&inBaseObject,	const AEDesc	&inCompareObjectOrDesc,	Boolean			&outResult){	OSErr	err = noErr;		Try_ {		sModelDirector->CompareObjects(inComparisonOperator, inBaseObject,									inCompareObjectOrDesc, outResult);	}			Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}pascal OSErrLModelDirector::OSLCountObjects(	DescType		inDesiredClass,	DescType		inContainerClass,	const AEDesc	&inContainer,	Int32			&outCount){	OSErr	err = noErr;		Try_ {		sModelDirector->CountObjects(inDesiredClass, inContainerClass,									inContainer, outCount);	}		Catch_(inErr) {		err = inErr;	} EndCatch_		return err;}