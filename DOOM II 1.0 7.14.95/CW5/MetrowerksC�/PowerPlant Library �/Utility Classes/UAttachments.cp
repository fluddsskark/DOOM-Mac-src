// ===========================================================================//	UAttachments.cp					©1994 Metrowerks Inc. All rights reserved.// ===========================================================================////	An assortment of Attachment classes#include <UAttachments.h>#include <UDrawingState.h>#include <PP_KeyCodes.h>#include <LView.h>// ===========================================================================// ¥ LCommanderPane											  LCommanderPane ¥// ===========================================================================//	A subclass of LCommander and LPane////	An object of this class would do nothing by itself, but is a powerful//	concept when combined with Attachments which control all drawing,//	printing, clicking, and command handling.LCommanderPane*LCommanderPane::CreateCommanderPaneStream(	LStream	*inStream){	return (new LCommanderPane(inStream));}LCommanderPane::LCommanderPane(	SPaneInfo	&inPaneInfo,	LCommander	*inSuper)		: LCommander(inSuper),		  LPane(inPaneInfo){}LCommanderPane::LCommanderPane(	LStream	*inStream)		: LPane(inStream){}// ===========================================================================// ¥ LBeepAttachment										 LBeepAttachment ¥// ===========================================================================//	Beeps when executed//		Suitable for use with any messageLBeepAttachment::LBeepAttachment(	MessageT	inMessage,	Boolean		inExecuteHost)		: LAttachment(inMessage, inExecuteHost){}voidLBeepAttachment::ExecuteSelf(	MessageT	inMessage,	void		*ioParam){	SysBeep(1);}// ===========================================================================// ¥ LEraseAttachment										LEraseAttachment ¥// ===========================================================================//	Erases the Frame of a Pane//		For use only with msg_DrawOrPrintLEraseAttachment::LEraseAttachment(	Boolean	inExecuteHost)		: LAttachment(msg_DrawOrPrint, inExecuteHost){}voidLEraseAttachment::ExecuteSelf(	MessageT	inMessage,	void		*ioParam){	::EraseRect((Rect*) ioParam);}// ===========================================================================// ¥ LBorderAttachment									   LBorderAttachment ¥// ===========================================================================//	Draws a border within the Frame of a Pane//		For use only with msg_DrawOrPrintLBorderAttachment::LBorderAttachment(	PenState	*inPenState,	RGBColor	*inForeColor,	RGBColor	*inBackColor,	Boolean		inExecuteHost)		: LAttachment(msg_DrawOrPrint, inExecuteHost){	mPenState = *inPenState;		if (inForeColor == nil) {		// Default to black foreground		mForeColor.red = 0;		mForeColor.green = 0;		mForeColor.blue = 0;	} else {		mForeColor = *inForeColor;	}		if (inBackColor == nil) {		// Default to white background		mBackColor.red = 65535;		mBackColor.green = 65535;		mBackColor.blue = 65535;	} else {		mBackColor = *inBackColor;	}}voidLBorderAttachment::ExecuteSelf(	MessageT	inMessage,	void		*ioParam){	StColorPenState	savePenState;		// Will save and restore pen state		::SetPenState(&mPenState);	::RGBForeColor(&mForeColor);	::RGBBackColor(&mBackColor);	::FrameRect((Rect*) ioParam);}// ===========================================================================// ¥ LPaintAttachment										LPaintAttachment ¥// ===========================================================================//	Paints a rectangle within the Frame of a Pane//		For use only with msg_DrawOrPrint////	The rectangle is painted using the specified PenState settings and//	foreground and background colors. The painted rectangle is inset from//	the Frame by the size of the pnSize field of the PenState. This lets//	you use an LPaintAttachment in conjuction with a LBorderAttachment//	to draw a filled rectangle.LPaintAttachment::LPaintAttachment(	PenState	*inPenState,	RGBColor	*inForeColor,	RGBColor	*inBackColor,	Boolean		inExecuteHost)		: LAttachment(msg_DrawOrPrint, inExecuteHost){	mPenState = *inPenState;		if (inForeColor == nil) {		// Default to black foreground		mForeColor.red = 0;		mForeColor.green = 0;		mForeColor.blue = 0;	} else {		mForeColor = *inForeColor;	}		if (inBackColor == nil) {		// Default to white background		mBackColor.red = 65535;		mBackColor.green = 65535;		mBackColor.blue = 65535;	} else {		mBackColor = *inBackColor;	}}voidLPaintAttachment::ExecuteSelf(	MessageT	inMessage,	void		*ioParam){	StColorPenState	savePenState;		// Will save and restore pen state		::SetPenState(&mPenState);	::RGBForeColor(&mForeColor);	::RGBBackColor(&mBackColor);		Rect	r = *(Rect*) ioParam;	::InsetRect(&r, mPenState.pnSize.h, mPenState.pnSize.v);	::PaintRect(&r);}// ===========================================================================// ¥ LCmdEnablerAttachment							   LCmdEnablerAttachment ¥// ===========================================================================//	Enables a particular menu command//		For use only with msg_CommandStatusLCmdEnablerAttachment::LCmdEnablerAttachment(	CommandT	inCmdToEnable)		: LAttachment(msg_CommandStatus){	mCmdToEnable = inCmdToEnable;}voidLCmdEnablerAttachment::ExecuteSelf(	MessageT	inMessage,	void		*ioParam){	mExecuteHost = true;	if (((SCommandStatusP) ioParam)->command == mCmdToEnable) {									// This is our command, enable it		*((SCommandStatusP) ioParam)->enabled = true;		mExecuteHost = false;		// We have enabled the command, so don't									//   bother to ask the host	}}// ===========================================================================// ¥ LKeyScrollAttachment								LKeyScrollAttachment ¥// ===========================================================================//	Handles scrolling a View using keyboard navigation keys://		Home, End, PageUp, PageDown////		For use only with msg_KeyPress////	If you have a View that is also a Commander, you can attach a//	LKeyScrollAttachment to it to implement keyboard navigation.////	If your View is not a Commander, but you still want to implement//	keyboard navigation, you can attach a LKeyScrollAttachment to//	a SuperView that is a Commander (such as the Window containing//	the View). However, if you can delete the View independent of//	the Window, you must take care to delete the Attachment.LKeyScrollAttachment::LKeyScrollAttachment(	LView	*inViewToScroll)		: LAttachment(msg_KeyPress){	mViewToScroll = inViewToScroll;}voidLKeyScrollAttachment::ExecuteSelf(	MessageT	inMessage,	void		*ioParam){	mExecuteHost = false;		// We handle navigation keys	Int16	theKey = ((EventRecord*) ioParam)->message & charCodeMask;		switch (theKey) {			case char_Home:			// Scroll to top left			mViewToScroll->ScrollImageTo(0, 0, true);			break;					case char_End: {		// Scroll to bottom right			SDimension16	frameSize;			SDimension32	imageSize;			mViewToScroll->GetFrameSize(frameSize);			mViewToScroll->GetImageSize(imageSize);			mViewToScroll->ScrollImageTo(imageSize.width - frameSize.width,										imageSize.height - frameSize.height,										true);			break;		}					case char_PageUp: {		// Scroll up by height of Frame,								//   but not past top of Image			SPoint32		frameLoc;			SPoint32		imageLoc;			mViewToScroll->GetFrameLocation(frameLoc);			mViewToScroll->GetImageLocation(imageLoc);						Int32	upMax = frameLoc.v - imageLoc.v;			if (upMax > 0) {				SPoint32		scrollUnit;				SDimension16	frameSize;				mViewToScroll->GetScrollUnit(scrollUnit);				mViewToScroll->GetFrameSize(frameSize);				Int32	up = (frameSize.height - 1) / scrollUnit.v;				if (up <= 0) {					up = 1;				}				up *= scrollUnit.v;				if (up > upMax) {					up = upMax;				}				mViewToScroll->ScrollImageBy(0, -up, true);			}			break;		}					case char_PageDown: {	// Scroll down by height of Frame,								//   but not past bottom of Image			SPoint32		frameLoc;			SPoint32		imageLoc;			SDimension16	frameSize;			SDimension32	imageSize;			mViewToScroll->GetFrameLocation(frameLoc);			mViewToScroll->GetImageLocation(imageLoc);			mViewToScroll->GetFrameSize(frameSize);			mViewToScroll->GetImageSize(imageSize);						Int32	downMax = imageSize.height - frameSize.height -								(frameLoc.v - imageLoc.v);			if (downMax > 0) {				SPoint32		scrollUnit;				mViewToScroll->GetScrollUnit(scrollUnit);				Int32	down = (frameSize.height - 1) / scrollUnit.v;				if (down <= 0) {					down = 1;				}				down *= scrollUnit.v;				if (down > downMax) {					down = downMax;				}				mViewToScroll->ScrollImageBy(0, down, true);			}			break;		}					default:			mExecuteHost = true;	// Some other key, let host respond			break;	}}