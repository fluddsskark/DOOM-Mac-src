// ===========================================================================//	UException.h					©1994 Metrowerks Inc. All rights reserved.// ===========================================================================////	Exception Handling////		This unit implements an exception handling mechanism that is similar//		to "real" C++ Exceptions. Our Exceptions are untyped, and there//		must be one and only one Catch block for each Try block.////	Try/Catch Syntax:////		Try_ {//			// Do something which may fail.//			// Call Throw() to signal failure and force jump//			// to the following Catch block.//		}////		Catch_(inErr) {//			// Recover or cleanup after a failure in the above Try block.//			// "inErr" is an ExceptionCode identifying the reason//			// for the failure.//			//			// You may call Throw() if you want to jump out to//			// the next Catch block.////			// The code in this Catch block does not execute if//			// the above Try block completes without a Throw.////		} EndCatch_////		You must structure your code exactly as above. You can't have a//		Try_ { } without a Catch_ { } EndCatch_, or vice versa.//////	Throw_////		To signal failure, call Throw_() from within a Try block. The//		Throw can occur anywhere in the Try block, even within functions//		called from the Try block. A Throw_() will jump execution to the//		start of the nearest Catch block, even across function calls.//		Destructors for stack-based objects which go out of scope as//		a result of the Throw() are called.////		For convenience, several macros are defined which call Throw()//		for the most common kinds of failures.////		You can call Throw_() from within a Catch block to "rethrow"//		the exception to the next nearest Catch block.//////	Exception Codes////		An ExceptionCode is a 32-bit number. You will normally use//		Toolbox error codes, which are 16-bit numbers. This allows//		plently of room for defining codes for your own kinds of errors.//////	Limitations////		Throwing an exception from within the Constructor of a//		stack-based object will result in the Destrutor being called//		for that object. The Destructor called will be the one for//		the fully constructed object, even if the object was only//		partially constructed (i.e., the Throw occurred within a//		base class Constructor).////		Try/Catch and Throw are based on setjmp/longjmp. At the//		beginning of a Try block, setjmp saves the machine registers.//		Throw calls longjmp, which restores the registers and jumps//		to the beginning of the Catch block. Therefore, any changes//		in the Try block to variables stored in registers will not//		be retained when entering the Catch block. ////		The solution is to declare variables that you want to use//		in both the Try and Catch blocks as "volatile". For example:////		volatile long	x = 1;		// Declare volatile local variable//		Try_ {//			x = 100;				// Set local variable in Try//			Throw_(-1);//		}////		Catch_(inErr) {//			if (x > 1) {			// Use local variable in Catch	//				SysBeep(1);//			}//		} EndCatch_////	Usage Notes:////		If you #define Debug_Throw, you can enable debugging options//		for monitoring throws. See the file "UDebugging.h" for details.#pragma once#include <setjmp.h>#ifdef Debug_Throw#include <UDebugging.h>#else#define	Throw_(err)		Throw(err)#endif	// Exception codestypedef long	ExceptionCode;enum {	err_NilPointer		= 'nilP',	err_AssertFailed	= 'asrt'};		// Exception Handler class	//	A UException object is created for each Try_ & Catch_ block.	//	At any point in the program, there is a linked list of	//	UException objects. UException::sFirstHandle points to the	//	most recently entered block. A UException blocks stores	//	information about the state of the machine (register values)	//	at the start of the Try_ block and points to a list of	//	Destructors that need to be called in the event of a Throw.class	UException {public:	UException			*mNextHandler;		// Next Exception handler	jmp_buf				mSaveBuffer;		// setjmp/longjmp storage	ExceptionCode		mError;				// Error code		static UException	*sFirstHandler;		// Nearest  Exception handler};	// Try & Catch macros#define	Try_														\	{																\		UException	_TryObject;										\		_TryObject.mError = 0;										\		_TryObject.mNextHandler = UException::sFirstHandler;		\		UException::sFirstHandler = &_TryObject;					\		if (setjmp(_TryObject.mSaveBuffer) == 0) {		#define	Catch_(err)													\			UException::sFirstHandler = _TryObject.mNextHandler;	\		} else {													\			ExceptionCode	err = _TryObject.mError;				\			UException::sFirstHandler = _TryObject.mNextHandler;						#define	EndCatch_													\		}															\	}	// Function Prototypesvoid	Throw(ExceptionCode inError);	// Useful macros for signaling common failures				// This macro avoids evaluating "err" twice by assigning		// its value to a local variable.	#define ThrowIfOSErr_(err)											\	do {															\		OSErr	theErr = err;										\		if (theErr != 0) {											\			Throw_(theErr);											\		}															\	} while (false)#define ThrowOSErr_(err)	Throw_(err)#define	ThrowIfNil_(ptr)	if ((ptr) == NULL) Throw_(err_NilPointer)#define	ThrowIfNULL_(ptr)	if ((ptr) == NULL) Throw_(err_NilPointer)#define	ThrowIfResError_()	ThrowIfOSErr_(ResError())#define	ThrowIfMemError_()	ThrowIfOSErr_(MemError())#define	ThrowIfResFail_(h)	if ((h) == NULL) Throw_( ResError() == noErr ?	\								resNotFound : ResError())#define	ThrowIfMemFail_(p)	if ((p) == NULL) Throw_(MemError())#define	ThrowIf_(test)		if (test) Throw_(err_AssertFailed)#define	ThrowIfNot_(test)	if (!(test)) Throw_(err_AssertFailed)#define	FailOSErr_(err)		ThrowIfOSErr_(err)#define FailNIL_(ptr)		ThrowIfNil_(ptr)