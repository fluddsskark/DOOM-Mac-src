// ===========================================================================//	UKeyFilters.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <UKeyFilters.h>#include <PP_KeyCodes.h>#ifndef __SCRIPT__#include <Script.h>#endif// ---------------------------------------------------------------------------//		¥ IntegerField// ---------------------------------------------------------------------------//	Key Filter for Integer characters////		> Identify delete and cursor keys//		> Accept numbers (0 to 9)//		> Reject all other printing characters//		> PassUp all other charactersEKeyStatusUKeyFilters::IntegerField(	const EventRecord	&inKeyEvent){	EKeyStatus	theKeyStatus = keyStatus_PassUp;	Char16		theKey = inKeyEvent.message;	Char16		theChar = theKey & charCodeMask;		if (IsTEDeleteKey(theKey)) {		theKeyStatus = keyStatus_TEDelete;	} else if (IsTECursorKey(theKey)) {		theKeyStatus = keyStatus_TECursor;	} else if (IsExtraEditKey(theKey)) {		theKeyStatus = keyStatus_ExtraEdit;	} else if (IsPrintingChar(theChar)) {		if (IsNumberChar(theChar)) {			theKeyStatus = keyStatus_Input;		} else {			theKeyStatus = keyStatus_Reject;		}	}		return theKeyStatus;}// ---------------------------------------------------------------------------//		¥ AlphaNumericField// ---------------------------------------------------------------------------//	Key Filter for AlphaNumeric characters////		> Identify delete and cursor keys//		> Accept numbers (0 to 9) and letters (a to z, and A to Z)//		> Reject all other printing characters//		> PassUp all other charactersEKeyStatusUKeyFilters::AlphaNumericField(	const EventRecord	&inKeyEvent){	EKeyStatus	theKeyStatus = keyStatus_PassUp;	Char16		theKey = inKeyEvent.message;	Char16		theChar = theKey & charCodeMask;		if (IsTEDeleteKey(theKey)) {		theKeyStatus = keyStatus_TEDelete;	} else if (IsTECursorKey(theKey)) {		theKeyStatus = keyStatus_TECursor;	} else if (IsExtraEditKey(theKey)) {		theKeyStatus = keyStatus_ExtraEdit;	} else if (IsPrintingChar(theChar)) {		if (IsNumberChar(theChar)  ||  IsLetterChar(theChar)) {			theKeyStatus = keyStatus_Input;		} else {			theKeyStatus = keyStatus_Reject;		}	}		return theKeyStatus;}// ---------------------------------------------------------------------------//		¥ PrintingCharField// ---------------------------------------------------------------------------//	Key Filter for Printing characters////		> Identify delete and cursor keys//		> Accept printing character//		> PassUp all other charactersEKeyStatusUKeyFilters::PrintingCharField(	const EventRecord	&inKeyEvent){	EKeyStatus	theKeyStatus = keyStatus_PassUp;	Char16		theKey = inKeyEvent.message;	Char16		theChar = theKey & charCodeMask;		if (IsTEDeleteKey(theKey)) {		theKeyStatus = keyStatus_TEDelete;	} else if (IsTECursorKey(theKey)) {		theKeyStatus = keyStatus_TECursor;	} else if (IsExtraEditKey(theKey)) {		theKeyStatus = keyStatus_ExtraEdit;	} else if (IsPrintingChar(theChar)) {		theKeyStatus = keyStatus_Input;	}		return theKeyStatus;}BooleanUKeyFilters::IsTEDeleteKey(	Char16	inKey){	return ((inKey & charCodeMask) == char_Backspace);}BooleanUKeyFilters::IsTECursorKey(	Char16	inKey){	Boolean	isCursor = false;	switch (inKey & charCodeMask) {			case char_LeftArrow:		case char_RightArrow:		case char_UpArrow:		case char_DownArrow:			isCursor = true;			break;	}		return isCursor;}BooleanUKeyFilters::IsExtraEditKey(	Char16	inKey){	Boolean	isExtraEdit = false;		switch (inKey & charCodeMask) {			case char_Home:		case char_End:		case char_PageUp:		case char_PageDown:		case char_FwdDelete:			isExtraEdit = true;			break;					case char_Clear:			isExtraEdit = (inKey & keyCodeMask) == vkey_Clear;			break;	}		return isExtraEdit;}BooleanUKeyFilters::IsNavigationKey(	Char16	inKey){	Boolean	isNavigation = false;		switch (inKey & charCodeMask) {			case char_LeftArrow:		case char_RightArrow:		case char_UpArrow:		case char_DownArrow:		case char_Home:		case char_End:		case char_PageUp:		case char_PageDown:			isNavigation = true;			break;	}		return isNavigation;}BooleanUKeyFilters::IsActionKey(	Char16	inKey){	Boolean	isAction = false;		switch (inKey & charCodeMask) {				case char_Enter:		case char_Tab:		case char_Return:			isAction = true;			break;					case char_Escape:			isAction = (inKey & keyCodeMask) == vkey_Escape;			break;	}		return isAction;}BooleanUKeyFilters::IsNonprintingChar(	Char16	inChar){	return (inChar < char_FirstPrinting) ||		   (inChar == char_FwdDelete);}BooleanUKeyFilters::IsPrintingChar(	Char16	inChar){	return (inChar >= char_FirstPrinting) &&		   (inChar != char_FwdDelete);}BooleanUKeyFilters::IsNumberChar(	Char16	inChar){	return (inChar >= '0') && (inChar <= '9');}BooleanUKeyFilters::IsLetterChar(	Char16	inChar){	return ((inChar >= 'a') && (inChar <= 'z'))  ||	// lower case		   ((inChar >= 'A') && (inChar <= 'Z'));	// upper case}// ---------------------------------------------------------------------------//		¥ IsCmdPeriod// ---------------------------------------------------------------------------//	Return whether a keystroke event is a command-period////	This routine supports international keyboards by using a//	combination of the techniques described in TechNote Text-23//	and IM:Text page C-24.BooleanUKeyFilters::IsCmdPeriod(	const EventRecord	&inKeyEvent){	Boolean	cmdPeriod = false;		if (inKeyEvent.modifiers & cmdKey) {	// Command key is down				// Extract raw key code, which is the key code from			// the EventRecord with the cmdKey bit masked out		Int32	virtualKey = (inKeyEvent.message & keyCodeMask) >> 8;		Int16	keyCode = (inKeyEvent.message & 0xFE00) | virtualKey;					// Get current KCHR resource from the Script Manager		Ptr		theKCHR = (Ptr) ::GetScriptManagerVariable(smKCHRCache);		Int32	state = 0;					// Lookup raw key code in the KCHR		Int32	keyInfo = ::KeyTranslate(theKCHR, keyCode, &state);					// Character can be in either the first or secord byte		Int32	char1 = keyInfo & 0x000000FF;			// Bits 0 to 7		Int32	char2 = (keyInfo & 0x0000FF00) >> 16;	// Bits 8 to 15			cmdPeriod = (char1 == char_Period) || (char2 == char_Period);	}		return cmdPeriod;}