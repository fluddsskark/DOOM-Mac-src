// ===========================================================================//	UWindows.cp				 		©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	Window utility functions#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <UWindows.h>#include <UDrawingUtils.h>#ifndef __WINDOWS__#include <Windows.h>#endif#ifndef __LOWMEM__#include <LowMem.h>#endif#ifndef __TEXTUTILS__#include <TextUtils.h>#endif// ---------------------------------------------------------------------------//		¥ GetWindowContentRect// ---------------------------------------------------------------------------//	Return the bounding rectangle of the content region of the specified//	Toolbox windowRectUWindows::GetWindowContentRect(	WindowPtr	inWindowP){	Rect	contentRect = {0, 0, 0, 0};	if (inWindowP != nil) {		if (((WindowPeek) inWindowP)->visible) {									// For visible windows, the bounding									//   box the content region is correct			contentRect = ((**((WindowPeek) inWindowP)->contRgn)).rgnBBox;					} else {					// For invisible windows, the content									//   region is not valid. Instead, get			GrafPtr	savePort;		//   the port rectangle and convert			GetPort(&savePort);		//   to global coordinates			SetPort(inWindowP);			contentRect = inWindowP->portRect;			::LocalToGlobal(&topLeft(contentRect));			::LocalToGlobal(&botRight(contentRect));			SetPort(savePort);		}	}		return contentRect;}// ---------------------------------------------------------------------------//		¥ GetWindowStructureRect// ---------------------------------------------------------------------------//	Return the bounding rectangle of the structure region of the specified//	Toolbox windowRectUWindows::GetWindowStructureRect(	WindowPtr	inWindowP){	const Int16 coord_Offscreen = 0x4000;	Rect	structureRect = {0, 0, 0, 0};	if (inWindowP != nil) {		if (((WindowPeek) inWindowP)->visible) {									// For visible windows, the bounding									//   box the structure region is correct			structureRect = ((**((WindowPeek) inWindowP)->strucRgn)).rgnBBox;					} else {					// For invisible windows, the structure									//   region is not valid. We have to									//   move the window offscreen, show it,									//   copy bounds of structure region,									//   hide it, and then move it back			GrafPtr	savePort;			GetPort(&savePort);			SetPort(inWindowP);		// Get current position in global coords			Point	savePosition = topLeft(inWindowP->portRect);			::LocalToGlobal(&savePosition);			SetPort(savePort);						MoveWindow(inWindowP, coord_Offscreen, coord_Offscreen, false);			ShowHide(inWindowP, true);						structureRect = ((**((WindowPeek) inWindowP)->strucRgn)).rgnBBox;			OffsetRect(&structureRect, savePosition.h - coord_Offscreen,									   savePosition.v - coord_Offscreen);						ShowHide(inWindowP, false);			MoveWindow(inWindowP, savePosition.h, savePosition.v, false);		}	}		return structureRect;}// ---------------------------------------------------------------------------//		¥ FindDominantDevice// ---------------------------------------------------------------------------//	Return the GDevice which contains the largest portion of the//	specified rectangleGDHandleUWindows::FindDominantDevice(	const Rect	&inGlobalRect){	GDHandle	dominantDevice = nil;										// Loop thru all GDevices to find the									//   one which the greatest intersection									//   area with inGlobalRect		GDHandle	theDevice = GetDeviceList();	Int32		greatestArea = 0;		while (theDevice != nil) {		if (UDrawingUtils::IsActiveScreenDevice(theDevice)) {			Rect	intersection;									// Find intersection of Window with									//   this active screen Device			if (SectRect(&inGlobalRect, &(**theDevice).gdRect,						 &intersection)) {									// Window intersects this Device									// Calculate area of intersection				Int32	sectArea = (intersection.right - intersection.left) *						   (Int32) (intersection.bottom - intersection.top);				if (sectArea > greatestArea) {									// Intersection is greater than previous									//    maximum					greatestArea = sectArea;					dominantDevice = theDevice;				}			}		}		theDevice = GetNextDevice(theDevice);	}		return dominantDevice;}// ---------------------------------------------------------------------------//		¥ FindNthWindow// ---------------------------------------------------------------------------//	Return a WindowPtr to the Nth Window////	Windows are ordered from front to back//		For positive indexes, 1 is the front window, 2 is the second, etc.//		For negative indexes, -1 is the last window, -2 next to last, etc.//	If Abs(N) > number of windows or N = 0, return nilWindowPtrUWindows::FindNthWindow(	Int16	inN){	WindowPeek	theWindowP = nil;	Int16		wIndex = inN;		if (wIndex < 0) {				// Negative index counts from end		Int16	windowCount = 0;	// Count how many windows there are		theWindowP = (WindowPeek) LMGetWindowList();		while (theWindowP) {			windowCount++;			theWindowP = theWindowP->nextWindow;		}							// Compute positive index		wIndex = windowCount + wIndex + 1;	}		if (wIndex > 0) {				// Count down into linked list		theWindowP = (WindowPeek) LMGetWindowList();		while (--wIndex  && theWindowP) {			theWindowP = theWindowP->nextWindow;		}	}			return (WindowPtr) theWindowP;}// ---------------------------------------------------------------------------//		¥ FindWindowIndex// ---------------------------------------------------------------------------//	Return index position of a Window////	Windows are ordered from front to back, with #1 being the front window.//	If inWindowP is not found, returns 0;Int16UWindows::FindWindowIndex(	WindowPtr	inWindowP){	Int16		index = 1;	WindowPeek	currWindowP = (WindowPeek) LMGetWindowList();		while (currWindowP && (currWindowP != (WindowPeek) inWindowP)) {		index++;		currWindowP = currWindowP->nextWindow;	}		if (currWindowP == nil) {		index = 0;	}		return index;}// ---------------------------------------------------------------------------//		¥ FindNamedWindow// ---------------------------------------------------------------------------//	Return a WindowPtr to the Window with the specified name////	Searches from front to back for the first window with the specified//	name. Returns nil if no match found.WindowPtrUWindows::FindNamedWindow(	Str255	inName){	WindowPeek	theWindowP = (WindowPeek) LMGetWindowList();		while (theWindowP) {		Str255	windowName;		::GetWTitle((WindowPtr) theWindowP, windowName);		if (::IUEqualString(inName, windowName) == 0) {			break;		}		theWindowP = theWindowP->nextWindow;	}		return (WindowPtr) theWindowP;}