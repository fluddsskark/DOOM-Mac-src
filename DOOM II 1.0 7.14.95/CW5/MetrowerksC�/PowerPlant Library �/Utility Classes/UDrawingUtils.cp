// ===========================================================================//	UDrawingUtils.cp				©1993 Metrowerks Inc. All rights reserved.// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <UDrawingUtils.h>#ifndef __EVENTS__#include <Events.h>#endif#ifndef __GESTALTEQU#include <GestaltEqu.h>#endif// ===========================================================================// ¥ UDrawingUtils											   UDrawingUtils ¥// ===========================================================================// ---------------------------------------------------------------------------//		¥ IsColorGrafPort// ---------------------------------------------------------------------------//	Return whether a Toolbox GrafPort supports colorBooleanUDrawingUtils::IsColorGrafPort(	GrafPtr	inMacPortP){								// Highest 2 bits of rowBytes are								//   set for a Color GrafPort	return ((inMacPortP->portBits.rowBytes & 0xC000) == 0xC000);}// ---------------------------------------------------------------------------//		¥ IsActiveScreenDevice// ---------------------------------------------------------------------------//	Return whether a GDevice represents an active screenBooleanUDrawingUtils::IsActiveScreenDevice(	GDHandle	inDevice){	return (::TestDeviceAttribute(inDevice, screenDevice) &&			::TestDeviceAttribute(inDevice, screenActive));}// ===========================================================================// ¥ StDeviceLoop												StDeviceLoop ¥// ===========================================================================//	Class for coordinating drawing in an area which may span multiple//	devices (monitors) with different bit depths.////	How to use://		You will usually create an StDeviceLoop on the stack inside//		the DrawSelf() function of a Pane. However, the implementation//		is not dependent on PowerPlant Panes, so you can use this class//		with any drawing code. This class works with both color and//		old (black and white) QuickDraw.////		The constructor takes a Rect in the local coordinates of the//		current port.////		The NextDepth(Int16 depth) function passes back the depth of the//		next device and returns true. After reaching the last device,//		the depth is zero and the function returns false. You would normally//		call NextDepth() as the condition in a "while" loop.////		When NextDepth() returns with a valid depth, it has already set//		the clipping region to the intersection of the specified Rect, the//		current device, and the original clipping region. Therefore, you can//		just draw "everything" and rely on the clipping region to properly//		restrict the drawing. If you need access to the current device,//		you can call the GetCurrentDevice() member function.////		The destructor restores the clipping region to what it was when//		the constructor was called.////	Example:////		The body of a DrawSelf() function would look something like this:////		Rect	frame;//		if (CalcLocalFrameRect(frame)) {//			StDeviceLoop	theLoop(frame);//			Int16			depth;//			while (theLoop.NextDepth(depth)) {//				switch (depth) {////					case 1:		// Black & white//						break;////					case 4:		// 16 colors//						break;////					case 8:		// 256 colors//						break;////					case 16:	// Thousands of colors//						break;////					case 32:	// Millions of colors//						break;//				}//			}//		}////		You would add the appropriate drawing code to each depth case.StDeviceLoop::StDeviceLoop(	const Rect	&inLocalRect){	mGlobalRect = inLocalRect;			// Convert to Global coords	::LocalToGlobal(&topLeft(mGlobalRect));	::LocalToGlobal(&botRight(mGlobalRect));		mCurrentDevice = nil;		mSaveClip = ::NewRgn();				// Save clipping region	if (mSaveClip != nil) {		::GetClip(mSaveClip);	}											// Check if machine has ColorQD	Int32		qdVersion = gestaltOriginalQD;	Gestalt(gestaltQuickdrawVersion, &qdVersion);	mHasOldQD = (qdVersion == gestaltOriginalQD);	mOldQDPending = true;}StDeviceLoop::~StDeviceLoop(){	if (mSaveClip != nil) {				// Restore clipping region		::SetClip(mSaveClip);		::DisposeRgn(mSaveClip);	}}BooleanStDeviceLoop::NextDepth(	Int16	&outDepth){	outDepth = 0;		if (mHasOldQD) {					// No ColorQD, so there can only		if (mOldQDPending) {			//   be 1-bit pixel depth			Rect	localRect = mGlobalRect;			::GlobalToLocal(&topLeft(localRect));			::GlobalToLocal(&botRight(localRect));			::ClipRect(&localRect);			outDepth = 1;			mOldQDPending = false;			return true;		}		return false;	}										// ColorQD present. Walk DeviceList.	if (mCurrentDevice == nil) {		mCurrentDevice = ::GetDeviceList();	} else {		mCurrentDevice = ::GetNextDevice(mCurrentDevice);	}		while (mCurrentDevice != nil) {				// Find active screen device that intersects our			// target rectangle			if (UDrawingUtils::IsActiveScreenDevice(mCurrentDevice)) {			Rect	deviceRect = (**mCurrentDevice).gdRect;			Rect	intersection;						if (::SectRect(&mGlobalRect, &deviceRect, &intersection)) {								// Set clipping region to the intersection of the target					// rectangle, the screen rectangle, and the original					// clipping region				::GlobalToLocal(&topLeft(intersection));				::GlobalToLocal(&botRight(intersection));				ClipToIntersection(intersection);				outDepth = (**((**mCurrentDevice).gdPMap)).pixelSize;				break;				// Exit device loop			}		}				mCurrentDevice = ::GetNextDevice(mCurrentDevice);	}		return (mCurrentDevice != nil);}GDHandleStDeviceLoop::GetCurrentDevice(){	return mCurrentDevice;}voidStDeviceLoop::ClipToIntersection(	const Rect	&inLocalRect){	if (mSaveClip != nil) {		RgnHandle	overlap = ::NewRgn();		if (overlap != nil) {			::RectRgn(overlap, &inLocalRect);			::SectRgn(mSaveClip, overlap, overlap);			::SetClip(overlap);			::DisposeRgn(overlap);		}	}}// ===========================================================================// ¥ UMarchingAnts											   UMarchingAnts ¥// ===========================================================================//	Utility functions for drawing marching ants, which is typically used//	for an animated selection marquee.Pattern	UMarchingAnts::sAntsPattern = {0xF8, 0xF1, 0xE3, 0xC7,								  	   0x8F, 0x1F, 0x3E, 0x7C};Int32	UMarchingAnts::sNextAntMarchTime = 0;const Int16		interval_AntMarch = 3;BooleanUMarchingAnts::BeginMarch(){	Boolean	marching = (TickCount() >= sNextAntMarchTime);		if (marching) {		UseAntsPattern();	}		return marching;		}voidUMarchingAnts::EndMarch(){	sNextAntMarchTime = TickCount() + interval_AntMarch;		unsigned char	lastRow = sAntsPattern.pat[7];	for (Int16 i = 7; i > 0; i--) {		sAntsPattern.pat[i] = sAntsPattern.pat[i - 1];	}	sAntsPattern.pat[0] = lastRow;}voidUMarchingAnts::UseAntsPattern(){	::PenNormal();	::PenPat(&sAntsPattern);}