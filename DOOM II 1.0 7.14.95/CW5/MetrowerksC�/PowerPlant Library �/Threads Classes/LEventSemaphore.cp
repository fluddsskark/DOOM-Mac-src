// ===========================================================================//	LEventSemaphore.cp				©1994 Metrowerks Inc. All rights reserved.////									Author:  Paul Lalonde// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif// standard headers#include <limits.h>// PowerPlant headers#include <LEventSemaphore.h>#include <LThread.h>#include <UException.h>#include <UThread.h>// ---------------------------------------------------------------------------//		¥ LEventSemaphore// ---------------------------------------------------------------------------//	Constructor.////	If posted is true, the semaphore is marked as being in the posted //	state, and any calls to Wait() will return immediately.LEventSemaphore::LEventSemaphore(Boolean posted) 	// call base class's constructor	: LSemaphore(0) {	mPostCount = 0;		if (posted)	{		mExcessSignals = LONG_MAX;		++mPostCount;	}}// ---------------------------------------------------------------------------//		¥ Signal// ---------------------------------------------------------------------------//	Make the semaphore available to all threads.  This includes all //	blocked threads, as well as those that will call Wait() before //	the next call to Reset().void	LEventSemaphore::Signal(void){	{		StCritical	critical;	// disable preemption within this block			mExcessSignals = LONG_MAX;		++mPostCount;				// unblock all of our waiting threads "simultaneously"		UnblockAll(noErr);	}		// reschedule	LThread::Yield();}// ---------------------------------------------------------------------------//		¥ Reset// ---------------------------------------------------------------------------//	Make the semaphore unavailable to any thread until the next call //	to Signal().  Returns the number of times that Signal() was called //	since the last call to Reset().  Throws an exception if the semaphore //	is already reset.Uint32	LEventSemaphore::Reset(void){	StCritical	critical;	// disable preemption	Uint32		count;	Int16		err;		if (mExcessSignals > 0)	{		count			= mPostCount;		mPostCount		= 0;		mExcessSignals	= 0;		err				= noErr;	}	else	{		err				= errSemaphoreAlreadyReset;	}		if (err != noErr)		Throw_(err);		return (count);}