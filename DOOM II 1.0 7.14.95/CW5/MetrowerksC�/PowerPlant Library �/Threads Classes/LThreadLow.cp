// ===========================================================================//	CThreadLow.cp					©1994 Metrowerks Inc. All rights reserved.////									Author:  Paul Lalonde// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif// standard headers#include <stdio.h>// system headers#ifndef __GESTALT__#	include <Gestalt.h>#endif#ifndef __PROCESSES__#	include <Processes.h>#endif#ifndef __SEGLOAD__#	include <SegLoad.h>#endif#ifndef __THREADS__#	include <Threads.h>#endif#if GENERATINGCFM && !defined(__CODEFRAGMENTS__)#	include <CodeFragments.h>#endif// compiler-specific headers#include <CPlusLib68K.h>// PowerPlant headers#include <LThread.h>#include <UDebugging.h>#include <UEnvironment.h>#include <UException.h>// turn off profiling in this module#pragma profile off// ===========================================================================//	¥ Constants// ===========================================================================#define	DEBUG_COMPLETION_PROC	0		// set non-zero to break on entry// define debugging macro, if needed#if DEBUG_COMPLETION_PROC#	define BREAK_INTO_DEBUGGER()	BreakToLowLevelDebugger_()#else#	define BREAK_INTO_DEBUGGER()#endif// milliseconds between attempts to wake up a threadconst Int32		kThreadWakeupDelay	= 10;// ===========================================================================//	¥ Local function declarations// ===========================================================================#if THREAD_DEBUGstatic void	DumpOneThread(LThread& thread, void *arg);#endif// ===========================================================================//	Type coercions from OS structures to our structures.  Ugly.// ===========================================================================#if GENERATINGCFMinline	SThreadParamBlk	*GetParmBlkPtr(ParmBlkPtr pbPtr)#elseinline	SThreadParamBlk	*GetParmBlkPtr(ParmBlkPtr pbPtr : __A0) : __A0#endif{	return ((SThreadParamBlk *) (-offsetof(SThreadParamBlk, ioPB) + (char *) pbPtr));}#if GENERATINGCFMinline SThreadTMTask	*GetTimeMgrPtr(TMTaskPtr tmTaskPtr)#elseinline SThreadTMTask	*GetTimeMgrPtr(TMTaskPtr tmTaskPtr : __A1) : __A0#endif{	return ((SThreadTMTask *) (-offsetof(SThreadTMTask, ioTask) + (char *) tmTaskPtr));}// ===========================================================================//	¥ Callbacks and Completion Routines// ===========================================================================// ---------------------------------------------------------------------------//		¥ DoEntry	[static]// ---------------------------------------------------------------------------//	Callback to the Thread Manager.////	This function is called when a thread begins execution.  It simply //	calls the thread's Run() member function.  If Run() returns (either //	normally or through the exception mechanism), the thread object is //	deallocated.pascal void	*LThread::DoEntry(void *arg){	LThread	* volatile	thread	= (LThread *) arg;	void * volatile		result	= NULL;	//	BreakStrToLowLevelDebugger_("\pEntering DoEntry");		Try_	{		// run the thread		result = thread->Run();	}		Catch_(inErr)		// should be catch(...)	{		// all we want is to stop error propagation			} EndCatch_		// destroy thread	thread->DeleteThread(result);		return (result);}// ---------------------------------------------------------------------------//		¥ DoSwapIn	[static]// ---------------------------------------------------------------------------//	Callback to the Thread Manager.//	//	Sets up global variables when a thread is switched in.  It also calls //	the thread's swap function, if it has one.pascal void	LThread::DoSwapIn(ThreadID, void *arg){	LThread	*thread	= (LThread *) arg;	//	BreakStrToLowLevelDebugger_("\pentering DoSwapIn");	#if !GENERATINGCFM	// get access to globals	Int32 savedA5 = SetA5(thread->mTimer.ioGlobals);#endif	#if THREAD_DEBUG && THREAD_PROFILE	// temporarily halt profiling	sProfiling = false;#endif		// call custom swap function	thread->SwapContext(true);	#if THREAD_DEBUG && THREAD_PROFILE	// restore profiling flag	sProfiling = thread->mProfiling;#endif	#if !GENERATINGCFM	// restore globals ptr	SetA5(savedA5);#endif}// ---------------------------------------------------------------------------//		¥ DoSwapOut	[static]// ---------------------------------------------------------------------------//	Callback to the Thread Manager.//	//	Sets up global variables when a thread is switched out.  It also calls //	the thread's swap function, if it has one.pascal void	LThread::DoSwapOut(ThreadID, void *arg){	LThread	*thread	= (LThread *) arg;	//	BreakStrToLowLevelDebugger_("\pentering DoSwapOut");	#if !GENERATINGCFM	// get access to globals	Int32 savedA5 = SetA5(thread->mTimer.ioGlobals);#endif	#if THREAD_DEBUG && THREAD_PROFILE	// save profiling flag	thread->mProfiling = sProfiling;	// temporarily halt profiling	sProfiling = false;#endif		// call custom swap function	thread->SwapContext(false);#if !GENERATINGCFM	// restore globals ptr	SetA5(savedA5);#endif}// ---------------------------------------------------------------------------//		¥ ThreadComplProc	[static]// ---------------------------------------------------------------------------//	I/O completion routine.  Converts the given parameter block into a //	SThreadParamBlk, then resumes the given thread.#if GENERATINGCFMvoid	LThread::ThreadComplProc(ParmBlkPtr pbPtr)#elsevoid	LThread::ThreadComplProc(ParmBlkPtr pbPtr : __A0)#endif{	SThreadParamBlk *tpb = GetParmBlkPtr(pbPtr);		// break if desired	BREAK_INTO_DEBUGGER();	#if !GENERATINGCFM	long savedA5 = SetA5(tpb->ioGlobals);#endif		ThreadAsynchronousResume(tpb->ioThread);	#if !GENERATINGCFM	SetA5(savedA5);#endif}// ---------------------------------------------------------------------------//		¥ ThreadTimerProc	[static]// ---------------------------------------------------------------------------//	Time Manager completion routine.  Converts the given Time Manager task //	into a SThreadTMTask, then resumes the given thread.#if GENERATINGCFMvoid	LThread::ThreadTimerProc(TMTaskPtr tmTaskPtr)#elsevoid	LThread::ThreadTimerProc(TMTaskPtr tmTaskPtr : __A1)#endif{	SThreadTMTask	*tpb = GetTimeMgrPtr(tmTaskPtr);		// break if desired	BREAK_INTO_DEBUGGER();	#if !GENERATINGCFM	long savedA5 = SetA5(tpb->ioGlobals);#endif	ThreadAsynchronousResume(tpb->ioThread);	#if !GENERATINGCFM	SetA5(savedA5);#endif}// ===========================================================================//	¥ Non-static member functions// ===========================================================================// ---------------------------------------------------------------------------//		¥ SwapContext// ---------------------------------------------------------------------------//	Override this function to provide custom thread-swapping behaviorvoid	LThread::SwapContext(Boolean swappingIn){	if (swappingIn)	{		// new current thread		sThread = this;		// restore head of exception handler list		UException::sFirstHandler = mExceptionLink;		// restore head of destructor chain		__local_destructor_chain = mDestructorLink;				// if this thread was in ready state, adjust ready thread count		if (mState == threadState_Ready)			MakeUnready();				// this thread is becoming the current thread		mState = threadState_Current;	}	else	{		// If this thread is in the current state, it means the thread is 		// yielding (ie, going into the ready state).  So we have to adjust 		// the thread's state as well as the ready thread count.				if (mState == threadState_Current)			MakeReady();				// save head of destructor chain		mDestructorLink = __local_destructor_chain;		// save head of exception handler list		mExceptionLink = UException::sFirstHandler;	}}// ---------------------------------------------------------------------------//		¥ DumpAllThreads	[static]// ---------------------------------------------------------------------------//	Prints information about all of the known threads to stdout.#if THREAD_DEBUGvoid	LThread::DumpAllThreads(void){	printf("\n %-3s %-9s %5s %5s  %5s %-10s", 		   "ID ", 		   "State", 		   "Stack", 		   "Used", 		   "Flags", 		   "Wait Sem");		LThread::DoForEach(DumpOneThread, NULL);		printf("\nNumber of ready threads: %ld", (long) CountReadyThreads());	putchar('\n');}#endif	// THREAD_DEBUG#if THREAD_DEBUG// ---------------------------------------------------------------------------//		¥ Dump// ---------------------------------------------------------------------------//	Prints information about the thread to stdout.void	LThread::Dump(void) const{	static char	*states[] = {		"Current",		"Ready",		"Suspended",		"Sleeping",		"Waiting",		"Blocked"	};		printf("\n#%-3lu %-9s %5ld %5ld  %c%c%c%-2c 0x%08.8p", 		   mThread, 		   states[mState], 		   mStackSize, 		   mMaxStack, 		   (this == sMainThread) ? 'M' : ' ', 		   mPreemptive ? 'P' : 'C', 		   mRecycle ? 'R' : ' ', 		   mFPU ? 'F' : ' ', 		   mSemaphore);}// ---------------------------------------------------------------------------//		¥ GetStackSize// ---------------------------------------------------------------------------//	Returns the size of the thread's stack.Uint32	LThread::GetStackSize(void) const		{ return (mStackSize);	}// ---------------------------------------------------------------------------//		¥ GetMaxUsedStack// ---------------------------------------------------------------------------//	Returns the maximum amount of stack space used by the thread.Uint32	LThread::GetMaxUsedStack(void) const	{ return (mMaxStack);	}// ---------------------------------------------------------------------------//		¥ RecordMaxStack// ---------------------------------------------------------------------------//	Calculates the maximum amount of stack space used by the thread, //	and stores it in a member variable.void	LThread::RecordMaxStack(void){	Uint32	freeStack;		freeStack = GetFreeStack();		if (mMaxStack < freeStack - mStackSize)		mMaxStack = freeStack - mStackSize;}#endif // THREAD_DEBUG// ===========================================================================//	¥ Utility functions// ===========================================================================// ---------------------------------------------------------------------------//		¥ SetupAsynchronousResume// ---------------------------------------------------------------------------//	Set up the fields of a standard parameter block (SThreadParamBlk) so //	that the thread may be resumed at interrupt time.void	LThread::SetupAsynchronousResume(	SThreadPBPtr	threadPB, 	IOCompletionUPP	callbackUPP){	if (callbackUPP == NULL)		callbackUPP = sThreadComplUPP;		threadPB->ioThread						= mTimer.ioThread;#if !GENERATINGCFM	threadPB->ioGlobals						= mTimer.ioGlobals;#endif	threadPB->ioPB.F.ioParam.ioCompletion	= callbackUPP;}// ---------------------------------------------------------------------------//		¥ SuspendUntilAsyncResume// ---------------------------------------------------------------------------//	Check the ioResult field of the given standard parameter block //	(SThreadPBPtr);  if it's noErr, suspend the thread.Int16	LThread::SuspendUntilAsyncResume(SThreadPBPtr threadPB, Int16 error){	if (error == noErr)	{		Block();		error = threadPB->ioPB.F.ioParam.ioResult;	}		return (error);}// ---------------------------------------------------------------------------//		¥ SuspendUntilAsyncResume// ---------------------------------------------------------------------------//	Alternate form of I/O blocking.  This function will only block the thread //	if the thread hasn't already completed.  This is useful in calls that //	may complete before returning to their caller;  in that case a context //	switch is avoided.Int16	LThread::SuspendUntilAsyncResume(SThreadPBPtr threadPB){	Int16	error	= threadPB->ioPB.F.ioParam.ioResult;		if (error == 1)	{		Block();		error = threadPB->ioPB.F.ioParam.ioResult;	}	else	{		RemoveTimeTask(mTimer);	}			return (error);}// ---------------------------------------------------------------------------//		¥ ThreadAsynchronousResume	[static]// ---------------------------------------------------------------------------//	Resume a thread at interrupt time.void	LThread::ThreadAsynchronousResume(LThread *thread){	ThreadID	id	= thread->mThread;	ThreadState	state;	Int16		err;		THREAD_ASSERT(sInited == true);	THREAD_ASSERT(thread != NULL);		// get the thread's state	err = ::GetThreadStateGivenTaskRef(sThreadTaskRef, id, &state);		// could we get its state?	if (err == noErr)	{		SThreadTMTask	&timer = thread->mTimer;				// remove any time manager element from its queue		RemoveTimeTask(timer);				// is the thread stopped ?		if (state == kStoppedThreadState)		{			err = ::SetThreadReadyGivenTaskRef(sThreadTaskRef, id);						// wake up this process (so thread can get a chance to run)			::WakeUpProcess(&sPSN);		}		else		{			// add task to timer queue, then prime it			InsertTimeTask(timer);			PrimeTimeTask(timer, kThreadWakeupDelay);		}	}		// Else, there's not much we can do.  Perhaps the thread was killed 	// while an asynchronous I/O operation was pending (ick).}#if THREAD_DEBUG// ---------------------------------------------------------------------------//		¥ ThreadAssert// ---------------------------------------------------------------------------//	Called in response to an assertion failure.  Prints a message in //	the debugger, then quits the application.int		ThreadAssert(char *test, char *file, int line){	extern char	*ThreadStrCat(const char *src, char *dest);		static char	buff[256];	char		*buffp	= buff + 1;	long		base, digit;		buffp = ThreadStrCat("Thread assert: ",	buffp);	buffp = ThreadStrCat(test,				buffp);	buffp = ThreadStrCat(", file ",			buffp);	buffp = ThreadStrCat(file,				buffp);	buffp = ThreadStrCat(", line ",			buffp);		// convert line number	if (line == 0)		*buffp++ = '0';	else	{		for (base = 100000; base >= 1; base /= 10)		{			digit = line / base;			*buffp++ = digit + '0';			line -= digit * base;		}	}		buff[0]	= buffp - buff - 1;		BreakStrToLowLevelDebugger_((StringPtr) buff);		ExitToShell();		return (0);}static char	*ThreadStrCat(const char *src, char *dest){	while (*src != '\0')	{		*dest++ = *src++;	}		return (dest);}#endif // THREAD_DEBUG// ---------------------------------------------------------------------------//		¥ DumpOneThread// ---------------------------------------------------------------------------#if THREAD_DEBUGstatic void	DumpOneThread(LThread& thread, void *){	thread.Dump();}#endif// ===========================================================================//	¥ LThread::ThreadInit// ===========================================================================#if GENERATINGCFM#	define WEAK_IMPORT_TEST(sym)	((sym) != (void *) kUnresolvedSymbolAddress)#else#	define WEAK_IMPORT_TEST(sym)	(true)#endif// ---------------------------------------------------------------------------//		¥ ThreadInit// ---------------------------------------------------------------------------//	Constructor.  Performs low-level initialisation for the Thread Class //	Library (essentially, checking if the Thread Manager is available and //	setting the proper flag in UEnvironment accordingly).LThread::ThreadInit::ThreadInit(void){	Int32	gestaltResult, gestaltMask;		gestaltMask	 = (1 << gestaltThreadMgrPresent);	gestaltMask	|= (1 << gestaltSpecificMatchSupport);	// On PowerMacs, we'll need the native (shared library) 	// version of the Thread Manager.  Also, the check we're 	// about to do will let the user do a "weak import" of 	// the Thread Manager's shared library.#if GENERATINGCFM	gestaltMask	|= (1 << gestaltThreadsLibraryPresent);#endif		// is the Thread Manager running ?	if ((::Gestalt(gestaltThreadMgrAttr, &gestaltResult) == noErr) && 		((gestaltResult & gestaltMask) == gestaltMask) && 		WEAK_IMPORT_TEST(::NewThread))	{		// we're all set!		UEnvironment::SetFeature(env_HasThreadsManager, true);	}}// ---------------------------------------------------------------------------//		¥ ~ThreadInit// ---------------------------------------------------------------------------//	Destructor.  If the Threads Class Library was actually used, this cleans //	up after it.LThread::ThreadInit::~ThreadInit(void){	Try_	{		if (LThread::sInited)			LThread::ExitThreads();	}		Catch_ (inErr)		// should be catch(...)	{		// just prevent the exception from propagating	} EndCatch_}// ===========================================================================//	¥ Profiling                                                    Profiling ¥// ===========================================================================#if THREAD_DEBUG && THREAD_PROFILE			// Profiling code//	¥ Globals ----------------------------------------------------------------// Controls the invocation of the profiler functionBoolean		LThread::sProfiling	= false;// ---------------------------------------------------------------------------//		¥ InitThreadProfiles// ---------------------------------------------------------------------------//	Start collecting profiling information.void	LThread::InitThreadProfiles(void){	SetThreadProfiling(true);}// ---------------------------------------------------------------------------//		¥ DumpThreadProfiles// ---------------------------------------------------------------------------//	Send profiling information to stdout.void	LThread::DumpThreadProfiles(void){	Boolean	savedProfile;		// stop profiling	savedProfile = SetThreadProfiling(false);		// dump thread info	LThread::DumpAllThreads();		// restart profiling	SetThreadProfiling(savedProfile);}// ---------------------------------------------------------------------------//		¥ SetThreadProfiling// ---------------------------------------------------------------------------//	Turn profile gathering on or off.Boolean	LThread::SetThreadProfiling(Boolean newProf){	Boolean	oldProf	= sProfiling;	sProfiling		= newProf;		return (oldProf);}// ---------------------------------------------------------------------------//		¥ ThreadProfiler// ---------------------------------------------------------------------------//	Glue between compiler specific profilers and our profiler.void	LThread::ThreadProfiler(void){	if (LThread::sProfiling)	{		LThread	*thread;				DebugStr("\pAbout to get thread stack info");				LThread::sProfiling	= false;		thread				= LThread::GetCurrentThread();				if (thread != NULL)			thread->RecordMaxStack();				LThread::sProfiling	= true;	}}// ===========================================================================//	¥ Symantec - specific stuff// ===========================================================================#if defined(__SC__)// Symantec doesn't define its profiler function anywherepascal void	_profile_(char *funcname);// Our replacement for Symantec's profiler functionpascal void	_profile_(char *funcname){	// silence compiler	functionName = functionName;		LThread::ThreadProfiler();}#endif	// defined(__SC__)// ===========================================================================//	¥ CodeWarrior - specific stuff// ===========================================================================#if defined(__MWERKS__)// get definion of profiler function#include <profiler.h>// Our replacement for CodeWarrior's profiler functionpascal void	__PROFILE(char *functionName){	// silence compiler	functionName = functionName;	LThread::ThreadProfiler();}#endif	// defined(__MWERKS__)#endif	// THREAD_DEBUG && THREAD_PROFILE