// ===========================================================================//	LSharedQueue.cp					©1994 Metrowerks Inc. All rights reserved.////									Author:  Paul Lalonde// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif// PowerPlant headers#include <LSharedQueue.h>#include <UDebugging.h>#include <UException.h>#include <UThread.h>// ---------------------------------------------------------------------------//		¥ LSharedQueue// ---------------------------------------------------------------------------//	Default ConstructorLSharedQueue::LSharedQueue() 	// call the constructors of our base classes	: LQueue(), LMutexSemaphore(false), mAvailable(0)	// the actual body of the constructor is empty!	{}// ---------------------------------------------------------------------------//		¥ LSharedQueue(const LSharedQueue&)// ---------------------------------------------------------------------------//	Copy constructor.  Shared queues can't be copied, so this is a protected //	function (that doesn't do anything).LSharedQueue::LSharedQueue(const LSharedQueue&)			: LMutexSemaphore(false), mAvailable(0){	BreakStrToSourceDebugger_("\pYou can't copy a shared queue object");}// ---------------------------------------------------------------------------//		¥ ~LSharedQueue// ---------------------------------------------------------------------------//	Destructor  -- just a placeholder, reallyLSharedQueue::~LSharedQueue(){	// there's nothing to do}// ---------------------------------------------------------------------------//		¥ Next// ---------------------------------------------------------------------------//	Removes and returns the first element in the queue.//	//	An optional argument specifies how long the caller is willing to //	wait for an element.  Possible values are://	//		sharedQueue_WaitForever	Wait indefinitely (default).//		sharedQueue_NoWait		Do not wait.  If the queue is empty, return NULL.//		other (> 0)				Wait time in millisecondsLLink	*LSharedQueue::Next(Int32 milliSeconds){	LLink	*outLinkP;	Int16	err;		// block until there's something in the queue	err = mAvailable.Wait(milliSeconds);	if (err == errSemaphoreTimedOut)		return (NULL);	else		ThrowIfOSErr_(err);		{		// get exclusive access to the queue within this block		StMutex	mutex(*this);				// remove first element from queue		outLinkP = LQueue::NextGet();	}		return (outLinkP);}// ---------------------------------------------------------------------------//		¥ Remove// ---------------------------------------------------------------------------//	Remove an arbitrary element from the queue.////	This function traverses the entire queue, looking for the given //	queue element.  If the element is found, it is removed from the //	queue.  Returns a Boolean indicating if the element was found.Boolean	LSharedQueue::Remove(LLink *inLinkP){	// get exclusive access to the queue	StMutex	mutex(*this);	Boolean	found;		// locate requested element	found = LQueue::Remove(inLinkP);		// return flag indicating if we found the element	return (found);}// ---------------------------------------------------------------------------//		¥ NextPut// ---------------------------------------------------------------------------//	Adds the given element to the end of the queuevoid	LSharedQueue::NextPut(LLink *inLinkP){	{		// get exclusive access to the queue within this block		StMutex	mutex(*this);			// add element to the end of the queue		LQueue::NextPut(inLinkP);	}		// signal the availability of an element	mAvailable.Signal();}// ---------------------------------------------------------------------------//		¥ DoForEach// ---------------------------------------------------------------------------//	Execute a user-supplied function for each element in the queuevoid	LSharedQueue::DoForEach(LQueueIterator proc, void *arg){	// get exclusive access to the queue	StMutex	mutex(*this);		// iterate	LQueue::DoForEach(proc, arg);}