// ===========================================================================//	LSemaphore.h					©1994 Metrowerks Inc. All rights reserved.////									Author:  Paul Lalonde// ===========================================================================#ifndef _H_LSemaphore#define _H_LSemaphore#ifdef __MWERKS__#	pragma once#endif// system headers#ifndef __OSUTILS__#	include <OSUtils.h>#endif// PowerPlant headers#include <PP_Types.h>// ===========================================================================//	¥ Constants// ===========================================================================// set non-zero to get unique semaphore IDs#ifndef SEMAPHORE_IDS#	define SEMAPHORE_IDS	0#endifconst Int32	semaphore_WaitForever	= -1;const Int32	semaphore_NoWait		= 0;// error codesenum {	errSemaphoreDestroyed = 28020, 	errSemaphoreTimedOut,	errSemaphoreNotOwner,	errSemaphoreAlreadyReset};// ===========================================================================//	¥ Data structures// ===========================================================================// forward class & structure declarationsclass	LThread;// ===========================================================================//	¥ class LSemaphore// ===========================================================================class LSemaphore{//	I N T E R F A C E ============================================public:		// CLASS METHODS --------------------		// searching#if SEMAPHORE_IDS	static LSemaphore	*FindSemaphore(Uint32 itsID);#endif		// INSTANCE METHODS -----------------		// constructors / destructors					LSemaphore(Int32 initialCount);	virtual			~LSemaphore();		// blocking	virtual void	Signal(void);	virtual Int16	Wait(Int32 milliSeconds = semaphore_WaitForever);		// inquiries#if SEMAPHORE_IDS	Uint32			GetID(void) const;#endif		//	I M P L E M E N T A T I O N ==================================	protected:		// CLASS VARIABLES ------------------	#if SEMAPHORE_IDS	static QHdr		sSemaphores;			// list of allocated semaphores	static Uint32	sNextSemaphoreID;		// next unique ID#endif		// INSTANCE METHODS -----------------		// constructors & destructors					LSemaphore(const LSemaphore&);		// thread control	Int16			BlockThread(Int32 milliSeconds);	LThread			*UnblockThread(QElemPtr qEl, Int16 error);	void			UnblockAll(Int16 error);		// INSTANCE VARIABLES ---------------	#if SEMAPHORE_IDS	QElemPtr		mQLink;			// link in chain of semaphores	Uint32			mID;			// unique ID for this semaphore#endif	Int32			mExcessSignals;	// excess signal / thread count	QHdr			mThreads;		// list of waiting threads		private:		// INSTANCE METHODS -----------------		// assignment	LSemaphore&		operator = (const LSemaphore&);		// GRANTING ACCESS --------------		friend class	LThread;};#endif // _H_LSemaphore