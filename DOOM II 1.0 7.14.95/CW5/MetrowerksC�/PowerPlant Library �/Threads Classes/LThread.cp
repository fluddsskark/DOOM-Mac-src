// ===========================================================================//	LThread.cp						©1994 Metrowerks Inc. All rights reserved.////									Author:  Paul Lalonde// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif// standard headers#include <string.h>// system headers#ifndef __ERRORS__#	include <Errors.h>#endif#ifndef __GESTALT__#	include <Gestalt.h>#endif#ifndef __PROCESSES__#	include <Processes.h>#endif#ifndef __THREADS__#	include <Threads.h>#endif#ifndef __LOWMEM__#	include <LowMem.h>#endif#if GENERATINGCFM && !defined(__CODEFRAGMENTS__)#	include <CodeFragments.h>#endif// PowerPlant headers#include <LSemaphore.h>#include <LThread.h>#include <UDebugging.h>#include <UEnvironment.h>#include <UException.h>#if !THREAD_INLINES#	include <LThreadInline.h>#endif// ===========================================================================//	The code in this module may be invoked at interrupt time, or called //	from the profiler, and should therefore not be profiled.// ===========================================================================#if defined(__SC__)#	pragma trace off#elif defined(__MWERKS__)//#	pragma profile off#else#	error "Don't know how to turn off profiling!"#endif// ===========================================================================//	¥ Conditional compilation// ===========================================================================// debugging aids#define BREAK_ON_YIELD		0		// non-zero to break on Yield#define BREAK_ON_SUSPEND	0		// non-zero to break on Suspend#define BREAK_ON_SLEEP		0		// non-zero to break on Sleep#define BREAK_ON_WAIT		0		// non-zero to break on Wait#define BREAK_ON_BLOCK		0		// non-zero to break on Block// ===========================================================================//	¥ Constants// ===========================================================================// stack size for disposal thread#if !defined(__powerc)const Uint32	kDisposalThreadStack	= 2500;const Uint32	kMainThreadStack		= 1000;#elseconst Uint32	kDisposalThreadStack	= 5000;const Uint32	kMainThreadStack		= 3000;#endifconst ThreadOptions	kThreadOptionsMask	= kNewSuspend | kUsePremadeThread | 										  kCreateIfNeeded | kFPUNotNeeded | 										  kExactMatchThread;// ===========================================================================//	¥ Static member variables// ===========================================================================Boolean				LThread::sInited			= false;LThread * volatile	LThread::sThread			= NULL;LThread * volatile	LThread::sMainThread		= NULL;LThread				*LThread::sCleanupThread	= NULL;QHdr volatile		LThread::sThreadQueue		= { 0, NULL, NULL };QHdr volatile		LThread::sCleanupQueue		= { 0, NULL, NULL };LSemaphore			*LThread::sCleanupSem		= NULL;void				*LThread::sThreadTaskRef	= NULL;ProcessSerialNumber	LThread::sPSN				= { 0, 0 };IOCompletionUPP		LThread::sThreadComplUPP	= NULL;TimerUPP			LThread::sThreadTimerUPP	= NULL;Int16 volatile		LThread::sReadyThreadCount	= 0;#if !GENERATINGCFMlong				LThread::sGlobals			= SetCurrentA5();#endifLThread::ThreadInit	LThread::sThreadInit;// ===========================================================================//	¥ Local function declarations// ===========================================================================//static void	ThreadIterate(LLink& aLink, void *arg);#if THREAD_DEBUGstatic pascal void	ThreadTermProc(ThreadID itsID, void *arg);#endif// ===========================================================================//	¥ Local variables// ===========================================================================#if BREAK_ON_YIELDstatic Boolean				sBreakBeforeYield	= true;static Boolean				sBreakAfterYield	= true;#endif// ===========================================================================//	¥ Static member functions// ===========================================================================// ---------------------------------------------------------------------------//		¥ EnterThreads	[static]// ---------------------------------------------------------------------------void	LThread::EnterThreads(void){	OSErr	err;		Try_	{		// is the Thread Manager running ?		if (!UEnvironment::HasFeature(env_HasThreadsManager))		{			ThrowOSErr_(threadProtocolErr);		}				// low-level initialisation		LThread::sThreadComplUPP = NewIOCompletionProc(ThreadComplProc);		ThrowIfNULL_(LThread::sThreadComplUPP);		LThread::sThreadTimerUPP = NewTimerProc(ThreadTimerProc);		ThrowIfNULL_(LThread::sThreadTimerUPP);		err = ::GetCurrentProcess(&sPSN);		ThrowIfOSErr_(err);		err = ::GetThreadCurrentTaskRef(&sThreadTaskRef);		ThrowIfOSErr_(err);				// make queue for releasing storage of preemptive threads		sCleanupSem	= new LSemaphore(0);		ThrowIfNULL_(sCleanupSem);				// we are now officially initialised		sInited = true;				// make thread that releases the storage of preemptive threads 		sCleanupThread = new UCleanupThread(sCleanupQueue, *sCleanupSem);		ThrowIfNULL_(sCleanupThread);				// start the cleanup thread		sCleanupThread->Resume();	}		Catch_(inErr)	{		if (sCleanupThread != NULL)		{			sCleanupThread->DeleteThread();			sCleanupThread = NULL;		}				if (sCleanupSem != NULL)		{			delete sCleanupSem;			sCleanupSem = NULL;		}				// we didn't get inited after all		sInited = false;				// transfer to enclosing error handler		Throw_(inErr);			} EndCatch_}// ---------------------------------------------------------------------------//		¥ ExitThreads	[static]// ---------------------------------------------------------------------------//	Cleans up the threads class library.  If the LThread::EnterThreads() //	returned successfully, this function gets called automatically when //	your application quits.void	LThread::ExitThreads(void){	LThread	*thread;	//	BreakStrToLowLevelDebugger_("\pEntering ExitThreads");		if (!sInited)		return;		// you should only call this from the main thread	THREAD_ASSERT(sThread == sMainThread);		// remove main thread from the list of all known threads	RemoveFromGlobalQueue((QElemPtr) &sMainThread->mThreadLink, sThreadQueue);#if THREAD_DEBUG	// we don't need thread term proc anymore	::SetThreadTerminator(sMainThread->mThread, NULL, NULL);#endif		// dispose of all known threads 	while (sThreadQueue.qHead != NULL)	{		thread = RemoveFromGlobalQueue(sThreadQueue.qHead, sThreadQueue);				THREAD_ASSERT(thread != NULL);				thread->DeleteThread();	}		sInited = false;}// ---------------------------------------------------------------------------//		¥ AllocateThreads	[static]// ---------------------------------------------------------------------------//	Pre-allocate some (Thread Manager) threads.void	LThread::AllocateThreads(	Boolean	inPreemptive, 	Uint16	inNumThreads, 	Uint32	inStackSize){	ThreadStyle	style;	Int16		err;		THREAD_ASSERT(!InPreemptiveThread());		style = (inPreemptive ? kPreemptiveThread : kCooperativeThread);		if (inNumThreads > 0)	{		err = ::CreateThreadPool(style, inNumThreads, inStackSize);		ThrowIfOSErr_(err);	}}// ---------------------------------------------------------------------------//		¥ GetFreeThreads	[static]// ---------------------------------------------------------------------------//	Count the number of unused pre-allocated (Thread Manager) threads.void	LThread::GetFreeThreads(	Boolean	inPreemptive, 	Uint16&	outNumThreads, 	Uint32	inStackSize){	ThreadStyle	style;	Int16		count;	Int16		err;		style = (inPreemptive ? kPreemptiveThread : kCooperativeThread);		if (inStackSize == thread_DefaultStack)		err = GetFreeThreadCount(style, &count);	else		err = GetSpecificFreeThreadCount(style, inStackSize, &count);		ThrowIfOSErr_(err);		outNumThreads = count;}// ---------------------------------------------------------------------------//		¥ GetThreadManagerTaskRef	[static]// ---------------------------------------------------------------------------//	Return the Thread Manager's reference number for this application.void	*LThread::GetThreadManagerTaskRef(void){	return (sThreadTaskRef);}// ---------------------------------------------------------------------------//		¥ Yield	[static]// ---------------------------------------------------------------------------//	Give up control of the CPU.void	LThread::Yield(const LThread *yieldTo){	if (!sInited)		return;	#if BREAK_ON_YIELD	if (sBreakBeforeYield)	BreakStrToLowLevelDebugger_("\pAbout to yield");#endif		// transfer control to some other needy thread	ThreadID theID = (yieldTo == NULL) ? kNoThreadID : yieldTo->mThread;	(void) ::YieldToThread(theID);	#if BREAK_ON_YIELD	if (sBreakAfterYield)	BreakStrToLowLevelDebugger_("\pJust yielded");#endif		// in case something bad happened while we weren't current	Int16 err = sThread->mError;	sThread->mError = noErr;	ThrowIfOSErr_(err);}// ---------------------------------------------------------------------------//		¥ InPreemptiveThread	[static]// ---------------------------------------------------------------------------//	Returns whether or not the current thread is a preemptive thread.Boolean	LThread::InPreemptiveThread(void){	LThread	*thread	= GetCurrentThread();	Boolean	preemptive;		if (thread != NULL)		preemptive = thread->IsPreemptive();	else		preemptive = false;		return (preemptive);}// ---------------------------------------------------------------------------//		¥ StateLinkToThread	[static]// ---------------------------------------------------------------------------//	Utility routine.  Given a pointer to a thread's mStateLink field, returns //	a pointer to the thread itself.LThread	*LThread::StateLinkToThread(QElemPtr inQElem){	return ((LThread *) (-offsetof(LThread, mStateLink) + (char *) inQElem));}// ---------------------------------------------------------------------------//		¥ AddToGlobalQueue	[static]// ---------------------------------------------------------------------------//	Adds a thread to a linked list, linking through the mThreadLink field.void	LThread::AddToGlobalQueue(LThread &inThread, QHdr& ioQueue){	::Enqueue((QElemPtr) &inThread.mThreadLink, &ioQueue);	++ioQueue.qFlags;}// ---------------------------------------------------------------------------//		¥ RemoveFromGlobalQueue	[static]// ---------------------------------------------------------------------------//	Removes a thread from a linked list, linking through the mThreadLink field.LThread	*LThread::RemoveFromGlobalQueue(QElemPtr inQElem, QHdr& ioQueue){	LThread	*thread;		if (::Dequeue(inQElem, &ioQueue) == noErr)	{		thread = (LThread *) (-offsetof(LThread, mThreadLink) + (char *) inQElem);		--ioQueue.qFlags;	}	else		thread = NULL;		return (thread);}// ---------------------------------------------------------------------------//		¥ AddToGlobalQueue	[static]// ---------------------------------------------------------------------------//	Adds a thread to a linked list, linking through the mStateLink field.void	LThread::AddToStateQueue(LThread &inThread, QHdr& ioQueue){	::Enqueue((QElemPtr) &inThread.mStateLink, &ioQueue);}// ---------------------------------------------------------------------------//		¥ RemoveFromGlobalQueue	[static]// ---------------------------------------------------------------------------//	Removes a thread from a linked list, linking through the mStateLink field.LThread	*LThread::RemoveFromStateQueue(QElemPtr inQElem, QHdr& ioQueue){	LThread	*thread;		if (::Dequeue(inQElem, &ioQueue) == noErr)	{		thread = (LThread *) (-offsetof(LThread, mStateLink) + (char *) inQElem);		thread->mStateLink = NULL;	}	else	{		thread = NULL;	}		return (thread);}// ---------------------------------------------------------------------------//		¥ DoForEach// ---------------------------------------------------------------------------//	Execute a user-supplied function for each thread.void	LThread::DoForEach(LThreadIterator proc, void *arg){	QHdr	tempQueue	= { 0, NULL, NULL };	LThread	*thread;		// take each thread off of the global queue & put it on the temp queue 	// before calling the iterator	while (sThreadQueue.qHead != NULL)	{		thread = RemoveFromGlobalQueue(sThreadQueue.qHead, sThreadQueue);				if (thread != NULL)		{			AddToGlobalQueue(*thread, tempQueue);						(*proc)(*thread, arg);		}			}		// move the threads back onto the global queue	while (tempQueue.qHead != NULL)	{		thread = RemoveFromGlobalQueue(tempQueue.qHead, tempQueue);		AddToGlobalQueue(*thread, sThreadQueue);	}}// ---------------------------------------------------------------------------//		¥ EnterCritical	[static]// ---------------------------------------------------------------------------//	Enter a critical section.void	LThread::EnterCritical(void){	::ThreadBeginCritical();}// ---------------------------------------------------------------------------//		¥ ExitCritical	[static]// ---------------------------------------------------------------------------//	Leave a critical section.void	LThread::ExitCritical(void){	::ThreadEndCritical();}// ---------------------------------------------------------------------------//		¥ operator new	[static]// ---------------------------------------------------------------------------//	Performs some sanity checks, then calls default operator new.void	*LThread::operator new(size_t size){	// we can't allocate memory while we're in a preemptive thread	THREAD_ASSERT(!InPreemptiveThread());		// Note this bizarre memory allocation.  This is used so we can hand off 	// the memory to the cleanup thread if need be (see operator delete).		return (new char[size]);}// ---------------------------------------------------------------------------//		¥ operator new	[static]// ---------------------------------------------------------------------------//	Placement form of operator new.  You can use this to "pre-allocate" the //	memory for a thread object.void	*LThread::operator new(size_t, char *ptr){	return (ptr);}// ---------------------------------------------------------------------------//		¥ operator delete	[static]// ---------------------------------------------------------------------------void	LThread::operator delete(void *ptr){	LThread	*thread	= (LThread *) ptr;		// are we in a preemptive thread ?	if (!InPreemptiveThread())	{		// no -- so we can delete the object's memory normally.				delete [] (char *) ptr;	}	else	{		// We're in a preemptive thread, so we can't release the object's 		// memory just yet.  What we do is we hand it off to the cleanup 		// thread, which is a cooperative thread whose whole purpose in 		// life is to service our requests.				// What we're doing here is pretty skanky -- namely, passing a 		// reference to a *deconstructed* object.  If this breaks at one 		// point, we'll have to enqueue the thread onto the disposal 		// queue ourselves.				AddToGlobalQueue(*thread, sCleanupQueue);				sCleanupSem->Signal();	}}// ===========================================================================//	¥ Non-static member functions// ===========================================================================// ---------------------------------------------------------------------------//		¥ LThread()// ---------------------------------------------------------------------------//	Constructor.  Completely initialises a thread object.////	This function takes four arguments:////		inPreemptive	- Indicates if the thread should be preemptive or not.//		inStacksize		- The thread's stack size.  If it is thread_DefaultStack, //						  the Thread Manager's default stack size is used.//		inFlags			- Flags controlling the creation and behavior of the //						  thread.//		outResult		- location to stuff with thread result;  may be NULL.LThread::LThread(	Boolean					inPreemptive, 	Uint32					inStacksize, 	LThread::EThreadOption	inFlags, 	void					**outResult){	ThreadStyle		style;	ThreadOptions	options;	Int16			err;		if (!sInited)		EnterThreads();		// sanity checks	if (inFlags & threadOption_Main)	{		// we can't have a preemptive main thread, nor two main threads!		if (inPreemptive || (sMainThread != NULL))			Throw_(threadProtocolErr);				// ignore all other options when creating the main thread		inFlags = threadOption_Main;	}		// init member variables	mDestructorLink		= NULL;	mExceptionLink		= NULL;	mThreadLink			= NULL;	mStateLink			= NULL;	mThread				= kNoThreadID;	mNextOfKin			= sThread;	mResult				= NULL;	mError				= noErr;	mState				= threadState_Suspended;	mPreemptive			= inPreemptive;	mFPU				= !(inFlags & threadOption_NoFPU);	mSemaphore			= NULL;#if THREAD_DEBUG && THREAD_PROFILE	mProfiling			= false;#endif		if (outResult != NULL)		*outResult = NULL;		// setup timer info	mTimer.ioThread				= this;#if !GENERATINGCFM	mTimer.ioGlobals			= sGlobals;#endif	mTimer.ioTask.qLink			= NULL;	mTimer.ioTask.qType			= 0;	mTimer.ioTask.tmAddr		= sThreadTimerUPP;	mTimer.ioTask.tmCount		= 0;	mTimer.ioTask.tmWakeUp		= 0;	mTimer.ioTask.tmReserved	= 0;		// set up thread style	style = inPreemptive ? kPreemptiveThread : kCooperativeThread;		// set up thread options	options = ((inFlags | kNewSuspend) & kThreadOptionsMask);		// if we're in a preemptive thread, force the Thread Manager to 	// use a preallocated thread.	if (InPreemptiveThread())	{		options |= kUsePremadeThread;	}		// recycle thread only if we MUST allocate from thread pool	mRecycle = ((options & kUsePremadeThread) && !(options & kCreateIfNeeded));		Try_	{		// Are we trying to create the main thread object ?  If so, just get the 		// ID of the current thread.				if (inFlags & threadOption_Main)		{			// the thread ID to use is the current one			err = ::GetCurrentThread(&mThread);			ThrowIfOSErr_(err);			#if THREAD_DEBUG			mStackSize	= LMGetCurStackBase() - GetApplLimit();#endif		}		else		{			// allocate thread			err	 = ::NewThread(style, DoEntry, this, inStacksize, options, outResult, 							   &mThread);			ThrowIfOSErr_(err);			#if THREAD_DEBUG			// since the thread hasn't started executing yet, all of its stack 			// is free;  therefore the amount of free space on the stack is the 			// same as the size of the stack.			::ThreadCurrentStackSpace(mThread, &mStackSize);			mMaxStack = 0;#endif		}				// set up termination, switch-in, & switch-out glue callbacks		err = ::SetThreadSwitcher(mThread, DoSwapIn, this, true);		ThrowIfOSErr_(err);		err = ::SetThreadSwitcher(mThread, DoSwapOut, this, false);		ThrowIfOSErr_(err);#if THREAD_DEBUG		err = ::SetThreadTerminator(mThread, ThreadTermProc, this);		ThrowIfOSErr_(err);#endif				// add thread to the queue of known threads		AddToGlobalQueue(*this, sThreadQueue);				if (inFlags & threadOption_Main)		{			sThread	= sMainThread = this;			mState	= threadState_Current;		}	}		Catch_(inErr)	{		Boolean	recycle;				RemoveFromGlobalQueue((QElemPtr) &mThreadLink, sThreadQueue);				if (mThread != kNoThreadID)		{			// recycle thread if we got it from the pool to begin with			recycle = ((options & kUsePremadeThread) != 0);						::SetThreadTerminator(mThread, NULL, NULL);			::DisposeThread(mThread, NULL, recycle);			mThread = kNoThreadID;		}				// transfer to enclosing error handler		Throw_(inErr);			} EndCatch_}// ---------------------------------------------------------------------------//		¥ LThread(const LThread&)// ---------------------------------------------------------------------------//	Copy constructor.  Threads can't be copied, so this is a protected //	function (that doesn't do anything).LThread::LThread(const LThread&){	BreakStrToSourceDebugger_("\pYou can't copy a thread object");}// ---------------------------------------------------------------------------//		¥ ~LThread// ---------------------------------------------------------------------------//	Destructor.  Doesn't do much, really, since all the work is done in //	DeleteThread and operator delete.LThread::~LThread(){	// we can't dispose of the main thread	if (this == sMainThread)		Throw_(threadProtocolErr);}// ---------------------------------------------------------------------------//		¥ DeleteThread// ---------------------------------------------------------------------------//	Thread disposal function.void	LThread::DeleteThread(void *inResult){	SetResult(inResult);		// remove ourselves from the thread queue	RemoveFromGlobalQueue((QElemPtr) &mThreadLink, sThreadQueue);		// enter critical section	::ThreadBeginCritical();		if (mState == threadState_Blocked)	{		// The thread is waiting for async I/O to complete, so we can't kill 		// it right away.  Instead, we stuff an error code into into object 		// that will cause the thread to delete itself once it's unblocked.		mError = errKilledThread;		::ThreadEndCritical();		return;	}		// remove any leftover timer	RemoveTimeTask(mTimer);		if (mState == threadState_Ready)	{		// this is one less ready thread to deal with		MakeUnready();	}	else if (mState == threadState_Waiting)	{		// the thread is waiting on a semaphore, so 		// remove it from the sem's queue		THREAD_ASSERT(mSemaphore != NULL);		mSemaphore->UnblockThread((QElemPtr) &this->mStateLink, errKilledThread);	}		ThreadID	savedID			= mThread;	Boolean		savedRecycle	= mRecycle;	void		*savedResult	= mResult;		// exit critical section	::ThreadEndCritical();		// notify next of kin	if (mNextOfKin != NULL)		mNextOfKin->ThreadDied(*this);		// release the thread object	delete this;	#if THREAD_DEBUG	// we don't need thread term proc anymore	::SetThreadTerminator(savedID, NULL, NULL);#endif		// kill the thread	(void) ::DisposeThread(savedID, savedResult, savedRecycle);		Yield();}// ---------------------------------------------------------------------------//		¥ ThreadDied// ---------------------------------------------------------------------------void	LThread::ThreadDied(const LThread& /*inThread*/){	// default behaviour:  do nothing}// ---------------------------------------------------------------------------//		¥ Suspend// ---------------------------------------------------------------------------//	Make a thread ineligible for CPU time.////	A suspended thread can only regain control of the CPU if another thread //	resumes it first.void	LThread::Suspend(void){	Boolean	selfSuspend;	Int16	err;		Try_	{#if BREAK_ON_SUSPEND		BreakStrToLowLevelDebugger_("\pAbout to suspend thread");#endif				// enter critical section		::ThreadBeginCritical();				// can't suspend a thread that's sleeping or waiting or already suspended		if (mState != threadState_Current && mState != threadState_Ready)		{			Throw_(errBadThreadState);		}				// change thread state		selfSuspend	= (mState == threadState_Current);		mState		= threadState_Suspended;				// If we're not suspending ourselves, it means the thread used to be in 		// the ready state.  So we have to bump down the ready thread count.		if (!selfSuspend)			MakeUnready();				// end critical section by stopping thread at OS level		err = ::SetThreadStateEndCritical(mThread, kStoppedThreadState, kNoThreadID);				// THIS SHOULD NEVER FAIL IN SHIPPING CODE ...		THREAD_ASSERT(err == noErr);		#if BREAK_ON_SUSPEND		BreakStrToLowLevelDebugger_("\pThread now resumed");#endif	} 		Catch_(inErr)	{		// exit critical section before leaving function		::ThreadEndCritical();				// transfer to enclosing error handler		Throw_(inErr);			} EndCatch_		// in case something bad happened while we were sleeping	if (selfSuspend)	{		err		= mError;		mError	= noErr;				ThrowIfOSErr_(err);	}	else		Yield();}// ---------------------------------------------------------------------------//		¥ Resume// ---------------------------------------------------------------------------//	Make a suspended thread eligible for CPU time once more.void	LThread::Resume(void){	Int16	err;		// a thread can't resume itself !	THREAD_ASSERT(sThread != this);		Try_ {		// enter critical section		::ThreadBeginCritical();				// can't resume a thread that's not suspended		if (mState != threadState_Suspended)		{			Throw_(errBadThreadState);		}				// adjust ready thread count accordingly		MakeReady();				// end critical section by resuming thread at OS level		err = ::SetThreadStateEndCritical(mThread, kReadyThreadState, kNoThreadID);				// THIS SHOULD NEVER FAIL IN SHIPPING CODE ...		THREAD_ASSERT(err == noErr);				Yield();			} 		Catch_(inErr) {		// exit critical section before leaving function		::ThreadEndCritical();				// transfer to enclosing error handler		Throw_(inErr);			} EndCatch_}// ---------------------------------------------------------------------------//		¥ Block// ---------------------------------------------------------------------------//	Make a thread ineligible for CPU time.  Use this function after an //	asynchronous I/O call.////	The thread can only regain control of the CPU once the async call //	completes.void	LThread::Block(void){	Int16	err;		// a thread can only block itself	THREAD_ASSERT(this == sThread);		Try_	{#if BREAK_ON_BLOCK		BreakStrToLowLevelDebugger_("\pAbout to block thread");#endif				// enter critical section		::ThreadBeginCritical();				// change thread state		mState = threadState_Blocked;				// End critical section by stopping thread at OS level.		//		// Because we're stopping the current thread, rescheduling 		// will have to occur.  Therefore, several error conditions 		// may arise:		//		// 1.	The current thread's critical depth isn't 1.  This 		//		means that we're either in a nested critical section 		//		(ThreadBeginCritical was called more that once), or 		//		we're not in a critical section at all.		//		// 2.	There are no other threads left to run.		// 		// All of these situations are programming errors.				err = ::SetThreadStateEndCritical(mThread, kStoppedThreadState, kNoThreadID);				// THIS SHOULD NEVER FAIL IN SHIPPING CODE ...		THREAD_ASSERT(err == noErr);		#if BREAK_ON_BLOCK		BreakStrToLowLevelDebugger_("\pThread now unblocked");#endif	} 		Catch_(inErr)	{		// exit critical section before leaving function		::ThreadEndCritical();				// transfer to enclosing error handler		Throw_(inErr);			} EndCatch_		if (mError == errKilledThread)	{		// We were killed while waiting for the I/O 		// to complete.  Finish the job.		DeleteThread(mResult);	}	else	{		err		= mError;		mError	= noErr;				ThrowIfOSErr_(err);	}}// ---------------------------------------------------------------------------//		¥ Sleep// ---------------------------------------------------------------------------//	Make a thread ineligible for CPU time for a certain time interval.////	A sleeping thread can only regain control of the CPU when its sleep //	time expires, or if another thread wakes it first.void	LThread::Sleep(Int32 milliSeconds){	Int16	err;	Boolean	selfSleep;		// we don't like negative sleep intervals	THREAD_ASSERT(milliSeconds >= 0);		// interval is zero -- don't sleep, just blink !	if (milliSeconds == 0)	{		Yield();		return;	}		Try_ {#if BREAK_ON_SLEEP		BreakStrToLowLevelDebugger_("\pAbout to put thread to sleep");#endif				// enter critical section		::ThreadBeginCritical();				// can't put to sleep a thread that's suspended or waiting or already sleeping		if (mState != threadState_Current && mState != threadState_Ready)		{			Throw_(errBadThreadState);		}				// set up timer		RemoveTimeTask(mTimer);		InsertTimeTask(mTimer);				// change thread state		selfSleep	= (mState == threadState_Current);		mState		= threadState_Sleeping;				// If we're not putting ourselves to sleep, it means the thread used to be		// in the ready state.  So we have to bump down the ready thread count.		if (!selfSleep)			MakeUnready();				// start countdown		PrimeTimeTask(mTimer, milliSeconds);				// end critical section by suspending thread at OS level		err = ::SetThreadStateEndCritical(mThread, kStoppedThreadState, kNoThreadID);				// THIS SHOULD NEVER FAIL IN SHIPPING CODE ...		THREAD_ASSERT(err == noErr);		#if BREAK_ON_SLEEP		BreakStrToLowLevelDebugger_("\pThread now awake");#endif	}		Catch_(inErr) {		// remove timer from TM queue, in case we got to enqueue it		RemoveTimeTask(mTimer);				// exit critical section before leaving function		::ThreadEndCritical();				// transfer to enclosing error handler		Throw_(inErr);			} EndCatch_		// in case something bad happened while we were sleeping	if (selfSleep)	{		err		= mError;		mError	= noErr;				ThrowIfOSErr_(err);	}	else		Yield();}// ---------------------------------------------------------------------------//		¥ Wake// ---------------------------------------------------------------------------//	Make a sleeping thread eligible for CPU time once more.void	LThread::Wake(void){	Int16	err;		// a thread can't wake itself !	THREAD_ASSERT(sThread != this);		Try_ {		// enter critical section		::ThreadBeginCritical();				// can't wake a thread that's not sleeping		if (mState != threadState_Sleeping)		{			Throw_(errBadThreadState);		}				// remove element from timer queue		RemoveTimeTask(mTimer);				// adjust ready thread count accordingly		MakeReady();				// end critical section by resuming thread at OS level		err = ::SetThreadStateEndCritical(mThread, kReadyThreadState, kNoThreadID);			// THIS SHOULD NEVER FAIL IN SHIPPING CODE ...		THREAD_ASSERT(err == noErr);				Yield();	} 		Catch_(inErr) {		// remove timer from TM queue, in case we didn't get to enqueue it		RemoveTimeTask(mTimer);				// exit critical section before leaving function		::ThreadEndCritical();						// transfer to enclosing error handler		Throw_(inErr);	} EndCatch_}// ---------------------------------------------------------------------------//		¥ SemWait// ---------------------------------------------------------------------------//	Make a thread ineligible for CPU time until a semaphore is released.//	//	A waiting thread can only regain control of the CPU when its semaphore //	is released, or if its wait timer expires.////	NOTE:	The current thread must be in a critical section upon //			entering this function!Int16	LThread::SemWait(	LSemaphore	*inSemaphore, 	Int32		inMilliSeconds, 	QHdr		&ioQHdr, 	Boolean		&outTimedOut){	Int16	err;		// perform some sanity checks ...	THREAD_ASSERT(this == sThread);	THREAD_ASSERT(inMilliSeconds == thread_WaitForever || inMilliSeconds > 0);	THREAD_ASSERT(mSemaphore == NULL);	THREAD_ASSERT(inSemaphore != NULL);	#if BREAK_ON_WAIT	BreakStrToLowLevelDebugger_("\pAbout to wait thread");#endif		// set up blocking vars	mSemaphore = inSemaphore;		// change thread state	mState = threadState_Waiting;		// add thread to semaphore's queue of waiting threads	AddToStateQueue(*this, ioQHdr);		// remove any leftover timer from TM queue	RemoveTimeTask(mTimer);		// if the caller wants a timeout, set up timer	if (inMilliSeconds > 0)	{		InsertTimeTask(mTimer);		PrimeTimeTask(mTimer, inMilliSeconds);	}		// End critical section by stopping thread at OS level.	//	// Because we're stopping the current thread, rescheduling 	// will have to occur.  Therefore, several error conditions 	// may arise:	//	// 1.	The current thread's critical depth isn't 1.  This 	//		means that we're either in a nested critical section 	//		(ThreadBeginCritical was called more that once), or 	//		we're not in a critical section at all.	//	// 2.	There are no other threads left to run.	// 	// All of these situations are programming errors.		err = ::SetThreadStateEndCritical(mThread, kStoppedThreadState, kNoThreadID);		// THIS SHOULD NEVER FAIL IN SHIPPING CODE ...	THREAD_ASSERT(err == noErr);		// enter critical section	::ThreadBeginCritical();		// remove any leftover timer	RemoveTimeTask(mTimer);		if (mError == errSemaphoreDestroyed)		outTimedOut = false;	else	{		// remove the thread from our queue of waiting threads.		// if the thread was in the queue, it means we timed out.		outTimedOut = (RemoveFromStateQueue((QElemPtr) &mStateLink, ioQHdr) != NULL);	}		// set our states var correctly	mSemaphore	= NULL;		// in case something bad happened while we were waiting ...	err			= mError;	mError		= noErr;		return (err);}// ---------------------------------------------------------------------------//		¥ SemUnwait	[static]// ---------------------------------------------------------------------------//	Make a waiting thread eligible for CPU time once again.//	//	NOTE:	The current thread must be in a critical section upon //			entering this function!LThread	*LThread::SemUnwait(	LSemaphore	*inSemaphore, 	Int16		inError, 	QElemPtr	inQElem, 	QHdr		&ioQHdr){	Int16	err;	LThread	*thread;		thread = RemoveFromStateQueue(inQElem, ioQHdr);	if (thread == NULL)		return (NULL);		// we can't unblock ourselves	THREAD_ASSERT(thread != sThread);	// do sanity check on semaphore	THREAD_ASSERT(thread->mSemaphore != NULL);	THREAD_ASSERT(thread->mSemaphore == inSemaphore);		// can't unblock a thread that isn't waiting	THREAD_ASSERT(thread->mState == threadState_Waiting);	#if BREAK_ON_WAIT	BreakStrToLowLevelDebugger_("\pThread now being unwaited (?)");#endif		// set our state vars correctly	thread->mSemaphore	= NULL;	thread->mError		= inError;		// if we're unblocking a thread because it's in the process 	// of being destroyed, don't bother waking it up.		if (inError != errKilledThread)	{		// change thread state		thread->MakeReady();				err = SetThreadState(thread->mThread, kReadyThreadState, kNoThreadID);				// THIS SHOULD NEVER FAIL IN SHIPPING CODE ...		THREAD_ASSERT(err == noErr);	}		return (thread);}// ---------------------------------------------------------------------------//		¥ IsPreemptive// ---------------------------------------------------------------------------//	Is the thread a preemptive thread ?Boolean	LThread::IsPreemptive(void) const			{ return (mPreemptive);	}// ---------------------------------------------------------------------------//		¥ SetNextOfKin// ---------------------------------------------------------------------------//	Set the thread to be notified of this thread's deathvoid	LThread::SetNextOfKin(LThread *inThread)	{ mNextOfKin = inThread; }// ---------------------------------------------------------------------------//		¥ GetRecycle// ---------------------------------------------------------------------------//	Is the thread's stack supposed to be recycled when the thread is //	destroyed ?Boolean	LThread::GetRecycle(void) const				{ return (mRecycle);	}// ---------------------------------------------------------------------------//		¥ SetRecycle// ---------------------------------------------------------------------------//	Set whether or not the thread's stack is supposed to be recycled //	when the thread is destroyed.void	LThread::SetRecycle(Boolean recycle)	{ mRecycle = recycle;	}// ---------------------------------------------------------------------------//		¥ GetResult// ---------------------------------------------------------------------------//	Get the thread's resultvoid	*LThread::GetResult(void) const			{ return (mResult);		}// ---------------------------------------------------------------------------//		¥ SetResult// ---------------------------------------------------------------------------//	Set the thread's resultvoid	LThread::SetResult(void *inResult)		{ mResult = inResult;	}// ---------------------------------------------------------------------------//		¥ GetFreeStack// ---------------------------------------------------------------------------//	Return the amount of free space in the thread's stack.  Note that //	this information is of dubious accuracy outside of a critical section.Uint32	LThread::GetFreeStack(void) const{	Uint32	stackSize;		::ThreadCurrentStackSpace(mThread, &stackSize);		return (stackSize);}// ---------------------------------------------------------------------------//		¥ operator =// ---------------------------------------------------------------------------//	Assignment operator.  Threads can't be assigned to, so this is a private //	function (that doesn't do anything).LThread&	LThread::operator = (const LThread&){	BreakStrToSourceDebugger_("\pYou can't assign to a thread object");		return (*this);		// eliminate compiler complaints}// ===========================================================================//	¥ Local functions// ===========================================================================// ---------------------------------------------------------------------------//		¥ ThreadTermProc// ---------------------------------------------------------------------------//	"Fake" termination function.  Does nothing.#if THREAD_DEBUGstatic pascal void	ThreadTermProc(ThreadID, void *){	BreakStrToLowLevelDebugger_("\pEntered thread termination proc -- this should never happen!");}#endif// ---------------------------------------------------------------------------//		¥ CreateMainThread	[static]// ---------------------------------------------------------------------------UMainThread::UMainThread(void)	: LThread(false, thread_DefaultStack, LThread::threadOption_Main){	// there's nothing else to do}void	*UMainThread::Run(void){	SignalPStr_("\pEntering UMainThread::Run() -- this should never happen!");		return (NULL);}// ===========================================================================//	¥ UCleanupThread// ===========================================================================// ---------------------------------------------------------------------------//		¥ UCleanupThread// ---------------------------------------------------------------------------//	ConstructorUCleanupThread::UCleanupThread(QHdr &inQueue, LSemaphore &inSem)		// construct base class & reference members	: LThread(false, kDisposalThreadStack), mQueue(inQueue), mSem(inSem){	// there's nothing else to do ...}// ---------------------------------------------------------------------------//		¥ UCleanupThread::Run// ---------------------------------------------------------------------------//	Thread function executed by the cleanup thread.////	This function sits in a loop, waiting for an element (i.e., a thread) //	to appear in the cleanup queue.  When one appears, it is deleted.void	*UCleanupThread::Run(void){	LThread	*thread;		while (true)	{		// wait until a thread needs to be deallocated		mSem.Wait();				thread = RemoveFromGlobalQueue(mQueue.qHead, mQueue);				THREAD_ASSERT(thread != NULL);				// release thread object's memory		delete [] (char *) thread;	}		return (NULL);}