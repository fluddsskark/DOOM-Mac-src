// ===========================================================================//	LThread.h						©1994 Metrowerks Inc. All rights reserved.////									Author:  Paul Lalonde// ===========================================================================#ifndef _H_LThread#define _H_LThread#ifdef __MWERKS__#	pragma once#endif// standard headers#include <stddef.h>// platform-specific headers#ifndef __APPLETALK__#	include <AppleTalk.h>#endif#ifndef __FILES__#	include <Files.h>#endif#ifndef __TIMER__#	include <Timer.h>#endif// PowerPlant headers#include <PP_Types.h>// ===========================================================================//	¥ Conditional compilation// ===========================================================================// set to a non-zero value to get debugging functions#ifndef THREAD_DEBUG#	define THREAD_DEBUG		1#endif// set to a non-zero value to get profiling functions (THREAD_DEBUG must also be non-zero)// ### NOTE:  NOT YET OPERATIONAL ####ifndef THREAD_PROFILE#	define THREAD_PROFILE	0#endif// set to a non-zero value to generate certain functions in-line#ifndef THREAD_INLINES#	define THREAD_INLINES	(!THREAD_PROFILE)#endif// ===========================================================================//	¥ Constants// ===========================================================================// error codesenum {	errKilledThread = 28000, 	errBadThreadState};// thread stack sizeconst Uint32	thread_DefaultStack	= 0;const Int32		thread_WaitForever	= -1;// ===========================================================================//	¥ Data structures// ===========================================================================// forward class & structure declarationsclass	LSemaphore;class	LThread;class	UException;struct	DestructorChain;struct	SchedulerInfoRec;struct	ProcessSerialNumber;// alias for a ThreadIDtypedef Uint32	ThreadIDT;typedef void	(*LThreadIterator)(LThread& inThread, void *arg);// support for thread resumption from within an I/O completion routine.typedef struct {	LThread				*ioThread;	Int32				ioGlobals;	union {		ATPParamBlock	A;		CInfoPBRec		C;		ParamBlockRec	F;		HParamBlockRec	H;		MPPParamBlock	M;		XPPParamBlock	X;	} ioPB;} SThreadParamBlk, *SThreadPBPtr;// support for sleep, timed wakeups, & async resumestypedef struct {	LThread		*ioThread;	Int32		ioGlobals;	TMTask		ioTask;} SThreadTMTask;// ===========================================================================//	¥ External function declarations// ===========================================================================#if THREAD_DEBUGextern "C" { 	// this function is called by THREAD_ASSERT macro	int		ThreadAssert(char *test, char *file, int line);}#endif// ===========================================================================//	¥ class LThread// ===========================================================================class LThread{// I N T E R F A C E ====================================================public:		// CONSTANTS -----------------------		// thread creation flags	enum EThreadOption	{ threadOption_UsePool = 0x0002,  threadOption_Alloc   = 0x0004, 						  threadOption_NoFPU   = 0x0008,  threadOption_Exact   = 0x0010, 						  threadOption_Main    = 0x1000, 						  threadOption_Default = threadOption_Alloc  };		// thread states	enum EThreadState	{ threadState_Current,   threadState_Ready, 						  threadState_Suspended, threadState_Sleeping, 						  threadState_Waiting,   threadState_Blocked };			// CLASS METHODS -------------------		// pre-allocated threads	static void			AllocateThreads(Boolean preemptive, Uint16 numThreads, 							Uint32 stackSize);	static void			GetFreeThreads(Boolean preemptive, Uint16& numThreads, 							Uint32 stackSize);		// thread switching	static void			Yield(const LThread *yieldTo = NULL);		// critical sections	static void			EnterCritical(void);	static void			ExitCritical(void);		// inquiries	static LThread		*GetCurrentThread(void);	static LThread		*GetMainThread(void);	static Int16		CountReadyThreads(void);	static Boolean		InPreemptiveThread(void);	static Boolean		InMainThread(void);	static void			*GetThreadManagerTaskRef(void);		// iterators	static void			DoForEach(LThreadIterator proc, void *arg);		// asynchronous resumes	static void			ThreadAsynchronousResume(LThread *aThread);		// semaphore support	static LThread		*StateLinkToThread(QElemPtr inQElem);		// free store	void				*operator new(size_t size);	void				*operator new(size_t size, char *ptr);		// debugging / profiling#if THREAD_DEBUG	static void			DumpAllThreads(void);#if THREAD_PROFILE	static void			InitThreadProfiles(void);	static void			DumpThreadProfiles(void);	static Boolean		SetThreadProfiling(Boolean nprof);	static void			ThreadProfiler(void);#endif	// THREAD_PROFILE#endif	// THREAD_DEBUG		// INSTANCE METHODS ----------------		// constructors / destructors						LThread(Boolean inPreemptive, 							Uint32 inStacksize = thread_DefaultStack, 							LThread::EThreadOption inFlags = threadOption_Default, 							void **outResult = NULL);		// thread disposal	virtual void		DeleteThread(void *inResult = NULL);		// altered states	virtual void		Suspend(void);	virtual void		Resume(void);	virtual void		Sleep(Int32 milliSeconds);	virtual void		Wake(void);	virtual void		Block(void);		// inquiries	Boolean				IsPreemptive(void) const;	Boolean				IsCurrent(void) const;	Boolean				GetRecycle(void) const;	Uint32				GetFreeStack(void) const;	void				*GetResult(void) const;		// modifiers	void				SetRecycle(Boolean recycle);	void				SetResult(void *mResult);	void				SetNextOfKin(LThread *inThread);		// asynchronous I/O	virtual void		SetupAsynchronousResume(SThreadPBPtr threadPB, 							IOCompletionUPP callbackUPP = NULL);	virtual Int16		SuspendUntilAsyncResume(SThreadPBPtr threadPB, Int16 error);	virtual Int16		SuspendUntilAsyncResume(SThreadPBPtr threadPB);		// debugging#if THREAD_DEBUG	virtual void		Dump(void) const;	Uint32				GetStackSize(void) const;	Uint32				GetMaxUsedStack(void) const;	void				RecordMaxStack(void);#endif	// I M P L E M E N T A T I O N ==========================================	protected:		// CLASS METHODS -------------------		static void			AddToStateQueue(LThread &inThread, QHdr& ioQueue);	static LThread		*RemoveFromStateQueue(QElemPtr inQElem, QHdr& ioQueue);	static LThread		*SemUnwait(LSemaphore *inSemaphore, Int16 inError, 							QElemPtr inQElem, QHdr &ioQHdr);		// Time Manager interface	static void			InsertTimeTask(SThreadTMTask& task);	static void			PrimeTimeTask(SThreadTMTask& task, Int32 interval);	static void			RemoveTimeTask(SThreadTMTask& task);		// free store	void				operator delete(void *ptr);		// completion routines#if GENERATINGCFM	static void			ThreadComplProc(ParmBlkPtr pbPtr);	static void			ThreadTimerProc(TMTaskPtr tmTaskPtr);#else	static void			ThreadComplProc(ParmBlkPtr pbPtr : __A0);	static void			ThreadTimerProc(TMTaskPtr tmTaskPtr : __A1);#endif		// CLASS VARIABLES -----------------		static LThread * volatile	sThread;			// current thread	static LThread * volatile	sMainThread;		// main thread	static QHdr volatile		sThreadQueue;		// all known threads	static ProcessSerialNumber	sPSN;				// ptr to application's PSN	static void					*sThreadTaskRef;	// thread task ref	static TimerUPP				sThreadTimerUPP;	// UPP for time mgr	static IOCompletionUPP		sThreadComplUPP;	// UPP for async resumes			// INSTANCE METHODS ----------------		// constructors / destructors						LThread(const LThread&);	virtual				~LThread(void);		// thread switching	virtual void		SwapContext(Boolean swappingIn);		// thread execution	virtual void		*Run(void) = 0;	virtual void		ThreadDied(const LThread& inThread);		// altered states	void				MakeReady(void);	void				MakeUnready(void);	virtual Int16		SemWait(LSemaphore *inSemaphore, Int32 inMilliSeconds, 							QHdr &ioQHdr, Boolean &outTimedOut);			// INSTANCE VARIABLES --------------		// state info	DestructorChain		*mDestructorLink;	// CodeWarrior runtime support	UException			*mExceptionLink;	// PowerPlant support	QElemPtr			mThreadLink;		// link in queue of all known threads	QElemPtr			mStateLink;			// link in state-dependent queue	ThreadIDT			mThread;			// thread ID	LThread				*mNextOfKin;		// thread to notify in case of death	void				*mResult;			// thread result	LSemaphore			*mSemaphore;		// the sem we're waiting on, or NULL	SThreadTMTask		mTimer;				// timeout stuff	Int16				mError;				// for detecting errors while a thread is asleep	EThreadState		mState;				// current state (ready, sleeping, etc)	Boolean				mPreemptive;		// is this a preemptive thread ?	Boolean				mRecycle;			// re-use stack upon termination ?	Boolean				mFPU;				// uses FPU ?		// debugging#if THREAD_DEBUG	Uint32				mMaxStack;	Uint32				mStackSize;#if THREAD_PROFILE	Boolean				mProfiling;#endif#endif		private:		// NESTED CLASSES ------------------		class ThreadInit 	{		ThreadInit(void);		~ThreadInit(void);				friend class	LThread;	};		// CLASS METHODS -------------------		// class initialisation	static void			EnterThreads(void);	static void			ExitThreads(void);		static LThread		*RemoveFromGlobalQueue(QElemPtr inQElem, QHdr& ioQueue);	static void			AddToGlobalQueue(LThread &inThread, QHdr& ioQueue);		// Thread Manager callbacks	static pascal void	*DoEntry(void *arg);	static pascal void	DoSwapIn(Uint32 switchedThread, void *arg);	static pascal void	DoSwapOut(Uint32 switchedThread, void *arg);			// CLASS VARIABLES -----------------		static LThread::ThreadInit	sThreadInit;		// class initialisation object	static Boolean				sInited;			// is the thread class initialised?	static LThread				*sCleanupThread;	// thread disposal thread	static QHdr volatile		sCleanupQueue;		// threads awaiting deletion	static LSemaphore			*sCleanupSem;	static Int16 volatile		sReadyThreadCount;	// # of threads capable of runnning#if !GENERATINGCFM	static long					sGlobals;#endif#if THREAD_DEBUG && THREAD_PROFILE	static Boolean				sProfiling;			// is profiling turned on ?#endif		// INSTANCE METHODS ----------------		// assignment	LThread&			operator = (const LThread&);		// GRANTING ACCESS -----------------		friend class		LSemaphore;	friend class		ThreadInit;};// ===========================================================================//	¥ UMainThread Class// ===========================================================================class UMainThread : public LThread{public:					UMainThread(void);protected:	virtual void	*Run(void);};// ===========================================================================//	¥ UCleanupThread class// ===========================================================================class UCleanupThread : public LThread{private:					UCleanupThread(QHdr &inQueue, LSemaphore &inSem);	QHdr			&mQueue;	LSemaphore		&mSem;	friend class	LThread;protected:	virtual void	*Run(void);};// ===========================================================================//	¥ Debugging Support// ===========================================================================#if THREAD_DEBUG#	define THREAD_ASSERT(cond)	\		((void) ((cond) ? 0 : ThreadAssert(#cond, __FILE__, __LINE__)))#else#	define THREAD_ASSERT(cond)	((void) 0)#endif// ===========================================================================//	¥ Inline functions// ===========================================================================#if THREAD_INLINES#	include "LThreadInline.h"#endif#endif // _H_LThread