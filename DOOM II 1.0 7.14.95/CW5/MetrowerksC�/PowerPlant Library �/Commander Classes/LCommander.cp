// ===========================================================================//	LCommander.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	Public Services://		- Command handling					> ObeyCommand//		- Keystroke handling				> HandleKeyPress////	Public Manipulation://		- Arranging commander hierarchy		> SetSuperCommander//		- Target control					> GetTarget,//												SwitchTarget,//												RestoreTarget////	Methods to Override://		- Responding to Commands			> ObeyCommand//		- Adjusting Menu Items				> FindCommandStatus//		- Responding to Keystrokes			> HandleKeyPress//		- Behavior when On/Off Duty			> PutOnDuty, TakeOffDuty//		- Behavior when Is/IsNot Target		> BeTarget, DontBeTarget////		- Controlling SubCommanders			> AllowSubRemoval////		- Changing implementation of		> SetSuperCommander,//			commander hierarchy					AddSubCommander,//												RemoveSubCommander#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LCommander.h>#include <LList.h>#include <LListIterator.h>#include <PP_Messages.h>// === Static Member Variables ===LCommander*	LCommander::sTarget= nil;LCommander*	LCommander::sDefaultCommander = nil;// ---------------------------------------------------------------------------//		¥ LCommander// ---------------------------------------------------------------------------//	Default ConstructorLCommander::LCommander(){	InitCommander(GetDefaultCommander());}// ---------------------------------------------------------------------------//		¥ LCommander(const LCommander&)// ---------------------------------------------------------------------------//	Copy Constructor////	Makes a shallow copy; SubCommanders are not copied.LCommander::LCommander(	const LCommander	&inOriginal){	InitCommander(inOriginal.mSuperCommander);}// ---------------------------------------------------------------------------//		¥ LCommander(LCommander*)// ---------------------------------------------------------------------------//	Constructor, specifying SuperCommanderLCommander::LCommander(	LCommander	*inSuper){	InitCommander(inSuper);}// ---------------------------------------------------------------------------//		¥ InitCommander// ---------------------------------------------------------------------------//	Private function for initializing data members from ConstructorsvoidLCommander::InitCommander(	LCommander	*inSuper){	mOnDuty = triState_Off;	mSuperCommander = nil;	SetSuperCommander(inSuper);	SetDefaultCommander(this);}	// ---------------------------------------------------------------------------//		¥ ~LCommander// ---------------------------------------------------------------------------//	DestructorLCommander::~LCommander(){	if (IsOnDuty()) {			// If this Commander is on duty, then it or one of its			// SubCommanders is the Target. This means that the Target			// is going to be deleted.		sTarget->DontBeTarget();	}									// Delete all SubCommanders	LListIterator iterator(mSubCommanders, iterate_FromStart);	LCommander	*theSub;	while (iterator.Next(&theSub)) {		delete theSub;	}		if (this == sTarget) {			// Don't leave a dangling Target		SetTarget(mSuperCommander);	}		if (sDefaultCommander == this) {		SetDefaultCommander(nil);	// Don't leave a dangling Default Cmdr	}		SetSuperCommander(nil);			// Detach from SuperCommander}// ===========================================================================// ¥ Command Chain Maintenance					   Command Chain Maintenance ¥// ===========================================================================voidLCommander::SetSuperCommander(	LCommander	*inSuper){	if (mSuperCommander != nil) {		mSuperCommander->RemoveSubCommander(this);	}		mSuperCommander = inSuper;		if (inSuper != nil) {		inSuper->AddSubCommander(this);	}}LCommander*LCommander::GetSuperCommander(){	return mSuperCommander;}BooleanLCommander::AllowSubRemoval(	LCommander	*inSub){	return true;}BooleanLCommander::AttemptQuit(	long	inSaveOption){	Boolean	quitAllowed = true;	LListIterator iterator(mSubCommanders, iterate_FromStart);	LCommander	*theSub;	while (iterator.Next(&theSub) && quitAllowed) {		quitAllowed = theSub->AttemptQuit(inSaveOption);	}		if (quitAllowed) {		quitAllowed = AttemptQuitSelf(inSaveOption);	}			return quitAllowed;}BooleanLCommander::AttemptQuitSelf(	Int32	inSaveOption){	return true;}voidLCommander::AddSubCommander(	LCommander	*inSub){	mSubCommanders.InsertItemsAt(1, arrayIndex_Last, &inSub);}voidLCommander::RemoveSubCommander(	LCommander	*inSub){	mSubCommanders.Remove(&inSub);}// ===========================================================================// ¥ Target Handling										 Target Handling ¥// ===========================================================================// ---------------------------------------------------------------------------//		¥ GetTarget [static]// ---------------------------------------------------------------------------//	Return a pointer to the Commander that is the current Target//	Should be an inline function.LCommander*LCommander::GetTarget(){	return sTarget;}// ---------------------------------------------------------------------------//		¥ SetTarget [static]// ---------------------------------------------------------------------------//	Set the Target class variable. Called internally.voidLCommander::SetTarget(	LCommander	*inNewTarget){	sTarget = inNewTarget;	if (inNewTarget != nil) {		inNewTarget->BeTarget();	}}// ---------------------------------------------------------------------------//		¥ SwitchTarget [static]// ---------------------------------------------------------------------------//	Try to change Target and return whether the specified Commander did//	indeed become the Target.////	Target switch can fail if some Superior of the old and new Target//	disallows the switch (e.g., when performing data entry validation).BooleanLCommander::SwitchTarget(	LCommander	*inNewTarget){			// Exit if current and new target are the same	if (inNewTarget == sTarget) {		return true;	}	if (inNewTarget == nil) {			// New chain of command is empty			// Take off duty all commanders in current chain of command		if (sTarget != nil) {			sTarget->DontBeTarget();			sTarget->TakeChainOffDuty(nil);		}			} else if (sTarget == nil) {			// There is no current chain of command			// Put on duty all commanders in new chain		inNewTarget->PutChainOnDuty();			} else {					// Current and new targets both exist. We must determine			// where the current and new chains of command overlap.			// The "junction" is the deepest commander that is common to			// both the current and new chains of command--it is a			// Superior of both the current and new targets. Searching up			// from the new target, the first on duty commander is the			// junction.				LCommander	*junction = inNewTarget;		while ((junction != nil) && !junction->IsOnDuty()) {			junction = junction->mSuperCommander;		}					// Ask junction if it's OK to switch targets. The junction			// can refuse to allow the target to switch from one of its			// Subordinates to another.				Boolean	switchAllowed = true;		if (junction != nil) {			switchAllowed = junction->AllowTargetSwitch(inNewTarget);		}		if (!switchAllowed) {			return false;		}					// Switch is allowed. Tell current target that it will			// no longer be the target.				sTarget->DontBeTarget();					// Determine relative positions of current and new targets in			// the command chain. There are 3 possibilities.					if (junction == sTarget) {				// 1. New target is a sub commander of the current target			inNewTarget->PutChainOnDuty();	// Extend chain of command down to											// the new target													} else if (junction == inNewTarget) {				// 2. New target is a super commander of the current target											// Shorten chain of command up to											// the new target			sTarget->TakeChainOffDuty(inNewTarget);													} else {				// 3. New and current targets are on different branches											// Take off duty current chain up											// to, but not including, the											// junction			sTarget->TakeChainOffDuty(junction);			inNewTarget->PutChainOnDuty();	// Put on duty new chain		}	}		SetTarget(inNewTarget);			// Finally, change to new target	return true;}// ---------------------------------------------------------------------------//		¥ RestoreTarget// ---------------------------------------------------------------------------//	Set target to the Commander which was the target when this Commander//	was last on dutyvoidLCommander::RestoreTarget(){		// When a command chain is taken off duty, the top Commander		// is marked as off duty, while all its Subordinates that		// were on duty are marked as latent. To restore the command		// chain, we must set the new target to the deepest latent		// Subordinate. If there are no latent Subordinates, then		// this Commander is the new target.	LCommander	*newTarget = this;	// Start with this Commander										// Search downward for latent Subordinates	LCommander	*latentSub = GetLatentSub();	while (latentSub != nil) {		newTarget = latentSub;		latentSub = latentSub->GetLatentSub();	}		SwitchTarget(newTarget);}// ---------------------------------------------------------------------------//		¥ AllowTargetSwitch// ---------------------------------------------------------------------------//	Give permission to switch target to the specified Commander////	Both the current target and inNewTarget must be Subordinates of//	this Commander.////	This function passes the request up the command chain by//	calling AllowTargetSwitch for its SuperCommander.////	Subclasses should override this function if they wish to disallow//	a target switch under certain circumstances.BooleanLCommander::AllowTargetSwitch(	LCommander	*inNewTarget){	Boolean	allowSwitch = true;	if (mSuperCommander != nil) {		allowSwitch = mSuperCommander->AllowTargetSwitch(inNewTarget);	}	return allowSwitch;}// ---------------------------------------------------------------------------//		¥ BeTarget// ---------------------------------------------------------------------------//	Commander is becoming the Target////	Subclasses should override this function if they wish to behave//	differently when they are and are not the Target. At entry, the class//	variable sTarget points to this Commander.voidLCommander::BeTarget(){}// ---------------------------------------------------------------------------//		¥ DontBeTarget// ---------------------------------------------------------------------------//	Commander will no longer be the Target////	Subclasses should override this function if they wish to behave//	differently when they are and are not the Target. At entry, the class//	variable sTarget points to this Commander. sTarget will be changed//	soon afterwards to the new target.voidLCommander::DontBeTarget(){}// ---------------------------------------------------------------------------//		¥ IsTarget// ---------------------------------------------------------------------------//	Return whether this Commander is the TargetBooleanLCommander::IsTarget() const{	return (this == sTarget);}// ===========================================================================// ¥ On Duty Handling										On Duty Handling ¥// ===========================================================================// ---------------------------------------------------------------------------//		¥ IsOnDuty// ---------------------------------------------------------------------------//	Return whether this Command is on dutyBooleanLCommander::IsOnDuty() const{	return (mOnDuty == triState_On);}// ---------------------------------------------------------------------------//		¥ GetLatentSub// ---------------------------------------------------------------------------//	Find the latent SubCommander of a Commander////	A Commander may have one or no latent SubCommander.LCommander*LCommander::GetLatentSub(){	LCommander	*latentSub = nil;	LListIterator iterator(mSubCommanders, iterate_FromStart);	LCommander	*theSub;	while (iterator.Next(&theSub)) {		if (theSub->mOnDuty == triState_Latent) {			latentSub = theSub;			break;		}	}	return latentSub;}// ---------------------------------------------------------------------------//		¥ SetLatentSub// ---------------------------------------------------------------------------//	Specify the SubCommander that will be put on duty when this Commander//	is put on duty.////	Does nothing if this Commander is already on duty////	inSub may be nil, in which case this Commander will have no Latent//	SubCommander. This will also be the case if inSub is not a//	Subordinate of this Commander (which raises a Signal).voidLCommander::SetLatentSub(	LCommander	*inSub){		// A Commander can have a Latent SubCommander only if it		// is not currently on duty			if (mOnDuty != triState_On) {			LCommander	*mostLatent = this;		LCommander	*theCommander = inSub;		if (inSub != nil) {				// Verify that this Commander is a Superior of inSub			do {				theCommander = theCommander->mSuperCommander;				if (theCommander == this) {					break;				}			} while (theCommander != nil);						mostLatent = inSub;			if (theCommander == nil) {					// This Commander is not a Superior of inSub					// Treat the same as if inSub were nil				mostLatent = this;				SignalPStr_("\pinSub is not a subordinate");			}		}					// For all Commanders from mostLatent to "this", inclusive,			// turn off all currently latent SubCommanders					theCommander = mostLatent;		do {			LCommander	*currLatent = theCommander->GetLatentSub();			if (currLatent != nil) {				currLatent->mOnDuty = triState_Off;			}						if (theCommander == this) {				break;			}			theCommander = theCommander->mSuperCommander;		} while (true);					// Make Latent all Commanders from mostLatent up to,			// but not including, "this"				theCommander = mostLatent;		while (theCommander != this) {			theCommander->mOnDuty = triState_Latent;			theCommander = theCommander->mSuperCommander;		}	}}// ---------------------------------------------------------------------------//		¥ PutChainOnDuty// ---------------------------------------------------------------------------//	Put on duty a chain of Commanders////	This is a wrapper function that guarantees that a Commander can't be//	put on duty until all its Superiors are on duty.voidLCommander::PutChainOnDuty(){		// Recursive function. Must put SuperCommander on duty before		// this Commander can be put on duty. Recursion stops when reaching		// a Commander that is already on duty, or a Commander that has		// no SuperCommander	if (mOnDuty != triState_On) {		if (mSuperCommander != nil) {			mSuperCommander->PutChainOnDuty();		}				mOnDuty = triState_On;		PutOnDuty();	}}// ---------------------------------------------------------------------------//		¥ PutOnDuty// ---------------------------------------------------------------------------//	A Commander is going on duty////	Subclasses should override this function if they wish to behave//	differently when on duty than when off dutyvoidLCommander::PutOnDuty(){}// ---------------------------------------------------------------------------//		¥ TakeChainOffDuty// ---------------------------------------------------------------------------//	Take off duty a chain of Commanders////	This is a wrapper function that traverses a command chain from the//	Commander that firsts receives this message up to the specified//	Commander. The inUpToCmdr is *not* taken off duty.////	It is an error if inUpToCmdr is not a Superior of the Commander that//	first receives this message. Note that this includes the case where//	inUpToCmdr is the Commander that first receives this message (since a//	Commander is not a Superior of itself). nil is a valid value for//	inUpToCmdr, since the Commander at the top of a chain of command has//	a nil SuperCommander.voidLCommander::TakeChainOffDuty(	const LCommander	*inUpToCmdr){		// Recursive function. Move up chain of command until reaching		// the Commander whose SuperCommander is inUpToCmdr.				//		Chain of Cmd	OnDuty		//		------------	------		//		inUpToCmdr		On			Could be nil		//		cmdr 1			Off			SuperCommander is inUpToCmdr		//		cmdr 2			Latent		//		...				...		//		cmdr n			Latent		First to receive message		SignalIf_(mOnDuty != triState_On);		// DEBUG, must be on duty		mOnDuty = triState_Latent;	TakeOffDuty();		if (mSuperCommander == inUpToCmdr) {			// This is "cmdr 1" in the table above. Mark as "off" duty			// rather than "latent". Recursion stops here.		mOnDuty = triState_Off;			} else if (mSuperCommander != nil) {		mSuperCommander->TakeChainOffDuty(inUpToCmdr);	}}// ---------------------------------------------------------------------------//		¥ TakeOffDuty// ---------------------------------------------------------------------------//	A Commander is going off duty////	Subclasses should override this function if they wish to behave//	differently when on duty than when off dutyvoidLCommander::TakeOffDuty(){}// ===========================================================================// ¥ Command Handling										Command Handling ¥// ===========================================================================BooleanLCommander::ProcessCommand(	CommandT	inCommand,	void		*ioParam){	Boolean	cmdHandled = true;	if (ExecuteAttachments(inCommand, ioParam)) {		cmdHandled = ObeyCommand(inCommand, ioParam);	}	return cmdHandled;}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Issue a Command to a Commander////	Returns whether or not the command was handled////	Subclasses must override this method in order to respond to commands.BooleanLCommander::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean	cmdHandled = false;	if (mSuperCommander != nil) {		cmdHandled = mSuperCommander->ProcessCommand(inCommand, ioParam);	}	return cmdHandled;}voidLCommander::ProcessCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	SCommandStatus	status;	status.command = inCommand;	status.enabled = &outEnabled;	status.usesMark = &outUsesMark,	status.mark = &outMark;	status.name = outName;	if (ExecuteAttachments(msg_CommandStatus, &status)) {		FindCommandStatus(inCommand, outEnabled, outUsesMark, outMark, outName);	}}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	Return the status of a Command////	Subclasses must override to enable/disable and mark commands////	PowerPlant uses the enabling and marking information to set the//	appearance of Menu items.voidLCommander::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	if (mSuperCommander != nil) {		mSuperCommander->ProcessCommandStatus(inCommand, outEnabled,											outUsesMark, outMark, outName);	} else {		outEnabled = false;		// Query has reached the top of a command		outUsesMark = false;	//   chain without any object dealing with								//   it, so command is disabled and unmarked	}}// ---------------------------------------------------------------------------//		¥ IsSyntheticCommand [static]// ---------------------------------------------------------------------------//	Return whether a Command is synthetic. If so, pass back the associated//	Menu ID and item number. If not synthetic, outMenuID and outMenuItem//	are undefined.////	A synthetic command number has the Menu ID in the high 16 bits//	and the item number in the low 16 bits, with the result negatated.//		syntheticCmd = - (MenuID << 16) - ItemNumber//	A synthetic command is the negative of the value returned by//	the Toolbox traps MenuSelect and MenuKey.////	The LMenu and LMenBar classes return synthetic command numbers for//	menu items whose actual command number is cmd_UseMenuItem. You should//	use synthetic command numbers when the menu choice depends on the//	runtime name of the menu item. For example, an item in a Font menu.BooleanLCommander::IsSyntheticCommand(	CommandT	inCommand,	ResIDT		&outMenuID,	Int16		&outMenuItem){	Boolean	isSynthetic = false;	if (inCommand < 0) {				// A synthetic command is negative										// with a non-zero hi word		outMenuID = (Int16) ((-inCommand) >> 16);		if (outMenuID > 0) {			outMenuItem = (Int16) (-inCommand);			isSynthetic = true;		}	}	return isSynthetic;}// ===========================================================================// ¥ Keystroke Handling									  Keystroke Handling ¥// ===========================================================================BooleanLCommander::ProcessKeyPress(	const EventRecord	&inKeyEvent){	Boolean	keyHandled = true;	if( ExecuteAttachments(msg_KeyPress, (void*) &inKeyEvent)) {		keyHandled = HandleKeyPress(inKeyEvent);	}	return keyHandled;}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Tell Commander to handle a keystroke////	Returns whether or not the keystroke was handled////	Subclasses must override this function to respond to keystrokes. In//	general subclasses should call this function, which passes keystrokes//	up the command chain, if they do not handle a particular keystroke.////	In pseudo-code, a subclass's HandleKeyPress function might be://		if (inKeyEvent is a keystroke I handle) {//			do something with inKeyEvent//			return true;//		} else {//			return LCommander::HandleKeyPress(inKeyEvent);//		}BooleanLCommander::HandleKeyPress(	const EventRecord	&inKeyEvent){	Boolean	keyHandled = false;	if (mSuperCommander != nil) {		keyHandled = mSuperCommander->ProcessKeyPress(inKeyEvent);	}	return keyHandled;}// ===========================================================================// ¥ Default Commander									   Default Commander ¥// ===========================================================================////	The default commander is the commander which will be the SuperCommander//	of a Commander created using Object I/O. Presently, PowerPlant uses//	the default commander when creating Panes classes that are also derived//	from Commander.LCommander*LCommander::GetDefaultCommander(){	return sDefaultCommander;}voidLCommander::SetDefaultCommander(	LCommander	*inCommander){	sDefaultCommander = inCommander;}