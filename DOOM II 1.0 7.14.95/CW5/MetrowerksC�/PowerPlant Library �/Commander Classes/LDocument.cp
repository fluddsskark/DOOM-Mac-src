// ===========================================================================//	LDocument.cp					©1994 Metrowerks Inc. All rights reserved.// ===========================================================================////	A Document associates one or more Windows with one or more Files.//	LDocument is an abstract class which provides a framework for//	supporting standard document operations via AppleEvents.////	Standard Document operations are://		Save, SaveAs, Revert, and Print//	You can also check whether or not a Document is modified, meaning//	that it differs from its last saved version.////	Usage Note://		LDocument is an abstract class. The GetDescriptor() function//		is pure virtual. Subclasses must override this function and//		provide a definition. For example:////		class MyDocument : public LDocument {//		public://			virtual StringPtr	GetDescriptor(Str255 outDescriptor);//		};////		StringPtr MyDocument::GetDescriptor(Str255 outDescriptor)//		{//			::BlockMove("\pMyName", outDescriptor, 7);	// 6 + length byte//			return outDescriptor;//		}#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LDocument.h>#include <LModelProperty.h>#include <LListIterator.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <UDesktop.h>#include <UAppleEventsMgr.h>#include <UPrintingMgr.h>#ifndef __AEREGISTRY__#include <AERegistry.h>#endif#ifndef __AEOBJECTS__#include <AEObjects.h>#endif#ifndef __AEOBJECTPACKING__#include <AEPackObject.h>#endif#ifndef __STANDARDFILE__#include <StandardFile.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif// === Static Globals ===LList	LDocument::sDocumentList;// ---------------------------------------------------------------------------//		¥ LDocument// ---------------------------------------------------------------------------//	Default constructorLDocument::LDocument(){	mIsModified = false;	mIsSpecified = false;	mPrintRecordH = nil;	sDocumentList.InsertItemsAt(1, arrayIndex_Last, &this);}// ---------------------------------------------------------------------------//		¥ LDocument(LCommander*)// ---------------------------------------------------------------------------//	Constructor, specifying SuperCommanderLDocument::LDocument(	LCommander	*inSuper)		: LCommander(inSuper){	mIsModified = false;	mIsSpecified = false;	mPrintRecordH = nil;	sDocumentList.InsertItemsAt(1, arrayIndex_Last, &this);}// ---------------------------------------------------------------------------//		¥ ~LDocument// ---------------------------------------------------------------------------//	DestructorLDocument::~LDocument(){	if (mPrintRecordH != nil) {		DisposeHandle((Handle) mPrintRecordH);	}	sDocumentList.Remove(&this);}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanLDocument::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {			case cmd_Close:			AttemptClose(true);			break;			case cmd_Save:			if (mIsSpecified) {				SendSelfAE(kAECoreSuite, kAESave, false);				DoSave();				break;			}			// else *fall thru*, saving an unspecified document is the			// same as "SaveAs"					case cmd_SaveAs: {			FSSpec	fileSpec;			AskSaveAs(fileSpec, true);			break;		}					case cmd_Revert: {			Str255	docName;			ParamText(GetDescriptor(docName), "\p", "\p", "\p");			if (CautionAlert(ALRT_ConfirmRevert, nil) == ok) {				SendSelfAE(kAEMiscStandards, kAERevert, false);				DoRevert();			}			break;		}					case cmd_Print:			if (mPrintRecordH == nil) {				mPrintRecordH = UPrintingMgr::CreatePrintRecord();			}						if (mPrintRecordH != nil) {				UDesktop::Deactivate();				if (UPrintingMgr::AskPrintJob(mPrintRecordH)) {					SendSelfAE(kCoreEventClass, kAEPrint, false);					DoPrint();				}				UDesktop::Activate();							} else {				// ++ Couldn't allocate print record				// ++ User probably has no printer selected in Chooser			}			break;					case cmd_PrintOne:			if (mPrintRecordH == nil) {				mPrintRecordH = UPrintingMgr::CreatePrintRecord();			}			if (mPrintRecordH != nil) {				(**mPrintRecordH).prJob.iFstPage = 1;				(**mPrintRecordH).prJob.iLstPage = max_Pages;				(**mPrintRecordH).prJob.iCopies = 1;				SendSelfAE(kCoreEventClass, kAEPrint, false);				DoPrint();							} else {				// ++ Couldn't allocate print record				// ++ User probably has no printer selected in Chooser			}			break;					default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	Return whether a Command is enabled and/or marked (in a Menu)voidLDocument::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	outUsesMark = false;	switch (inCommand) {			case cmd_SaveAs:		case cmd_Print:		case cmd_PrintOne:			outEnabled = true;			break;					case cmd_Save:			outEnabled = IsModified() || !mIsSpecified;			break;					case cmd_Revert:			outEnabled = IsModified() && mIsSpecified;			break;					default:			LCommander::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			break;	}}voidLDocument::Close(){	if ((mSuperCommander == nil) || mSuperCommander->AllowSubRemoval(this)) {		delete this;	}}BooleanLDocument::IsModified(){	return mIsModified;}voidLDocument::SetModified(	Boolean	inModified){	mIsModified = inModified;}BooleanLDocument::AskSaveAs(	FSSpec	&outFSSpec,	Boolean	inRecordIt){	StandardFileReply	reply;	Str255				saveAsPrompt;	Str255				defaultName;	GetIndString(saveAsPrompt, STRx_Standards, str_SaveAs);		::UDesktop::Deactivate();	::StandardPutFile(saveAsPrompt, GetDescriptor(defaultName), &reply);	::UDesktop::Activate();		if (reply.sfGood) {		if (inRecordIt) {			SendAESaveAs(reply.sfFile, fileType_Default, false);		}		DoAESave(reply.sfFile, fileType_Default);		outFSSpec = reply.sfFile;	}		return reply.sfGood;}voidLDocument::AttemptClose(	Boolean	inRecordIt){	Boolean	closeIt = true;		if (IsModified()) {		FSSpec	fileSpec = {1, 1, "\p"};		Str63	appName;		::GetIndString(appName, STRx_Standards, str_ProgramName);		Str63	docName;		::ParamText(appName, GetDescriptor(docName), "\p", "\p");		UDesktop::Deactivate();		Int16 answer = ::CautionAlert(ALRT_SaveChangesClosing, nil);		UDesktop::Activate();				if (answer == answer_Save) {			if (mIsSpecified) {				DoSave();				SendAEClose(kAEYes, fileSpec, false);							} else {				closeIt = AskSaveAs(fileSpec, false);				SendAEClose(kAEYes, fileSpec, false);			}					} else if (answer == answer_Cancel) {			closeIt = false;					} else { // answer == answer_No			SendAEClose(kAENo, fileSpec, false);		}	}		if (closeIt) {		Close();	}}BooleanLDocument::AttemptQuitSelf(	Int32	inSaveOption){	Boolean	allowQuit = true;		if (IsModified()) {		if (inSaveOption == kAEYes) {			DoSave();			} else if (inSaveOption == kAEAsk) {			FSSpec	fileSpec = {1, 1, "\p"};			Str63	appName;			::GetIndString(appName, STRx_Standards, str_ProgramName);			Str63	docName;			::ParamText(appName, GetDescriptor(docName), "\p", "\p");			UDesktop::Deactivate();			Int16 answer = ::CautionAlert(ALRT_SaveChangesQuitting, nil);			UDesktop::Activate();						if (answer == answer_Save) {				if (mIsSpecified) {					DoSave();									} else {					allowQuit = AskSaveAs(fileSpec, false);				}							} else if (answer == answer_Cancel) {				allowQuit = false;							}		}	}		if (allowQuit) {		delete this;	}	return allowQuit;}voidLDocument::DoAEClose(	const AppleEvent	&inCloseAE){	OSErr		err;	DescType	theType;	Size		theSize;	FSSpec		fileSpec = {1, 1, "\p"};	Int32		saveOption = kAEAsk;		err = ::AEGetParamPtr(&inCloseAE, keyAESaveOptions,				typeEnumeration, &theType, &saveOption,				sizeof(Int32), &theSize);	err = AEGetParamPtr(&inCloseAE, keyAEFile, typeFSS, &theType,						&fileSpec, sizeof(FSSpec), &theSize);	if (saveOption == kAEYes) {		DoAESave(fileSpec, fileType_Default);		Close();			} else if (saveOption == kAEAsk) {		AttemptClose(false);			} else {		Close();	}}voidLDocument::DoAESave(	FSSpec	&inFileSpec,	OSType	inFileType){}voidLDocument::DoSave(){}voidLDocument::DoRevert(){}voidLDocument::DoPrint(){}// ===========================================================================// ¥ AppleEvent Object Model Support		 AppleEvent Object Model Support ¥// ===========================================================================voidLDocument::MakeSelfSpecifier(	AEDesc	&inSuperSpecifier,	AEDesc	&outSelfSpecifier) const{	Str255	docName;	GetDescriptor(docName);	StAEDescriptor	keyData;	OSErr	err = ::AECreateDesc(typeChar, docName + 1, docName[0],						&keyData.mDesc);	ThrowIfOSErr_(err);		err = ::CreateObjSpecifier(cDocument, &inSuperSpecifier, formName,								&keyData.mDesc, false, &outSelfSpecifier);	ThrowIfOSErr_(err);}voidLDocument::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	switch (inAENumber) {			case ae_Close:			DoAEClose(inAppleEvent);			break;			case ae_Save: {			OSErr		err;			DescType	theType;			Size		theSize;			FSSpec		fileSpec = {1, 1, "\p"};			err = AEGetParamPtr(&inAppleEvent, keyAEFile, typeFSS, &theType,								&fileSpec, sizeof(FSSpec), &theSize);			OSType		fileType = fileType_Default;			err = AEGetParamPtr(&inAppleEvent, keyAEFileType, typeType,								&theType, &fileType, sizeof(OSType), &theSize);			DoAESave(fileSpec, fileType);			break;		}				case ae_Revert:			DoRevert();			break;			case ae_Print:			DoPrint();			break;					default:			LModelObject::HandleAppleEvent(inAppleEvent, outAEReply,											outResult, inAENumber);			break;	}}DescTypeLDocument::GetModelKind() const{	return cDocument;}voidLDocument::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	OSErr	err;	switch (inProperty) {			case pName: {			Str255	docName;			GetDescriptor(docName);			err = AECreateDesc(typeChar, docName + 1, docName[0],								&outPropertyDesc);			break;		}			case pIsModified: {			// Has Document changed since last save?			Boolean	dirty = ((LDocument *) this)->IsModified();			err = AECreateDesc(typeBoolean, (Ptr) &dirty,								sizeof(Boolean), &outPropertyDesc);			break;		}					default:			LModelObject::GetAEProperty(inProperty, inRequestedType,											outPropertyDesc);			break;	}}voidLDocument::SendAESaveAs(	FSSpec	&inFileSpec,	OSType	inFileType,	Boolean	inExecute){	AppleEvent	theAppleEvent;	UAppleEventsMgr::MakeAppleEvent(kAECoreSuite, kAESave, theAppleEvent);		StAEDescriptor	docSpec;	MakeSpecifier(docSpec.mDesc);	OSErr err = AEPutParamDesc(&theAppleEvent, keyDirectObject,								&docSpec.mDesc);	ThrowIfOSErr_(err);		err = AEPutParamPtr(&theAppleEvent, keyAEFile, typeFSS, &inFileSpec,								sizeof(FSSpec));	ThrowIfOSErr_(err);		if (inFileType != fileType_Default) {		err = AEPutParamPtr(&theAppleEvent, keyAEFileType, typeType,									&inFileType, sizeof(OSType));		ThrowIfOSErr_(err);	}	UAppleEventsMgr::SendAppleEvent(theAppleEvent, inExecute);}voidLDocument::SendAEClose(	Int32	inSaveOption,	FSSpec	&inFileSpec,	Boolean	inExecute){	AppleEvent	theAppleEvent;	UAppleEventsMgr::MakeAppleEvent(kAECoreSuite, kAEClose, theAppleEvent);		StAEDescriptor	docSpec;	MakeSpecifier(docSpec.mDesc);	OSErr err = ::AEPutParamDesc(&theAppleEvent, keyDirectObject,								&docSpec.mDesc);	ThrowIfOSErr_(err);		err = ::AEPutParamPtr(&theAppleEvent, keyAESaveOptions, typeEnumeration,								&inSaveOption, sizeof(Int32));	ThrowIfOSErr_(err);		if ((inSaveOption == kAEYes) && (inFileSpec.parID != 1)) {		err = ::AEPutParamPtr(&theAppleEvent, keyAEFile, typeFSS, &inFileSpec,								sizeof(FSSpec));		ThrowIfOSErr_(err);	}	UAppleEventsMgr::SendAppleEvent(theAppleEvent, inExecute);}// ---------------------------------------------------------------------------//		¥ FindNamedDocument [static]// ---------------------------------------------------------------------------//	Return the Document with the specified nameLDocument*LDocument::FindNamedDocument(	Str255	inName){	LListIterator iterator(sDocumentList, iterate_FromStart);	LDocument	*theDoc = nil;	while (iterator.Next(&theDoc)) {		Str255	docName;		theDoc->GetDescriptor(docName);		if (IUEqualString(inName, docName) == 0) {			break;		}		theDoc = nil;	}		return theDoc;}