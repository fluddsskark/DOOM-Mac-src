// ===========================================================================//	LDocApplication.cp				©1993 Metrowerks Inc. All rights reserved.// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LDocApplication.h>#include <LDocument.h>#include <UAppleEventsMgr.h>#include <UPrintingMgr.h>#include <UDesktop.h>#include <PP_Messages.h>#ifndef __AEOBJECTS__#include <AEObjects.h>#endifLDocApplication::LDocApplication(){}LDocApplication::~LDocApplication(){}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanLDocApplication::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;	switch (inCommand) {			case cmd_New:			SendAECreateDocument();			break;					case cmd_Open:			ChooseDocument();			break;						case cmd_PageSetup:			SetupPage();			break;					default:			cmdHandled = LApplication::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}voidLDocApplication::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	outUsesMark = false;	switch (inCommand) {			case cmd_New:		case cmd_Open:		case cmd_PageSetup:			outEnabled = true;			break;					default:			LApplication::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			break;	}}voidLDocApplication::SendAEOpenDoc(	FSSpec	&inFileSpec){	Try_ {		AppleEvent	openEvent;		UAppleEventsMgr::MakeAppleEvent(kCoreEventClass, kAEOpen, openEvent);				OSErr err = ::AEPutParamPtr(&openEvent, keyDirectObject, typeFSS,								&inFileSpec, sizeof(FSSpec));		ThrowIfOSErr_(err);				UAppleEventsMgr::SendAppleEvent(openEvent);	}		Catch_(inErr) {		OpenDocument(&inFileSpec);	} EndCatch_}voidLDocApplication::SendAECreateDocument(){	Try_ {		AppleEvent	createDocEvent;		UAppleEventsMgr::MakeAppleEvent(kAECoreSuite, kAECreateElement,											createDocEvent);		DescType	docType = cDocument;		OSErr err = ::AEPutParamPtr(&createDocEvent, keyAEObjectClass,							typeType, &docType, sizeof(DescType));		ThrowIfOSErr_(err);		UAppleEventsMgr::SendAppleEvent(createDocEvent);	}		Catch_(inErr) {		MakeNewDocument();	} EndCatch_}voidLDocApplication::DoAEOpenOrPrintDoc(	const AppleEvent	&inAppleEvent,	AppleEvent&			outAEReply,	long				inAENumber){	AEDescList	docList;	OSErr		err = AEGetParamDesc(&inAppleEvent, keyDirectObject,							typeAEList, &docList);	ThrowIfOSErr_(err);		Int32	numDocs;	err = AECountItems(&docList, &numDocs);	ThrowIfOSErr_(err);			// Loop through all items in the list			// Extract descriptor for the document			// Coerce descriptor data into a FSSpec			// Tell Program object to open document			for (Int32 i = 1; i <= numDocs; i++) {		AEKeyword	theKey;		DescType	theType;		FSSpec		theFileSpec;		Size		theSize;		err = AEGetNthPtr(&docList, i, typeFSS, &theKey, &theType,							(Ptr) &theFileSpec, sizeof(FSSpec), &theSize);		ThrowIfOSErr_(err);		if (inAENumber == ae_OpenDoc) {			OpenDocument(&theFileSpec);		} else {			PrintDocument(&theFileSpec);		}	}		AEDisposeDesc(&docList);}voidLDocApplication::OpenDocument(	FSSpec	*inMacFSSpec){}voidLDocApplication::PrintDocument(	FSSpec	*inMacFSSpec){}LModelObject*LDocApplication::MakeNewDocument(){	return nil;}voidLDocApplication::ChooseDocument(){}voidLDocApplication::SetupPage(){	UDesktop::Deactivate();	UPrintingMgr::AskPageSetup(UPrintingMgr::GetDefaultPrintRecord());	UDesktop::Activate();}// ===========================================================================// ¥ Apple Event Handlers								Apple Event Handlers ¥// ===========================================================================voidLDocApplication::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	switch (inAENumber) {					case ae_OpenDoc:		case ae_PrintDoc:			DoAEOpenOrPrintDoc(inAppleEvent, outAEReply, inAENumber);			break;					default:			LApplication::HandleAppleEvent(inAppleEvent, outAEReply,								outResult, inAENumber);			break;	}}LModelObject*LDocApplication::HandleCreateElementEvent(	DescType			inElemClass,	DescType			inInsertPosition,	LModelObject*		inTargetObject,	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply){	switch (inElemClass) {			case cDocument:		case cWindow:			return MakeNewDocument();			break;					default:			return LApplication::HandleCreateElementEvent(inElemClass,						inInsertPosition, inTargetObject, inAppleEvent,						outAEReply);			break;	}}Int32LDocApplication::CountSubModels(	DescType	inModelID) const{	Int32	count = 0;	switch (inModelID) {			case cDocument: 			count = LApplication::CountSubModels(cWindow);			break;					default:			count = LApplication::CountSubModels(inModelID);			break;	}		return count;}voidLDocApplication::GetSubModelByPosition(	DescType		inModelID,	Int32			inPosition,	AEDesc			&outToken) const{	switch (inModelID) {			case cDocument:			ThrowOSErr_(errAENoSuchObject);			break;					default:			LApplication::GetSubModelByPosition(inModelID, inPosition,													outToken);			break;	}}voidLDocApplication::GetSubModelByName(	DescType		inModelID,	Str255			inName,	AEDesc			&outToken) const{	switch (inModelID) {			case cDocument: {			LDocument	*theDoc = LDocument::FindNamedDocument(inName);			if (theDoc == nil) {				ThrowOSErr_(errAENoSuchObject);			}			PutInToken(theDoc, outToken);			break;		}					default:			LApplication::GetSubModelByName(inModelID, inName, outToken);			break;	}}// ---------------------------------------------------------------------------//		¥ GetPositionOfSubModel// ---------------------------------------------------------------------------//	Return the position (1 = first) of a SubModel within an ApplicationInt32LDocApplication::GetPositionOfSubModel(	DescType			inModelID,	const LModelObject	*inSubModel) const{	switch (inModelID) {			case cDocument:			return 1;		// +++ find position			break;					default:			return LApplication::GetPositionOfSubModel(inModelID, inSubModel);			break;	}}