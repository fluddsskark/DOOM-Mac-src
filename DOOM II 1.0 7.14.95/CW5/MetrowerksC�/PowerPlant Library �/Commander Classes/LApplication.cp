// ===========================================================================//	LApplication.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LApplication.h>#include <LMenuBar.h>#include <LMenu.h>#include <LWindow.h>#include <LPeriodical.h>#include <LModelDirector.h>#include <LGrowZone.h>#include <LClipboard.h>#include <UPowerTools.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <UDesktop.h>#include <UWindows.h>#include <UAppleEventsMgr.h>#include <UEnvironment.h>#include <PP_Resources.h>#include <PP_Messages.h>#ifndef __AEOBJECTS__#include <AEObjects.h>#endif#ifndef __GESTALTEQU__#include <GestaltEqu.h>#endif#ifndef __DESK__#include <Desk.h>#endif#ifndef __LOWMEM__#include <LowMem.h>#endif#ifndef __RESOURCES__#include <Resources.h>#endif#ifndef __TEXTUTILS__#include <TextUtils.h>#endif#ifndef __DIALOGS__#include <Dialogs.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif#ifndef __DISKINIT__#include <DiskInit.h>#endif// ---------------------------------------------------------------------------//		¥ LApplication// ---------------------------------------------------------------------------//	Default constructorLApplication::LApplication(){	mState = programState_StartingUp;	SwitchTarget(this);		new LMenuBar(MBAR_Initial);			// Menu Bar	new LModelDirector(this);			// Apple Events			// The default sleep time is 6 ticks (0.1 seconds). You may		// wish to change this, either by setting mSleepTime directly		// in the constructor of your Application subclass or by		// calling SetSleepTime()			mSleepTime = 6;						// Event Handling	mMouseRgnH = NewRgn();											// Check for Color QuickDraw	Int32		qdVersion = gestaltOriginalQD;	::Gestalt(gestaltQuickdrawVersion, &qdVersion);	UEnvironment::SetFeature(env_SupportsColor,							 (qdVersion > gestaltOriginalQD));}// ---------------------------------------------------------------------------//		¥ ~LApplication// ---------------------------------------------------------------------------//	DestructorLApplication::~LApplication(){}// ===========================================================================// ¥ Accessors													   Accessors ¥// ===========================================================================EProgramStateLApplication::GetState(){	return mState;}voidLApplication::SetSleepTime(	const Int32 inSleepTime){	mSleepTime = inSleepTime;}// ---------------------------------------------------------------------------//		¥ StartUp// ---------------------------------------------------------------------------//	Perform actions at application start up when launched without any//	documents.////	Override if you wish to perform some default action, such as//	creating a new, untitled documentvoidLApplication::StartUp(){}voidLApplication::Run(){	::InitCursor();		mState = programState_ProcessingEvents;		while (mState != programState_Quitting) {		Try_ {			ProcessNextEvent();		}				Catch_(inErr) {			SignalPStr_("\pException caught in LApplication::Run");		} EndCatch_	}}voidLApplication::SendAEQuit(){								// Send Quit AppleEvent for recording only	AppleEvent	quitEvent;	UAppleEventsMgr::MakeAppleEvent(kCoreEventClass, kAEQuitApplication,							quitEvent);	UAppleEventsMgr::SendAppleEvent(quitEvent, false);		DoQuit();}voidLApplication::DoQuit(	Int32	inSaveOption){	if (AttemptQuit(inSaveOption)) {		mState = programState_Quitting;		LClipboard	*theClipboard = LClipboard::GetClipboard();		if (theClipboard != nil) {			theClipboard->Suspend();		}	}}// ---------------------------------------------------------------------------//		¥ ProcessNextEvent// ---------------------------------------------------------------------------//	Retrieve and handle the next event in the event queue voidLApplication::ProcessNextEvent(){	EventRecord		macEvent;		// When on duty (application is in the foreground), adjust the		// cursor shape before waiting for the next event. Except for the		// very first time, this is the same as adjusting the cursor		// after every event.		if (IsOnDuty()) {						// Calling OSEventAvail with a zero event mask will always			// pass back a null event. However, it fills the EventRecord			// with the information we need to set the cursor shape--			// the mouse location in global coordinates and the state			// of the modifier keys.					::OSEventAvail(0, &macEvent);		AdjustCursor(macEvent);	}			// Retrieve the next event. Context switch could happen here.		Boolean	gotEvent = ::WaitNextEvent(everyEvent, &macEvent, mSleepTime,										mMouseRgnH);			// Let Attachments process the event. Continue with normal		// event dispatching unless suppressed by an Attachment.		if (ExecuteAttachments(msg_Event, &macEvent)) {		if (gotEvent) {			DispatchEvent(macEvent);		} else {			UseIdleTime(macEvent);		}	}									// Repeaters get time after every event	LPeriodical::DevoteTimeToRepeaters(macEvent);}// ---------------------------------------------------------------------------//		¥ DispatchEvent// ---------------------------------------------------------------------------//	Identify event and call the appropriate member function to handle it voidLApplication::DispatchEvent(	const EventRecord&	inMacEvent){	switch (inMacEvent.what) {				case mouseDown:			AdjustCursor(inMacEvent);			EventMouseDown(inMacEvent);			break;					case mouseUp:			EventMouseUp(inMacEvent);			break;					case keyDown:			EventKeyDown(inMacEvent);			break;					case autoKey:			EventAutoKey(inMacEvent);			break;					case keyUp:			EventKeyUp(inMacEvent);			break;			case diskEvt:			EventDisk(inMacEvent);			break;					case updateEvt:			EventUpdate(inMacEvent);			break;					case activateEvt:			EventActivate(inMacEvent);			break;					case osEvt:			EventOS(inMacEvent);			break;					case kHighLevelEvent:			EventHighLevel(inMacEvent);			break;					default:			UseIdleTime(inMacEvent);			break;	}}voidLApplication::UseIdleTime(	const EventRecord	&inMacEvent){	LPeriodical::DevoteTimeToIdlers(inMacEvent);}voidLApplication::EventMouseDown(	const EventRecord	&inMacEvent){	WindowPtr	macWindowP;		Int16	thePart = ::FindWindow(inMacEvent.where, &macWindowP);		switch (thePart) {			case inMenuBar:			ClickMenuBar(inMacEvent);			break;					case inContent:			// Click occurred in a Window		case inDrag:		case inGrow:		case inGoAway:		case inZoomIn:		case inZoomOut:						// Check for the special case of clicking in an underlying				// window when the front window is modal.							if (macWindowP != ::FrontWindow()) {								// Clicked Window is not the front one				LWindow *frontW = LWindow::FetchWindowObject(FrontWindow());				if ( (frontW != nil) &&					 frontW->HasAttribute(windAttr_Modal) ) {					 			// Front Window is Modal					 			// Change part code to a special number.					 			//   The only exception is a command-Drag,					 			//   which moves, but does not re-order,					 			//   an underlying window.					 if ( (thePart != inDrag) ||					 	  !(inMacEvent.modifiers & cmdKey) ) {						thePart = click_OutsideModal;					}				}			}										// Dispatch click to Window object			LWindow	*theWindow = LWindow::FetchWindowObject(macWindowP);			if (theWindow != nil) {				theWindow->HandleClick(inMacEvent, thePart);			}			break;	}}voidLApplication::EventMouseUp(	const EventRecord	&inMacEvent){	LPane	*paneClicked = LPane::GetLastPaneClicked();	if (paneClicked != nil) {		paneClicked->EventMouseUp(inMacEvent);	}}voidLApplication::EventKeyDown(	const EventRecord	&inMacEvent){	long	keyCommand = cmd_Nothing;	if (LMenuBar::GetCurrentMenuBar()->CouldBeKeyCommand(inMacEvent)) {		UpdateMenus();		keyCommand = LMenuBar::GetCurrentMenuBar()->FindKeyCommand(inMacEvent);	}	SignalIf_(sTarget == nil);	if (keyCommand != cmd_Nothing) {		sTarget->ProcessCommand(keyCommand);		::HiliteMenu(0);	} else {		sTarget->ProcessKeyPress(inMacEvent);	}}// ---------------------------------------------------------------------------//		¥ EventAutoKey// ---------------------------------------------------------------------------//	Respond to an auto-key eventvoidLApplication::EventAutoKey(	const EventRecord	&inMacEvent){									// Treat the same as a single keystroke	sTarget->ProcessKeyPress(inMacEvent);}// ---------------------------------------------------------------------------//		¥ EventKeyUp// ---------------------------------------------------------------------------//	Respond to a key up event////	By default, the system masks out key up events. voidLApplication::EventKeyUp(	const EventRecord	&inMacEvent){}	// Do nothing// ---------------------------------------------------------------------------//		¥ EventDisk// ---------------------------------------------------------------------------//	Respond to a disk-inserted eventvoidLApplication::EventDisk(	const EventRecord	&inMacEvent){	if (HiWord(inMacEvent.message) != noErr) {				// Error mounting disk. Ask if user wishes to format it.				Point	pt = {120, 120};	// System 7 will auto-center dialog		::DILoad();		::DIBadMount(pt, inMacEvent.message);		::DIUnload();	}}voidLApplication::EventUpdate(	const EventRecord	&inMacEvent){	LWindow	*theWindow = LWindow::FetchWindowObject(									(WindowPtr) inMacEvent.message);	if (theWindow != nil) {		theWindow->UpdatePort();	}}voidLApplication::EventActivate(	const EventRecord	&inMacEvent){	LWindow	*theWindow = LWindow::FetchWindowObject(									(WindowPtr) inMacEvent.message);	if (theWindow != nil) {		if (inMacEvent.modifiers & activeFlag) {			theWindow->Activate();		} else {			theWindow->Deactivate();		}	}}voidLApplication::EventOS(	const EventRecord	&inMacEvent){	Uint8	osEvtFlag = ((Uint32) inMacEvent.message) >> 24;		if (osEvtFlag == mouseMovedMessage) {		UseIdleTime(inMacEvent);	} else if (osEvtFlag == suspendResumeMessage) {		if (inMacEvent.message & resumeFlag) {			EventResume(inMacEvent);		} else {			EventSuspend(inMacEvent);		}	}}voidLApplication::EventHighLevel(	const EventRecord	&inMacEvent){	OSErr	err = ::AEProcessAppleEvent(&inMacEvent);	ThrowIfOSErr_(err);}voidLApplication::ClickMenuBar(	const EventRecord	&inMacEvent){	UpdateMenus();	long	menuCmd = LMenuBar::GetCurrentMenuBar()->										MenuCommandSelection(inMacEvent);		if (menuCmd != cmd_Nothing) {		SignalIf_(sTarget == nil);		sTarget->ProcessCommand(menuCmd,  nil);		::HiliteMenu(0);	}}voidLApplication::EventSuspend(	const EventRecord	&inMacEvent){	LClipboard	*theClipboard = LClipboard::GetClipboard();	if (theClipboard != nil) {		theClipboard->Suspend();	}				::HiliteMenu(0);				// Unhighlight menu titles	UDesktop::Suspend();			// Desktop handles suspending Windows			// When in the background, the program does not receive		// keystrokes and menu commands. Therefore, no Commander		// is on duty, and the Target should be nil.			SwitchTarget(nil);}voidLApplication::EventResume(	const EventRecord	&inMacEvent){	if (inMacEvent.message & convertClipboardFlag) {		LClipboard	*theClipboard = LClipboard::GetClipboard();		if (theClipboard != nil) {			theClipboard->Resume();		}	}				UDesktop::Resume();				// Desktop handles resuming Windows		if (GetTarget() == nil) {				// Some Commander must be the Target when the program is			// in the foreground. No Window (or Window SubCommander)			// became the Target when the Desktop resumed, so we need			// to restore the Target here. The Target will be some			// Commander that's not part of a Window, possibly the			// Application itself.					RestoreTarget();	}}// ---------------------------------------------------------------------------//		¥ AdjustCursor// ---------------------------------------------------------------------------//	Adjust the shape of the cursor (mouse pointer)voidLApplication::AdjustCursor(	const EventRecord	&inMacEvent){									// Find out where the mouse is	WindowPtr	macWindowP;	Point		globalMouse = inMacEvent.where;	Int16		thePart = ::FindWindow(globalMouse, &macWindowP);		Boolean		useArrow = true;	// Assume cursor will be the Arrow		if (macWindowP != nil) {		// Mouse is inside a Window		LWindow	*theWindow = LWindow::FetchWindowObject(macWindowP);		if ((theWindow != nil) &&			theWindow->IsActive() &&			theWindow->IsEnabled()) {									// Mouse is inside an active and enabled									//   PowerPlant Window. Let the Window									//   adjust the cursor shape.																		// Get mouse location in Port coords			Point	portMouse = globalMouse;			theWindow->GlobalToPortPoint(portMouse);						theWindow->AdjustCursor(portMouse, inMacEvent);			useArrow = false;		}	}		if (useArrow) {					// Window didn't set the cursor									// Default cursor is the arrow					SetCursor(&UQDGlobals::GetQDGlobals()->arrow);	}				// Rather than trying to calculate an accurate mouse region,		// we define a region that contains just the one pixel where		// the mouse is located. This is quick, and handles the common		// case where this application is in the foreground but the user		// isn't doing anything. However, any mouse movement will generate		// a mouse-moved event.			::SetRectRgn(mMouseRgnH, globalMouse.h, globalMouse.v,							 globalMouse.h + 1, globalMouse.v + 1);}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to commandsBooleanLApplication::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;		ResIDT	theMenuID;	Int16	theMenuItem;	if (IsSyntheticCommand(inCommand, theMenuID, theMenuItem)) {			if (theMenuID == MENU_Apple) {									// Handle selection from the Apple Menu			Str255	appleItem;			::GetMenuItemText(GetMenuHandle(theMenuID), theMenuItem, appleItem);			::OpenDeskAcc(appleItem);					} else {			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);		}				} else {				switch (inCommand) {					case cmd_About:				ShowAboutBox();				break;							case cmd_Quit:				SendAEQuit();				break;							default:				cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);				break;		}	}		return cmdHandled;}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	Pass back whether a Command is enabled and/or marked (in a Menu)voidLApplication::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	outUsesMark = false;	switch (inCommand) {			case cmd_About:		case cmd_Quit:			outEnabled = true;			break;					case cmd_Undo:			outEnabled = false;			::GetIndString(outName, STRx_Standards, str_CantUndo);			break;					default:			LCommander::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			break;	}}// ---------------------------------------------------------------------------//		¥ UpdateMenus// ---------------------------------------------------------------------------//	Update the status of all menu itemsvoidLApplication::UpdateMenus(){	LMenuBar	*theMenuBar = LMenuBar::GetCurrentMenuBar();	Int16		menuItem;	MenuHandle	macMenuH;	LMenu		*theMenu;	CommandT	theCommand;	Boolean		isEnabled;	Boolean		usesMark;	Char16		mark;	Str255		itemName;										// Loop thru each menu item that has an									//   associated command	macMenuH = nil;	while (theMenuBar->FindNextCommand(menuItem, macMenuH,										theMenu, theCommand)) {																			// Don't change menu item state for special									//   commands (all negative values except									//   cmd_UseMenuItem)		if ((theCommand > 0) || (theCommand == cmd_UseMenuItem)) {											// For commands that depend on the menu									//   item, get synthetic command number			if (theCommand == cmd_UseMenuItem) {				theCommand = theMenu->SyntheticCommandFromIndex(menuItem);			}									// Ask Target if command is enabled,									//   if the menu item should be marked,									//   and if the name should be changed			itemName[0] = 0;			usesMark = false;						LCommander	*theTarget = GetTarget();			if (theTarget == nil) {				isEnabled = false;			} else {				theTarget->ProcessCommandStatus(theCommand, isEnabled, usesMark, mark,											itemName);			}						if (isEnabled) {				::EnableItem(macMenuH, menuItem);			} else {				::DisableItem(macMenuH, menuItem);			}						if (usesMark) {				::SetItemMark(macMenuH, menuItem, mark);			}						if (itemName[0] > 0) {				::SetMenuItemText(macMenuH, menuItem, itemName);			}		}	}										// Loop thru each menu	theMenu = nil;	while (theMenuBar->FindNextMenu(theMenu)) {				// The "command" for an entire Menu is the synthetic command			// number for item zero (negative number that has the Menu ID			// in the high word and 0 in the low word.		theCommand = theMenu->SyntheticCommandFromIndex(0);					// We call FindCommandStatus but aren't interested in the			// status of the Menu. PowerPlant calls this UpdateMenus			// function just after the user clicks in the MenuBar (or			// types a command-key equivalent). By this time, it's too			// late to hilite/dim a menu title (you wouldn't want a menu			// title to turn from black to gray when the user clicked on it).			// However, Commanders can respond to this status request by			// manipulating the items in a particular menu. For example,			// a text handling Commander could put a check mark next to			// the current font in a Fonts menu.					GetTarget()->FindCommandStatus(theCommand, isEnabled, usesMark, mark, itemName);	}}// ---------------------------------------------------------------------------//		¥ ShowAboutBox// ---------------------------------------------------------------------------//	Display the About Box for the Application////	This implementation just puts up an Alert Box. Override if you wish//	to display a more elaborate About Box.voidLApplication::ShowAboutBox(){	UDesktop::Deactivate();		// Alert will swallow Deactivate event	::Alert(ALRT_About, nil);	UDesktop::Activate();}// ===========================================================================// ¥ Apple Event Handlers								Apple Event Handlers ¥// ===========================================================================voidLApplication::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	switch (inAENumber) {			case ae_OpenApp:			StartUp();			break;					case ae_Quit:			DoQuit();			break;					default:			LModelObject::HandleAppleEvent(inAppleEvent, outAEReply,								outResult, inAENumber);			break;	}}Int32LApplication::CountSubModels(	DescType	inModelID) const{	Int32	count = 0;	switch (inModelID) {			case cWindow: {			WindowPeek	windowP = (WindowPeek) LMGetWindowList();			while (windowP != nil) {				count++;				windowP = windowP->nextWindow;			}			break;		}					default:			count = LModelObject::CountSubModels(inModelID);			break;	}		return count;}voidLApplication::GetSubModelByPosition(	DescType		inModelID,	Int32			inPosition,	AEDesc			&outToken) const{	switch (inModelID) {			case cWindow: {			WindowPtr	windowP = UWindows::FindNthWindow(inPosition);			if (windowP != nil) {				PutInToken(LWindow::FetchWindowObject(windowP), outToken);			} else {				ThrowOSErr_(errAENoSuchObject);			}			break;		}					default:			LModelObject::GetSubModelByPosition(inModelID, inPosition,													outToken);			break;	}}// ---------------------------------------------------------------------------//		¥ GetSubModelByName// ---------------------------------------------------------------------------//	Pass back a token to a SubModel specified by namevoidLApplication::GetSubModelByName(	DescType		inModelID,	Str255			inName,	AEDesc			&outToken) const{	switch (inModelID) {			case cWindow: {			WindowPtr	windowP = UWindows::FindNamedWindow(inName);			if (windowP != nil) {				PutInToken(LWindow::FetchWindowObject(windowP), outToken);			} else {				ThrowOSErr_(errAENoSuchObject);			}			break;		}					default:			LModelObject::GetSubModelByName(inModelID, inName, outToken);			break;	}}// ---------------------------------------------------------------------------//		¥ GetPositionOfSubModel// ---------------------------------------------------------------------------//	Return the position (1 = first) of a SubModel within an ApplicationInt32LApplication::GetPositionOfSubModel(	DescType			inModelID,	const LModelObject	*inSubModel) const{	switch (inModelID) {			case cWindow:			return UWindows::FindWindowIndex(								((LWindow*) inSubModel)->GetMacPort());			break;					default:			return LModelObject::GetPositionOfSubModel(inModelID, inSubModel);			break;	}}// ---------------------------------------------------------------------------//		¥ MakeSelfSpecifier// ---------------------------------------------------------------------------//	Make an Object Specifier for an ApplicationvoidLApplication::MakeSelfSpecifier(	AEDesc	&inSuperSpecifier,	AEDesc	&outSelfSpecifier) const{	outSelfSpecifier.descriptorType = typeNull;	outSelfSpecifier.dataHandle = nil;}