//	===========================================================================//	LCoreAEOM.cp					й1994 Metrowerks Inc. All rights reserved.//	===========================================================================//	===========================================================================/*	The purpose of this undocumented class is a buffer zone between	LModelObject and to provide more Core Suite features.  At the present it	adds support for sub model lists and an mKind for storing the model kind.*///	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LCoreAEOM.h"#include	<LList.h>#include	<UAEDesc.h>#include	<UAppleEventsMgr.h>#include	<UExtractFromAEDesc.h>#include	<LListIterator.h>#include	<LModelProperty.h>//	===========================================================================//	MaintenanceLCoreAEOM::LCoreAEOM(){	Assert_(false);		//	Parameters required}LCoreAEOM::LCoreAEOM(		LModelObject	*inSuperModel,		DescType		inKind)	:	LModelObject(inSuperModel)/*	By default objects are lazy and listless.*/{	mKind = inKind;	mLaziness = true;	mSubModels = NULL;	mSubCount = 0;}LCoreAEOM::~LCoreAEOM(){	Assert_(mSubCount <= 0);	if (mSubModels) {		//	Are there going to be orphan children with dangling		//	super model pointers?		Assert_(mSubModels->GetCount() == 0);				delete mSubModels;	}}	void	LCoreAEOM::SetSuperModel(LModelObject *inSuperModel){	if (mSuperModel)		mSuperModel->RemoveSubModel(this);	mSuperModel = inSuperModel;	if (mSuperModel)		mSuperModel->AddSubModel(this);}void	LCoreAEOM::SetModelKind(DescType inModelKind){	mKind = inModelKind;}void	LCoreAEOM::SetLaziness(Boolean inBeLazy)/*	SetLaziness is only useful during construction/initialization.		DO NOT change lazyiness after an object has been initialized.*/{	mLaziness = inBeLazy;}void	LCoreAEOM::SetUseSubModelList(Boolean inUseSubModelList){	if (inUseSubModelList != (mSubModels != NULL) ) {		if (inUseSubModelList)			mSubModels = new LList();		else {			Assert_(false);		//	shouldn't happen -- default is off			delete mSubModels;			mSubModels = NULL;		}	}}// ===========================================================================// Submodel list supportvoid	LCoreAEOM::AddSubModel(LModelObject *inSubModel){	mSubCount++;	if (mSubCount > 20) Assert_(false);	//	This should not be left in in debugged code.		if (!mSubModels)		return;	if (!mSubModels->FetchIndexOf(&inSubModel)) {		mSubModels->InsertItemsAt(1, arrayIndex_Last, &inSubModel);	} else {		Assert_(false);	}		Assert_(mSubCount == mSubModels->GetCount());}void	LCoreAEOM::RemoveSubModel(LModelObject *inSubModel){	mSubCount--;	Assert_(mSubCount >= 0);	if (!mSubModels)		return;			mSubModels->RemoveItemsAt(1, mSubModels->FetchIndexOf(&inSubModel));	Assert_(mSubCount == mSubModels->GetCount());}void	LCoreAEOM::Finalize(void){	LModelObject	*super = GetSuperModel();		if (!IsLazy())		return;	if (mSubCount > 0) {		//	Can't delete cause a sub model must still be referencing		//		this as a supermodel.		return;	}/*	done in inherited destructor	if (super)		super->RemoveSubModel(this);*/	delete this;	if (super)		super->Finalize();}Int32	LCoreAEOM::CountSubModels(	DescType	inModelID) const{	if (mSubModels) {		LListIterator	iterator(*mSubModels, iterate_FromStart);		Int32			count = 0;		LModelObject	*p;			while (iterator.Next(&p)) {			if ((p->GetModelKind() == inModelID) || (inModelID == typeWildCard))				count++;		}				if (count)			return count;	}	return inherited::CountSubModels(inModelID);}LCoreAEOM *	LCoreAEOM::GetSubModelForInsertion(	DescType		inInsertPosition,	LModelObject*	inTargetObject) const{	if (inInsertPosition != kAEReplace)		Throw_(errAENoSuchObject);	return (LCoreAEOM *)inTargetObject;}void	LCoreAEOM::GetSubModelByPosition(	DescType		inModelID,	Int32			inPosition,	AEDesc			&outToken) const/*	See LModelObject::GetSubModelByPosition		inPosition refers to the nth occurance of a submodel with	a GetModelKind of inModelID.*/{	if (mSubModels) {		LListIterator	iterator(*mSubModels, iterate_FromStart);		Int32			index = 0;		LModelObject	*p;		Boolean			found = false;				while (iterator.Next(&p)) {			if ((p->GetModelKind() == inModelID) || (inModelID == typeWildCard)) {				index++;				if (index == inPosition) {					found = true;					break;				}			}		}				if (found) {			PutInToken(p, outToken);			return;		}	}		inherited::GetSubModelByPosition(inModelID, inPosition, outToken);}void	LCoreAEOM::GetSubModelByName(	DescType		inModelID,	Str255			inName,	AEDesc			&outToken) const{/*	if (mSubModels) {		LListIterator	iterator(*mSubModels, iterate_FromStart);		LModelObject	*p;		Boolean			found = false;		StringPtr		str;				while (iterator.Next(&p)) {			if ((p->GetModelKind() == inModelID) || (inModelID == typeWildCard)) {//				if (member(p, LCoreAEOM)) {					str = ((LCoreAEOM *)p) ->GetModelNamePtr();					if (str) {						if (EqualString(str, inName, true, true)) {							found = true;							break;						}					}//				}			}		}				if (found) {			PutInToken(p, outToken);			return;		}	}*/		inherited::GetSubModelByName(inModelID, inName, outToken);}Int32	LCoreAEOM::GetPositionOfSubModel(	DescType			inModelID,	const LModelObject	*inSubModel) const/*	See LModelObject::GetPositionOfSubModel		Return value refers to the nth occurance of a submodel with	a GetModelKind of inModelID -- ie. NOT the nth item in the untyped	submodel list.*/{	if (mSubModels) {		LListIterator	iterator(*mSubModels, iterate_FromStart);		Int32			index = 0;		LModelObject	*p;		Boolean			found = false;				while (iterator.Next(&p)) {			if ((p->GetModelKind() == inModelID) || (inModelID == typeWildCard)) {				index++;				if (p == inSubModel)					return index;			}		}	}		return inherited::GetPositionOfSubModel(inModelID, inSubModel);}// ===========================================================================// AEOMBoolean		LCoreAEOM::IsLazy(void) const{	return mLaziness;}DescType	LCoreAEOM::GetModelKind(void) const{	return mKind;}LModelProperty*	LCoreAEOM::GetModelProperty(DescType inProperty){	return (new LModelProperty(inProperty, this));}void	LCoreAEOM::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	switch(inProperty) {		case pClass: {				DescType	value = GetModelKind();								UAEDesc::AddPtr(&outPropertyDesc, 0, typeType, &value, sizeof(value));			} break;				default:			inherited::GetAEProperty(inProperty, inRequestedType, outPropertyDesc);			break;	}}void LCoreAEOM::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	OSErr		err;	DescType	actualType;	Size		actualSize;	LModelObject *object = NULL;		switch (inAENumber) {		case ae_Clone:			HandleClone(inAppleEvent, outAEReply, outResult);Finalize();			break;		case ae_Move:			HandleMove(inAppleEvent, outAEReply, outResult);Finalize();			break;		case ae_CountElements:		{			DescType	classType;						err = AEGetKeyPtr(&inAppleEvent, keyAEObjectClass, typeType, &actualType,					&classType, sizeof(classType), &actualSize);			ThrowIfOSErr_(err);						HandleCount(classType, outAEReply);Finalize();			break;		}//		case ae_Create:						//	See LModelObject::HandleCreateElementEvent		case ae_Delete:			HandleDelete(outAEReply, outResult);Finalize();			break;		//		case ae_DoObjectsExist:				//	Implemented in LModelObject?//		case ae_GetClassInfo:				//	Not implemented		case ae_GetData:		case ae_GetDataSize:		case ae_SetData:		{			//	Must be referring to contents so...			//		simulate the content property.			LModelProperty	*content = new LModelProperty(pContents, this);						Try_ {				this->AddSubModel(NULL);	//	prevent any Finalize in HandleAppleEvent											//	from unzipping up the AEOM hiearchy.				content->HandleAppleEvent(inAppleEvent, outAEReply, outResult, inAENumber);				this->RemoveSubModel(NULL);			} Catch_ (err) {				content->Finalize();				this->RemoveSubModel(NULL);				Throw_(err);			} EndCatch_;Finalize();			break;		}		default:			inherited::HandleAppleEvent(inAppleEvent, outAEReply, outResult, inAENumber);			break;	}}void	LCoreAEOM::HandleCount(	DescType			&inKind,	AppleEvent			&outAEReply)/*	Derived classes probably do not need to override this method.*/{	Int32	count = CountSubModels(inKind);	OSErr	err;		err = AEPutParamPtr(&outAEReply, keyAEResult, typeLongInteger, &count, sizeof(count));}void	LCoreAEOM::HandleDelete(	AppleEvent			&outAEReply,	AEDesc				&outResult){	ThrowOSErr_(errAEEventNotHandled);}void	LCoreAEOM::HandleClone(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult){	OSErr			err;	StAEDescriptor	objData,					objProps,					target,					targAERecord,					nullDesc;	StAEDescriptor	createEvent,					replyEvent;	DescType		objectClass = GetModelKind();	//	ее	Get data for clone object	err = AECreateList(NULL, 0, true, &objProps.mDesc);	ThrowIfOSErr_(err);	this->GetImportantAEProperties(objProps.mDesc);	//	ее	Build create element event	UAppleEventsMgr::MakeAppleEvent(kAECoreSuite, kAECreateElement, createEvent.mDesc);	//	keyAEData	//		left empty -- all data (if any) goes through objProps		//	keyAEInsertHere	target.GetOptionalParamDesc(inAppleEvent, keyAEInsertHere, typeWildCard);	switch (target.mDesc.descriptorType) {		case typeNull:		{			//	make an insertion location specifier for after this object			DescType		relType = kAEAfter;			StAEDescriptor	temp,							temp2;					err = AECreateList(NULL, 0, true, &temp.mDesc);			ThrowIfOSErr_(err);				this->MakeSpecifier(temp2.mDesc);				err = AEPutParamDesc(&temp.mDesc, keyAEObject, &temp2.mDesc);			ThrowIfOSErr_(err);						err = AEPutParamPtr(&temp.mDesc, keyAEPosition, typeEnumerated, &relType, sizeof(relType));			ThrowIfOSErr_(err);				err = AECoerceDesc(&temp.mDesc, typeInsertionLoc, &target.mDesc);			ThrowIfOSErr_(err);			break;		}		case typeObjectSpecifier:		{			StAEDescriptor	classDesc;						UAEDesc::ParamDescFromDesc(target.mDesc, keyAEDesiredClass, typeType, &classDesc.mDesc);			UExtractFromAEDesc::TheType(classDesc.mDesc, objectClass);			break;		}		case typeInsertionLoc:		{			StAEDescriptor	classDesc;			StAEDescriptor	asAERecord;			StAEDescriptor	targRecord;						UAEDesc::ParamDescFromDesc(target.mDesc, keyAEObject, typeObjectSpecifier, &targRecord.mDesc);			UAEDesc::ParamDescFromDesc(targRecord.mDesc, keyAEDesiredClass, typeType, &classDesc.mDesc);			UExtractFromAEDesc::TheType(classDesc.mDesc, objectClass);			break;		}	}	err = AEPutKeyDesc(&createEvent.mDesc, keyAEInsertHere, &target.mDesc);	ThrowIfOSErr_(err);	//	keyAEObjectClass	err = AEPutKeyPtr(&createEvent.mDesc, keyAEObjectClass, typeType, &objectClass,		sizeof(objectClass));	ThrowIfOSErr_(err);		//	keyAEPropData	if (objProps.mDesc.descriptorType != typeNull) {		err = AEPutKeyDesc(&createEvent.mDesc, keyAEPropData, &objProps.mDesc);		ThrowIfOSErr_(err);	}	//	ее	Execute create element event (but don't record)	SendAppleEventWithReply(createEvent.mDesc, replyEvent.mDesc, false);		//	ее	Put result of create element event in reply	err = AEGetKeyDesc(&replyEvent.mDesc, keyAEResult, typeObjectSpecifier, &outResult);	ThrowIfOSErr_(err);}void	LCoreAEOM::HandleMove(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult){	OSErr			err;	StAEDescriptor	cloneResult,					cloneResultToken,					deleteResult;	LModelObject	*cloneResultObj = NULL;		//	ее	Clone behavior	//	//		If this is an offset based lazy object, the create element event	//		in the default HandleClone should "magically" update this object's	//		offsets as necessary.	this->HandleClone(inAppleEvent, outAEReply, cloneResult.mDesc);		//	ее	Delete behavior	//	//		If the object to be removed is also in a lazy offset object scheme, 	//		conversion to an LModelObject of the above cloneResult will allow 	//		the result object specifier (the new copy) to have its offsets	//		"magically" updated by the HandleDelete.	err = AEResolve(&cloneResult.mDesc, kAEIDoMinimum, &cloneResultToken.mDesc);	ThrowIfOSErr_(err);	cloneResultObj = GetModelFromToken(cloneResultToken.mDesc);	Try_ {			this->HandleDelete(outAEReply, deleteResult.mDesc);		//		//	Note:		//		//	As an aid for undo inside of a PowerPlant app, the HandleDelete		//	has already set the keyAEInsertHere parameter to the "hole" left by		//	the deletion.		//	Fill in the adjusted result		cloneResultObj->MakeSpecifier(outResult);				cloneResultObj->Finalize();		//	Ie. maybe delete	} Catch_(inErr) {		cloneResultObj->Finalize();		//	Ie. maybe delete		Throw_(inErr);	} EndCatch_;}void	LCoreAEOM::SendAppleEventWithReply(	AppleEvent			&inAppleEvent,	AppleEvent			&outAEReply,	Boolean				inRecord){	StAEDescriptor	theAEReply;	StAEDescriptor	aeResult;	OSErr			err;	AESendMode		mode = kAEWaitReply;	if (!inRecord)		mode |= kAEDontRecord;	err = AESend(&inAppleEvent, &outAEReply, mode, kAENormalPriority,						kAEDefaultTimeout, nil, nil);	ThrowIfOSErr_(err);}void	LCoreAEOM::GetImportantAEProperties(AERecord &outKeyDescList)/*	Get all important AE property data for this object.		"Important" includes things necessary for cloning.*/{	OSErr			err;	StAEDescriptor	contents,					reqType;		Assert_(outKeyDescList.descriptorType == typeAERecord);	this->GetAEProperty(pContents, reqType.mDesc, contents.mDesc);		err = AEPutKeyDesc(&outKeyDescList, pContents, &contents.mDesc);	ThrowIfOSErr_(err);}