//	===========================================================================//	UAEDesc.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"UAEDesc.h"#include	<UAppleEventsMgr.h>void	UAEDesc::AddDesc(	AEDesc			*ioDesc,		//	io descriptor or descriptor list	long			inIndex,		//	new/replace sub descriptor position (0 for append/don't care)	const AEDesc	&inDesc			//	new/replace sub descripter)/*	Places inDesc in ioDesc at position inIndex.		Will throw and exception if one occurs.*/{	OSErr	err = noErr;		if (ioDesc->descriptorType == typeNull) {		err = AEDuplicateDesc(&inDesc, ioDesc);		ThrowIfOSErr_(err);		return;	} 		//	Must end up being some sort of list	//		make descriptor a list	if (ioDesc->descriptorType != typeAEList) {		AEDesc		tempDesc = {typeNull, NULL};				err = AEDuplicateDesc(ioDesc, &tempDesc);		ThrowIfOSErr_(err);				err = AEDisposeDesc(ioDesc);		ThrowIfOSErr_(err);				err = AECreateList(NULL, 0, false, ioDesc);		ThrowIfOSErr_(err);				err = AEPutDesc(ioDesc, 0, &tempDesc);		ThrowIfOSErr_(err);				err = AEDisposeDesc(&tempDesc);		ThrowIfOSErr_(err);	}			//	Add data to the list	err = AEPutDesc(ioDesc, inIndex, &inDesc);	ThrowIfOSErr_(err);}void	UAEDesc::AddPtr(	AEDesc			*ioDesc,		//	io descriptor or descriptor list	long			inIndex,		//	new/replace sub descriptor position (0 for append/don't care)	DescType		inDescType,		//	new/replace sub descripter type	const void		*inDataPtr,		//	pointer to date for new sub descriptor	Size			inDataSize		//	size of data in inDataPtr)/*	ioDesc may be a NULL descriptor, a simple descriptor, or a list descriptor.	At function end it will be simple or list descriptor as appropriate.		If an error occurs, function will throw an appropriate exception.*/{	OSErr	err = noErr;		if (ioDesc->descriptorType == typeNull) {		err = AECreateDesc(inDescType, inDataPtr, inDataSize, ioDesc);		ThrowIfOSErr_(err);		return;	} 		//	Must end up being some sort of list	//		make descriptor a list	if (ioDesc->descriptorType != typeAEList) {		AEDesc		tempDesc = {typeNull, NULL};				err = AEDuplicateDesc(ioDesc, &tempDesc);		ThrowIfOSErr_(err);				err = AEDisposeDesc(ioDesc);		ThrowIfOSErr_(err);				err = AECreateList(NULL, 0, false, ioDesc);		ThrowIfOSErr_(err);				err = AEPutDesc(ioDesc, 0, &tempDesc);		ThrowIfOSErr_(err);				err = AEDisposeDesc(&tempDesc);		ThrowIfOSErr_(err);	}			//	Add data to the list	err = AEPutPtr(ioDesc, inIndex, inDescType, inDataPtr, inDataSize);	ThrowIfOSErr_(err);}void	UAEDesc::MakeRange(	const AEDesc	&inSuperSpecifier,	DescType		inKind,	Int32			inIndex1,	Int32			inIndex2,	AEDesc			*outDesc){	StAEDescriptor	defContainer,					desc1,					desc2,					ospec1,					ospec2,					rangeDesc;	AEDesc			*container;	Boolean			doRange = false;	OSErr			err;		if (inIndex2 > inIndex1)		doRange = true;		if (doRange) {		err = AECreateDesc(typeCurrentContainer, NULL, 0, &defContainer.mDesc);		ThrowIfOSErr_(err);				container = &defContainer.mDesc;	} else {		container = (AEDesc *)&inSuperSpecifier;	}	//	index1	Assert_(inIndex1 > 0);	//	0 is a bad number in the AEOM.	err = CreateOffsetDescriptor(inIndex1, &desc1.mDesc);	ThrowIfOSErr_(err);	if (doRange) {		err = CreateObjSpecifier(inKind, container,				formAbsolutePosition, &desc1.mDesc, false, &ospec1.mDesc);	} else {		err = CreateObjSpecifier(inKind, container,				formAbsolutePosition, &desc1.mDesc, false, outDesc);	}	ThrowIfOSErr_(err);		if (doRange) {		//	index2		err = CreateOffsetDescriptor(inIndex2, &desc2.mDesc);		ThrowIfOSErr_(err);		err = CreateObjSpecifier(inKind, container,				formAbsolutePosition, &desc2.mDesc, false, &ospec2.mDesc);		ThrowIfOSErr_(err);			//	range		err = CreateRangeDescriptor(&ospec1.mDesc, &ospec2.mDesc,				false, &rangeDesc.mDesc);		ThrowIfOSErr_(err);		Assert_(outDesc);		err = CreateObjSpecifier(inKind, (AEDesc *) &inSuperSpecifier,				formRange, &rangeDesc.mDesc, false, outDesc);		ThrowIfOSErr_(err);	}}void	UAEDesc::MakeInsertionLoc(	const AEDesc	&inObjSpec,	DescType		inPosition,	AEDesc			*outDesc){	StAEDescriptor	desc;	OSErr			err;		err = AECreateList(NULL, 0, true, &desc.mDesc);	ThrowIfOSErr_(err);	err = AEPutParamDesc(&desc.mDesc, keyAEObject, &inObjSpec);	ThrowIfOSErr_(err);		err = AEPutParamPtr(&desc.mDesc, keyAEPosition, typeEnumerated, &inPosition, sizeof(inPosition));	ThrowIfOSErr_(err);	Assert_(outDesc);	AEDisposeDesc(outDesc);	err = AECoerceDesc(&desc.mDesc, typeInsertionLoc, outDesc);	ThrowIfOSErr_(err);}void	UAEDesc::MakeBooleanDesc(Boolean inValue, AEDesc *outDesc){	Int8	value = inValue;	//	This might be required as Frontmost 1.0 apparently 								//	ONLY looks at the most significant byte of boolean								//	descriptor.	ThrowIfOSErr_( AECreateDesc(typeBoolean, (Ptr) &value, sizeof(value), outDesc) );}void	UAEDesc::ParamDescFromDesc(const AEDesc &inDesc, AEKeyword inKeyword, DescType inDesiredType, AEDesc *outDesc){	StAEDescriptor	asAERecord;	OSErr			err;		err = AECoerceDesc(&inDesc, typeAERecord, &asAERecord.mDesc);	ThrowIfOSErr_(err);		err = AEGetParamDesc(&asAERecord.mDesc, inKeyword, inDesiredType, outDesc);	ThrowIfOSErr_(err);}