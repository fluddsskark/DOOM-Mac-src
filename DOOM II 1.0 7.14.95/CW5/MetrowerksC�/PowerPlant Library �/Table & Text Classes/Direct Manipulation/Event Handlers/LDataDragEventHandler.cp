//	===========================================================================//	LDataDragEventHandler.cp		©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LDataDragEventHandler.h"#include	<LSelection.h>#include	<LSelectableItem.h>#include	<LAESemanticAction.h>#include	<UAppleEventsMgr.h>#include	<UDrawingState.h>#include	<UMemoryMgr.h>#include	<Errors.h>// #include	<AERegistry.h>// #include	<AEObjects.h>#include	<LDragTube.h>#include	<LSelectHandlerView.h>#define	ZOOMSTEPS	12#define	DragTask	LDataDragTask::sActiveTask//	===========================================================================//	MaintenanceDragSendDataUPP			LDataDragEventHandler::sDragSendDataUPP							= NewDragSendDataProc(LDropArea::HandleDragSendData);Boolean	LDataDragEventHandler::sPreScrollWasHilited;LDataDragEventHandler::LDataDragEventHandler():	LDropArea(UQDGlobals::GetCurrentPort()){	Assert_(false);	//	Parameters required}LDataDragEventHandler::LDataDragEventHandler(LSelection *inSelection, LSemanticUndoer *inUndoer):	LDragEventHandler(inSelection, inUndoer),	LDropArea(UQDGlobals::GetCurrentPort()){	mReceiver = NULL;	mPossibleReceiver = NULL;}LDataDragEventHandler::~LDataDragEventHandler(){	SHARED_OBJ_REPLACE_REF(mReceiver, NULL);	SHARED_OBJ_REPLACE_REF(mPossibleReceiver, NULL);}void	LDataDragEventHandler::Reset(void){	OSErr	err = noErr;	LDragEventHandler::Reset();			SHARED_OBJ_REPLACE_REF(mReceiver, NULL);	SHARED_OBJ_REPLACE_REF(mPossibleReceiver, NULL);		Try_ {		delete DragTask;		DragTask = NULL;	} Catch_(err) {		DragTask = NULL;	} EndCatch_;}LDataDragTask	*	LDataDragEventHandler::MakeDragTask(	LDataDragEventHandler	*inHandler,	Boolean					inHandlerIsSource){	return new LDataDragTask(inHandler, inHandlerIsSource);}//	===========================================================================//	Drag actions:DataDragT	LDataDragEventHandler::FindDragSemantic(void){	OSErr			err;	DragAttributes	attributes;	DataDragT		rval;	short			modifiers,					downModifiers,					upModifiers;		err = GetDragAttributes(DragTask->mDragRef, &attributes);	ThrowIfOSErr_(err);		if (!(attributes & dragInsideSenderApplication))		Throw_(paramErr);	//	Can't be here because sender does the drag.		if ((attributes & dragInsideSenderWindow) &&		(DragTask->mSourceHandler == DragTask->mReceiveHandler) )		rval = dataDrag_Move;	else		rval = dataDrag_Copy;		err = GetDragModifiers(DragTask->mDragRef, &modifiers, &downModifiers, &upModifiers);	ThrowIfOSErr_(err);		if ((upModifiers & optionKey) || (downModifiers & optionKey))		rval = dataDrag_Copy;	//	dataDrag_OSpec & Link could be determined through overriding and examing	//	modifiers.		return rval;}//	===========================================================================//	New features -- data dragging:#if	__profile__	#include	<StProfile.h>#endifvoid	LDataDragEventHandler::DataDragDo(void){	OSErr			err;	RgnHandle		dragRgn = NULL;	Point			origin = {0,0};	Boolean			dragDone = false;	Assert_(mReceiver == NULL);	Assert_(mPossibleReceiver == NULL);	Assert_(mSelection);	Assert_(sDragSendDataUPP);		Try_ {#if	__profile__		StProfile	instrumentedProfilingForThisBlock;#endif		//	Make the drag... task & tube		{			DragTask = MakeDragTask(this, true);					Assert_(DragTask->mDragTube == NULL);			DragTask->mDragTube = new LDragTube(DragTask->mDragRef, mSelection);						//	Use send data callback			err = SetDragSendProc(DragTask->mDragRef, sDragSendDataUPP, (LDropArea *)this);			ThrowIfOSErr_(err);		}		//	Drag outline...		dragRgn = mSelection->FindDragOutline(mEvtRecord.where);		ThrowIfNULL_(dragRgn);		/*			It is merely a matter of convention but...			the "origin less" drag outlines made by LDragEventHandler			need to be converted to the global origin regions			used by the OS Drag Manager.		*/		LocalToGlobal(&origin);		origin.h += mEvtRecord.where.h;		origin.v += mEvtRecord.where.v;		OffsetRgn(dragRgn, origin.h, origin.v);		ThrowIfOSErr_(QDError());		Try_ {			//	Do the drag tracking any maybe the actual transfer...			err = TrackDrag(DragTask->mDragRef, &mEvtRecord, dragRgn);						//	If transfer was delayed, make sure it is now done.			if (err == noErr) {				DragTask->DoTransfer();				dragDone = true;			}		} Catch_(err) {			//	Rejection zoom			Point		startPt,						endPt,						zoomVector;			OSErr		newErr;						OffsetRgn(dragRgn, -origin.h, -origin.v);			newErr = GetDragMouse(DragTask->mDragRef, &startPt, &endPt);			Assert_(newErr == noErr);			endPt = mEvtRecord.where;			zoomVector.h = endPt.h - startPt.h;			zoomVector.v = endPt.v - startPt.v;			origin.h = origin.v = 0;			LocalToGlobal(&origin);			origin.h += startPt.h;			origin.v += startPt.v;			OffsetRgn(dragRgn, origin.h, origin.v);			newErr = ZoomRegion(dragRgn, zoomVector, ZOOMSTEPS, zoomDecelerate);			Assert_(newErr == noErr);				if (err != userCanceledErr)				Throw_(err);		} EndCatch_;				//	Accepting zoom		//	???		//	Clean up...				Try_ {			delete DragTask;			DragTask = NULL;		} Catch_(err) {			DragTask = NULL;		} EndCatch_;		if (mReceiver)			mReceiver->UnDrawSelfReceiver();		SHARED_OBJ_REPLACE_REF(mReceiver, NULL);		SHARED_OBJ_REPLACE_REF(mPossibleReceiver, NULL);		DisposeRgn(dragRgn);		SetEvtState(evtl_idle);			} Catch_(inErr) {			Try_ {			delete DragTask;			DragTask = NULL;		} Catch_(err) {			DragTask = NULL;		} EndCatch_;		if (mReceiver)			mReceiver->UnDrawSelfReceiver();		SHARED_OBJ_REPLACE_REF(mReceiver, NULL);		SHARED_OBJ_REPLACE_REF(mPossibleReceiver, NULL);		if (dragRgn)			DisposeRgn(dragRgn);		SetEvtState(evtl_idle);		Throw_(inErr);	} EndCatch_;}//	---------------------------------------------------------------------------//	Receive Handlersvoid	LDataDragEventHandler::DataDragMoveIn(void){	if (DragTask->mSourceHandler != this) {		mPreDragState = GetEvtState();		SetEvtState(evtl_dragging);		mDragType = dragType_Data;	}		if (mReceiver)		mReceiver->UnDrawSelfReceiver();	SHARED_OBJ_REPLACE_REF(mReceiver, NULL);	SHARED_OBJ_REPLACE_REF(mPossibleReceiver, NULL);}void	LDataDragEventHandler::DataDragMoveOut(void){	if (mReceiver)		mReceiver->UnDrawSelfReceiver();	SHARED_OBJ_REPLACE_REF(mReceiver, NULL);	SHARED_OBJ_REPLACE_REF(mPossibleReceiver, NULL);	if (DragTask->mSourceHandler != this) {		SetEvtState(mPreDragState);	}		if (DragTask->mSourceHandler == NULL) {		delete DragTask;		DragTask = NULL;	}}void	LDataDragEventHandler::DataDragTrackMove(void){	Point			mouse,					temp;	OSErr			err;	LSelectableItem	*itemFound,					*newReceiver;			err = GetDragMouse(DragTask->mDragRef, &mouse, &temp);	ThrowIfOSErr_(err);	temp = mouse;	GlobalToLocal(&mouse);		mEvtMouse = mouse;	CheckBoundaryDrag();		mouse = temp;	GlobalToLocal(&mouse);	itemFound = OverItem(mouse);	SHARED_OBJ_REPLACE_REF(mPossibleReceiver, itemFound);	newReceiver = mPossibleReceiver;		//	Filter out if receiver is the selection & in the sender drop area	if (newReceiver) {		if (DragTask->mSourceHandler) {			if (DragTask->mSourceHandler == this) {				if (mSelection) {					if (!mSelection->IndependentFrom(newReceiver))						newReceiver = NULL;				}			}		}	}		//	Filter out if receiver can't receive the drop	if (newReceiver) {		Assert_(DragTask->mDragTube != NULL);		if (newReceiver->PickFlavorFrom(DragTask->mDragTube) == typeNull)			newReceiver = NULL;	}	if (mReceiver != newReceiver) {		if (mReceiver)			mReceiver->UnDrawSelfReceiver();		SHARED_OBJ_REPLACE_REF(mReceiver, newReceiver);		if (mReceiver)			mReceiver->DrawSelfReceiver();				}		if (mReceiver)		mReceiver->DrawSelfReceiverTick();}void	LDataDragEventHandler::PreScroll(Point inVector){	LDragEventHandler::PreScroll(inVector);		if (mReceiver)		mReceiver->UnDrawSelfReceiver();	if (mIsHilited) {		sPreScrollWasHilited = true;	//	DragPreScroll(mDragRef, -inVector.h, -inVector.v);		HideDragHilite(DragTask->mDragRef);	//	Above would be better but exact scroll amounts are needed.		mIsHilited = false;	} else {		sPreScrollWasHilited = false;	}}void	LDataDragEventHandler::PostScroll(Point inVector){	LDragEventHandler::PostScroll(inVector);		if (sPreScrollWasHilited) {	//	DragPostScroll(mDragRef);		HiliteDropArea(DragTask->mDragRef);	//	Above would be better but exact scroll amounts are needed.  		mIsHilited = true;	}	if (mReceiver)		mReceiver->DrawSelfReceiver();}Boolean LDataDragEventHandler::PtInBoundaryArea(Point inWhere){	Boolean	rval;		if (mDragType == dragType_Data)		rval = !PtInRect(inWhere, &mBDArea) && PtInRect(inWhere, &mBDAreaOutside);	else		rval = LDragEventHandler::PtInBoundaryArea(inWhere);	return rval;}//	===========================================================================//	Implementation:void	LDataDragEventHandler::CheckDragRef(DragReference inDragRef){	if (DragTask) {		if (DragTask->mDragRef != inDragRef)			Throw_(paramErr);	} else {		DragTask = MakeDragTask(this);		DragTask->mDragRef = inDragRef;		DragTask->CheckTube();	}}Boolean	LDataDragEventHandler::PointInDropArea(Point inGlobalPt){	Point	localPt = inGlobalPt;		mView->GlobalToPortPoint(localPt);	mView->PortToLocalPoint(localPt);		return PtInRect(localPt, &mMouseBounds);}void	LDataDragEventHandler::SetMouseBounds(const Rect &inBounds){	LDragEventHandler::SetMouseBounds(inBounds);}void	LDataDragEventHandler::NoteDragStart(void){//	A block until composite data tubes are functionalif (mSelection->ListCount() > 1)	return;	Boolean	dataMove = false;		if (mEvtThing) {		switch(mEvtThing->ItemType()) {			case kSelection:				dataMove = mSelectionCanMove;				break;		}	}	if (dataMove && DragAndDropIsPresent()) {		if (mEvtThing->ItemType() != kSelection)			Throw_(paramErr);		mDragType = dragType_Data;		DataDragDo();	} else {		LDragEventHandler::NoteDragStart();	}}LSelectableItem *	LDataDragEventHandler::OverItemSelf(Point inWhere){	LSelectableItem *rval = LDragEventHandler::OverItemSelf(inWhere);		if (rval)		return rval;		if (mReceiver)		if (mReceiver->PointInRepresentation(inWhere))			return mReceiver;		if (mPossibleReceiver)		if (mPossibleReceiver->PointInRepresentation(inWhere))			return mPossibleReceiver;		return NULL;}//	===========================================================================//	Implementation -- DropArea:void	LDataDragEventHandler::EnterDropArea(	DragReference	inDragRef,	Boolean			inDragHasLeftSender){	CheckDragRef(inDragRef);			Try_ {		LDropArea::EnterDropArea(inDragRef, inDragHasLeftSender);		mBDHasEntered = false;	//	Ugly fix -- should be somewhere else.		DataDragMoveIn();	} Catch_(inErr) {		SHARED_OBJ_REPLACE_REF(mReceiver, NULL);		SHARED_OBJ_REPLACE_REF(mPossibleReceiver, NULL);		Throw_(inErr);	} EndCatch_;}void	LDataDragEventHandler::LeaveDropArea(	DragReference	inDragRef){	CheckDragRef(inDragRef);		Try_ {		DataDragMoveOut();		LDropArea::LeaveDropArea(inDragRef);	} Catch_(inErr) {		SHARED_OBJ_REPLACE_REF(mReceiver, NULL);		SHARED_OBJ_REPLACE_REF(mPossibleReceiver, NULL);		Throw_(inErr);	} EndCatch_;}void	LDataDragEventHandler::InsideDropArea(	DragReference	inDragRef){	CheckDragRef(inDragRef);		Try_ {		LDropArea::InsideDropArea(inDragRef);		DataDragTrackMove();	} Catch_(inErr) {		SHARED_OBJ_REPLACE_REF(mReceiver, NULL);		SHARED_OBJ_REPLACE_REF(mPossibleReceiver, NULL);		Throw_(inErr);	} EndCatch_;}void	LDataDragEventHandler::DoDragReceive(DragReference inDragRef){	CheckDragRef(inDragRef);	DragTask->mReceiveHandler = this;	SHARED_OBJ_REPLACE_REF(DragTask->mReceiver, mReceiver);	DragTask->NoteTransfer();}void	LDataDragEventHandler::DoDragSendData(	FlavorType		inFlavor,	ItemReference	inItemRef,	DragReference	inDragRef){	CheckDragRef(inDragRef);		DragTask->NoteTransfer();		LTubeableItem	*item = (LTubeableItem *) inItemRef;		//	item itself sends the data	Assert_(DragTask->mDragTube);				//	??? what about finding the actual sub tube?	item->SendFlavorTo(inFlavor, DragTask->mDragTube);}Boolean	LDataDragEventHandler::DragIsAcceptable(	DragReference	inDragRef){	return true;	//	Assume receivability -- mReceiver will make					//	the final decision.}void	LDataDragEventHandler::FocusDropArea(void){	Assert_(mView);	mView->FocusDraw();}void	LDataDragEventHandler::HiliteDropArea(	DragReference	inDragRef){	Rect	dropRect;		Assert_(mView);	mView->CalcLocalFrameRect(dropRect);//	::InsetRect(&dropRect, 1, 1);		RgnHandle	dropRgn = ::NewRgn();	::RectRgn(dropRgn, &dropRect);	::ShowDragHilite(inDragRef, dropRgn, true);	::DisposeRgn(dropRgn);}