//	===========================================================================//	LSelectionEventHandler.cp		©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LSelectionEventHandler.h"#include	<LSelection.h>#include	<LSelectableItem.h>#include	<LAESemanticAction.h>#include	<LSemanticUndoer.h>#include	<UCursor.h>#include	<LModelProperty.h>#include	<AERegistry.h>#include	<LSelectHandlerView.h>//	===========================================================================//	MaintenanceLSelectionEventHandler::LSelectionEventHandler(){	Assert_(false);		//	Parameters required}LSelectionEventHandler::LSelectionEventHandler(LSelection *inSelection, LSemanticUndoer *inUndoer){	mAllowSingleGestureMove = false;	mSelection = inSelection;	Assert_(mSelection);	mSelection->OwnershipClaimed(this);		mUndoer = inUndoer;	mEvtThing = NULL;	mEvtManipulator = NULL;	mEvtSelection = NULL;	mEvtItem = NULL;	mClickInLastSelection = false;	mSelectionCanMove = false;}LSelectionEventHandler::~LSelectionEventHandler(){	ClearAction();	//	eradicate any lingering action	SHARED_OBJ_REPLACE_REF(mEvtThing, NULL);	SHARED_OBJ_REPLACE_REF(mEvtManipulator, NULL);	SHARED_OBJ_REPLACE_REF(mEvtSelection, NULL);	SHARED_OBJ_REPLACE_REF(mEvtItem, NULL);		SHARED_OBJ_REPLACE_REF(mSelection, NULL);}void	LSelectionEventHandler::Reset(void){	OSErr	err = noErr;	Try_ {		mSelection->FixSelection();	} Catch_(err) {	} EndCatch_;	inherited::Reset();	mClickInLastSelection = false;	mSelectionCanMove = false;	SHARED_OBJ_REPLACE_REF(mEvtThing, NULL);	SHARED_OBJ_REPLACE_REF(mEvtManipulator, NULL);	SHARED_OBJ_REPLACE_REF(mEvtSelection, NULL);	SHARED_OBJ_REPLACE_REF(mEvtItem, NULL);}Boolean		LSelectionEventHandler::GetAllowSingleGestureDrag(void){	return mAllowSingleGestureMove;}void	LSelectionEventHandler::SetAllowSingleGestureDrag(Boolean inValue){	mAllowSingleGestureMove = inValue;}//	===========================================================================//	Overridesvoid	LSelectionEventHandler::NoteOverNewThing(LManipulator *inThing)/*	This function is called with appropriate parameters when	the mouse is over a new manipulator or newly over no manipulator	(inItem will be NULL).		Override & inherit to provide for cursor shape feedback on based on	mouse position over manipulators, selectable items, or selections	(check inItem->ItemType() to determine which).*/{	if (mView)		mView->NoteOverNewThing(inThing);}void	LSelectionEventHandler::NoteOverNewThingSelf(LManipulator *inThing){	if (inThing) {		switch(inThing->ItemType()) {			case kSelectableItem:				UCursor::Tick(cu_Arrow);				break;			case kManipulator:			case kSelection:				UCursor::Tick(cu_Hand);				break;		}	} else {		UCursor::Tick(cu_Arrow);	}}LManipulator *	LSelectionEventHandler::OverManipulator(Point inWhere){	LManipulator *rval = mView->OverManipulator(inWhere);		if (rval)		return rval;		return OverManipulatorSelf(inWhere);}LSelection *	LSelectionEventHandler::OverSelection(Point inWhere){	LSelection *rval = mView->OverSelection(inWhere);		if (rval)		return rval;		return OverSelectionSelf(inWhere);}LSelectableItem *	LSelectionEventHandler::OverItem(Point inWhere){	LSelectableItem *rval = mView->OverItem(inWhere);		if (rval)		return rval;		return OverItemSelf(inWhere);}LManipulator *	LSelectionEventHandler::OverManipulatorSelf(Point inWhere)/*	If overridden, inherit this method.  In the overriding method,	return the inherited rval if it is non-NULL.*/{	if (mEvtManipulator)		if (mEvtManipulator->PointInRepresentation(inWhere))			return mEvtManipulator;				return NULL;}LSelection *	LSelectionEventHandler::OverSelectionSelf(Point inWhere)/*	Clients likely will not need to override this method.*/{/*	Note this checks mSelection and not mEvtSelection -- mEvtSelection	can pretty much be considered a Boolean flag.*/	if (mSelection)		if (mSelection->PointInRepresentation(inWhere))			return mSelection;		return NULL;}LSelectableItem *	LSelectionEventHandler::OverItemSelf(Point inWhere){	if (mEvtItem)		if (mEvtItem->PointInRepresentation(inWhere))			return mEvtItem;		return NULL;}Boolean	LSelectionEventHandler::OverDifferentThing(				const Point		inWhere,		//	local coordinates				LManipulator	*inOldThing,	//	Old item pointer				LManipulator	**outNewThing	//	Location for new item ptr.)/*	Note, if overridden, method SHOULD give priority to items in the order:			Manipulators (not selections or selectable items)		Selections		Selectable items			See the code below for an example on the selections.*/{	LManipulator	*itemFound = NULL;		Assert_(outNewThing != NULL);		if (mInBounds)		itemFound = OverManipulator(inWhere);	SHARED_OBJ_REPLACE_REF(mEvtManipulator, (LManipulator *)itemFound);		if (mInBounds)		itemFound = OverSelection(inWhere);	SHARED_OBJ_REPLACE_REF(mEvtSelection, (LSelection *)itemFound);	if (mInBounds)		itemFound = OverItem(inWhere);	SHARED_OBJ_REPLACE_REF(mEvtItem, (LSelectableItem *)itemFound);	do {		itemFound = mEvtManipulator;		if (itemFound)			break;				itemFound = mEvtSelection;		if (itemFound)			break;				itemFound = mEvtItem;	} while (false);		//	Return	if (itemFound != inOldThing) {		*outNewThing = itemFound;		return true;	} else {		return false;	}}//	===========================================================================//	New featuresvoid	LSelectionEventHandler::SelectSimple(void)/*	Called when an item (mEvtItem) is clicked on.*/{	if (mSelection)		mSelection->SelectSimple(mEvtItem);}void	LSelectionEventHandler::SelectContinuous(void)/*	Called when an item (mEvtItem) is shift-clicked on.*/{	if (mSelection)		mSelection->SelectContinuous(mEvtItem);}void	LSelectionEventHandler::SelectDiscontinuous(void)/*	Called when an item (mEvtItem) is command-clicked on.*/{	if (mSelection)		mSelection->SelectDiscontinuous(mEvtItem);}void	LSelectionEventHandler::PostAction(LSemanticAction *inAction)/*	To which class should this really belong?*/{	if (mUndoer)		mUndoer->PostAction(inAction);	else {		if (inAction)			inAction->Redo();		delete inAction;	}}void	LSelectionEventHandler::ClearAction(void){	if (mUndoer)		mUndoer->ClearAction();}//	===========================================================================//	Implementationvoid	LSelectionEventHandler::SetEvtThing(LManipulator *inThing){	if (inThing != mEvtThing) {		SHARED_OBJ_REPLACE_REF(mEvtThing, inThing);				//	Notification of being over new item		NoteOverNewThing(mEvtThing);	}}void	LSelectionEventHandler::NoteNthClick(Int16 inClickCount, Point inWhere){	mClickInLastSelection = false;	mSelectionCanMove = false;		if (mSelection)		mClickInLastSelection = mSelection->PointInRepresentation(inWhere);		switch (inClickCount) {		case 1:			if (mEvtRecord.modifiers & cmdKey) {				SelectDiscontinuous();			} else if (mEvtRecord.modifiers & shiftKey) {				SelectContinuous();			} else {				if (!mClickInLastSelection)					SelectSimple();				//	else					//	wait till mouse up for a simple select on the item -- maybe					//	it will become a drag.			}			break;				default:			break;	}	//	Determine mSelectionCanMove	if (mAllowSingleGestureMove) {		CheckCursor();		mSelectionCanMove = (mEvtSelection != NULL);	} else {		if (mClickInLastSelection) {			if (mSelection->PointInRepresentation(inWhere))				mSelectionCanMove = true;			else				CheckCursor();	//	Something was deselected -- fix cursor.		}	}}void	LSelectionEventHandler::MouseMove(void){	inherited::MouseMove();		switch(GetEvtState()) {		case evtl_dragging:		case evtl_idle:			CheckCursor();			break;	}}void	LSelectionEventHandler::MouseUp(void){	switch (GetEvtState()) {		case evtl_maybeDrag:		case evtl_clickCounting:			if (mClickInLastSelection && (mEvtClickCount == 1)) {				if ( !(mEvtRecord.modifiers & (cmdKey | shiftKey))) {					SelectSimple();	//	A click through de-selection / selection				}			}			break;					default:			break;	}		inherited::MouseUp();		//	Make sure cursor stays up to date if there was	//	a new item selected...	CheckCursor();}void	LSelectionEventHandler::CheckCursor(void){	LManipulator	*tempThing;		inherited::CheckCursor();		switch (GetEvtState()) {		case evtl_idle:		case evtl_clickCounting:		case evtl_maybeDrag:			if (OverDifferentThing(mEvtMouse, mEvtThing, &tempThing)) {				SetEvtThing(tempThing);			}			break;	}}