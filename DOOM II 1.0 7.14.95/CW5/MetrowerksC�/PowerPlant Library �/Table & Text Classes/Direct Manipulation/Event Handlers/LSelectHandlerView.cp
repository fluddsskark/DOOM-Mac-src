//	===========================================================================//	LSelectHandlerView.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LSelectHandlerView.h"#include	<LSelection.h>#include	<LSelectionEventHandler.h>#include	<UAEDesc.h>#include	<PP_Messages.h>#include	<LSemanticUndoer.h>#include	<LAESemanticAction.h>#include	<LClipboardTube.h>#include	<LList.h>#include	<LListIterator.h>#include	<LTargeter.h>#include	<UDrawingState.h>#include	<LWindow.h>#include	<Desk.h>//	===========================================================================//	MaintenanceLSelectHandlerView::LSelectHandlerView()	:	LMiscAEOM(NULL, typeNull){	SetLaziness(false);		mSelection = NULL;	mEventHandler = NULL;	mFocusBox = NULL;}LSelectHandlerView::LSelectHandlerView(LModelObject *inSuperModel, DescType inModelKind)	:	LMiscAEOM(inSuperModel, inModelKind){	SetLaziness(false);		mSelection = NULL;	mEventHandler = NULL;	mFocusBox = NULL;}LSelectHandlerView::LSelectHandlerView(LStream *inStream)	:	LView(inStream)	,	LMiscAEOM(NULL, typeNull){	SetLaziness(false);	mSelection = NULL;	mEventHandler = NULL;	mFocusBox = NULL;}LSelectHandlerView::~LSelectHandlerView(){	mFocusBox = NULL;	//	A view is automatically deleted}LSelection *	LSelectHandlerView::GetSelection(void){	return mSelection;}LEventHandler *	LSelectHandlerView::GetEventHandler(void){	return mEventHandler;}//	===========================================================================//	Called by mEventHandler (override)void	LSelectHandlerView::NoteOverNewThing(LManipulator *inThing)/*	When overriding, calling this inherited method will take care of several	things for you.		Typically you would have a block something like:			if (inThing) {		switch(inThing->ItemType()) {					case kManipulator:				UCursor::Tick(?);						//	A cursor for a manipulator				break;							case kSelectableItem:				UCursor::Tick(?);						//	A cursor for a selectable object				break;			case kSelection:				inherited::NoteOverNewThing(inThing);	//	Default data drag "hand"				break;						}	} else {		UCursor::Set(?);	}*/{	if (mEventHandler)		mEventHandler->NoteOverNewThingSelf(inThing);}/*	Override these to link in application specific manipulators and	selectable items.		Shared object policy warning:		1)		See the external documentation.				2)		When implementing your "model" be sure it follows shared object		policies on its selectable items.  Ie, when a selectable item is		constructed, make the "model" claim ownership on that selectable		item.  That claim should not be released until the model is destroyed.				3)		Note that manipulators, selectable items, and selections are shared		objects and their use must follow shared object policies.  So...				If methods derived from those below store a manipulator, selectable		item, or a selection pointer in any semi-persistent variable, that		variable and its use must follow shared object policies.  A "semi-		persistent variable" in this case is any variable that will retain		reference to a manipulator, selectable item, or selection past the		lifetime of the given Over... method call.				Also note that it is the caller's responsibility to follow shared		object policies on the returned value.  Meaning:  don't call		OwnershipClaimed for the return value.  Since typically only event		handlers will call these methods, you wont have to be concerned		with any of this.  In most cases a method such as below will be		sufficient:					LManipulator * CAModelView::OverSelectableItem(Point inWhere)			{				LManipulator	*rval = inherited::OverSelectableItem(inWhere);								if (rval)					return rval;								rval = myModel->FindSelectableItemFromPoint(inWhere);								return rval;			}*/LManipulator *		LSelectHandlerView::OverManipulator(Point inWhere)/*	See large note above.*/{	LManipulator	*rval = NULL;		if (mEventHandler)		rval = mEventHandler->OverManipulatorSelf(inWhere);		return rval;}LSelectableItem *	LSelectHandlerView::OverItem(Point inWhere)/*	See large note above.*/{	LSelectableItem	*rval = NULL;		if (mEventHandler)		rval = mEventHandler->OverItemSelf(inWhere);		return rval;}LSelection *		LSelectHandlerView::OverSelection(Point inWhere)/*	You should not need to override this method!		It is included in this section for completeness.*/{	LSelection	*rval = NULL;		if (mEventHandler)		rval = mEventHandler->OverSelectionSelf(inWhere);		return rval;}//	===========================================================================//	Linkage from subclassesvoid	LSelectHandlerView::DrawSelfSelection(void){	if (mSelection)		mSelection->Draw();}//	===========================================================================//	Linkage to LEventHandlervoid	LSelectHandlerView::Click(	SMouseDownEvent	&inMouseDown){	Boolean			delaySelect = inMouseDown.delaySelect;	EventRecord		event;	Boolean			isNonTargetDrag;	Point			localPt;		isNonTargetDrag = !IsTarget();	isNonTargetDrag = isNonTargetDrag && mEventHandler && mSelection;	if (isNonTargetDrag) {		localPt = inMouseDown.whereLocal;		PortToLocalPoint(localPt);				isNonTargetDrag = mSelection->PointInRepresentation(localPt);		//	Conditional to allow picking of only already selected elements...		//	otherwise selection could be changed w/o bringing a window to		//	the foreground.  That would be a Mac HI violation.	}		if (!isNonTargetDrag) {		LView::Click(inMouseDown);	} else {		LView::OutOfFocus(NULL);		FocusDraw();				//	sort of LPane::Click(inMouseDown);		inMouseDown.delaySelect = true;		inMouseDown.whereLocal = localPt;		UpdateClickCount(inMouseDown);				if (ExecuteAttachments(msg_Click, &inMouseDown)) {			ClickSelf(inMouseDown);		}		//	Track click		do {			//	Stuff an event.			GetMouse(&event.where);			LocalToGlobal(&event.where);			event.when = TickCount();			event.modifiers = (Button()) ? btnState : 0;			if (event.modifiers & btnState)				event.what = nullEvent;	//	MouseMoved			else				event.what = mouseUp;					mEventHandler->DoEvent(event);						SystemTask();	//	Be cooperative					} while (event.what != mouseUp);				//	To be on the safe side...		GlobalToLocal(&event.where);	}}void	LSelectHandlerView::ClickSelf(const SMouseDownEvent &inMouseDown){	FocusDraw();		if (IsActive() && !IsTarget() && !inMouseDown.delaySelect)		SwitchTarget(this);			if (mEventHandler)			mEventHandler->DoEvent(inMouseDown.macEvent);}void	LSelectHandlerView::EventMouseUp(const EventRecord &inMacEvent){	EventRecord	rec = inMacEvent;	LView::EventMouseUp(inMacEvent);	FocusDraw();		if (mEventHandler)		mEventHandler->DoEvent(rec);}void	LSelectHandlerView::SpendTime(const EventRecord &inMacEvent){	EventRecord	rec = inMacEvent;		FocusDraw();		if (mEventHandler)		mEventHandler->DoEvent(rec);}Boolean	LSelectHandlerView::HandleKeyPress(const EventRecord &inKeyEvent){	Boolean	rval = false;		FocusDraw();		//	Event handlers not yet trusted with command key events...	if (inKeyEvent.what == keyDown && (inKeyEvent.modifiers & cmdKey)) {		rval = LCommander::HandleKeyPress(inKeyEvent);	} else {		rval = true;		if (mEventHandler) 			rval = mEventHandler->DoEvent(inKeyEvent);	}	return rval;}void	LSelectHandlerView::AdjustCursorSelf(	Point				inPortPt,	const EventRecord	&inMacEvent){	/*	NOT!			if (mEventHandler) {			FocusDraw();			mEventHandler->DoEvent(inMacEvent);		}				NOT!			LApplication doesn't process a "Null event" to AdjustCursor but just		returns the "current" event.  Doing so will mess up the event handler		state machine.		*/}//	===========================================================================//	Linkage to LSelectionvoid	LSelectHandlerView::Draw(	RgnHandle	inSuperDrawRgnH){	LView::Draw(inSuperDrawRgnH);		DrawSelfSelection();}void	LSelectHandlerView::ActivateSelf(void){	LView::ActivateSelf();		FocusDraw();	FixHandlerFrame();	FocusDraw();	if (mEventHandler) {		StartIdling();		mEventHandler->Activate();	}}void	LSelectHandlerView::DeactivateSelf(void){	LView::DeactivateSelf();	FocusDraw();	if (mEventHandler) {		StopIdling();		mEventHandler->Deactivate();	}}void	LSelectHandlerView::BeTarget(void){	FocusDraw();	LCommander::BeTarget();		OutOfFocus(NULL);	FocusDraw();	if (mSelection)		mSelection->Activate();	if (mFocusBox)		mFocusBox->ShowFocus();		FocusDraw();}void	LSelectHandlerView::DontBeTarget(void){	FocusDraw();	LCommander::DontBeTarget();		OutOfFocus(NULL);	FocusDraw();	if (mSelection)		mSelection->Deactivate();		if (mFocusBox)		mFocusBox->HideFocus();		FocusDraw();}void	LSelectHandlerView::SetFocusBox(LTargeter *inFocusBox){	mFocusBox = inFocusBox;}//	===========================================================================//	AEOM Misc suite (clipboard) supportvoid	LSelectHandlerView::HandleCut(AppleEvent &outAEReply){	StAEDescriptor	result,					deleteReply,					insertLoc;	OSErr			err;	HandleCopy(outAEReply);		err = AECreateList(NULL, 0, true, &deleteReply.mDesc);	ThrowIfOSErr_(err);		mSelection->HandleDelete(deleteReply.mDesc, result.mDesc);	insertLoc.GetOptionalParamDesc(deleteReply.mDesc, keyAEInsertHere, typeWildCard);	if (insertLoc.mDesc.descriptorType != typeNull) {		err = AEPutParamDesc(&outAEReply, keyAEResult, &insertLoc.mDesc);		ThrowIfOSErr_(err);	}}void	LSelectHandlerView::HandleCopy(AppleEvent &outAEReply){	LClipboardTube	tube(mSelection);}void	LSelectHandlerView::HandlePaste(AppleEvent &outAEReply){	OSErr			err;	LClipboardTube	tube;	mSelection->ReceiveDataFrom(&tube);		//	As an added bonus (so that undo will work easy for text like things), 	//	lets add the resulting selection descriptor as a reply...	StAEDescriptor	result,					typeWanted;	DescType		type = typeWildCard;		err = AECreateDesc(typeType, &type, sizeof(type), &typeWanted.mDesc);	ThrowIfOSErr_(err);	mSelection->GetAEValue(typeWanted.mDesc, result.mDesc); 	err = AEPutParamDesc(&outAEReply, keyAEResult, &result.mDesc);	ThrowIfOSErr_(err);}void	LSelectHandlerView::HandleRedo(	AppleEvent			&outAEReply){	Throw_(errAEEventNotHandled);}void	LSelectHandlerView::HandleUndo(	AppleEvent			&outAEReply){	Throw_(errAEEventNotHandled);}//	===========================================================================//	ImplementationLModelProperty *	LSelectHandlerView::GetModelProperty(	DescType	inProperty){	LModelProperty	*theProperty = nil;		switch (inProperty) {		case pSelection:FocusDraw();	//	A real lazy way of making sure the view is prepared IF, the associated				//	event this pane to be prepared.			theProperty = mSelection;			break;					default:			theProperty = LCoreAEOM::GetModelProperty(inProperty);	}		return theProperty;}void	LSelectHandlerView::ResizeFrameBy(	Int16	inWidthDelta, 	Int16	inHeightDelta,	Boolean	inRefresh){	LView::ResizeFrameBy(inWidthDelta, inHeightDelta, inRefresh);		FixHandlerFrame();}void	LSelectHandlerView::ScrollImageBy(	Int32		inLeftDelta,	Int32		inTopDelta,	Boolean		inRefresh){	LView::ScrollImageBy(inLeftDelta, inTopDelta, inRefresh);		FixHandlerFrame();}void	LSelectHandlerView::SetImageLocation(const SPoint32 &inLocation)/*	Function should be part of LView*/{	SPoint32	delta;	delta.h = inLocation.h - mImageLocation.h;	delta.v = inLocation.v - mImageLocation.v;	mImageLocation.h = inLocation.h;	// Move Image	mImageLocation.v = inLocation.v;	CalcPortOrigin();	OutOfFocus(this);		LListIterator iterator(mSubPanes, iterate_FromStart);	LPane	*theSub;	while (iterator.Next(&theSub)) {		theSub->AdaptToSuperScroll(delta.h, delta.v);	}		if (mSuperView != nil) {		mSuperView->SubImageChanged(this);	}		FixHandlerFrame();	#ifdef	DEBUGRECTS		FocusDraw();		DrawDebugRects();	#endif}void	LSelectHandlerView::FixHandlerFrame(void){	Rect	frame;	Boolean	b;		b = CalcLocalFrameRect(frame);	Assert_(b);		if (mEventHandler)		mEventHandler->SetMouseBounds(frame);}//	===========================================================================//	Clipboard / selection support...		Boolean	LSelectHandlerView::ObeyCommand(	CommandT	inCommand,	void*		ioParam){	Boolean				cmdHandled = true;	LSemanticAction		*action = NULL;	OSErr				err;		switch(inCommand) {			case cmd_Cut:			action = MakeCutAction();			PostAction(action);			UpdatePort();			cmdHandled = true;			break;		case cmd_Copy:		{			StAEDescriptor	ae,							aeTarget;						//	Copy does nothing to be undone...			this->MakeSpecifier(aeTarget.mDesc);			PostAction(NULL);	//	copy is problematic with recording typing!			if (mSelection)				mSelection->RecordPresentSelection();			UAppleEventsMgr::MakeAppleEvent(kAEMiscStandards, kAECopy, ae.mDesc);			err = AEPutParamDesc(&ae.mDesc, keyDirectObject, &aeTarget.mDesc);			ThrowIfOSErr_(err);			UAppleEventsMgr::SendAppleEvent(ae.mDesc);			cmdHandled = true;			break;		}		case cmd_Paste:			action = MakePasteAction();			PostAction(action);			UpdatePort();			cmdHandled = true;			break;		case cmd_Clear:			action = MakeClearAction();			PostAction(action);			UpdatePort();			cmdHandled = true;			break;		case msg_TabSelect:			//	Want the command handled but don't want the selection changed.			cmdHandled = true;			break;					default:			OutOfFocus(NULL);			FocusDraw();			cmdHandled = LSemanticUndoer::ObeyCommand(inCommand, ioParam);			break;	}	return cmdHandled;}void	LSelectHandlerView::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	switch (inCommand) {		case cmd_Copy:		case cmd_Clear:		case cmd_Cut:		case cmd_Paste:		case cmd_SelectAll:			outUsesMark = false;			outEnabled = false;	}	switch (inCommand) {			case cmd_Copy:		case cmd_Clear:		case cmd_Cut:			if (mSelection)				if (mSelection->IsSubstantive())					outEnabled = true;			break;							case cmd_Paste:			if (mSelection) {				LClipboardTube	tube;				FlavorType		flavor;								flavor = mSelection->PickFlavorFrom(&tube);				if (flavor != typeNull)					outEnabled = true;			}			break;//		case cmd_SelectAll:		//	Must be done by overrider		default:			LSemanticUndoer::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			break;	}}LSemanticAction *	LSelectHandlerView::MakeCutAction(void){	StAEDescriptor		aeTarget,						aeUndoData;	LAESemanticAction	*action;		this->MakeSpecifier(aeTarget.mDesc);	action = new LAESemanticAction(STRx_RedoClipboardDescriptions, str_Cut);	action->SetSelection(mSelection);		//	Redo	action->SetRedoAE(kAEMiscStandards, kAECut);	action->RedoAEAdd(keyDirectObject, aeTarget.mDesc);		//	Undo	UndoAddOldData(action);		return action;}LSemanticAction *	LSelectHandlerView::MakeClearAction(void){	StAEDescriptor		aeTarget,						aeUndoData,						temp;	LAESemanticAction	*action;		if (mSelection)		mSelection->GetAEValue(temp.mDesc, aeTarget.mDesc);	else		return NULL;//		this->MakeSpecifier(aeTarget.mDesc);		action = new LAESemanticAction(STRx_RedoClipboardDescriptions, str_Clear);	action->SetSelection(mSelection);	//	Redo	action->SetRedoAE(kAECoreSuite, kAEDelete);	action->RedoAEAdd(keyDirectObject, aeTarget.mDesc);	//	Undo	UndoAddOldData(action);	action->UndoAESetKeyFed(keyAEInsertHere, keyAEInsertHere);		return action;}LSemanticAction *	LSelectHandlerView::MakePasteAction(void){	StAEDescriptor		aeTarget;	LAESemanticAction	*action;		this->MakeSpecifier(aeTarget.mDesc);		action = new LAESemanticAction(STRx_RedoClipboardDescriptions, str_Paste);	action->SetSelection(mSelection);	//	Redo	action->SetRedoAE(kAEMiscStandards, kAEPaste);	action->RedoAEAdd(keyDirectObject, aeTarget.mDesc);	//	Undo	UndoAddOldData(action);	return action;}void	LSelectHandlerView::UndoAddOldData(LAESemanticAction *inAction){/*	The kAECreateElement code below smells like a potential application	of a composite "LAEDescTube."*/	StAEDescriptor		aeTarget,						aeUndoData,						aeClass;	OSErr				err;		if (!mSelection)		return;			err = AECreateList(NULL, 0, true, &aeUndoData.mDesc);	ThrowIfOSErr_(err);	mSelection->GetImportantAEProperties(aeUndoData.mDesc);	mSelection->GetContentAEKinds(aeClass.mDesc);		inAction->SetUndoAE(kAECoreSuite, kAECreateElement);	inAction->UndoAEAdd(keyAEObjectClass, aeClass.mDesc);	inAction->UndoAEAdd(keyAEPropData, aeUndoData.mDesc);	inAction->UndoAESetKeyFed(keyAEInsertHere);}