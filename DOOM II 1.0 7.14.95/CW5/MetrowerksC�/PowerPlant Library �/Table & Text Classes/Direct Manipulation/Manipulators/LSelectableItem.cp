//	===========================================================================//	LSelectableItem.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LSelectableItem.h"#include	<UAppleEventsMgr.h>#include	<UMemoryMgr.h>#include	<AERegistry.h>#include	<AEObjects.h>#include	<LDataTube.h>//	===========================================================================//	MaintenanceLSelectableItem::LSelectableItem(){	Assert_(false);		//	Parameters required}LSelectableItem::LSelectableItem(LModelObject *inSuperModel, DescType inKind)	:	LCoreAEOM(inSuperModel, inKind){}LSelectableItem::~LSelectableItem(){}void	LSelectableItem::Release(void){	if (IsLazy())		Finalize();	else		delete this;}//	===========================================================================//	Query (override)Boolean	LSelectableItem::EquivalentTo(const LSelectableItem *inItem)/*	Returns whether this is equivalent to inItem.		Equivalent means the model objects refer to the same set of 	actual objects.		OVERRIDE for lazy objects.*/{	return (this == inItem);}Boolean	LSelectableItem::IndependentFrom(const LSelectableItem *inItem)/*	Returns whether this is independent from inItem.		Independent means none of the set of actual objects indicated by	this are represented in the set indicated by inItem.		OVERRIDE for lazy objects.*/{	return (this != inItem);}//	===========================================================================//	Visual (override)void	LSelectableItem::DrawSelfSelected(void){	Assert_(false);}void	LSelectableItem::DrawSelfLatent(void){	Assert_(false);}void	LSelectableItem::UnDrawSelfSelected(void){	DrawSelfSelected();}void	LSelectableItem::UnDrawSelfLatent(void){	DrawSelfLatent();}Int32		LSelectableItem::sReceiverTicker;Boolean		LSelectableItem::sReceiverOn;void	LSelectableItem::DrawSelfReceiver(void)/*	Override but inherit at end of overriden method to have "receiver" blink.*/{	sReceiverTicker = TickCount();	sReceiverOn = true;}void	LSelectableItem::UnDrawSelfReceiver(void){	if (sReceiverOn)		DrawSelfReceiver();	sReceiverTicker = TickCount();	sReceiverOn = false;}void	LSelectableItem::DrawSelfReceiverTick(void){	if ((TickCount() - sReceiverTicker) > GetCaretTime()) {		if (sReceiverOn)			UnDrawSelfReceiver();		else			DrawSelfReceiver();	}}//	===========================================================================//	Data draggingvoid	LSelectableItem::AddFlavorTypesTo(LDataTube *inTube)/*	Promises the object specifier for this item.		When overriding, remember to "inherit" this method.*/{	inTube->AddFlavor(typeObjectSpecifier);/*	Subclass template:	inTube->AddFlavor(<your data type 1>);	inTube->AddFlavor(<your data type 2>);	...		inherited::AddFlavorTypesTo(inTube);*/}Boolean	LSelectableItem::SendFlavorTo(FlavorType inFlavor, LDataTube *inTube)/*	When overriding, remember to "inherit" this method.		This method also serves as a template for subclass methods.*/{	Int32	size = 0;		switch(inFlavor) {		case typeObjectSpecifier:		{			StAEDescriptor	desc;			MakeSpecifier(desc.mDesc);			inTube->SetFlavorHandle(inFlavor, desc.mDesc.dataHandle);			return true;			break;		}/*		case <your data type>:			inTube->SetFlavorData(inFlavor, ptr, size);			break;				default:			return inherited::SendFlavorTo(inTube);			break;*/	}	return false;}