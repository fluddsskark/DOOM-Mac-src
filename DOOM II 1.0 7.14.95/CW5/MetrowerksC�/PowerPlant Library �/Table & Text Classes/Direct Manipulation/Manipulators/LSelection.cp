//	===========================================================================//	LSelection.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LSelection.h"#include	<LListIterator.h>#include	<LSelectableItem.h>#include	<UDrawingState.h>#include	<AERegistry.h>#include	<AEObjects.h>#include	<UAEDesc.h>#include	<LModelProperty.h>#include	<UAppleEventsMgr.h>#include	<UExtractFromAEDesc.h>#include	<LDataTube.h>#include	<LTubeableItem.h>#include	<AEDebugSuite.h>#include	<URegions.h>#include	<Errors.h>//	===========================================================================//	MaintenanceLSelection::LSelection(LModelObject *inSuperModel)	:	LModelProperty(pSelection, inSuperModel){	mDragOutline = NULL;	mShowAllSelections = false;//	mShowAllSelections = true;	//	True for debugging}LSelection::~LSelection(void){	if (mDragOutline)		DisposeRgn(mDragOutline);	mDragOutline = NULL;		//	Don't use ListClear -- it would try and undraw the items from a deleted	//	container.		LListIterator		iter(mItems, iterate_FromEnd);	LSelectableItem		*p;		while(iter.Previous(&p)) {//		Assert_(member(p, LSelectableItem));		if (p) p->OwnershipReleased(this);	}}void	LSelection::Release(void){	if (IsLazy())		Finalize();	else		delete this;}void	LSelection::FixSelection(void)/*	Sometimes, the selection mechanism is implemented on top of some other	library.  This routine provides a hook to make sure things	are kept in sync.*/{}//	===========================================================================//	Linkagevoid	LSelection::Activate(void){	if (!IsActive()) {		UnDrawLatent();		mActive = true;		DrawSelected();	}}void	LSelection::Deactivate(void){	if (IsActive()) {		UnDrawSelected();		mActive = false;		DrawLatent();	}}void	LSelection::Idle(void){}//	===========================================================================//	New featuresvoid	LSelection::SelectSimple(LSelectableItem *inItem){	ListClear();	ListAddItem(inItem);	if (mShowAllSelections)		RecordPresentSelection();}void	LSelection::SelectContinuous(LSelectableItem *inItem)/*	May need to override depending on implementation strategy for continous	selections.*/{	SelectDiscontinuous(inItem);}void	LSelection::SelectDiscontinuous(LSelectableItem *inItem){	if (mShowAllSelections) {		StAEDescriptor	desc,						temp;				if (inItem) {			this->MakeSpecifier(desc.mDesc);	//	"This" present selection			inItem->MakeSpecifier(temp.mDesc);			UAEDesc::AddDesc(&desc.mDesc, 0, temp.mDesc);			SendSetDataAEDesc(desc.mDesc, true);		}	} else {		LSelectableItem	*p;		p = ListEquivalentItem(inItem);		if (p) {			ListRemoveItem(p);		} else {			ListAddItem(inItem);		}	}}void	LSelection::RecordPresentSelection(void){	StAEDescriptor	requestedType;	StAEDescriptor	desc;	OSErr			err;		err = AECreateDesc(typeWildCard, NULL, 0, &requestedType.mDesc);	ThrowIfOSErr_(err);		this->GetAEValue(requestedType.mDesc, desc.mDesc);	SendSetDataAEDesc(desc.mDesc, false);}//	===========================================================================//	QueryBoolean	LSelection::IsSubstantive(void)/*	Does the selection contain data that can be copied & cut?*/{	return mItems.GetCount() > 0;}LSelectableItem *	LSelection::ListEquivalentItem(const LSelectableItem *inItem)/*	Returns a pointer to the selection item that is equivalent to inItem.		If no selection item is equivalent to inItem, NULL is returned.		Equivalent means the model objects resolve to the same set of 	actual objects.		Notes:			You may treat the return value as a boolean indicating whether			the present selection includes the inItem.						For non-lazy objects, the return value may be inItem.			For lazy objects, the return value will be the pointer to the				selection's copy of the equivalent inItem.  If inItem is				one of the selection's lazy objects, the return value will				be inItem.							If a value is returned consider it an object owned by the			selection.  Specifically, don't dispose or Finalize it.			If you need it in a longer term scenario, follow the policies			regarding objects of class LSharedObject.*/{	LListIterator	iter(mItems, iterate_FromStart);	LSelectableItem	*p = NULL;		while (iter.Next(&p)) {		Assert_(p);		if (p->EquivalentTo(inItem))			return p;	}		return NULL;}LSelectableItem *	LSelection::ListDependentItem(const LSelectableItem *inItem)/*	Returns a pointer to a selection item that is not independent from inItem.		If all selection items are independent from inItem, NULL is returned.		Independent means none of the set of actual objects indicated by inItem	are represented in the set indicated by the selection.		Notes:			You may treat the return value as a boolean indicating whether			the present selection is dependent with inItem.						For non-lazy objects, the return value may be inItem.			For lazy objects, the return value will be the pointer to the				selection's copy of the equivalent inItem.  If inItem is				one of the selection's lazy objects, the return value will				be inItem.							If a value is returned consider it an object owned by the			selection.  Specifically, don't dispose or Finalize it.			If you need it in a longer term scenario, follow the policies			regarding objects of class LSharedObject.*/{	LListIterator	iter(mItems, iterate_FromStart);	LSelectableItem	*p = NULL;		while (iter.Next(&p)) {		Assert_(p);		if (!p->IndependentFrom(inItem))			return p;	}		return NULL;}//	===========================================================================//	Visualvoid	LSelection::Draw(void)/*	Draw the selection hiliting.		Does not draw selection content -- that should be done by LPaneSubClass::DrawSelf*/{//	Pen saving & restoring?		if (!IsActive())		DrawLatent();	else		DrawSelected();}void	LSelection::DrawContent(void)/*	Draw selection content.		This routine should be rarely called		-- only for something like "print selection."*/{	Assert_(false);}//	===========================================================================//	Implementation -- manipulatorBoolean		LSelection::EquivalentTo(const LSelectableItem *inItem){	if (ListCount() == 1)		return ListEquivalentItem(inItem) != NULL;	else		return false;}Boolean		LSelection::IndependentFrom(const LSelectableItem *inItem){	return ListDependentItem(inItem) == NULL;}Boolean		LSelection::PointInRepresentation(Point inWhere){	LListIterator	iter(mItems, iterate_FromStart);	LSelectableItem	*p = NULL;		if (!IsSubstantive())		return false;			while (iter.Next(&p)) {		if (p->PointInRepresentation(inWhere))			return true;	}		return false;}void	LSelection::DrawSelf(void){	DrawLatent();}void	LSelection::UnDrawSelf(void){}//	===========================================================================//	Implementationvoid	LSelection::DrawSelected(void){	LListIterator		iter(mItems, iterate_FromStart);	LSelectableItem		*p;		while(iter.Next(&p)) {		p->DrawSelfSelected();	}}void	LSelection::DrawLatent(void){	LListIterator		iter(mItems, iterate_FromStart);	LSelectableItem		*p;		while(iter.Next(&p)) {		p->DrawSelfLatent();	}}void	LSelection::UnDrawSelected(void){	LListIterator		iter(mItems, iterate_FromStart);	LSelectableItem		*p;	while(iter.Next(&p)) {		p->UnDrawSelfSelected();	}}void	LSelection::UnDrawLatent(void){	LListIterator		iter(mItems, iterate_FromStart);	LSelectableItem		*p;		while(iter.Next(&p)) {		p->UnDrawSelfLatent();	}}Boolean	LSelection::IsActive(void){	return	(mActive);}//	===========================================================================//	Data draggingvoid	LSelection::AddFlavorTypesTo(LDataTube *inTube){	LSelectableItem	*item;	Assert_(inTube);		if (ListCount() == 1) {		mItems.FetchItemAt(1, &item);		Assert_(item);				item->AddFlavorTypesTo(inTube);	} else {		LListIterator	iter(mItems, iterate_FromStart);		LDataTube		*subTube;				while (iter.Next(&item)) {			subTube = inTube->MakeNewSubTubeFor(item);			item->AddFlavorTypesTo(subTube);			inTube->AddSubTube(subTube);		}	}}Boolean	LSelection::SendFlavorTo(FlavorType inFlavor, LDataTube *inTube){	LSelectableItem	*selItem;	LListIterator	iter(mItems, iterate_FromStart);	Boolean			rval = false;		Assert_(inTube);		while (iter.Next(&selItem)) {		selItem->SendFlavorTo(inFlavor, inTube);		rval = true;	}	return rval;}FlavorType	LSelection::PickFlavorFrom(const LDataTube *inTube)/*	This will not provide the correct mapping if the selection contains	multiple items.*/{	LSelectableItem	*selItem;	LListIterator	iter(mItems, iterate_FromStart);	FlavorType		rval;		Assert_(inTube);	/*		Q:	In the general case, how do you pick			the flavors when there are multiple			independent receivers?		A:	Override according to application			specific requirements.					Note:	This also means most of this				routine is redundant.	*/		while (iter.Next(&selItem)) {		rval = selItem->PickFlavorFrom(inTube);		if (rval != typeNull)			return rval;	}	return typeNull;}void	LSelection::ReceiveDataFrom(LDataTube *inTube)/*	This will not provide the correct mapping if the selection contains	multiple items.*/{	LSelectableItem	*selItem;	LListIterator	iter(mItems, iterate_FromStart);		Assert_(inTube);	while (iter.Next(&selItem)) {		selItem->ReceiveDataFrom(inTube);	}}//	===========================================================================//	AEOM supportvoid	LSelection::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	OSErr	err = noErr;		Assert_(outPropertyDesc.descriptorType == typeNull);		switch (inProperty) {		case pShowAllSelections:			UAEDesc::MakeBooleanDesc(mShowAllSelections, &outPropertyDesc);			break;		break;	}	ThrowIfOSErr_(err);		if (outPropertyDesc.descriptorType == typeNull)		LModelProperty::GetAEProperty(inProperty, inRequestedType, outPropertyDesc);}void	LSelection::SetAEProperty(	DescType		inProperty,	const AEDesc	&inValue,	AEDesc&			outAEReply){	Boolean		newState;		switch (inProperty) {		case pShowAllSelections:			UExtractFromAEDesc::TheBoolean(inValue, newState);			mShowAllSelections = newState;			break;		default:			LModelProperty::SetAEProperty(inProperty, inValue, outAEReply);			break;	}}void	LSelection::GetAEValue(	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	OSErr	err;	LListIterator	iter( ((LSelection *)this)->mItems, iterate_FromStart);	LSelectableItem	*p = NULL;	StAEDescriptor	tempDesc;		if (mItems.GetCount() == 0) {		//	Force an empty list to be made		err = AECreateList(NULL, 0, false, &outPropertyDesc);		ThrowIfOSErr_(err);	}	while (iter.Next(&p)) {		p->MakeSpecifier(tempDesc.mDesc);		UAEDesc::AddDesc(&outPropertyDesc, 0, tempDesc.mDesc);		err = AEDisposeDesc(&tempDesc.mDesc);		ThrowIfOSErr_(err);	}}void	LSelection::SetAEValue(	const AEDesc	&inValue,	AEDesc&			outAEReply){	LModelObject	*o = NULL;	LSelectableItem	*p = NULL;	LSelectableItem	*q = NULL;	Int32			i, n;	OSErr			err;	LList			newItems;	Boolean			appending = false;		StAEDescriptor	desc;	StAEDescriptor	token;	//	Get new value(s) in list	switch(inValue.descriptorType) {		case typeNull:			break;		case typeObjectSpecifier:			err = AEResolve(&inValue, kAEIDoMinimum, &token.mDesc);			ThrowIfOSErr_(err);						o = GetModelFromToken(token.mDesc);			Assert_(o);	//	GetModelFromToken should raise an exception so this should						//	never fail.						err = AEDisposeDesc(&desc.mDesc);			ThrowIfOSErr_(err);			err = AEDisposeDesc(&token.mDesc);			ThrowIfOSErr_(err);										if (this == o) {				return;			}						//	check to see if p can be entered to this selection.			//	... how ? no rtti						p = (LSelectableItem *) o;			newItems.InsertItemsAt(1, arrayIndex_Last, &p);			break;				case typeAEList:		{			AEKeyword	zTheKeyword;						err = AECountItems(&inValue, &n);			ThrowIfOSErr_(err);					for (i = 1; i <= n; i++) {				err = AEGetNthDesc(&inValue, i, typeObjectSpecifier, &zTheKeyword, &desc.mDesc);				ThrowIfOSErr_(err);								err = AEResolve(&desc.mDesc, kAEIDoMinimum, &token.mDesc);				ThrowIfOSErr_(err);								o = GetModelFromToken(token.mDesc);				Assert_(o);	//	GetModelFromToken should raise an exception so this should							//	never fail.								err = AEDisposeDesc(&desc.mDesc);				ThrowIfOSErr_(err);				err = AEDisposeDesc(&token.mDesc);				ThrowIfOSErr_(err);								if (this == o) {					appending = true;					continue;				}								//	check to see if p can be entered to this selection.				//	... how ? no rtti								p = (LSelectableItem *) o;				newItems.InsertItemsAt(1, arrayIndex_Last, &p);			}			break;		}				case typeInsertionLoc:		{			StAEDescriptor	locDesc,							keyData;			DescType		location,							zTypeCode;			Size			zActualSize;			LCoreAEOM		*target;	//	Note:			/*				No special memory handling is required because if the target				is the insertion location, target will be added to the selection				list.  If not, the insertion location will contain a super				model pointer back to target -- lazy instantiated subtrees of				the AEOM hierarchy are destroyed up the AEOM hiearchy when a leaf				lazy object is destroyed (finalized).			*/			err = AECoerceDesc(&inValue, typeAERecord, &keyData.mDesc);			ThrowIfOSErr_(err);			err = AEGetParamDesc(&keyData.mDesc, keyAEObject, typeObjectSpecifier, &desc.mDesc);			ThrowIfOSErr_(err);						err = AEGetParamPtr(&keyData.mDesc, keyAEPosition, typeEnumeration, &zTypeCode, &location,				sizeof(location), &zActualSize);			ThrowIfOSErr_(err);						err = AEResolve(&desc.mDesc, kAEIDoMinimum, &token.mDesc);			ThrowIfOSErr_(err);						target = (LCoreAEOM *) GetModelFromToken(token.mDesc);			Assert_(target);//			Assert_(member(target, LCoreAEOM));			p = (LSelectableItem *) target->GetSubModelForInsertion(location, target);			Assert_(p);//			Assert_(member(p, LSelectableItem));			newItems.InsertItemsAt(1, arrayIndex_Last, &p);			break;		}				default:			ThrowOSErr_(errAEBadKeyForm);			break;	}	//	"Toggle" item(s) to selection list	if (!appending)		ListClear();		LListIterator	iter(newItems, iterate_FromStart);		while(iter.Next(&p)) {		q = ListEquivalentItem(p);		if (q) {			ListRemoveItem(q);			p->OwnershipReleased(this);		} else {			ListAddItem(p);		}	}}void	LSelection::GetImportantAEProperties(AERecord &outKeyDescList)/*	Get all important AE property data for referred objects.		"Important" includes things necessary for cloning.*/{	LSelectableItem	*item;	OSErr			err = noErr;	StAEDescriptor	contents,					reqType;	Int32			i;		if (ListCount() == 1) {		item = ListNthItem(1);		item->GetImportantAEProperties(outKeyDescList);		return;	}		Assert_(false);	for (i = 1; i <= ListCount(); i++) {	}}void	LSelection::GetContentAEKinds(AEDesc &outKindList){	LSelectableItem	*item;	OSErr			err = noErr;	DescType		kind;	Int32			i;		for (i = 1; i <= ListCount(); i++) {		item = (LSelectableItem *)ListNthItem(i);		Assert_(item);//		Assert_(member(item, LSelectableItem));		kind = item->GetModelKind();		UAEDesc::AddPtr(&outKindList, 0, typeType, &kind, sizeof(kind));	}}void	LSelection::HandleGetData(	const AppleEvent	&inAppleEvent,	AEDesc				&outResult,	long				inAENumber){/*	Taken and modified from LModelObject::HandleGetData*/									// Find requested type for the data									// This parameter is optional, so it's OK									//   if it's not found	StAEDescriptor	requestedType;	StAEDescriptor	theProperty;		requestedType.GetOptionalParamDesc(inAppleEvent, keyAERequestedType,									typeAEList);										// Error if there are more parameters	UAppleEventsMgr::CheckForMissedParams(inAppleEvent);										// Ask SuperModel for the property value	GetAEValue(requestedType.mDesc, theProperty.mDesc);	//	jah changed		if (inAENumber == ae_GetData) {									// For GetData, Property is the result//		outResult = theProperty;	//	Wierd things happen when this is done.		UAEDesc::AddDesc(&outResult, 0, theProperty.mDesc);			} else {						// For GetDataSize, size of Property									//   is the result		Int32	theSize = GetHandleSize(theProperty.mDesc.dataHandle);		OSErr err = ::AECreateDesc(typeLongInteger, &theSize, sizeof(Int32), &outResult);		ThrowIfOSErr_(err);	}}void	LSelection::HandleSetData(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply){	StAEDescriptor	value;	value.GetParamDesc(inAppleEvent, keyAEData, typeWildCard);		UAppleEventsMgr::CheckForMissedParams(inAppleEvent);	SetAEValue(value.mDesc, outAEReply);					//	jah changed}void	LSelection::HandleDelete(	AppleEvent			&outAEReply,	AEDesc				&outResult)/*	It makes no sense to delete the selection object but it does make sense	to delete the objects referenced by it.		This routine will set the keyAEInsertHere parameter of the reply to	the result of the object's delete or multiple object deletes.  In the 	latter case, a descriptor list will be returned in keyAEInsertHere.*/{	StAEDescriptor	cumulativeResult,					objectResult,					objectReply;	LSelectableItem	*p;	LListIterator	iter(mItems, iterate_FromStart);	OSErr			err = noErr;		while(iter.Next(&p)) {		Assert_(p);		err = AECreateList(NULL, 0, true, &objectReply.mDesc);		ThrowIfOSErr_(err);				//	Do the delete		p->HandleDelete(objectReply.mDesc, objectResult.mDesc);	//	p is NOW gone		//	assumulate delete replies		objectResult.GetParamDesc(objectReply.mDesc, keyAEInsertHere, typeWildCard);		UAEDesc::AddDesc(&cumulativeResult.mDesc, 0, objectResult.mDesc);		ThrowIfOSErr_(err);	}	err = AEPutKeyDesc(&outAEReply, keyAEInsertHere, &cumulativeResult.mDesc);	ThrowIfOSErr_(err);}//	===========================================================================//	Probably removevoid	LSelection::ListClear(void){	LListIterator		iter(mItems, iterate_FromEnd);	LSelectableItem		*p;		while(iter.Previous(&p)) {		ListRemoveItem(p);	}}Int32	LSelection::ListCount(void){	return (mItems.GetCount());}LSelectableItem *	LSelection::ListNthItem(Int32 inIndex){	LSelectableItem	*rval;		mItems.FetchItemAt(inIndex, &rval);	return rval;}Boolean	LSelection::ListContains(	const LSelectableItem	*inItem)/*	Make sure you shouldn't be using ListDependentWith*/{	LListIterator		iter(mItems, iterate_FromStart);	LSelectableItem		*p;		while(iter.Next(&p)) {		if (p == inItem)			return true;	}	return NULL;}		void	LSelection::ListAddItem(LSelectableItem *inItem){	if (inItem != NULL && !ListContains(inItem)) {		mItems.InsertItemsAt(1, arrayIndex_Last, &inItem);		inItem->OwnershipClaimed(this);		if (!IsActive()) {			inItem->DrawSelfLatent();		} else {			inItem->DrawSelfSelected();		}	}}void	LSelection::ListRemoveItem(LSelectableItem *inItem){	Int32	index;		Assert_(inItem);	index = mItems.FetchIndexOf(&inItem);	Assert_(index);		if (!IsActive()) {		inItem->UnDrawSelfLatent();	} else {		inItem->UnDrawSelfSelected();	}	mItems.RemoveItemsAt(1, index);	inItem->OwnershipReleased(this);}//	===========================================================================//	Implementation -- Manipulation behaviorvoid	LSelection::DragStart(Point inStart){	Assert_(mDragOutline == NULL);	mDragOutline = FindDragOutline(inStart);		//	Draw initial position.	LManipulator::DragStart(inStart);}void	LSelection::DragStop(Point inEnd){	//	Remove feedback at last position	LManipulator::DragStop(inEnd);		Assert_(mDragOutline);	DisposeRgn(mDragOutline);	mDragOutline = NULL;}void	LSelection::DrawDragFeedback(Point inWhere){	StColorPenState	savePen;	PenPat(&UQDGlobals::GetQDGlobals()->gray);	ThrowIfOSErr_(QDError());		URegions::FrameAt(mDragOutline, inWhere);}RgnHandle	LSelection::FindDragOutline(Point inOrigin){	StRegion	rgn(MakeRegion(inOrigin));	return URegions::MakeRegionOutline(rgn.mRgn);}RgnHandle	LSelection::MakeRegion(Point inOrigin)/*	Resulting region will have it's origin as inOrigin --	this means the region can be independent of coordinate	system origin.*/{	RgnHandle	itemsRgn = NewRgn();	OSErr		err = noErr;		Try_ {		ThrowIfNil_(itemsRgn);				//	Can't nest open regions		if (UQDGlobals::GetQDGlobals()->thePort->rgnSave != NULL)			Throw_(paramErr);			//	Get latent region		OpenRgn();		ThrowIfOSErr_(QDError());		//	don't know if this is the culprit but...		//	having probs with hide/show pen balancing...		Try_ {			DrawSelected();//			DrawLatent();			err = noErr;		} Catch_(inErr) {			err = inErr;		} EndCatch_;		CloseRgn(itemsRgn);		ThrowIfOSErr_(err);		ThrowIfOSErr_(QDError());				//	Set "origin" of region		Point	offset;		offset.h = -inOrigin.h;		offset.v = -inOrigin.v;		URegions::Translate(itemsRgn, offset);	} Catch_(inErr) {		if (itemsRgn)			DisposeRgn(itemsRgn);		itemsRgn = NULL;				Throw_(inErr);	} EndCatch_;		return itemsRgn;}