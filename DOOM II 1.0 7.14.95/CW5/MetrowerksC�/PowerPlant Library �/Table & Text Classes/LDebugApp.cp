//	===========================================================================//	LDebugApp.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LDebugApp.h"#include	<UAppleEventsMgr.h>#include	<UExtractFromAEDesc.h>#include	<UAEDesc.h>#include	<AEDebugSuite.h>//	===========================================================================//	Class variables#if	__profile__	#include	"profiler.h"	TProfilerState	LDebugApp::sProfilerState			= profiler_Off;	Int16			LDebugApp::sProfilerOn				= 0;	//	0 is off, + is nested on	Int32			LDebugApp::sProfilerTimeUnit		= microsecondsTimeBase;	Int32			LDebugApp::sProfilerMethod			= collectDetailed;	Int32			LDebugApp::sProfilerMaxFunctions	= 3000;	Int32			LDebugApp::sProfilerMaxStack		= 300;	Str255			LDebugApp::sProfilerDumpFile		= "\pPowerPlant Profile";#endif	//	===========================================================================LDebugApp::LDebugApp(){}LDebugApp::~LDebugApp(){	#if	__profile__		SetProfiler_(false);		ProfilerTerm();		sProfilerState = profiler_Off;	#endif}void	LDebugApp::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	Int32	intValue;	OSErr	err = noErr;		Assert_(outPropertyDesc.descriptorType == typeNull);		switch (inProperty) {#if	__profile__				//	Profiler		case pProfilerState:			intValue = sProfilerState;			err = AECreateDesc(typeLongInteger, (Ptr) &intValue, sizeof(intValue), &outPropertyDesc);			break;		case pProfilerTimeUnit:			intValue = sProfilerTimeUnit;			err = AECreateDesc(typeLongInteger, (Ptr) &intValue, sizeof(intValue), &outPropertyDesc);			break;					case pProfilerMethod:			intValue = sProfilerMethod;			err = AECreateDesc(typeLongInteger, (Ptr) &intValue, sizeof(intValue), &outPropertyDesc);			break;		case pProfilerMaxFunctions:			intValue = sProfilerMaxFunctions;			err = AECreateDesc(typeLongInteger, (Ptr) &intValue, sizeof(intValue), &outPropertyDesc);			break;		case pProfilerMaxStack:			intValue = sProfilerMaxStack;			err = AECreateDesc(typeLongInteger, (Ptr) &intValue, sizeof(intValue), &outPropertyDesc);			break;		case pProfilerDumpFile:			err = AECreateDesc(typeChar, (Ptr) sProfilerDumpFile+1, sProfilerDumpFile[0], &outPropertyDesc);			break;#endif			//	Memory		case pMemoryLargestBlock:			intValue = MaxBlock();			err = AECreateDesc(typeLongInteger, (Ptr) &intValue, sizeof(intValue), &outPropertyDesc);			break;		case pMemoryFreeAmount:			intValue = FreeMem();			err = AECreateDesc(typeLongInteger, (Ptr) &intValue, sizeof(intValue), &outPropertyDesc);			break;#ifdef	Debug_Throw		//	Debug actions		case pDebugThrowAction:			intValue = gDebugThrow;			err = AECreateDesc(typeLongInteger, (Ptr) &intValue, sizeof(intValue), &outPropertyDesc);			break;#endif#ifdef	Debug_Signal		case pDebugSignalAction:			intValue = gDebugSignal;			err = AECreateDesc(typeLongInteger, (Ptr) &intValue, sizeof(intValue), &outPropertyDesc);			break;#endif	}	ThrowIfOSErr_(err);		if (outPropertyDesc.descriptorType == NULL)		inherited::GetAEProperty(inProperty, inRequestedType, outPropertyDesc);}void	LDebugApp::SetAEProperty(	DescType		inProperty,	const AEDesc	&inValue,	AEDesc&			outAEReply){	OSErr			err = noErr;	Int32			newIntValue = 0;		switch (inProperty) {		//	Profiler#if	__profile__		case pProfilerState:		{			TProfilerState	newState;			UExtractFromAEDesc::TheInt32(inValue, newIntValue);			newState = (TProfilerState) newIntValue;			if (newState != sProfilerState) {				switch (newState) {					case profiler_Off:						SetProfiler_(false);						Assert_(sProfilerOn == 0);						sProfilerState = newState;						break;					case profiler_Source_Controlled:					case profiler_On:					case profiler_Include_WNE:					{						ProfilerCollectionMethod	meth = (ProfilerCollectionMethod) sProfilerMethod;						ProfilerTimeBase			base = (ProfilerTimeBase) sProfilerTimeUnit;												SetProfiler_(false);						Assert_(sProfilerOn == 0);						ProfilerTerm();						err = ProfilerInit(meth, base, sProfilerMaxFunctions, sProfilerMaxStack);						if (err) {							sProfilerState = profiler_Off;							sProfilerOn = 0;							ThrowOSErr_(err);						} else {							sProfilerOn = 1;	//	ProfilerInit defaults on						}						if (newState != profiler_Include_WNE) {							SetProfiler_(false);							Assert_(sProfilerOn == 0);						}													sProfilerState = newState;						break;					}										default:						Throw_(paramErr);						break;				}			}			break;		}		case pProfilerTimeUnit:			if (sProfilerState != profiler_Off)				Throw_(paramErr);			UExtractFromAEDesc::TheInt32(inValue, newIntValue);			sProfilerTimeUnit = newIntValue;			break;					case pProfilerMethod:			if (sProfilerState != profiler_Off)				Throw_(paramErr);			UExtractFromAEDesc::TheInt32(inValue, newIntValue);			sProfilerMethod = newIntValue;			break;		case pProfilerMaxFunctions:			if (sProfilerState != profiler_Off)				Throw_(paramErr);			UExtractFromAEDesc::TheInt32(inValue, newIntValue);			sProfilerMaxFunctions = newIntValue;			break;		case pProfilerMaxStack:			if (sProfilerState != profiler_Off)				Throw_(paramErr);			UExtractFromAEDesc::TheInt32(inValue, newIntValue);			sProfilerMaxStack = newIntValue;			break;		case pProfilerDumpFile:			UExtractFromAEDesc::ThePString(inValue, sProfilerDumpFile);			break;#endif			//	Debug actions#ifdef	Debug_Throw		case pDebugThrowAction:			UExtractFromAEDesc::TheInt32(inValue, newIntValue);			gDebugThrow = (EDebugAction) newIntValue;			break;#endif#ifdef	Debug_Signal		case pDebugSignalAction:			UExtractFromAEDesc::TheInt32(inValue, newIntValue);			gDebugSignal = (EDebugAction) newIntValue;			break;#endif		default:			inherited::SetAEProperty(inProperty, inValue, outAEReply);			break;	}}Boolean	LDebugApp::SetProfiler(Boolean inState)/*	Do not use this member for instrumented or more narrow	profile traces.  Instead use a StProfile stack object to control	instrumented profiling -- it is nestable and will call this method	as appropriate.		Returns whether the profiler was previously on.*/{#if	__profile__	if (sProfilerState == profiler_Source_Controlled)		return SetProfiler_(inState);#endif	return false;}#if	__profile__	#include	<PP_Messages.h>	#include	<LPeriodical.h>		Boolean	LDebugApp::SetProfiler_(Boolean inState)	{		Boolean	rval = sProfilerOn != 0;				if (inState) {			sProfilerOn++;				if (sProfilerOn == 1)				ProfilerSetStatus(true);		} else {			sProfilerOn--;				if (sProfilerOn == 0)				ProfilerSetStatus(false);				if (sProfilerOn < 0)				sProfilerOn = 0;		}					return rval;	}		Boolean	LDebugApp::WaitNextEvent(		short 		inEventMask,		EventRecord	*outEvent,		long		inSleep,		RgnHandle	inMouseRgn)	{		Boolean rval;		if (sProfilerState == profiler_On)			SetProfiler_(false);		rval = ::WaitNextEvent(inEventMask, outEvent, inSleep, inMouseRgn);		if (sProfilerState == profiler_On)			SetProfiler_(true);					return rval;	}		void	LDebugApp::ProcessNextEvent(void)	{		EventRecord		macEvent;		if (IsOnDuty()) {			::OSEventAvail(0, &macEvent);			AdjustCursor(macEvent);		}		Boolean	gotEvent = this->WaitNextEvent(everyEvent, &macEvent, mSleepTime,											mMouseRgnH);				if (ExecuteAttachments(msg_Event, &macEvent)) {			if (gotEvent) {				DispatchEvent(macEvent);			} else {				UseIdleTime(macEvent);			}		}		LPeriodical::DevoteTimeToRepeaters(macEvent);	}#endifvoid	LDebugApp::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	OSErr		err = noErr;		switch (inAENumber) {		case ae_Debug_MemoryPurge:		{			Size	aSize;						MaxMem(&aSize);			break;		}#ifdef	Debug_Signal		case ae_Debug_DebugAssert:			Assert_(false);			break;#endif#ifdef	Debug_Throw					case ae_Debug_DebugThrow:		{			Int32			errToThrow;			StAEDescriptor	errDesc;			errDesc.GetParamDesc(inAppleEvent, keyDirectObject, typeLongInteger);			UExtractFromAEDesc::TheInt32(errDesc.mDesc, errToThrow);			Throw_(errToThrow);			break;		}		#endif#if	__profile__		case ae_Debug_ProfilerDump:			err = ProfilerDump(sProfilerDumpFile);			ThrowIfOSErr_(err);			break;					case ae_Debug_ProfilerClear:			ProfilerClear();			break;			#endif		default:			inherited::HandleAppleEvent(inAppleEvent, outAEReply, outResult, inAENumber);			break;	}}#include	<StProfile.cp>