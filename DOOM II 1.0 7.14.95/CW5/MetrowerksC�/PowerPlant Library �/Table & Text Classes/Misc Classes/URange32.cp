//	===========================================================================//	URange32.cp						©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"URange32.h"Boolean	URange32::RangeIntersection(const Range32T &inRangeA, const Range32T &inRangeB, Range32T *outRange){	Int32	aStart = inRangeA.start,			bStart = inRangeB.start,			aEnd = inRangeA.start + inRangeA.length,			bEnd = inRangeB.start + inRangeB.length;		if ( (aStart < bStart ) && (aEnd < bStart) )		return false;	if ( (bStart < aStart ) && (bEnd < aStart) )		return false;	if (outRange) {		outRange->start = Max(aStart, bStart);		outRange->length = Min(aEnd, bEnd) - outRange->start;	}		return true;}Boolean	URange32::RangeUnion(const Range32T &inRangeA, const Range32T &inRangeB, Range32T *outRange){	Int32		start, end;		start = Min(inRangeA.start, inRangeB.start);	end = Max(inRangeA.start + inRangeA.length, inRangeB.start + inRangeB.length);		if (outRange) {		outRange->start = start;		outRange->length = end - start;	}	return true;}Boolean	URange32::RangesSame(const Range32T &inRangeA, const Range32T &inRangeB){	return (inRangeA.start == inRangeB.start) && (inRangeA.length == inRangeB.length);}Boolean	URange32::RangeWithinRange(const Range32T &inRangeA, const Range32T &inRangeB){	return	(inRangeA.start >= inRangeB.start) &&			((inRangeA.start + inRangeA.length) <= (inRangeB.start + inRangeB.length));}void	URange32::RangeShift(const Range32T &inRange, Int32 inDelta, Range32T *outRange){	Assert_(outRange);	outRange->start = inRange.start + inDelta;	outRange->length = inRange.length;}void	URange32::RangeExpand(const Range32T &inRange, Int32 inDelta, Range32T *outRange){	Assert_(outRange);	outRange->start = inRange.start;	outRange->length = inRange.length + inDelta;}void	URange32::RangeAdjust(			const Range32T		&inRange,			Int32				inStart,			Int32				inDelta,			Boolean				inInclusive,			Range32T			*outRange)/*	Note:	Inclusive parameter doesn't apply when inDelta < 0.*/{	Range32T	range = inRange;	Int32		range_end = range.start + range.length,				headDelta = 0,				lengthDelta = 0;					if (inDelta > 0) {		if (inInclusive) {			if ( (range.start <= inStart) && (inStart <= range_end) ) {				lengthDelta = inDelta;			}			if (inStart < range.start) {				headDelta = inDelta;			}		} else {			if ( (range.start < inStart) && (inStart < range_end) ) {				lengthDelta = inDelta;			}			if (inStart <= range.start) {				headDelta = inDelta;			}		}	} else {		if ( (range.start <= inStart) && (inStart < range_end) ) {			lengthDelta = -URange32::Min(range_end - inStart, -inDelta);						Assert_(lengthDelta <= 0);		}		if (inStart < range.start) {			Int32	in_end = inStart + (-inDelta);						if (range.start < in_end) {				lengthDelta = -URange32::Min(in_end - range.start, range.length);			}						headDelta = -URange32::Min(range.start - inStart, -inDelta);		}	}	range.start += headDelta;	range.length += lengthDelta;	Assert_(range.start >= 0);	Assert_(range.length >= 0);	*outRange = range;}void	URange32::RangeCrop(	const Range32T		&inRange,	const Range32T		&inBoundary,	Range32T			*outRange){	Int32		start = inRange.start,				end = start + inRange.length,				bStart = inBoundary.start,				bEnd = bStart + inBoundary.length;		start = Max(start, bStart);	end = Min(end, bEnd);		start = Min(start, bEnd);	end = Max(end, bStart);		outRange->start = start;	outRange->length = end - start;		Assert_(outRange->length >= 0);}Int32	URange32::Min(Int32 inA, Int32 inB){	if (inA < inB)		return inA;	else		return inB;}Int32	URange32::Max(Int32 inA, Int32 inB){	if (inA > inB)		return inA;	else		return inB;}