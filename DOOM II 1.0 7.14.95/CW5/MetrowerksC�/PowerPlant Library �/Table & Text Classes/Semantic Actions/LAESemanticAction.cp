// ===========================================================================//	LAESemanticAction.cp			©1994 Metrowerks Inc. All rights reserved.// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LAESemanticAction.h"#include	<UAppleEventsMgr.h>#include	<String_Utils.h>#include	<AERegistry.h>#include	<LSelection.h>#include	<UAEDesc.h>#include	<AEObjects.h>LAESemanticAction::LAESemanticAction(){	Assert_(false);}LAESemanticAction::LAESemanticAction(	ResIDT		inRedoDescriptionResource,	Int16		inDescriptionIndex)	:	LSemanticAction(inRedoDescriptionResource, inDescriptionIndex){	mRecordOnlyFinalState = false;	mUndoAEKeyFed = typeNull;	mPostUndoAEKeyFed = typeNull;	mFromReplyKey = typeNull;		mRedoEvent.descriptorType = typeNull;	mRedoEvent.dataHandle = NULL;	mUndoEvent.descriptorType = typeNull;	mUndoEvent.dataHandle = NULL;	mPostUndoEvent.descriptorType = typeNull;	mPostUndoEvent.dataHandle = NULL;}LAESemanticAction::~LAESemanticAction(){	OSErr	err;		err = AEDisposeDesc(&mRedoEvent);	err = AEDisposeDesc(&mUndoEvent);	err = AEDisposeDesc(&mPostUndoEvent);}void	LAESemanticAction::Finalize(void){	if (mRecordOnlyFinalState && mIsDone) {		SendAppleEvent(mRedoEvent, kAEDontExecute);	}		inherited::Finalize();}void	LAESemanticAction::SetRecordOnlyFinalState(Boolean inRecordOnlyFinalState){	mRecordOnlyFinalState = inRecordOnlyFinalState;}void	LAESemanticAction::SetRedoAE(AEEventClass inEventClass, AEEventID inEventID)/*	Don't use this routine if the associated event has parameters.	Instead, make an AppleEvent and use SetRedo/UndoAE(AppleEvent).*/{	UAppleEventsMgr::MakeAppleEvent(inEventClass, inEventID, mRedoEvent);}void	LAESemanticAction::SetRedoAE(const AppleEvent &inAppleEvent){	OSErr	err;		err = AEDisposeDesc(&mRedoEvent);	err = AEDuplicateDesc(&inAppleEvent, &mRedoEvent);	ThrowIfOSErr_(err);}void	LAESemanticAction::SetUndoAE(	AEEventClass		inEventClass,	AEEventID			inEventID,	Boolean				inFeedUndoWithRedoReply)/*	Don't use this routine if the associated event has parameters.	Instead, make an AppleEvent and use SetRedo/UndoAE(AppleEvent).		Avoid using explicitly using the optional inFeedUndoWithRedoReply.	Instead, call UndoAESetKeyFed after all SetUndoAE's have been called.*/{	UAppleEventsMgr::MakeAppleEvent(inEventClass, inEventID, mUndoEvent);		if (inFeedUndoWithRedoReply)		UndoAESetKeyFed(keyDirectObject);}void	LAESemanticAction::SetUndoAE(	const AppleEvent	&inAppleEvent,	Boolean				inFeedUndoWithRedoReply)/*		Avoid using explicitly using the optional inFeedUndoWithRedoReply.	Instead, call UndoAESetKeyFed after all SetUndoAE's have been called.*/{	OSErr	err;	err = AEDisposeDesc(&mUndoEvent);	err = AEDuplicateDesc(&inAppleEvent, &mUndoEvent);	ThrowIfOSErr_(err);		if (inFeedUndoWithRedoReply)		UndoAESetKeyFed(keyDirectObject);}void	LAESemanticAction::SetPostUndoAE(const AppleEvent &inAppleEvent){	OSErr	err;	err = AEDisposeDesc(&mPostUndoEvent);	err = AEDuplicateDesc(&inAppleEvent, &mPostUndoEvent);	ThrowIfOSErr_(err);}void	LAESemanticAction::UndoAESetKeyFed(DescType inKey, DescType inFromReplyKey)/*	Used to set the "key parameter receiver" for the undo event	from the reply of the redo event.		Avoid calling this method with typeNull because that is the natural	constructed state of an LAESemanticAction.*/{	mUndoAEKeyFed = inKey;	mFromReplyKey = inFromReplyKey;}void	LAESemanticAction::PostUndoAESetKeyFed(DescType inKey, DescType inFromReplyKey){	mPostUndoAEKeyFed = inKey;	mPostFromReplyKey = inFromReplyKey;}void	LAESemanticAction::RedoAEAdd(AEKeyword theAEKeyword, const AEDesc &inDesc){	OSErr	err;		err = AEPutParamDesc(&mRedoEvent, theAEKeyword, &inDesc);	ThrowIfOSErr_(err);}void	LAESemanticAction::UndoAEAdd(AEKeyword theAEKeyword, const AEDesc &inDesc){	OSErr	err;		err = AEPutParamDesc(&mUndoEvent, theAEKeyword, &inDesc);	ThrowIfOSErr_(err);}void	LAESemanticAction::RedoSelf(void){	Assert_(CanRedo());		//	Do the event...	SendAppleEvent(mRedoEvent, mRecordOnlyFinalState ? kAEDontRecord : 0);	//	Record information from reply for undo	if ((mUndoEvent.descriptorType != typeNull) && (mUndoAEKeyFed != typeNull)) {		StAEDescriptor	aeResult;			//	keyDirectObject -- the result from the original operation		Assert_(mFromReplyKey != typeNull);		aeResult.GetParamDesc(mReply.mDesc, mFromReplyKey, typeWildCard);		UndoAEAdd(mUndoAEKeyFed, aeResult.mDesc);				mUndoAEKeyFed = typeNull;	//	Don't add it twice	}		//	Update selection	if (mSelection)		FixSelectionWReply(mRedoSelectionModifier);}void	LAESemanticAction::UndoSelf(void){	OSErr	err;		Assert_(CanUndo());		//	Do the event	SendAppleEvent(mUndoEvent, mRecordOnlyFinalState ? kAEDontRecord : 0);		//	Update selection	if (mSelection)		FixSelectionWReply(mUndoSelectionModifier);	//	Post undo AE...	if (mPostUndoAEKeyFed != typeNull) {		StAEDescriptor	aeResult;			//	mPostFromReplyKey -- the result from the undo operation		Assert_(mPostFromReplyKey != typeNull);		aeResult.GetParamDesc(mReply.mDesc, mPostFromReplyKey, typeWildCard);		err = AEPutParamDesc(&mPostUndoEvent, mPostFromReplyKey, &aeResult.mDesc);		ThrowIfOSErr_(err);				mPostUndoAEKeyFed = typeNull;	//	Don't add it twice	}	if (mPostUndoEvent.descriptorType != typeNull)		SendAppleEvent(mPostUndoEvent, mRecordOnlyFinalState ? kAEDontRecord : 0);}void	LAESemanticAction::FixSelectionWReply(DescType inSelectionModifier){	StAEDescriptor		aeResult,						modifiedSelection,						rubbish;	Assert_(mSelection);		aeResult.GetOptionalParamDesc(mReply.mDesc, keyAEResult, typeWildCard);	if (aeResult.mDesc.descriptorType != typeNull) {		switch (inSelectionModifier) {					case typeNull:				break;						//	Unknown selection modifiers			default:				Assert_(false);							//	Normal selection modifiers.			case kAEBefore:			case kAEAfter:			//	Possibly useful selection modifiers			case kAEBeginning:			case kAEEnd:			case kAEReplace:				UAEDesc::MakeInsertionLoc(aeResult.mDesc, inSelectionModifier, &modifiedSelection.mDesc);				break;		}		if (modifiedSelection.mDesc.descriptorType != typeNull)			mSelection->SetAEValue(modifiedSelection.mDesc, rubbish.mDesc);		else			mSelection->SetAEValue(aeResult.mDesc, rubbish.mDesc);	}	//	mSelection->FixSelection();}Boolean	LAESemanticAction::CanRedo(void) const{	return	inherited::CanRedo() &&	(mRedoEvent.descriptorType != typeNull);}Boolean	LAESemanticAction::CanUndo(void) const{	return	inherited::CanUndo() && (mUndoEvent.descriptorType != typeNull);}void	LAESemanticAction::GetReplyDesc(AEDesc *outDesc){	OSErr	err;		err = AEDuplicateDesc(&mReply.mDesc, outDesc);	ThrowIfOSErr_(err);}void	LAESemanticAction::SendAppleEvent(AppleEvent &inAppleEvent, AESendMode inSendModifiers){	StAEDescriptor	aeResult;	StAEDescriptor	aeHole;	OSErr			err;		inSendModifiers |= kAEWaitReply;	err = AEDisposeDesc(&mReply.mDesc);	ThrowIfOSErr_(err);		err = AESend(&inAppleEvent, &mReply.mDesc, inSendModifiers, kAENormalPriority,						kAEDefaultTimeout, nil, nil);	ThrowIfOSErr_(err);}// ===========================================================================LAEMoveAction::LAEMoveAction(){	Assert_(false);	//	Parameters required}LAEMoveAction::LAEMoveAction(	ResIDT		inRedoDescriptionResource,	Int16		inDescriptionIndex)	:	LAESemanticAction(inRedoDescriptionResource, inDescriptionIndex){}LAEMoveAction::~LAEMoveAction(){}void	LAEMoveAction::RedoSelf(void){	SendAppleEvent(mRedoEvent, mRecordOnlyFinalState ? kAEDontRecord : 0);	if (mUndoAEKeyFed != typeNull) {		StAEDescriptor	aeResult,						aeHole;			//	keyDirectObject -- the result from the original move		Assert_(mFromReplyKey != typeNull);		aeResult.GetParamDesc(mReply.mDesc, mFromReplyKey, typeWildCard);		UndoAEAdd(keyDirectObject, aeResult.mDesc);				//	keyAEInsertHere -- the resulting hole from the original move		aeHole.GetParamDesc(mReply.mDesc, keyAEInsertHere, typeWildCard);		UndoAEAdd(keyAEInsertHere, aeHole.mDesc);				mUndoAEKeyFed = typeNull;	//	Don't add it twice	}		//	Update selection	if (mSelection)		FixSelectionWReply(mRedoSelectionModifier);}