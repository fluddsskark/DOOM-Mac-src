//	===========================================================================//	LTextEngine.cp				©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LTextEngine.h"#include	<LListIterator.h>#include	<LSelectableItem.h>#include	<UMemoryMgr.h>#include	<AERegistry.h>#include	<AEObjects.h>/*	===========================================================================Notes:------¥	Part accessing is implemented in a two tier scheme.  The first tier would	be overridden for performance enhancements.  The second tier is just to	increase code reuse for this specific implementation.¥	All "char" routines will have to be modified to support multibyte	characters.		This should probably entail a run array of character lengths and	indexing from that run array.		Parsing the entire buffer for character boundaries would be unacceptably	inefficient.*///	===========================================================================Int32	LTextEngine::CountParts(	const TextRangeT	&inQueryRange,	DescType			inPartType) const{	Int32		rval = 0;		TextRangeT	queryRange = inQueryRange;	CropRange(&queryRange);	switch (inPartType) {		case cParagraph:			rval = CountParas(queryRange);			break;		case cLine:			rval = CountLines(queryRange);			break;		case cWord:			rval = CountWords(queryRange);			break;		case cChar:			rval = CountChars(queryRange);			break;		default:			ThrowOSErr_(errAEUnknownObjectType);			break;	}		return rval;}DescType	LTextEngine::FindNthPart(	const TextRangeT	&inQueryRange,	DescType			inPartType,	Int32				inPartIndex,	TextRangeT			*outPartRange) const/*	Find the nth part occurance of an inPartType relative to inQueryRange.		OutPartRange returns the range of the found part.*/{	TextRangeT	range;	DescType	rval = typeNull;		TextRangeT	queryRange = inQueryRange;	CropRange(&queryRange);		Assert_(inPartIndex > 0);	Assert_(queryRange.start >= 0);	Assert_(queryRange.length > 0);		switch (inPartType) {		case cParagraph:			rval = FindNthPara(queryRange, inPartIndex, &range);			break;		case cLine:			rval = FindNthLine(queryRange, inPartIndex, &range);			break;		case cWord:			rval = FindNthWord(queryRange, inPartIndex, &range);			break;		case cChar:			rval = FindNthChar(queryRange, inPartIndex, &range);			break;		default:			ThrowOSErr_(errAEUnknownObjectType);			break;		}	if (outPartRange)		*outPartRange = range;			return rval;}DescType	LTextEngine::FindSubRangePartIndices(	const TextRangeT	&inQueryRange,	const TextRangeT	&inSubRange,	DescType			inSubRangeType,	Int32				*outFirstIndex,	Int32				*outLastIndex) const	//	< 0 if not a subrange/*	Returns the part range indices (1 based) for inSubRange of part type	inSubRangeType.  All relative to inQueryRange (ie, the first corresponding	part in inQueryRange is 1 and indices correspond to parts counted from	that first part.		If inSubRange doesn't lie within inQueryRange, outFirstIndex will be set	to < 0 and the function return value will be typeNull.		If inSubRange.length is 0, outLastIndex doesn't make any sense and will be	set to < 0.		On return, if outLastIndex == outFirstIndex, inSubRange corresponded to	a single inSubRangeType part.		Return value (excluding when inSubRange.length == 0):		¥	In short, don't call FindSubRangePartIndices with an inSubRangeType that		doesn't match inSubRange.  The exception to this rule would be when		inSubRange.length == 0.			¥	Also, don't use an inQueryRange that doesn't fall on inSubRangeType		boundaries.				Doing either really doesn't make sense anyway.  But...				If inSubRange doesn't fall on inSubRangeType boundaries,		FindSubRangePartIndices returns a part type that would match inSubRange.		However, the indices returned are still relative to the original		inSubRangeType.				No check is made to see if inQueryRange lies on inSubRangeType part		boundaries.*/{	Int32		index1 = -1,				index2 = -1;	DescType	partFoundType = inSubRangeType;	TextRangeT	queryRange = inQueryRange,				subRange = inSubRange;	CropRange(&queryRange);	CropRange(&subRange);		do {		//	Sanity checks.		if (!URange32::RangeWithinRange(subRange, queryRange)) {			partFoundType = typeNull;			Assert_(false);			break;		}				switch (inSubRangeType) {			case cParagraph:				partFoundType = FindParaSubRangeIndices(queryRange, subRange, &index1, &index2);				break;			case cLine:				partFoundType = FindLineSubRangeIndices(queryRange, subRange, &index1, &index2);				break;			case cWord:				partFoundType = FindWordSubRangeIndices(queryRange, subRange, &index1, &index2);				break;			case cChar:				partFoundType = FindCharSubRangeIndices(queryRange, subRange, &index1, &index2);				break;			default:				ThrowOSErr_(errAEUnknownObjectType);				break;		}	} while (false);		if (index1 < 0 && index2 < 0)		partFoundType = typeNull;			if (outFirstIndex)		*outFirstIndex = index1;	if (outLastIndex)		*outLastIndex = index2;			return partFoundType;}//	---------------------------------------------------------------------------//	CountParts implementation:Int32	LTextEngine::CountParas(const TextRangeT &inQueryRange) const{	return CountParts_(inQueryRange, cParagraph);}Int32	LTextEngine::CountLines(const TextRangeT &inQueryRange) const{	return CountParts_(inQueryRange, cLine);}Int32	LTextEngine::CountWords(const TextRangeT &inQueryRange) const{	return CountParts_(inQueryRange, cWord);}Int32	LTextEngine::CountChars(const TextRangeT &inQueryRange) const{	return inQueryRange.length;}//	---------------------------------------------------------------------------//	FindSubRangePartIndices implementation:/*	This following routines should only be used by FindSubRangePartIndices.		Description for all routines:			Return the subrange indices for inSubRange relative to inQueryRange.				index1 & index2 are modified only if corresponding indexes are found.				Assumptions:						inQueryRange falls on part boundaries						inSubRange falls on part boundaries or, if 0 length, corresponds			to the start of a part*/DescType	LTextEngine::FindParaSubRangeIndices(	const TextRangeT	&inQueryRange,	const TextRangeT	&inSubRange,	Int32				*inIndex1,	Int32				*inIndex2) const{	return FindPartSubRangeIndices(inQueryRange, inSubRange, cParagraph, inIndex1, inIndex2);}DescType	LTextEngine::FindLineSubRangeIndices(	const TextRangeT	&inQueryRange,	const TextRangeT	&inSubRange,	Int32				*inIndex1,	Int32				*inIndex2) const{	return FindPartSubRangeIndices(inQueryRange, inSubRange, cLine, inIndex1, inIndex2);}DescType	LTextEngine::FindWordSubRangeIndices(	const TextRangeT	&inQueryRange,	const TextRangeT	&inSubRange,	Int32				*inIndex1,	Int32				*inIndex2) const{	return FindPartSubRangeIndices(inQueryRange, inSubRange, cWord, inIndex1, inIndex2);}DescType	LTextEngine::FindCharSubRangeIndices(	const TextRangeT	&inQueryRange,	const TextRangeT	&inSubRange,	Int32				*inIndex1,	Int32				*inIndex2) const{	//	index1	*inIndex1 = inSubRange.start - inQueryRange.start + 1;		//	index2	if (inSubRange.length > 0)		*inIndex2 = inSubRange.start + inSubRange.length - inQueryRange.start;			return cChar;}//	---------------------------------------------------------------------------//	FindNthPart implementation:DescType	LTextEngine::FindNthPara(	const TextRangeT	&inQueryRange,	Int32				inPartIndex,	TextRangeT			*outRange) const{	return FindNthPart_(inQueryRange, inPartIndex, cParagraph, outRange);}DescType	LTextEngine::FindNthLine(	const TextRangeT	&inQueryRange,	Int32				inPartIndex,	TextRangeT			*outRange) const{	return FindNthPart_(inQueryRange, inPartIndex, cLine, outRange);}DescType	LTextEngine::FindNthWord(	const TextRangeT	&inQueryRange,	Int32				inPartIndex,	TextRangeT			*outRange) const{	return FindNthPart_(inQueryRange, inPartIndex, cWord, outRange);}DescType	LTextEngine::FindNthChar(	const TextRangeT	&inQueryRange,	Int32				inPartIndex,	TextRangeT			*outRange) const{	outRange->start = inQueryRange.start + inPartIndex -1;	outRange->length = 1;		return cChar;}//	---------------------------------------------------------------------------//	Where the real non cChar work is done by this implementation...Int32	LTextEngine::CountParts_(const TextRangeT inQueryRange, DescType inPartType) const{	Int32		count = 0,				nextOffset;	TextRangeT	range = {inQueryRange.start, 0};	while (typeNull != FindPart(inQueryRange, &range, inPartType, &nextOffset)) {		range.start = nextOffset;		count++;	}	return count;}DescType	LTextEngine::FindPartSubRangeIndices(	const TextRangeT	&inQueryRange,	const TextRangeT	&inSubRange,	DescType			inSubPartType,	Int32				*inIndex1,	Int32				*inIndex2) const{	Int32		nextOffset = -1;	TextRangeT	range = {inQueryRange.start, 0};	Int32		count = 0;	DescType	partType,				rval = typeNull;	Boolean		foundIndex1 = false;	while (true) {		partType = FindPart(inQueryRange, &range, inSubPartType, &nextOffset);				if (partType == typeNull)			break;				count++;				//	index1		if (!foundIndex1) {			if (range.start >= inSubRange.start) {				if (	(range.start == inSubRange.start) &&						URange32::RangeWithinRange(range, inSubRange))					rval = partType;				else					rval = cChar;								foundIndex1 = true;				*inIndex1 = count;			}		}				//	index2		if (inSubRange.length > 0) {			if (range.start + range.length >= inSubRange.start + inSubRange.length) {				if (range.start + range.length == inSubRange.start + inSubRange.length) {					if (rval != partType)						rval = cChar;				} else {					rval = cChar;				}							*inIndex2 = count;				break;			}		} else {			Assert_(inSubRange.length == 0);			if (foundIndex1)				break;		}				//	past inSubRange?		if (nextOffset >= inSubRange.start + inSubRange.length)			break;		//	next		range.start = nextOffset;	}		return rval;}DescType	LTextEngine::FindNthPart_(	const TextRangeT	&inQueryRange,	Int32				inPartIndex,	DescType			inPartType,	TextRangeT			*outRange) const{	Int32		i,				nextOffset = inQueryRange.start;	TextRangeT	range;	DescType	partType;		for (i = 1; i <= inPartIndex; i++) {		range.start = nextOffset;		partType = FindPart(inQueryRange, &range, inPartType, &nextOffset);				if (partType == typeNull)			ThrowOSErr_(errAEIllegalIndex);	}		if (partType != typeNull)		*outRange = range;		return partType;}DescType	LTextEngine::FindPart(	const TextRangeT	&inQueryRange,	TextRangeT			*ioSubRange,	DescType			inSubPartType,	Int32				*outNextOffset) const{	switch (inSubPartType) {		case cParagraph:			return FindPara(inQueryRange, ioSubRange, outNextOffset);			break;		case cLine:			return FindLine(inQueryRange, ioSubRange, outNextOffset);			break;		case cWord:			return FindWord(inQueryRange, ioSubRange, outNextOffset);			break;		case cChar:	//	Already broken out in this implementation		default:			ThrowOSErr_(errAEUnknownObjectType);			break;	}		return typeNull;	//	Avoid compiler warning}DescType	LTextEngine::FindPara(	const TextRangeT	&inQueryRange,	TextRangeT			*ioRange,	Int32				*outEndOffset) const/*	Should only be called by FindPart*/{	return typeNull;}DescType	LTextEngine::FindLine(	const TextRangeT	&inQueryRange,	TextRangeT			*ioRange,	Int32				*outEndOffset) const/*	Should only be called by FindPart*/{	return typeNull;}DescType	LTextEngine::FindWord(	const TextRangeT	&inQueryRange,	TextRangeT			*ioRange,	Int32				*outEndOffset) const{	return typeNull;}