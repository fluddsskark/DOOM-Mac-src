//	===========================================================================//	LTETextEngine.cp				©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LTETextEngine.h"#include	<LListIterator.h>#include	<LSelectableItem.h>#include	<LTextEdit.h>#include	<UTextTraits.h>#include	<UMemoryMgr.h>#include	<UDrawingState.h>#include	<Scrap.h>#include	<LDataTube.h>#include	<PP_KeyCodes.h>#include	<LAESemanticAction.h>#include	<Errors.h>#include	<LNTextEdit.h>#include	<LStyleSet.h>#include	<URegions.h>//	===========================================================================//	Uglyness for TextEdit...#define				TEXTBUF	( *( (*mTEH)->hText ) )#define				TEREC	( *mTEH )#define				TEXTLENGTH	(GetHandleSize((*mTEH)->hText))#define				TEMONO	( TEREC->txSize != -1 )//	===========================================================================//	Uglyness for the click loop...extern "C" {/*	#pragma	parameter __D0 LTEClickLoop(__A3)	pascal Boolean LTEClickLoop(TEPtr pTE);	Should be but...		A3 and non inlines are rarely supported*/	pascal Boolean LTEClickLoop(void);}pascal Boolean LTEClickLoop(void){	//	Say what!#if	powerc	return !LTETextEngine::sActiveEngine->DoClickLoop();#else	return LTETextEngine::sActiveEngine->DoClickLoop();#endif	}TEClickLoopUPP	LTETextEngine::sClickUPP = NewTEClickLoopProc(LTEClickLoop);//	===========================================================================LTETextEngine::LTETextEngine():	LTextEngine(){//	Rect	r = UQDGlobals::GetQDGlobals()->thePort->portRect;	Rect	d, v;		d.top = mMargins.top;	d.left = mMargins.left;	d.right = d.left;	d.bottom = d.top;		v.top = 0;	v.left = 0;	v.right = mMargins.left + mMargins.right;	v.bottom = mMargins.top + mMargins.bottom;		mTEH = NULL;#if	0	mTEH = TEStyleNew(&d, &v);#else	mTEH = TENew(&d, &v);#endif	ThrowIfNULL_(mTEH);		TEAutoView(true, mTEH);	TESetClickLoop(sClickUPP, mTEH);	mImageSize.width = v.right;	mImageSize.height = v.bottom;}LTETextEngine::~LTETextEngine(void){	if (mTEH)		TEDispose(mTEH);	mTEH = NULL;		ClearHiliteRgn();}//	===========================================================================void	LTETextEngine::SetAttributes(Uint16 inAttributes){	inherited::SetAttributes(inAttributes);	RefreshText();}void	LTETextEngine::SetTextTraits(const TextTraitsRecord &inTraits){	inherited::SetTextTraits(inTraits);	Focus();	RefreshText();	}void	LTETextEngine::GetImageSize(	SDimension32	*outSize) const{	Rect	r = TEREC->destRect;		outSize->width = r.right - r.left;//	outSize->height = r.bottom - r.top;	//	not!	outSize->height = TEGetHeight(TEREC->nLines, 1, mTEH);		//	Margins;		outSize->width += mMargins.left;	outSize->width += mMargins.right;	outSize->height += mMargins.top;	outSize->height += mMargins.bottom;}void	LTETextEngine::SetImageSize(	const SDimension32	&inSize)/*	InSize.v = 0 --> automatically adjusted.*/{	SDimension32	oldSize;		GetImageSize(&oldSize);	if ((oldSize.width == inSize.width) && (oldSize.height == inSize.height)) 		return;			if ((inSize.height == 0) && (oldSize.width == inSize.width))		return;	TEREC->destRect.top = mMargins.top;	TEREC->destRect.left = mMargins.left;	TEREC->destRect.right = inSize.width - mMargins.right - mMargins.left;	TEREC->destRect.bottom = inSize.height - mMargins.bottom - mMargins.top;		Refresh(recalc_FormatAllText + recalc_WindowUpdate);}void	LTETextEngine::GetViewRect(	SPoint32		*outOrigin,	SDimension32	*outSize) const{	Rect	r = TEREC->viewRect;		outOrigin->h = r.left;	outOrigin->v = r.top;	outSize->width = r.right - r.left;	outSize->height = r.bottom - r.top;}void	LTETextEngine::SetViewRect(	const SPoint32		&inLocation,	const SDimension32	&inSize){	Rect	r;		r.top = inLocation.v;	r.left = inLocation.h;	r.right = inSize.width + r.left;	r.bottom = inSize.height + r.top;		TEREC->viewRect = r; //	Refresh(recalc_FormatAllText + recalc_WindowUpdate);}void	LTETextEngine::RecalcSelf(void){Focus();	if (mFlags)		ClearHiliteRgn();			if (mFlags & recalc_FormatAllText) {		FixImageRect();		UTextTraits::SetTETextTraits(&mTraits, mTEH);Focus();		TECalText(mTEH);				mFlags &= ~recalc_FormatAllText;	}		CheckImageSize();		inherited::RecalcSelf();}void	LTETextEngine::RefreshText(Int32 inAfterOffset){	Refresh(recalc_FormatAllText + recalc_WindowUpdate);}void	LTETextEngine::Focus(void){	inherited::Focus();	if (!(mAttributes & textAttr_MultiStyle)) {		UTextTraits::SetTETextTraits(&mTraits, mTEH);	} else {		Assert_(false);	//	Not yet implemented.	}}void	LTETextEngine::FixImageRect(void){	Rect	*vr = &(TEREC->viewRect); 	if ((mAttributes & textAttr_WordWrap) && (TEREC->viewRect.left == 0)) {		TEREC->destRect.left = 0 + mMargins.left;		TEREC->destRect.right = TEREC->viewRect.right - mMargins.right;	}	//	Make sure viewRect scrolls instead of destRect.	//	This takes care of auto scrolling	{		Point	delta;				delta.h = mMargins.left - TEREC->destRect.left;		delta.v = mMargins.top - TEREC->destRect.top;				if ((delta.h != 0) || (delta.v != 0)) {				OffsetRect(&TEREC->destRect, delta.h, delta.v);			OffsetRect(&TEREC->viewRect, delta.h, delta.v);				//	Synchronize PowerPlant owner view.			SPoint32		viewOrigin;			viewOrigin.h = vr->left - (TEREC->destRect.left - mMargins.left);			viewOrigin.v = vr->top - (TEREC->destRect.top - mMargins.top);						mView->SetScrollPosition(viewOrigin);				BroadcastMessage(msg_ViewParmsChanged);//			mView->ScrollImageTo(viewOrigin.h, viewOrigin.v, true);Focus();		}	}}void	LTETextEngine::ScrollView(	Int32	inLeftDelta,	Int32	inTopDelta,	Boolean	inRefresh){Focus();	ClearHiliteRgn();	//	So drag region is clipped to scrolling properly.	TEScroll(-inLeftDelta, -inTopDelta, mTEH);Focus();	FixImageRect();Focus();/*	//	Actually, our frame scrolls -- undo rect changes and let caller take care of it.	OffsetRect(&TEREC->destRect, inLeftDelta, inTopDelta);	OffsetRect(&TEREC->viewRect, inLeftDelta, inTopDelta);	SPoint32	imageLocation;		imageLocation.h = -(TEREC->viewRect.left - TEREC->destRect.left);	imageLocation.v = -(TEREC->viewRect.top - TEREC->destRect.top);		mView->SetImageLocation(imageLocation);*/}void	LTETextEngine::ScrollToSelection(Boolean inBottom){	Assert_(false);	//	Not yet implemented.  Not needed in LTETextEngine?/*	SPoint32	destination,				delta;		if (inBottom)	mText->GetViewRect(&view);	if (mText->IsSelectionVisible(view, &delta, inBottom)) {		mView->ScrollImageBy(delta.h, delta.v, true);	}*/}void	LTETextEngine::DrawArea(	const SPoint32		&inLocation,	const SDimension32	&inSize){	inherited::DrawArea(inLocation, inSize);	/*	From LTextEdit.h:		A Mac TERec stores a pointer to its owner port.  We have to change	it to the current port in case we are drawing into a port that is	not the owner port.  This happens when we are printing or drawing	into an offscreen port.*/	Rect	r;	GrafPtr	savePort = TEREC->inPort;	r.top = inLocation.v;	r.left = inLocation.h;	r.right = inSize.width + r.left;	r.bottom = inSize.height + r.top;	TEREC->inPort = UQDGlobals::GetCurrentPort();	EraseRect(&r);		TEUpdate(&r, mTEH);	TEREC->inPort = savePort;}void	LTETextEngine::Activate(void){	ClearHiliteRgn();	//	Uglyness 'cause of having to cache hilite regions.	TEActivate(mTEH);}void	LTETextEngine::Deactivate(void){	ClearHiliteRgn();	//	Uglyness 'cause of having to cache hilite regions.	TEDeactivate(mTEH);}void	LTETextEngine::Idle(void){Focus();	TEIdle(mTEH);}Boolean	LTETextEngine::DoKey(EventRecord &inEventRecord){	Int32	lines = TEREC->nLines;	char	inKey = inEventRecord.message & charCodeMask;		Try_ {	//	Don't let the destRect get messed up...		DoKeyPre(inEventRecord);				//	Strange TextEdit bug remedy... (Thanks to Patrick Doane)		TEREC->clikStuff = -1;				TEKey(inKey, mTEH);				DoKeyPost(inEventRecord);				if (TEREC->nLines != lines)			BroadcastMessage(msg_ModelScopeChanged);		FixImageRect();	} Catch_(inErr) {			if (TEREC->nLines != lines)			BroadcastMessage(msg_ModelScopeChanged);		FixImageRect();		Throw_(inErr);	} EndCatch_;		return true;}void	LTETextEngine::Click(SPoint32 inWhere, EventRecord &inEventRecord, Int16 inClickCount){	sActiveEngine = this;	Focus();	Point	where;	where.h = inWhere.h;	where.v = inWhere.v;	TEClick(where, (inEventRecord.modifiers & shiftKey) == shiftKey, mTEH);	Focus();}Boolean	LTETextEngine::DoClickLoop(void){	Boolean	rval;		Assert_((TEREC->destRect.top == mMargins.top) && (TEREC->destRect.left == mMargins.left));Focus();	rval = inherited::DoClickLoop();Focus();	return rval;}void	LTETextEngine::GetTotalRange(TextRangeT *outRange) const{	outRange->start = 0;	outRange->length = GetHandleSize(TEREC->hText);}//	===========================================================================//	Text get/setvoid	LTETextEngine::TextDelete(const TextRangeT &inRange){	TextRangeT	totalRange,				selRange,				range = inRange;	Int32		moveStart,				moveLength;		GetTotalRange(&totalRange);	GetSelectionRange(&selRange);		CropRange(&range);	moveLength = totalRange.length - (range.start + range.length);	moveStart = range.start + range.length;		//	AdjustSelection(selRange, range, -range.length);	if (moveLength > 0) {		BlockMoveData(TEXTBUF + moveStart, TEXTBUF + range.start, moveLength);	}	SetHandleSize(TEREC->hText, range.start + moveLength);		//	refill text...	RefreshText(range.start);	SetTextChanged();}void	LTETextEngine::TextGetThruPtr(const TextRangeT &inRange, Ptr outBuffer)/*	Note:			This method is MAYBE only suitable for plain text.  Consider using		one of the tube methods above unless really needing plain text		from a non tube source.*/{	Assert_(outBuffer);		BlockMoveData(TEXTBUF + inRange.start, outBuffer, inRange.length);}void	LTETextEngine::TextReplaceByPtr(	const TextRangeT	&inRange,	const Ptr			inSrcText,	Int32				inSrcLength)/*	Note:			This method is MAYBE only suitable for plain text.  Consider using		one of the tube methods above unless really needing plain text		from a non tube source.*/{	TextRangeT	selRange,				totRange,				range = inRange;	Int32		sizeDelta,				tailHead,				tailSize;		if (!SpaceForBytes(inSrcLength - inRange.length))		ThrowOSErr_(teScrapSizeErr);		GetTotalRange(&totRange);	GetSelectionRange(&selRange);	CropRange(&range);	sizeDelta = inSrcLength - range.length;	if (sizeDelta > 0) {		//	Make bigger		SetHandleSize(TEREC->hText, GetHandleSize(TEREC->hText) + sizeDelta);		ThrowIfMemError_();	}	//	Move tail if any	tailSize = totRange.length - (range.start + range.length);	tailHead = range.start + range.length;	Assert_(tailSize >= 0);	if (tailSize > 0) {		BlockMoveData(TEXTBUF + tailHead, TEXTBUF + tailHead + sizeDelta, tailSize);	}		if (sizeDelta < 0) {		//	Make smaller		SetHandleSize(TEREC->hText, GetHandleSize(TEREC->hText) + sizeDelta);		ThrowIfMemError_();	}	//	Adjust selection...//	AdjustSelection(selRange, range, sizeDelta);	//	New text	Assert_(inSrcLength >= 0);	if (inSrcLength > 0) {		BlockMoveData(inSrcText, TEXTBUF + range.start, inSrcLength);	}	//	refill text...	RefreshText(range.start);	SetTextChanged();}//	===========================================================================//	Data tube i/o:FlavorType	LTETextEngine::PickFlavorFrom(	const TextRangeT	&inRange,	const LDataTube		*inTube){	Assert_(inTube);		if (inTube->FlavorExists(typeChar))		return typeChar;	else		return typeNull;}void	LTETextEngine::AddFlavorTypesTo(	const TextRangeT	&inRange,	LDataTube			*inTube){	if (inRange.length > 0)		inTube->AddFlavor(typeChar);}Boolean	LTETextEngine::SendFlavorTo(	FlavorType			inFlavor,	const TextRangeT	&inRange,	LDataTube			*inTube){	TextRangeT	range = inRange;		CropRange(&range);		switch (inFlavor) {		case typeChar:		{			StHandleLocker(TEREC->hText);			inTube->SetFlavorData(inFlavor, TEXTBUF + range.start, range.length);			return true;			break;		}				default:			return false;			break;	}}void	LTETextEngine::ReceiveDataFrom(	const TextRangeT	&inRange,	LDataTube			*inTube){	FlavorType	flavor = PickFlavorFrom(inRange, inTube);		//	must be reworked to support non 'TEXT' replacement	Assert_(flavor == typeChar);		if (flavor == typeNull)		ThrowOSErr_(noTypeErr);		StTempHandle	data(inTube->GetFlavorSize(flavor));	inTube->GetFlavorHandle(flavor, data.mHandle);	TextReplaceByHandle(inRange, data.mHandle);}//	===========================================================================//	Selecting textvoid	LTETextEngine::SetSelectionRange(const TextRangeT &inRange){	TextRangeT	range = inRange,				oldRange;		CropRange(&range);	GetSelectionRange(&oldRange);		if (!URange32::RangesSame(oldRange, range)) {		ClearHiliteRgn();		Focus();		TESetSelect(range.start, range.start + range.length, mTEH);		BroadcastMessage(msg_ViewSelectionChanged);		FixImageRect();		//	Dang TextEdit scrolling wierdness...		//	TextEdit may have scrolled wierd so now we have to undo it		//	Yes, it will look glitchy.		//	AND, it is very bad coupling.		{			SPoint32	viewOrigin;						mView->GetScrollPosition(viewOrigin);			if (viewOrigin.h != 0) {				Int32 viewWidth = TEREC->viewRect.right - TEREC->viewRect.left;								if (GetRangeWidth(range) >= viewWidth){					viewOrigin.h = 0;					mView->ScrollImageTo(viewOrigin.h, viewOrigin.v, true);				}			}		}	}}void	LTETextEngine::GetSelectionRange(TextRangeT *outRange) const{	Assert_(mTEH);	Assert_(*mTEH);		outRange->start = TEREC->selStart;	outRange->length = TEREC->selEnd - TEREC->selStart;}//	===========================================================================//	Hiliting uglyness -- a real text engine wouldn't need this.RgnHandle	LTETextEngine::GetHiliteRgn(void){//	Parallel code in LTXTextEngine!!	TextRangeT	selRange;	OSErr		err;		GetSelectionRange(&selRange);		if (URange32::RangesSame(selRange, mHiliteRange) && mHiliteRgn)		return mHiliteRgn;	ClearHiliteRgn();		//	Can't do nested region creation	if (UQDGlobals::GetQDGlobals()->thePort->rgnSave != 0)		ThrowIfOSErr_(paramErr);			Try_ {		mHiliteRgn = NewRgn();													ThrowIfNULL_(mHiliteRgn);		err = TEGetHiliteRgn(mHiliteRgn, mTEH);													ThrowIfOSErr_(err);	} Catch_(err) {		ClearHiliteRgn();		Throw_(err);	} EndCatch_;		mHiliteRange = selRange;		return mHiliteRgn;}//	===========================================================================//	Presentation queryInt32	LTETextEngine::GetRangeHeight(const TextRangeT &inRange) const{	TextRangeT	range = inRange;		CropRange(&range);		Int32	line = TEGetLine(range.start);	return TEGetHeight(line, line, mTEH);}Boolean	LTETextEngine::Range2Image(	TextRangeT			&inRange,	Boolean				inLeadingEdge,	SPoint32			*outWhere) const{	Point		where;	TextRangeT	range = inRange;		CropRange(&range);		if (!inLeadingEdge)		range.start += range.length;			where = TEGetPoint(range.start, mTEH);		outWhere->h = where.h;	outWhere->v = where.v;		return true;}Boolean	LTETextEngine::Image2Range(	SPoint32			inWhere,	Boolean				*outLeadingEdge,	//	not yet implemented	TextRangeT			*outRange) const{	Point		where;	TextRangeT	rangeFound;	SPoint32	anchor;	//	Lower left of found character	Int32		width, height;	Boolean		leftEdge;		//	Get initial rangeFound	mView->ImageToLocalPoint(inWhere, where);	rangeFound.start = TEGetCorrectOffset(where);	//	Code here is paralleled in LTXTextEngine...		//	find edge & offset	Range2Image(rangeFound, true, &anchor);	if (where.h >= anchor.h) {		leftEdge = true;	} else {		leftEdge = false;		rangeFound.start -= PrevCharSize(rangeFound.start);	}	rangeFound.length = NextCharSize(rangeFound.start);	//	Adjust length according to whether the point is really over the character	if (rangeFound.length != 0) {		Range2Image(rangeFound, true, &anchor);		width = GetRangeWidth(rangeFound);		height = GetRangeHeight(rangeFound);				//	is the point really in the character?		if (!(	(anchor.h <= inWhere.h) && (inWhere.h < (anchor.h + width)) &&				((anchor.v - height) <= inWhere.v) && (inWhere.v < anchor.v)	))			rangeFound.length = 0;	}	if (outLeadingEdge) {		*outLeadingEdge = leftEdge;	}	if (outRange)		*outRange = rangeFound;			return true;}//	===========================================================================//	Implementation help:Boolean	LTETextEngine::SpaceForBytes(Int32 inAdditionalBytes){	return (TEREC->teLength + inAdditionalBytes) <= 32700;}Int16	LTETextEngine::ThisChar(Int32 inInsertionLocation) const/*	Returns the character immediately following the character at	inInsertionLocation.		Note that the return value is the 16 bit multi-byte value!		Will fail if attempting to return character past end of text.*/{	Int16	rval = TEXTBUF[inInsertionLocation];		Assert_((0 <= inInsertionLocation) && (inInsertionLocation < TEXTLENGTH));	return rval;}Int16	LTETextEngine::TEGetLine(Int16 inOffset) const{	Int32			line = 0;	if (inOffset > TEREC->teLength)		return(TEREC->nLines);	while (TEREC->lineStarts[line] < inOffset)		line++;		return line ;}Boolean LTETextEngine::TEIsFrontOfLine(Int32 inCharacterOffset) const/*	Is offset front of a line?		Originally seen in teutilities.c of DragText.*/{	short		line = 0;	if (TEREC->teLength == 0)		return(true);	if (inCharacterOffset >= TEREC->teLength)		return TEXTBUF[TEXTLENGTH - 1] == 0x0d;	while (TEREC->lineStarts[line] < inCharacterOffset)		line++;	return TEREC->lineStarts[line] == inCharacterOffset;}Int32	LTETextEngine::TEGetCorrectOffset(Point inWhere) const{	Int32	rval = TEGetOffset(inWhere, mTEH);	//	TextEdit is just plain wierd... (originally hinted at in DragText's HitTest)...			if (rval) {//		short	line = TEGetLine(rval);		short	prevCharOffset = rval - PrevCharSize(rval);		short	h = TEGetPoint(prevCharOffset, mTEH).h;		Point	prevWhere = TEGetPoint(prevCharOffset, mTEH);		short	prevHeight;		TextRangeT	range;				range.start = prevCharOffset;		range.length = PrevCharSize(rval);		prevHeight = GetRangeHeight(range);				/*	If we had intelligent cut and paste...		//	If at end of line don't let be at beginning of next line.  Instead back up before		//	trailing space		if (	TEIsFrontOfLine(rval)			&&	(ThisChar(prevCharOffset) != 0x0d)			&&	(h <= inWhere.h)			&&	((prevWhere.v >= inWhere.v) && (inWhere.v > (prevWhere.v - prevHeight)))		) {			rval = prevCharOffset;		} else		*/				//	TEGetOffset will return 1 past the correct number if the query point		//	is 1 and only one pixel to the right of the last non 0x0d character!		//		//	Wonder if this also holds true for non Roman scripts...		if (	TEIsFrontOfLine(rval)			&&	(ThisChar(prevCharOffset) == 0x0d)			&&	((h+1) == inWhere.h)			&&	((prevWhere.v >= inWhere.v) && (inWhere.v > (prevWhere.v - prevHeight)))		) {			rval = prevCharOffset;		}	}			return rval;}//	===========================================================================//	Parts implementation:DescType	LTETextEngine::FindPara(	const TextRangeT	&inQueryRange,	TextRangeT			*ioRange,	Int32				*outEndOffset) const/*	Should only be called by FindPart*/{	Int32	offset = ioRange->start;		if (ioRange->start >= (inQueryRange.start + inQueryRange.length))		return typeNull;		while (true) {		if (*(TEXTBUF + offset) == 0x0d) {			//	Found Mac return character -- accept range			*outEndOffset = offset + 1;			ioRange->length = offset + 1 - ioRange->start;			return cParagraph;		}				if (offset >= inQueryRange.start + inQueryRange.length) {					//	End of query range -- accept range			*outEndOffset = offset + 1;			ioRange->length = offset - ioRange->start;			return cChar;		}		offset++;	}		//	Should never get here	Assert_(false);	return typeNull;}DescType	LTETextEngine::FindLine(	const TextRangeT	&inQueryRange,	TextRangeT			*ioRange,	Int32				*outEndOffset) const/*	Should only be called by FindPart*/{	Int32		line;	//	Find the line the offset occurs in	for (line = 0; line < TEREC->nLines; line++) {			if (TEREC->lineStarts[line] >= (inQueryRange.start + inQueryRange.length))			return typeNull;					if (line == TEREC->nLines -1) {			if (	( TEREC->lineStarts[line] <= (ioRange->start) ) &&					( (ioRange->start) < TEREC->teLength ) )				break;		} else {			if (	( TEREC->lineStarts[line] <= (ioRange->start) ) &&					( (ioRange->start) < TEREC->lineStarts[line +1] )	)				break;		}	}	if (line == TEREC->nLines)		return typeNull;		//	Stuff and truncate range parameter for line	ioRange->start = TEREC->lineStarts[line];	if (line == TEREC->nLines -1) {		ioRange->length = TEREC->teLength - ioRange->start;	} else {		ioRange->length = TEREC->lineStarts[line+1] - ioRange->start;	}	if ( (ioRange->start + ioRange->length) > (inQueryRange.start + inQueryRange.length) ) {		ioRange->length = inQueryRange.start + inQueryRange.length - ioRange->start;	}		//	Report result	*outEndOffset = ioRange->start + ioRange->length;	if (ioRange->start != TEREC->lineStarts[line])		return cChar;	if (line != (TEREC->nLines -1)) {		if ( (ioRange->start + ioRange->length) != TEREC->lineStarts[line+1] )			return cChar;	}		return cLine;}DescType	LTETextEngine::FindWord(	const TextRangeT	&inQueryRange,	TextRangeT			*ioRange,	Int32				*outEndOffset) const{	if (ioRange->start >= (inQueryRange.start + inQueryRange.length))		return typeNull;	StHandleLocker	lock(TEREC->hText);	OffsetTable		offsets;	FindWordBreaks(		TEXTBUF,				//	Text buffer parms (ptr)		TEREC->teLength,		//		(buffer length)		ioRange->start,		 	//	Buffer offset to start search		true,					//	"leadingEdge," whatever that is		(BreakTablePtr) 0,		//	search for word breaks		offsets,				//	result		smCurrentScript	);		ioRange->start = offsets[0].offFirst;	ioRange->length = offsets[0].offSecond - ioRange->start;		//	Truncate to query range.	if (ioRange->start + ioRange->length > inQueryRange.start + inQueryRange.length)		ioRange->length = inQueryRange.start + inQueryRange.length - ioRange->start;	Assert_(ioRange->length >= 0);		*outEndOffset = offsets[0].offSecond;		return cWord;}