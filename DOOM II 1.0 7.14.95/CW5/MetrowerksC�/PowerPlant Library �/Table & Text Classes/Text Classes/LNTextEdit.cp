//	===========================================================================//	LNTextEdit.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif//	#define		INCLUDE_TX//	#define	DEBUGRECTS	1//	#define	DEBUGRECTS	2#include	<PP_Prefix.h>#include	"LNTextEdit.h"#include	<LTETextEngine.h>#ifdef	INCLUDE_TX	#include	<LTXTextEngine.h>	#include	<UAEGizmos.h>#endif#include	<LStyleSet.h>#include	<LTextElemAEOM.h>#include	<LTextSelection.h>#include	<LTextEditHandler.h>#include	<UAEDesc.h>#include	<LClipboardTube.h>#include	<LAESemanticAction.h>#include	<LListIterator.h>#include	<PP_Messages.h>#include	<LStream.h>#include	<UTextTraits.h>#include	<UMemoryMgr.h>#include	<UAppleEventsMgr.h>#include	<UDrawingState.h>#include	<URegions.h>#include	<UCursor.h>#ifndef		__RESOURCES__#include	<Resources.h>#endif#include	<Scrap.h>#include	<Errors.h>const Int16		Unwrapped_Width	= 1000;//	===========================================================================//	MaintenanceLNTextEdit*	LNTextEdit::CreateNTextEditStream(LStream	*inStream){	return new LNTextEdit(inStream);}LNTextEdit::LNTextEdit(){	Assert_(false);	//	Must use parameters}LNTextEdit::LNTextEdit(LStream	*inStream):	LSelectHandlerView(inStream){	Uint16			textAttributes;	ResIDT			textTraitsID;	ResIDT			initialTextID;	mTextLink = NULL;	mText = NULL;	mSelectAllOnTabSelect = false;		inStream->ReadData(&textAttributes, sizeof(Uint16));	inStream->ReadData(&textTraitsID, sizeof(ResIDT));	inStream->ReadData(&initialTextID, sizeof(ResIDT));		//	Text engine initialization	#ifdef	INCLUDE_TX		mText = new LTXTextEngine();	#else		mText = new LTETextEngine();	#endif	//	TextTraits	mText->SetAttributes(textAttributes);	SetTextTraitsID(textTraitsID);	//	Initial text	StResource	textRsrc('TEXT', initialTextID, false);	if (textRsrc.mResourceH != nil) {		mText->TextReplaceByHandle(LTextEngine::sTextAll, textRsrc.mResourceH);	}}void	LNTextEdit::FinishCreateSelf(void){	inheritView::FinishCreateSelf();		SetModelKind(cText);	SetUseSubModelList(true);	if (!(mText->GetAttributes() & textAttr_WordWrap))		mText->SetImageSize(mImageSize);	//	Set this before it will broadcast it back.	FixImage();		mText->AddListener(this);	mText->SetView(this);	//	AEOM initialization...	TextRangeT	range = {0, 0};	mTextLink = new LTextElemAEOM(this, cChar, this, range);	mTextLink->SetLaziness(false);	//	a permanent object.	mTextLink->OwnershipClaimed(this);	FixLink();		//	SelectHandlerView initialization	mSelection = new LTextSelection(this, this, mText, mTextLink);	mSelection->OwnershipClaimed(this);	mEventHandler = new LTextEditHandler(this, mSelection, this);	FixView();}LNTextEdit::~LNTextEdit(){	Int32		i,				n = CountSubModels(cStyleSet);	LStyleSet	*s;	for (i = n; i >= 1; i--) {		StAEDescriptor	token;		GetSubModelByPosition(cStyleSet, i, token.mDesc);//		s = (LStyleSet *) mSubModels->GetSubModelByPosition(cStyleSet, i);		s = (LStyleSet *) GetModelFromToken(token.mDesc);		RemoveSubModel(s);	//	should imply a delete//		s->OwnershipReleased(this);	}	delete mEventHandler;	SHARED_OBJ_REPLACE_REF(mSelection, NULL);	SHARED_OBJ_REPLACE_REF(mTextLink, NULL);	delete mText;}void	LNTextEdit::SetTextTraitsID(	ResIDT	inTextTraitsID){	TextTraitsRecord	traits;	TextTraitsH			traitsH = UTextTraits::LoadTextTraits(inTextTraitsID);	if (traitsH) {		traits = **traitsH;	} else {		UTextTraits::LoadSystemTraits(traits);	}		mText->SetTextTraits(traits);}//	===========================================================================//	Text object accessLTextEngine *	LNTextEdit::GetTextObject(void){	return mText;}LTextElemAEOM *	LNTextEdit::GetTextLink(void){	return mTextLink;}//	===========================================================================//	Implementationclass	StVisRgn{public:	StVisRgn(GrafPtr inPort, const Rect &inRect);	~StVisRgn();		StRegion	mTempRgn;	GrafPtr		mPort;	RgnHandle	mSavedVisRgn;};StVisRgn::StVisRgn(GrafPtr inPort, const Rect &inRect){	ThrowIfNULL_(inPort);		mPort = inPort;	mSavedVisRgn = mPort->visRgn;	RectRgn(mTempRgn.mRgn, &inRect);	mPort->visRgn = mTempRgn.mRgn;}StVisRgn::~StVisRgn(){	mPort->visRgn = mSavedVisRgn;}void	LNTextEdit::ListenToMessage(MessageT inMessage, void *ioParam){	switch (inMessage) {		case msg_ModelChanged:			FixLink();			break;		case msg_ModelScopeChanged:		{			SDimension32	size,							oldSize;			GrafPtr			mPort = GetMacPort();			ThrowIfNULL_(mPort);			StVisRgn		saveVisRgn(mPort, mPort->portRect);			mText->GetImageSize(&size);			GetImageSize(oldSize);#if	1			inheritView::ResizeImageBy(size.width - oldSize.width, size.height - oldSize.height, true);FocusDraw();#else			Try_ {				mEngineGeneratedResize = true;	//	UGLY! coupling				ResizeImageBy(size.width - oldSize.width, size.height - oldSize.height, true);				mEngineGeneratedResize = false;			} Catch_(inErr) {				mEngineGeneratedResize = false;				Throw_(inErr);			} EndCatch_;#endif			break;		}		case msg_ViewParmsChanged:		{			GrafPtr			mPort = GetMacPort();			ThrowIfNULL_(mPort);			StVisRgn		saveVisRgn(mPort, mPort->portRect);			if (mSuperView != nil) {				mSuperView->SubImageChanged(this);			}			FixHandlerFrame();			break;		}	}}Boolean	LNTextEdit::ObeyCommand(	CommandT	inCommand,	void*		ioParam){	Boolean				cmdHandled = true;		switch (inCommand) {			case msg_TabSelect:			if (!mSelectAllOnTabSelect)				return LSelectHandlerView::ObeyCommand(inCommand, ioParam);			//	fall through...		case cmd_SelectAll:		{			if (mSelection) {				LTextElemAEOM 	*newSelect = new LTextElemAEOM(this->mTextLink, cChar, this, LTextEngine::sTextAll);				mSelection->SelectSimple(newSelect);			}			cmdHandled = true;			break;		}					default:			cmdHandled = LSelectHandlerView::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}LSemanticAction *	LNTextEdit::MakePasteAction(void)/*	For text, the selection point should be moved to the end	of the new text.*/{	LAESemanticAction	*action;	Assert_(mSelection);	action = (LAESemanticAction *)LSelectHandlerView::MakePasteAction();	action->SetSelection(mSelection, kAEAfter);  //	note selection modifier.	return action;}void	LNTextEdit::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	switch (inCommand) {			case cmd_Copy:			if (mSelection)			//	If any selection, always exists to allow				outEnabled = true;	//	copy/paste of selection object specifier									//	-- even if it is an insertion point.			break;		case cmd_SelectAll:			outUsesMark = false;			if (mSelection)				outEnabled = true;			break;					default:			LSelectHandlerView::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			switch (inCommand) {				case cmd_Clear:				case cmd_Cut:				case cmd_Paste:					if (!(mText->GetAttributes() & textAttr_Editable))						outEnabled = false;					break;			}			break;	}}LSelectableItem *	LNTextEdit::OverItem(Point inWhere){	LSelectableItem	*rval = inheritView::OverItem(inWhere);	TextRangeT		range,					temp;	Boolean			leadingEdge;		if (rval)		return rval;	//	Is there a corresponding text offset?	SPoint32		where;	LocalToImagePoint(inWhere, where);	if (mText->Image2Range(where, &leadingEdge, &range)) {		if (!leadingEdge)			range.start = range.start + range.length;		range.length = 0;	} else {//		Assert_(b);		range.start = 0;		range.length = 0;	}		mText->GetTotalRange(&temp);	Assert_(URange32::RangeWithinRange(range, temp));	rval = new LTextElemAEOM(mTextLink, cChar, this, range);	return rval;}void	LNTextEdit::NoteOverNewThing(LManipulator *inThing){	if (inThing) {		switch(inThing->ItemType()) {			case kManipulator:				UCursor::Reset();	//	?				break;			case kSelectableItem:				UCursor::Tick(cu_IBeam);				break;			case kSelection:				LSelectHandlerView::NoteOverNewThing(inThing);	//	Ie. data drag "hand"				break;		}	} else {		UCursor::Reset();	}}Boolean	LNTextEdit::FocusDraw(void){	Boolean			rval;		rval = inheritView::FocusDraw();	return rval;}void	LNTextEdit::SubtractSelfErasingAreas(RgnHandle inSourceRgn){	StRegion	myRgn;	Rect		r;		if (CalcPortFrameRect(r)) {		RectRgn(myRgn, &r);		DiffRgn(inSourceRgn, myRgn, inSourceRgn);	}//	NO!	This panes entire region was already subtracted above!////	inherited::SubtractSelfErasingAreas(inSourceRgn);////	NO!}void	LNTextEdit::DrawSelf(void){	SPoint32		location;	SDimension32	size;		Rect			r;		if (CalcLocalFrameRect(r)) {//		EraseRect(&r);	}		mText->GetViewRect(&location, &size);	mText->DrawArea(location, size);	#ifdef	DEBUGRECTS		DrawDebugRects();	#endif}void	LNTextEdit::DrawDebugRects(void){#ifdef	DEBUGRECTS	StColorState	savePen;	RGBColor		red = {0xffff, 0, 0},			//	Image					green = {0, 0xffff, 0},			//	Frame					blue = {0, 0, 0xffff},			//	text frame					purple = {0xffff, 0, 0xffff};	//	text image	Rect			r,					cr;	SPoint32		o;	SDimension32	s;//	PenMode(srcXor);	cr = GetMacPort()->portRect;	ClipRect(&cr);	RGBForeColor(&green);	CalcLocalFrameRect(r);	FrameRect(&r);	mText->GetViewRect(&o, &s);	r.top = o.v;	r.left = o.h;	r.right = r.left + s.width;	r.bottom = r.top + s.height;	RGBForeColor(&blue);	FrameRect(&r);		//	image rects	#if	DEBUGRECTS > 1		GetScrollPosition(o);		GetImageSize(s);		r.top = 0;		r.left = 0;		r.right = r.left + s.width;		r.bottom = r.top + s.height;		RGBForeColor(&red);		FrameRect(&r);			mText->GetImageSize(&s);		r.top = 0;		r.left = 0;		r.right = r.left + s.width;		r.bottom = r.top + s.height;		RGBForeColor(&purple);		FrameRect(&r);	#endif	#endif}void	LNTextEdit::FixView(void){	Rect			r;	SPoint32		location;	SDimension32	size;	if (!CalcLocalFrameRect(r))		Throw_(paramErr);	size.width = r.right - r.left;	size.height = r.bottom - r.top;	GetScrollPosition(location);	mText->SetViewRect(location, size);}void	LNTextEdit::FixImage(void){	SDimension32	size;		//	Wrap to frame size...	if ((mText->GetAttributes() & textAttr_WordWrap)) {		SPoint32		location;		Rect			r;		GetScrollPosition(location);		if (location.h == 0) {			if (!CalcLocalFrameRect(r))				Throw_(paramErr);					size.width = r.right - r.left;			size.height = 0;			mText->SetImageSize(size);	//	Will likely cause an update that										//	will fix the scrollbars		}	}}void	LNTextEdit::MoveBy(	Int32	inHorizDelta,	Int32	inVertDelta,	Boolean	inRefresh){	inheritView::MoveBy(inHorizDelta, inVertDelta, inRefresh);	FixView();}void	LNTextEdit::ResizeFrameBy(	Int16		inWidthDelta,	Int16		inHeightDelta,	Boolean		inRefresh){	inheritView::ResizeFrameBy(inWidthDelta, inHeightDelta, inRefresh);	FixView();	FixImage();}void	LNTextEdit::ResizeImageBy(	Int32		inWidthDelta,	Int32		inHeightDelta,	Boolean		inRefresh){//	inheritView::ResizeImageBy(inWidthDelta, inHeightDelta, inRefresh);//	FixView();	SDimension32	size;	GetImageSize(size);	size.width += inWidthDelta;	size.height = 0;				//	ie variable	mText->SetImageSize(size);}void	LNTextEdit::ScrollImageBy(	Int32		inLeftDelta,			// Pixels to scroll horizontally	Int32		inTopDelta,				// Pixels to scroll vertically	Boolean		inRefresh){	mText->ScrollView(inLeftDelta, inTopDelta, inRefresh);	FixHandlerFrame();	#ifdef	DEBUGRECTS		FocusDraw();		DrawDebugRects();	#endif}void	LNTextEdit::GetPortOrigin(Point *outOrigin){	*outOrigin = mPortOrigin;}void	LNTextEdit::SetScrollPosition(const SPoint32 &inLocation){	mImageLocation.h = mFrameLocation.h - inLocation.h;	mImageLocation.v = mFrameLocation.v - inLocation.v;	CalcPortOrigin();	OutOfFocus(this);	Assert_(mSubPanes.GetCount() == 0);	if (mSuperView != nil) {		mSuperView->SubImageChanged(this);	}}void	LNTextEdit::SavePlace(	LStream		*outPlace){	SPoint32		location;	SDimension32	size;	mText->GetViewRect(&location, &size);	LView::SavePlace(outPlace);		outPlace->WriteData(&location, sizeof(location));	outPlace->WriteData(&size, sizeof(size));}void	LNTextEdit::RestorePlace(	LStream		*inPlace){	SPoint32		location;	SDimension32	size;	LView::RestorePlace(inPlace);	inPlace->ReadData(&location, sizeof(location));	inPlace->ReadData(&size, sizeof(size));	mText->SetViewRect(location, size);}//	===========================================================================//	AEOM supportLModelObject*	LNTextEdit::HandleCreateElementEvent(	DescType			inElemClass,	DescType			inInsertPosition,	LModelObject		*inTargetObject,	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply){	LModelObject	*rval = NULL;	FixLink();	//	Precautionary		switch(inElemClass) {#ifdef	INCLUDE_TX		case cStyleSet:		{			StAEDescriptor	properties;			Int32			i,							count;			StAEDescriptor	bogusReply,							propDesc;			AEKeyword		keyword;						rval = mText->GetNewStyleSet();			properties.GetOptionalParamDesc(inAppleEvent, keyAEPropData, typeAERecord);			if (properties.mDesc.descriptorType != typeNull) {				LAESubDesc	aProperty,							theProps(properties);				count = theProps.CountItems();								for (i = 1; i <= count; i++) {					theProps.NthItem(i, &keyword, aProperty);					AEDisposeDesc(propDesc);					aProperty.ToDesc(typeWildCard, propDesc);					rval->SetAEProperty(keyword, propDesc, bogusReply.mDesc);				}			}			if (inTargetObject)				inTargetObject->Finalize();			break;		}#endif		default:			rval = mTextLink->HandleCreateElementEvent(inElemClass, inInsertPosition,						mTextLink, inAppleEvent, outAEReply);			break;	}	return rval;}void	LNTextEdit::GetSubModelByName(	DescType		inModelID,	Str255			inName,	AEDesc			&outToken) const{	if (inModelID == cStyleSet) {		if (mSubModels) {			LListIterator	iterator(*mSubModels, iterate_FromStart);			LModelObject	*p;			Boolean			found = false;			StringPtr		str;						while (iterator.Next(&p)) {				if (p->GetModelKind() == inModelID) {	//				if (member(p, LCoreAEOM)) {						str = ((LStyleSet *)p)->GetModelNamePtr();						if (str) {							if (EqualString(str, inName, true, true)) {								found = true;								break;							}						}	//				}				}			}			if (found) {				PutInToken(p, outToken);				return;			}		}	} else {		LSelectHandlerView::GetSubModelByName(inModelID, inName, outToken);	}		}LCoreAEOM *	LNTextEdit::GetSubModelForInsertion(	DescType		inInsertPosition,	LModelObject*	inTargetObject) const{	FixLink();	//	Precautionary		return mTextLink->GetSubModelForInsertion(inInsertPosition, mTextLink);}void	LNTextEdit::GetSubModelByPosition(	DescType		inModelID,	Int32			inPosition,	AEDesc			&outToken) const{	FixLink();	//	Precautionary		switch (inModelID) {		case cStyleSet:			LCoreAEOM::GetSubModelByPosition(inModelID, inPosition, outToken);			break;		default:			mTextLink->GetSubModelByPosition(inModelID, inPosition, outToken);			break;	}}									void	LNTextEdit::GetSubModelByComplexKey(	DescType		inModelID,	DescType		inKeyForm,	const AEDesc	&inKeyData,	AEDesc			&outToken) const{	FixLink();	//	Precautionary			switch (inModelID) {		case cStyleSet:			LCoreAEOM::GetSubModelByComplexKey(inModelID, inKeyForm, inKeyData, outToken);			break;		default:			mTextLink->GetSubModelByComplexKey(inModelID, inKeyForm, inKeyData, outToken);			break;	}}Int32	LNTextEdit::CountSubModels(DescType inModelID) const{	FixLink();	//	Precautionary		switch (inModelID) {		case cStyleSet:			return LCoreAEOM::CountSubModels(inModelID);			break;		default:			return mTextLink->CountSubModels(inModelID);			break;	}	return 0;}Int32	LNTextEdit::GetPositionOfSubModel(			DescType			inModelID,			const LModelObject	*inSubModel) const{	FixLink();	//	Precautionary		switch (inModelID) {		case cStyleSet:			return LCoreAEOM::GetPositionOfSubModel(inModelID, inSubModel);			break;		default:			return mTextLink->GetPositionOfSubModel(inModelID, inSubModel);			break;	}}void	LNTextEdit::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{ 	switch (inProperty) {		case pPPTextAEOMVersion:		{			OSErr	err;			Int32	intValue;			intValue = PPTEXTAEOMVERSION;			err = AECreateDesc(typeLongInteger, (Ptr) &intValue, sizeof(intValue), &outPropertyDesc);			ThrowIfOSErr_(err);			break;		}		default:			FixLink();	//	Precautionary			mTextLink->GetAEProperty(inProperty, inRequestedType, outPropertyDesc);			break;	}}void	LNTextEdit::SetAEProperty(	DescType		inProperty,	const AEDesc	&inValue,	AEDesc&			outAEReply){	FixLink();	//	Precautionary		mTextLink->SetAEProperty(inProperty, inValue, outAEReply);}//	===========================================================================//	Implementationvoid	LNTextEdit::FixLink(void) const/*	Call this routine when the mText has changed.		This routine brings the link range up to date.*/{	TextRangeT	range;	((LTextEngine *)mText)->GetTotalRange(&range);		((LTextElemAEOM *)mTextLink)->SetRange(range);}#if	0void	LNTextEdit::FixSelection(void)/*	Call this routine when the mText might have changed.		This routine brings the test selection range up to date.*/{	mSelection->FixSelection();}#endif