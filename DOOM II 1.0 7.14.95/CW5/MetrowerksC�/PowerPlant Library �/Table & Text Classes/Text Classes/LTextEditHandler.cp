//	===========================================================================//	LTextEditHandler.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LTextEditHandler.h"#include	<LNTextEdit.h>#include	<LTextElemAEOM.h>#include	<LAESemanticAction.h>#include	<LSelection.h>#include	<LListIterator.h>#include	<UAppleEventsMgr.h>#include	<UMemoryMgr.h>#include	<AERegistry.h>#include	<AEObjects.h>#include	<Errors.h>#include	<LDataTube.h>//	===========================================================================//	Maintenance:LTextEditHandler::LTextEditHandler(){	Assert_(false);}LTextEditHandler::LTextEditHandler(	LNTextEdit			*inTextFlow,	LSelection			*inSelection,	LSemanticUndoer		*inUndoer)	:	LDataDragEventHandler(inSelection, inUndoer){	mTextFlow = inTextFlow;	SetView(inTextFlow);}LTextEditHandler::~LTextEditHandler(){}//	===========================================================================//	Implementation//		LEventHandlerBoolean	LTextEditHandler::DoEvent(const EventRecord &inEvent){	if (IsActive()) {			//	update mText		mText = mTextFlow->GetTextObject();		//	for blinking caret...		mText->Idle();	}		return inherited::DoEvent(inEvent);}void	LTextEditHandler::Activate(void){	inherited::Activate();	//	(mTextFlow->GetTextObject())->Activate();}void	LTextEditHandler::Deactivate(void){	//	(mTextFlow->GetTextObject())->Deactivate();	inherited::Deactivate();}void	LTextEditHandler::KeyDown(void){	inherited::KeyDown();		Try_ {		if (mText->DoKey(mEvtRecord)) {			//	Post typing action?		} else {			SysBeep(30);		}	} Catch_(inErr) {		if (inErr != editingNotAllowed)			Throw_(inErr);	} EndCatch_;}void	LTextEditHandler::Idle(void){	inherited::Idle();	//	for blinking caret...	mText->Idle();}void	LTextEditHandler::NoteNthClick(Int16 inClickCount, Point inWhere){/*	Note:	This routine replaces the standard behavior of			LSelectionEventHandler::NoteNthClick.*/		Boolean			shiftDown = (	(mEvtRecord.modifiers & shiftKey) ||									(mEvtRecord.modifiers & cmdKey)	)? true : false;	TextRangeT		prevRange;		//	Of the selection	TextRangeT		newRange;		//	Of the selection	DescType		newRangeType;	LTextElemAEOM	*newlySelectedText;	Assert_(mSelection);		mClickInLastSelection = mSelection->PointInRepresentation(inWhere);	//	In selection area?	if (mClickInLastSelection) {		if (!shiftDown)			inherited::NoteNthClick(inClickCount, inWhere);		return;	}		if (!(mText->GetAttributes() & textAttr_Selectable))		return;	mText->GetSelectionRange(&prevRange);	mText->Idle();		//	A precaution to help TE with its double						//	click detection and caret idling.	SPoint32	where;	where.h = inWhere.h;	where.v = inWhere.v;	mText->Click(where, mEvtRecord, inClickCount);	/*		TextEngine click is a more traditional "Track mouse" type operation.		ie.  control won't come back until a mouse up.				This means the LEventHandler state machine will become		unsynchronized with mouse dragging during the click.		The state information must be correctly updated or 		LEventHandler will detect and implement a redundant drag...	*/	mEvtClickCountUpTime = TickCount();	GetMouse(&mEvtMouse);	if (!PointIsClose(mEvtMouse, mLastEvtMouse)) {		//	Moved far enough		mEvtClickCount = 0;		SetEvtState(evtl_idle);	} else {		if (GetEvtState() == evtl_clickCounting)			mEvtMouse = mLastEvtMouse;	//	Don't degrade original down location		else			SetEvtState(evtl_idle);	} 	mEvtRecord.where = mEvtMouse;	LocalToGlobal(&mEvtRecord.where);	mEvtRecord.modifiers &= ~((short)btnState);	//	Details! -- mouse is now up		//	Find AE "class" of text being newly selected	switch (inClickCount) {		default:		case 1:			newRangeType = cChar;			break;		case 2:			newRangeType = cWord;			break;/*	Suggestive ideas if code wasn't a wrapper to TextEdit:		case 3:			newRangeType = cLine:			break;		case 4:			newRangeType = cParagraph:			break;*/	}	//	Find range of new selection	shiftDown = false;	//	This "feature" doesn't work and doesn't make						//	sense without discontinuous text selections anyway.	//		(What about command & option keys?  Again, TextEdit restriction.)	if (shiftDown) {		TextRangeT		cumRange;				mText->GetSelectionRange(&cumRange);		if (cumRange.start == prevRange.start) {			//	Head same			newRange.start = prevRange.start + prevRange.length;		} else {			//	Tail same			if ( (cumRange.start + cumRange.length) != (prevRange.start + prevRange.length) )				ThrowOSErr_(paramErr);		//	Should never happen			newRange.start = cumRange.start;		}		newRange.length = cumRange.length - prevRange.length;	} else {		mText->GetSelectionRange(&newRange);	}	newRangeType = cChar;	//	disable selection as words for performance reasons		//	Make a new LSelectableItem for the newly selected range	newlySelectedText = new LTextElemAEOM(mTextFlow->mTextLink, newRangeType, mTextFlow, newRange);		if (shiftDown) {		mSelection->SelectContinuous(newlySelectedText);	} else {		mSelection->SelectSimple(newlySelectedText);	}	CheckCursor();}Boolean	LTextEditHandler::DragIsAcceptable(	DragReference	inDragRef){	if (mText->GetAttributes() & textAttr_Editable)		return inherited::DragIsAcceptable(inDragRef);	return false;	//	A non-editable text frame can't receive a drag.}