//	===========================================================================//	LTextSelection.cp				©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LTextSelection.h"#include	<LListIterator.h>#include	<LSelectableItem.h>#include	<LTextElemAEOM.h>#include	<LTextEngine.h>#include	<UAppleEventsMgr.h>#include	<UAEDesc.h>#include	<Errors.h>//	Shouldn't be defined for any user code -- just for internal debugging of//	LTextEngine and derivatives.//	#define	DEBUG_POINTINRANGELTextSelection::LTextSelection(	LModelObject	*inSuperModel,	LNTextEdit		*inFlow,	LTextEngine		*inText,	LTextElemAEOM	*inLink):	LSelection(inSuperModel){	mText = inText;	mTextFlow = inFlow;	mTextLink = inLink;		mText->AddListener(this);		FixSelection();}LTextSelection::~LTextSelection(void){}void	LTextSelection::Activate(void){	LSelection::Activate();		mText->Activate();}void	LTextSelection::Deactivate(void){	mText->Deactivate();		LSelection::Deactivate();}void	LTextSelection::Idle(void){	mText->Idle();}void	LTextSelection::ListenToMessage(MessageT inMessage, void *ioParam){	switch (inMessage) {		case msg_ViewSelectionChanged:			FixSelection();			break;	}}void	LTextSelection::FixSelection(void)/*	Fix mSelection range (this) to reflect text object selection (mText)*/{	TextRangeT		selRange,					lstRange;	LTextElemAEOM	*lstItem;	Boolean			doFix = true;		Assert_(mText);		mText->GetSelectionRange(&selRange);			do {		if (ListCount() != 1)			break;				lstItem = (LTextElemAEOM *) ListNthItem(1);		Assert_(lstItem);//		Assert_(member(lstItem, LTextElemAEOM));		lstItem->GetRange(&lstRange);				if (!URange32::RangesSame(selRange, lstRange))			break;				doFix = false;	} while (false);		if (doFix) {		Try_ {			StopListening();			ListClear();			lstItem = new LTextElemAEOM(mTextLink, cChar, mTextFlow, selRange);			ListAddItem(lstItem);			StartListening();		} Catch_(inErr) {			StartListening();			Throw_(inErr);		} EndCatch_;	}}void	LTextSelection::ListAddItem(LSelectableItem *inItem){	TextRangeT		selRange,					addRange,					totRange;	LTextElemAEOM	*selItem,					*addItem = (LTextElemAEOM *) inItem,					*totItem;	DescType		selKind,					addKind,					totKind;		Assert_(mText);	Assert_(addItem);//	Assert_(member(newItem, LTextElemAEOM));	addItem->GetRange(&addRange);	addKind = addItem->GetModelKind();		Try_ {		StopListening();				switch(ListCount()) {					case 0:				mText->SetSelectionRange(addRange);				LSelection::ListAddItem(addItem);				break;							case 1:				//	Get and remove existing selection range				selItem = (LTextElemAEOM *) ListNthItem(1);				selItem->GetRange(&selRange);				selKind = selItem->GetModelKind();				ListClear();	//	Likely a deletion of selItem				selItem = NULL;								//	Make and add total selection range				URange32::RangeUnion(selRange, addRange, &totRange);				if (selKind != addKind)					totKind = cChar;				else					totKind = selKind;				totItem = new LTextElemAEOM(mTextLink, totKind, mTextFlow, totRange);				LSelection::ListAddItem(totItem);								//	Double check				mText->GetSelectionRange(&selRange);				Assert_(URange32::RangesSame(selRange, totRange));				break;						default:				Throw_(paramErr);				break;		}		StartListening();	} Catch_(err) {		StartListening();		Throw_(err);	} EndCatch_;}Boolean		LTextSelection::PointInRepresentation(Point inWhere)/*	It is irritating to have to implement this method this way rather than using	the inherited LTextEngine::PointInRange.  Unfortunately, there is no way to	tell exactly what the selection region contains when gluing to other	engines.  This method will work.*/{#ifdef	DEBUG_POINTINRANGE	return LSelection::PointInRepresentation(inWhere);#else	Boolean rval;		if (!IsSubstantive())		return false;			Assert_(mItems.GetCount() == 1);	/*		Before LSelection::FindDragOutline opens a region, make sure that all		composite selections have already cached their regions.				If this isn't done, another region would be opened by TEGetHiliteRgn and		you can't nest open regions!	*/	DrawSelected();	//	really doesn't draw but just cache's selection trhion		RgnHandle	rgn = MakeRegion(inWhere);	Point		origin;		origin.h = origin.v = 0;	rval = PtInRgn(origin, rgn);	DisposeRgn(rgn);	return rval;#endif}RgnHandle	LTextSelection::FindDragOutline(Point inOrigin){	/*		Before LSelection::FindDragOutline opens a region, make sure that all		composite selections have already cached their regions.				If this isn't done, another region would be opened by TEGetHiliteRgn and		you can't nest open regions!	*/	Try_ {		HidePen();		DrawLatent();		ShowPen();	} Catch_(inErr) {		ShowPen();		Throw_(inErr);	} EndCatch_;		return LSelection::FindDragOutline(inOrigin);}Boolean	LTextSelection::IsSubstantive(void)/*	Does the selection contain data that can be copied?*/{	if (mItems.GetCount() > 0) {		LSelectableItem	*selItem;		LTextElemAEOM	*item;		TextRangeT		range;		mItems.FetchItemAt(1, &selItem);		Assert_(selItem);		item = (LTextElemAEOM *)selItem;//		Assert_(member(item, LTextElemAEOM));		item->GetRange(&range);		if (range.length > 0)			return true;	}	return false;}