//	===========================================================================//	LTextEngine.cp				©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LTextEngine.h"#include	<LListIterator.h>#include	<LSelectableItem.h>#include	<LTextEdit.h>#include	<UTextTraits.h>#include	<UMemoryMgr.h>#include	<UDrawingState.h>#include	<Scrap.h>#include	<LDataTube.h>#include	<PP_KeyCodes.h>#include	<LAESemanticAction.h>#include	<Errors.h>#include	<LNTextEdit.h>#include	<LSelectionEventHandler.h>#include	<UEventUtils.h>LTextEngine		*LTextEngine::sActiveEngine;//	===========================================================================const	TextRangeT	LTextEngine::sTextAll = {0, -1};const	TextRangeT	LTextEngine::sTextEnd = {-1, 0};const	TextRangeT	LTextEngine::sTextUndefined = { -1, -1};LTextEngine::LTextEngine(void){	mView = NULL;		mAttributes = 0;	mTraits.size = 0;	mTraits.style = 0;	mTraits.justification = 0;	mTraits.mode = 0;	mTraits.color.red = 0;	mTraits.color.green = 0;	mTraits.color.blue = 0;	mTraits.fontNumber = 0;	GetFontName(mTraits.fontNumber, mTraits.fontName);		mMargins.top = 4;	mMargins.left = 4;	mMargins.right = 4;	mMargins.bottom = 4;		mImageSize.width = 0;	mImageSize.height = 0;		mHiliteRange = sTextUndefined;	mHiliteRgn = NULL;	KeyStreamPurge();}LTextEngine::~LTextEngine(void){}//	===========================================================================void	LTextEngine::SetAttributes(Uint16 inAttributes){	if (inAttributes & textAttr_Editable) {		if (!(inAttributes & textAttr_Selectable))			Throw_(paramErr);	}		if (inAttributes & textAttr_MultiStyle) {		Assert_(false);	//	A multi-style text engine is not yet implemented.		inAttributes &= ~textAttr_MultiStyle;	}	mAttributes = inAttributes;}Uint16	LTextEngine::GetAttributes(void) const{	return mAttributes;}void	LTextEngine::GetTextTraits(TextTraitsRecord *outTraits) const{	*outTraits = mTraits;}void	LTextEngine::SetTextTraits(const TextTraitsRecord &inTraits){	mTraits = inTraits;	UTextTraits::LoadTextTraits(&mTraits);		Refresh(recalc_FormatAllText + recalc_WindowUpdate);}void	LTextEngine::SetTextMargins(const Rect &inMargins){	mMargins = inMargins;		Refresh(recalc_FormatAllText + recalc_WindowUpdate);}void	LTextEngine::GetTextMargins(Rect *outMargins) const{	*outMargins = mMargins;}void	LTextEngine::SetView(LView *inView){	mView = (LNTextEdit *)inView;	//	Assert_(member(mView, LNTextEdit));}void	LTextEngine::GetImageSize(	SDimension32	*outSize) const{	Assert_(false);	//	Must override}void	LTextEngine::SetImageSize(	const SDimension32	&inSize)/*	SetImageSize will NOT:		change the view rect 					or				broadcast msg_ViewParmsChanged		But may make an update event that will			broadcast msg_ModelScopeChanged*/{	Assert_(false);}void	LTextEngine::GetViewRect(	SPoint32		*outOrigin,	SDimension32	*outSize) const{	Assert_(false);	//	Must override}void	LTextEngine::SetViewRect(	const SPoint32		&inLocation,	const SDimension32	&inSize)/*	SetViewRect will not:		change the image size 					or				broadcast msg_ViewParmsChanged, or msg_ModelScopeChanged*/{	Assert_(false);	//	Must override}void	LTextEngine::ScrollView(	Int32	inLeftDelta,	Int32	inTopDelta,	Boolean	inRefresh){	Assert_(false);	//	Must override}void	LTextEngine::ScrollToSelection(Boolean inBottom){}void	LTextEngine::DrawArea(	const SPoint32		&inLocation,	const SDimension32	&inSize){	Recalc();}void	LTextEngine::Activate(void){}void	LTextEngine::Deactivate(void){}void	LTextEngine::Idle(void){}Boolean	LTextEngine::GetTextChanged(void) {	return mIsChanged;}void	LTextEngine::SetTextChanged(Boolean inChanged){	mIsChanged = inChanged;		BroadcastMessage(msg_ModelChanged);		if (inChanged)		CheckImageSize();}Boolean	LTextEngine::DoKey(char inKey)/*	Don't use this member!  Instead, use the member that takes and EventRecord as	a parameter.		This member is only provided for backwards compatibility.*/{	EventRecord	rec;		rec.what = keyDown;	rec.message = inKey;	rec.when = TickCount();Focus();	GetMouse(&rec.where);	LocalToGlobal(&rec.where);	rec.modifiers = UEventUtils::GetModifiers();	return DoKey(rec);}Boolean	LTextEngine::DoKey(EventRecord &inEventRecord){	return false;}void	LTextEngine::Click(SPoint32 inWhere, EventRecord &inEventRecord, Int16 inClickCount){}Boolean	LTextEngine::DoClickLoop(void){	LNTextEdit		*flow = (LNTextEdit *) mView;	EventRecord		event;		event.what = nullEvent;		//	Mouse move	event.when = TickCount();		Focus();		flow->mEventHandler->DoEvent(event);		return Button();}void	LTextEngine::GetTotalRange(TextRangeT *outRange) const{}//	===========================================================================//	Text get/setvoid	LTextEngine::TextMove(const TextRangeT &inRangeA, const TextRangeT &inRangeB)/*	Range A is moved to range B.*/{	TextRangeT	srcRange = inRangeA,				dstRange = inRangeB;		CropRange(&srcRange);	CropRange(&dstRange);		if (URange32::RangeIntersection(srcRange, dstRange, NULL))		ThrowOSErr_(paramErr);		if (!SpaceForBytes(srcRange.length - dstRange.length))		ThrowOSErr_(teScrapSizeErr);	StPointerBlock	temp(srcRange.length);	TextGetThruPtr(srcRange, temp.mPtr);	TextDelete(srcRange);		if (srcRange.start < dstRange.start)		URange32::RangeShift(dstRange, -srcRange.length, &dstRange);		TextReplaceByPtr(dstRange, temp.mPtr, srcRange.length);}void	LTextEngine::TextDelete(const TextRangeT &inRange){}void	LTextEngine::TextGetThruPtr(const TextRangeT &inRange, Ptr outBuffer)/*	Notes:			This method is MAYBE only suitable for plain text.  Consider using		one of the tube methods above unless really needing plain text		from a non tube source.				TextGetThruPtr or TextGetThruHandle must be overridden or infinite		recursion will occur.*/{	StHandleBlock	text(inRange.length);	Assert_(outBuffer);		TextGetThruHandle(inRange, text.mHandle);	BlockMoveData(*(text.mHandle), outBuffer, inRange.length);}void	LTextEngine::TextGetThruHandle(const TextRangeT &inRange, Handle outTextH)/*	Notes:			This method is MAYBE only suitable for plain text.  Consider using		one of the tube methods above unless really needing plain text		from a non tube source.				TextGetThruPtr or TextGetThruHandle must be overridden or infinite		recursion will occur.*/{	Assert_(outTextH);		SetHandleSize(outTextH, inRange.length);	ThrowIfMemError_();		StHandleLocker	p(outTextH);		TextGetThruPtr(inRange, *outTextH);}void	LTextEngine::TextReplaceByPtr(	const TextRangeT	&inRange,	const Ptr			inSrcText,	Int32				inSrcLength)/*	Note:			This method is MAYBE only suitable for plain text.  Consider using		one of the tube methods above unless really needing plain text		from a non tube source.*/{}void	LTextEngine::TextReplaceByHandle(	const TextRangeT	&inRange,	const Handle		inNewTextH)/*	Note:			This method is MAYBE only suitable for plain text.  Consider using		one of the tube methods above unless really needing plain text		from a non tube source.*/{	StHandleLocker	p(inNewTextH);	Int32			length = GetHandleSize(inNewTextH);		TextReplaceByPtr(inRange, *inNewTextH, length);}//	===========================================================================//	Data tube i/o:FlavorType	LTextEngine::PickFlavorFrom(	const TextRangeT	&inRange,	const LDataTube		*inTube){	return typeNull;}void	LTextEngine::AddFlavorTypesTo(	const TextRangeT	&inRange,	LDataTube			*inTube){}Boolean	LTextEngine::SendFlavorTo(	FlavorType			inFlavor,	const TextRangeT	&inRange,	LDataTube			*inTube){	return false;}void	LTextEngine::ReceiveDataFrom(	const TextRangeT	&inRange,	LDataTube			*inTube){	FlavorType	flavor = PickFlavorFrom(inRange, inTube);		//	must be reworked to support non 'TEXT' replacement	Assert_(flavor == typeChar);		if (flavor == typeNull)		ThrowOSErr_(noTypeErr);		//	Could be replaced by more efficient engine specific code but...	StTempHandle	data(inTube->GetFlavorSize(flavor));	inTube->GetFlavorHandle(flavor, data.mHandle);	TextReplaceByHandle(inRange, data.mHandle);}//	===========================================================================//	Selecting textvoid	LTextEngine::SetSelectionRange(const TextRangeT &inRange){}void	LTextEngine::GetSelectionRange(TextRangeT *outRange) const{}//	===========================================================================//	Presentationvoid	LTextEngine::Hilite(TextRangeT &inRange)/*	Hilite the indicated text range.*/{	TextRangeT	range;		GetSelectionRange(&range);	//	Assert_(URange32::RangesSame(inRange, range));	SetSelectionRange(inRange);	GetHiliteRgn();	//	cache region		//	We might be accumulating in a region so...//	if (pen is invisible)	if (UQDGlobals::GetCurrentPort()->pnVis != 0) {//		FillRgn(mHiliteRgn, &UQDGlobals::GetQDGlobals()->black);		FrameRgn(mHiliteRgn);	}}void	LTextEngine::UnHilite(TextRangeT &inRange)/*	UnHilite the indicated text range.*/{//	Hilite(inRange);	//	Done when Hilite is called with a different range...                  }void	LTextEngine::LatentHilite(TextRangeT &inRange){	TextRangeT	range;		GetSelectionRange(&range);	//	Assert_(URange32::RangesSame(inRange, range));	SetSelectionRange(inRange);		if (inRange.length == 0) {		StColorPenState	savePen;				PenPat(&UQDGlobals::GetQDGlobals()->black);		PenMode(srcXor);		PrimeHiliteMode_();				DrawDropHilite(inRange);			} else {		StColorPenState	savePen;		GetHiliteRgn();			ThrowIfNULL_(mHiliteRgn);				PenPat(&UQDGlobals::GetQDGlobals()->black);		PenMode(srcXor);		PrimeHiliteMode_();				FrameRgn(mHiliteRgn);		ThrowIfOSErr_(QDError());	}}void	LTextEngine::UnLatentHilite(TextRangeT &inRange){	LatentHilite(inRange);}void	LTextEngine::DrawDropHilite(TextRangeT &inRange, Boolean inTrailingEdge){	SPoint32		where32;	Point			where;	Int32			height;	TextRangeT		range = inRange;	if (inRange.length == 0) {		Range2Image(inRange, true, &where32);		mView->ImageToLocalPoint(where32, where);//		mView->LocalToPortPoint(where);				height = GetRangeHeight(inRange);Focus();		MoveTo(where.h - 1, where.v - 1);		Line(0, 1 - height);	} else {		LatentHilite(inRange);	}}void	LTextEngine::UnDrawDropHilite(TextRangeT &inRange, Boolean inTrailingEdge){	DrawDropHilite(inRange, inTrailingEdge);}//	===========================================================================//	Hiliting uglyness -- a real text engine wouldn't need these.void	LTextEngine::ClearHiliteRgn(void){	if (mHiliteRgn)		DisposeRgn(mHiliteRgn);	mHiliteRgn = NULL;		mHiliteRange = sTextUndefined;}RgnHandle	LTextEngine::GetHiliteRgn(void){	return NULL;}//	===========================================================================//	Presentation queryInt32	LTextEngine::GetRangeHeight(const TextRangeT &inRange) const{	return 0;}Int32	LTextEngine::GetRangeWidth(const TextRangeT &inRange) const{	SPoint32	anchor, end;	Int32		width;	TextRangeT	range = inRange;	if (range.length == 0)		return 0;	CropRange(&range);	Range2Image(range, true, &anchor);	Range2Image(range, false, &end);		width = end.h - anchor.h;		if (end.v != anchor.v) {		SDimension32	size;				GetImageSize(&size);				return size.width;	}		if (width <= 0) {		SDimension32	size;				GetImageSize(&size);				if (width == 0)			return size.width;		width += size.width;	}		Assert_(width > 0);		return width;}Boolean	LTextEngine::Range2Image(	TextRangeT			&inRange,	Boolean				inLeadingEdge,	SPoint32			*outWhere) const{	return false;}Boolean	LTextEngine::Image2Range(	SPoint32			inWhere,	Boolean				*outLeadingEdge,	//	not yet implemented	TextRangeT			*outRange) const{	return false;}Boolean	LTextEngine::PointInRange(SPoint32 inWhere, const TextRangeT &inRange) const/*	Returns true iff:			inRange.length > 0:		inWhere lies on top of any glyph in inRange		inRange.length = 0:		inWhere lies on the "insides" of the characters								adjacent to inRange.start (the insertion point).*/{	TextRangeT	rangeFound,				range = inRange;	Boolean		leadingEdge,				rval;		CropRange(&range);	Image2Range(inWhere, &leadingEdge, &rangeFound);		if (range.length == 0) {		if (rangeFound.length == 0) {			rval = rangeFound.start == range.start;		} else {			if (leadingEdge)				rval = rangeFound.start == range.start;			else				rval = (rangeFound.start + rangeFound.length) == range.start;		}				//	Unusual construction is for breakpoint handles		if (rval)			return rval;		else			return rval;	}	if (rangeFound.length == 0) {		if ((rangeFound.start == range.start) || (rangeFound.start == (range.start + range.length)) )			return false;	}		//	Unusual construction is for breakpoint handles	if (URange32::RangeWithinRange(rangeFound, range))		return true;	else		return false;}void	LTextEngine::FindDropRange(SPoint32 inWhere, TextRangeT *outRange){	Boolean	result = Image2Range(inWhere, false, outRange);		Assert_(result);}//	===========================================================================//	StylesInt32	LTextEngine::CountStyleSets(const TextRangeT &inRange) const{	return 1;}LStyleSet *	LTextEngine::GetStyleSet(const TextRangeT &inRange, Int32 inIndex) const{	Throw_(paramErr);	return NULL;}void	LTextEngine::SetStyleSet(const TextRangeT &inRange, LStyleSet *inNewStyle){	Assert_(false);}void	LTextEngine::StyleSetChanged(LStyleSet *inChangedStyle){}LStyleSet *	LTextEngine::GetNewStyleSet(LStyleSet *inOriginal){	return NULL;}Int32	LTextEngine::GetStyleLength(Int32 inCharacterOffset) const{	TextRangeT	range;		GetTotalRange(&range);		return range.start + range.length - inCharacterOffset;}//	===========================================================================//	Implementation help:void	LTextEngine::Focus(void){//	BroadcastMessage(msg_ViewFocusNow);LView::OutOfFocus(NULL);	if (mView)		mView->FocusDraw();}void	LTextEngine::CheckImageSize(void){	SDimension32	imageSize;		GetImageSize(&imageSize);	if ((mImageSize.width != imageSize.width) || (mImageSize.height != imageSize.height)) {		BroadcastMessage(msg_ModelScopeChanged);		Focus();		mImageSize = imageSize;	}}void	LTextEngine::Refresh(RecalcFlagsT inFlags){	RecalcFlagsT	oldFlags = mFlags;		LRecalcAccumulator::Refresh(inFlags);Focus();		if (!(oldFlags & recalc_WindowUpdate) && (mFlags & recalc_WindowUpdate)) {		if (mView)			mView->Refresh();	}Focus();}Boolean	LTextEngine::SpaceForBytes(Int32 inAdditionalBytes){	return false;}void	LTextEngine::CropRange(TextRangeT *ioRange) const{	TextRangeT	range = *ioRange,				totRange;		GetTotalRange(&totRange);		Assert_(totRange.start == 0);	Assert_(totRange.length >= 0);		if (range.start < 0)		range.start = totRange.length;	if (range.length < 0)		range.length = totRange.length;		URange32::RangeCrop(range, totRange, ioRange);}Int32	LTextEngine::ThisCharSize(Int32 inInsertionLocation) const/*	Returns the size of the character at inInsertionLocation	offset.  Usage is required for multi-byte text engines.		Will return 0 if inInsertionLocation is past an end of the text.		Will fail if inInsertionLocation is not at a character boundary	(in a multi-byte scenario).*/{/*	Presently defaults to a single byte per character system.*/	TextRangeT	totalRange;		GetTotalRange(&totalRange);		if (inInsertionLocation >= (totalRange.start + totalRange.length))		return 0;	else		return 1;}Int32	LTextEngine::NextCharSize(Int32 inInsertionLocation) const/*	Returns the size of the character immediately after the inInsertionLocation	offset.  Usage is required for multi-byte text engines.		Will return 0 if inInsertionLocation is at the end of all text.*/{/*	Presently defaults to a single byte per character system.*/	TextRangeT	totalRange;		GetTotalRange(&totalRange);		if (inInsertionLocation >= (totalRange.start + totalRange.length))		return 0;	else		return 1;}Int32	LTextEngine::PrevCharSize(Int32 inInsertionLocation) const/*	Returns the size of the character immediately before the inInsertionLocation	offset.  Usage is required for multi-byte text engines.	Will return 0 if inInsertionLocation is at the begginning of all text.*/{/*	Presently defaults to a single byte per character system.*/	TextRangeT	totalRange;		GetTotalRange(&totalRange);		if (inInsertionLocation <= totalRange.start)		return 0;	else		return 1;}Int16	LTextEngine::ThisChar(Int32 inInsertionLocation) const/*	Returns the character immediately following the character at	inInsertionLocation.		Note that the return value is the 16 bit multi-byte value!		Will fail if attempting to return character past ends of text.*/{	Assert_(false);	//	Must be overridden.	return 0;}void	LTextEngine::AdjustSelection(	const TextRangeT 	&inStartSelection,	const TextRangeT	&inStartRange,	Int32				inRangeDelta){	TextRangeT	selRange;		URange32::RangeAdjust(inStartSelection, inStartRange.start, inRangeDelta, true, &selRange);	SetSelectionRange(selRange);}