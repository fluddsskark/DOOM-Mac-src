//	===========================================================================//	LTextElemAEOM.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LTextElemAEOM.h"#include	<LTextEngine.h>#include	<LNTextEdit.h>#include	<UMemoryMgr.h>#include	<TextUtils.h>#include	<LDataTube.h>#include	<Drag.h>#include	<UAEDesc.h>#include	<UDrawingState.h>//	===========================================================================//	Maintenance/*LTextElemAEOM::LTextElemAEOM(){	Assert_(false);		//	Parameters required}*/LTextElemAEOM::LTextElemAEOM(	LModelObject		*inSuperModel,	DescType			inKind,	LNTextEdit			*inFlow,	const TextRangeT	&inRange)	:	LSelectableItem(inSuperModel, inKind){	mRange = inRange;	mTextFlow = inFlow;	mDragRgn = NULL;	mText = NULL;	switch (inKind) {		case cParagraph:		case cLine:		case cWord:		case cChar:			break;		default:			Throw_(errAECantHandleClass);			break;	}	Assert_(mTextFlow);	mText = mTextFlow->GetTextObject();		SetUseSubModelList(true);		mText->CropRange(&mRange);}LTextElemAEOM::~LTextElemAEOM(){	if (mDragRgn)		DisposeRgn(mDragRgn);	mDragRgn = NULL;}//	===========================================================================//	LSelectableItem implementationBoolean		LTextElemAEOM::EquivalentTo(const LSelectableItem *inItem){	LTextElemAEOM*	that = (LTextElemAEOM*) inItem;	//	Assert_(member(that, LTextElemAEOM));	return	(this->mRange.start == that->mRange.start) &&			(this->mRange.length == that->mRange.length);}Boolean		LTextElemAEOM::IndependentFrom(const LSelectableItem *inItem){	LTextElemAEOM*	that = (LTextElemAEOM*) inItem;	TextRangeT		thatRange;	//	Assert_(member(that, LTextElemAEOM));	that->GetRange(&thatRange);		return !URange32::RangeIntersection(mRange, thatRange, NULL);}Boolean		LTextElemAEOM::PointInRepresentation(Point inWhere){	SPoint32	where;		mTextFlow->LocalToImagePoint(inWhere, where);	return mText->PointInRange(where, mRange);}//	---------------------------------------------------------------------------//	Visual representation implementation.void	LTextElemAEOM::DrawSelfSelected(void){	mText->Hilite(mRange);}void	LTextElemAEOM::DrawSelfLatent(void){	mText->LatentHilite(mRange);}void	LTextElemAEOM::UnDrawSelfSelected(void){	mText->UnHilite(mRange);}void	LTextElemAEOM::UnDrawSelfLatent(void){	mText->UnLatentHilite(mRange);}void	LTextElemAEOM::DrawSelfReceiver(void){	StColorPenState	savePen;	PenPat(&UQDGlobals::GetQDGlobals()->black);	PenMode(srcXor);	mText->DrawDropHilite(mRange);		LSelectableItem::DrawSelfReceiver();}void	LTextElemAEOM::AddFlavorTypesTo(LDataTube *inTube){	Assert_(this == (LSelectableItem *)this);	//	If this fails... it is bad and something must be systemically fixed.	mText->AddFlavorTypesTo(mRange, inTube);	if (!inTube->GetOnlyReqdFlavors())		LSelectableItem::AddFlavorTypesTo(inTube);}Boolean	LTextElemAEOM::SendFlavorTo(FlavorType inFlavor, LDataTube *inTube){	if (mText->SendFlavorTo(inFlavor, mRange, inTube)) {		return true;	} else {		return LSelectableItem::SendFlavorTo(inFlavor, inTube);	}}FlavorType	LTextElemAEOM::PickFlavorFrom(const LDataTube *inTube){	return mText->PickFlavorFrom(mRange, inTube);}void	LTextElemAEOM::ReceiveDataFrom(LDataTube *inTube){	FlavorType	flavor = PickFlavorFrom(inTube);	Int32		newDataSize = inTube->GetFlavorSize(flavor);		mText->ReceiveDataFrom(mRange, inTube);	AdjustRanges(mRange.start, newDataSize - mRange.length, true);}//	===========================================================================//	Implementationvoid	LTextElemAEOM::GetSuperRange(TextRangeT *outRange) const{	if (this == mTextFlow->mTextLink) {		//	This model is the link and has no super range		mText->GetTotalRange(outRange);				Assert_(URange32::RangesSame(*outRange, mRange));	} else {		LTextElemAEOM	*super = (LTextElemAEOM *)((LTextElemAEOM *)this)->GetSuperModel();				Assert_(super);		Assert_(super->mTextFlow == this->mTextFlow);//		Assert_(member(super, LTextElemAEOM));		super->GetRange(outRange);	}}void	LTextElemAEOM::GetRange(TextRangeT *outRange) const{	*outRange = mRange;}void	LTextElemAEOM::SetRange(const TextRangeT &inRange){	if (!URange32::RangesSame(mRange, inRange)) {		mRange = inRange;		if (mDragRgn)			DisposeRgn(mDragRgn);		mDragRgn = NULL;	}}void	LTextElemAEOM::AdjustRanges(Int32 inStart, Int32 inDelta, Boolean inInclusive)/*	Adjust's all ranges for all LTextElemAEOM in the AEOM hiearchy	(ie mTextFlow->mTextLink) that "this" belongs to.*/{	mTextFlow->FixLink();	mTextFlow->mTextLink->AdjustRangesRecurse(inStart, inDelta, inInclusive);}void	LTextElemAEOM::AdjustRangesRecurse(Int32 inStart, Int32 inDelta, Boolean inInclusive){	LModelObject	*p = NULL;	LTextElemAEOM	*q;	Int32			i,					n;		if (mSubModels) {		n = mSubModels->GetCount();		for (i = 1; i <= n; i++) {			StAEDescriptor	token;			GetSubModelByPosition(typeWildCard, i, token.mDesc);			p = GetModelFromToken(token.mDesc);			ThrowIfNULL_(p);						switch(p->GetModelKind()) {				case cWord:				case cLine:				case cParagraph:				case cChar:					q = (LTextElemAEOM *)p;					q->AdjustRangesRecurse(inStart, inDelta, inInclusive);					break;				default:					break;			}					}	}	if (this != mTextFlow->mTextLink)		AdjustRange(inStart, inDelta, inInclusive);}void	LTextElemAEOM::AdjustRange(Int32 inStart, Int32 inDelta, Boolean inInclusive){	TextRangeT	range;		URange32::RangeAdjust(mRange, inStart, inDelta, inInclusive, &range);	SetRange(range);}