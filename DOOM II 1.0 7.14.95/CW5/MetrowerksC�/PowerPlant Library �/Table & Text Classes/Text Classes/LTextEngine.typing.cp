//	===========================================================================//	LTextEngine.undo.cp				й1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LTextEngine.h"#include	<LDynamicArray.h>#include	<LSelectableItem.h>#include	<LTextEdit.h>#include	<UMemoryMgr.h>#include	<Scrap.h>#include	<LDataTube.h>#include	<PP_KeyCodes.h>#include	<LAESemanticAction.h>#include	<UAppleEventsMgr.h>#include	<AERegistry.h>#include	<LAETypingAction.h>#include	<LNTextEdit.h>#include	<UAEDesc.h>#include	<LTextSelection.h>#include	<Errors.h>//	----------------------------------------------------------------------//	Typing undo support (public):void	LTextEngine::RedoTyping(void){	if (mTypingIsUndone) {		TextRangeT		range = mNewTextRange;				//	Redo typing		range.length = mRemovedText.GetSize();		TextReplaceByPtr(range, (Ptr) mNewCharacters.GetOffsetPtr(0), mNewCharacters.GetSize());		mTypingIsUndone = false;				//	Update selection//		...	}}void	LTextEngine::UndoTyping(void){	if (!mTypingIsUndone) {			//	Undo typing		TextReplaceByPtr(mNewTextRange, (Ptr) mRemovedText.GetOffsetPtr(0), mRemovedText.GetSize());		mTypingIsUndone = true;				//	Update selection//		...	}}Boolean	LTextEngine::CanRedoTyping(void){	return TypingBuffered() && mTypingIsUndone;}Boolean	LTextEngine::CanUndoTyping(void){	return TypingBuffered() && !mTypingIsUndone;}Boolean	LTextEngine::TypingBuffered(void){	return mNewCharacters.GetSize() || mRemovedText.GetSize();}void	LTextEngine::GetPreTypingSelection(AEDesc *outDesc){	OSErr	err;		err = AEDuplicateDesc(&mInsertTextHere.mDesc, outDesc);	ThrowIfOSErr_(err);}void	LTextEngine::RecordTyping(void){	StAEDescriptor		ae,						destSpec,						insertLoc;	AEDesc				*destPtr;	OSErr				err;	DescType			type;	Size				size;	//	Get destination descriptor	if (mUseIndexes) {/*		TextRangeT	range;				range		//	Evil cross coupling...		LTextElemAEOM	ourRange(*/		UAEDesc::MakeRange(mInsertSuperSpec.mDesc, cChar,				mTypeCharIndex1, mTypeCharIndex2, &destSpec.mDesc);		destPtr = &destSpec.mDesc;	} else {		destPtr = &mInsertTextHere.mDesc;	}	if (mNewCharacters.GetSize() > 0) {		//	ее	Build the CreateElement event		UAppleEventsMgr::MakeAppleEvent(kAECoreSuite, kAECreateElement, ae.mDesc);				//	keyAEData		size = mNewCharacters.GetSize();		Assert_(size > 0);		StHandleLocker lock(mNewCharacters.mData);		err = AEPutParamPtr(&ae.mDesc, keyAEData, typeChar, *(mNewCharacters.mData), size);		ThrowIfOSErr_(err);			//	keyAEInsertHere		UAEDesc::MakeInsertionLoc(*destPtr, kAEReplace, &insertLoc.mDesc);		err = AEPutParamDesc(&ae.mDesc, keyAEInsertHere, &insertLoc.mDesc);		ThrowIfOSErr_(err);		//	keyAEObjectClass		type = cChar;		err = AEPutParamPtr(&ae.mDesc, keyAEObjectClass, typeType, &type, sizeof(type));		ThrowIfOSErr_(err); 			//	keyAEPropData		//		is optional & keyAEData above has enough info.		} else {		Assert_(mNewCharacters.GetSize() == 0);	//	Make sure it is a delete		Assert_(mRemovedText.GetSize() != 0);	//	Avoid useless AE				//	ее	Build Delete event		UAppleEventsMgr::MakeAppleEvent(kAECoreSuite, kAEDelete, ae.mDesc);				//	keyDirectObject		err = AEPutParamDesc(&ae.mDesc, keyDirectObject, destPtr);		ThrowIfOSErr_(err);	}		//	ее Send the event for recording only	mTypingAction->SendAppleEvent(ae.mDesc, kAEDontExecute);}//	----------------------------------------------------------------------//	Typing undo support (protected):Int32	LTextEngine::sExpectedLength;void	LTextEngine::DoKeyPre(const EventRecord &inEventRecord){	char		inKey = inEventRecord.message & charCodeMask;	TextRangeT	range, totRange;		GetSelectionRange(&range);	GetTotalRange(&totRange);		sExpectedLength = totRange.length;		switch (inKey) {		case char_LeftArrow:		case char_RightArrow:		case char_UpArrow:		case char_DownArrow:		case char_Home:		case char_End:		case char_PageUp:		case char_PageDown:			//	Nothing need be explicitly remembered -- the KeyStream			//	will be purged the next time it is important to note that			//	the selection has changed.			break;		case char_Backspace:		case char_FwdDelete://		case char_Clear:		//	char_Clear is char_Escape?			KeyStreamCheck();			mIsChanged = true;			sExpectedLength -= range.length;			if (range.length > 0) {				KeyStreamRememberPrepend(range);			} else if (range.length == 0) {				//	No selection -- remember characters before				//	or after insertion point.				switch (inKey) {					case char_Backspace:						KeyStreamRememberBackspace();						break;					case char_FwdDelete:						KeyStreamRememberRubout();						break;					case char_Clear:						KeyStreamRememberClear();						break;				}			} else {				Assert_(false);		//	A negative selection length?			}						break;					case char_Enter:		case char_Tab:		case char_Return:		case char_Escape:		default:			Assert_(range.length >= 0);			if (SpaceForBytes(2 - range.length)) {	//	Two is for possible multibyte character				KeyStreamCheck();				mNewTextRange.start = URange32::Min(mNewTextRange.start, range.start);				mIsChanged = true;				sExpectedLength -= range.length;				if (range.length > 0) {					KeyStreamRememberPrepend(range);				}			} else {				ThrowOSErr_(teScrapSizeErr);			}			break;	}}void	LTextEngine::DoKeyPost(const EventRecord &inEventRecord){	char		inKey = inEventRecord.message & charCodeMask;	TextRangeT	range, totRange;		GetSelectionRange(&range);	GetTotalRange(&totRange);	switch (inKey) {		case char_LeftArrow:		case char_RightArrow:		case char_UpArrow:		case char_DownArrow:		case char_Home:		case char_End:		case char_PageUp:		case char_PageDown:			//	Nothing need be explicitly remembered -- the KeyStream			//	will be purged the next time it is important to note that			//	the selection has changed.			break;		default:			//	Remember new character (which may be multibyte)			Int32	newCharCount = totRange.length - sExpectedLength;						switch (newCharCount) {				case 0:					//	Nothing new to remember					break;								case 1:				{					//	A single byte character					TextRangeT	newCharRange = {range.start -1, 1};										KeyStreamRemember(newCharRange);					break;				}				case 2:				{					//	A two byte character					TextRangeT	newCharRange = {range.start -2, 2};										KeyStreamRemember(newCharRange);					break;				}								default:					Assert_(false);		/*									 		Something is awry --											Maybe an overridden KeyStreamRemember											Backspace/Rubout/Clear method is not											properly adjusting mExpectedLength.										*/					break;			}			SetTextChanged();						mLastRange = range;						mNewTextRange.start = URange32::Min(mNewTextRange.start, range.start);			mNewTextRange.length = mNewCharacters.GetSize();			break;	}		BroadcastMessage(msg_ViewSelectionChanged);}void	LTextEngine::KeyStreamCheck(void){	TextRangeT	range;		GetSelectionRange(&range);		if (!(mAttributes & textAttr_Editable)) {		Throw_(editingNotAllowed);	}		if (!URange32::RangesSame(range, mLastRange) || (mTypingAction == NULL)) {				//	Dump existing typing action before the important data is purged...		Assert_(mView);//		Assert_(member(mView, LNTextEdit));		((LNTextEdit *)mView)->PostAction(NULL);				//	Clear existing typing		KeyStreamPurge();		//	Pre-make destination ospec		{			//	evil cross coupling...			LTextSelection	*selection;			LNTextEdit		*view;			LTextElemAEOM	*item;			TextRangeT		totRange;						view = (LNTextEdit *)mView;			Assert_(view);//			Assert_(member(view, LNTextEdit));			selection = (LTextSelection *)view->GetSelection();			Assert_(selection);//			Assert_(member(selection, LTextSelection));			//			view->FixSelection();	//	should be redundant.			Assert_(selection->ListCount() == 1);			item = (LTextElemAEOM *)selection->ListNthItem(1);			Assert_(item);//			Assert_(member(item, LTextElemAEOM));						item->MakeSpecifier(mInsertTextHere.mDesc);			view->MakeSpecifier(mInsertSuperSpec.mDesc);			mOrigInsertRange = range;						//	If LTextEngine's selection range becomes out of			//	sync with the selection mechanism, things will			//	get hosed			item->GetRange(&range);			Assert_(URange32::RangesSame(mOrigInsertRange, range));			//	Pre-load char indices incase there's subsequent back|fwd deletions.			GetTotalRange(&totRange);			FindSubRangePartIndices(totRange, range, cChar, &mTypeCharIndex1, &mTypeCharIndex2);//			if (mTypeCharIndex2 < mTypeCharIndex1)//				mTypeCharIndex2 = mTypeCharIndex1;			//	Make and post a new typing action			mTypingAction = new LAETypingAction(this);			mTypingAction->SetSelection(selection);			Assert_(mView);//		Assert_(member(mView, LNTextEdit));		}				((LNTextEdit *)mView)->PostAction(mTypingAction, false);	}}void	LTextEngine::KeyStreamPurge(void){	mNewCharacters.Clear();	mRemovedText.Clear();	mTypingIsUndone = false;	mNewTextRange.start = max_Int32;	mNewTextRange.length = 0;	mTypingAction = NULL;		AEDisposeDesc(&mInsertTextHere.mDesc);	AEDisposeDesc(&mInsertSuperSpec.mDesc);	mTypeCharIndex1 = mTypeCharIndex2 = -1;	mUseIndexes = false;}void	LTextEngine::KeyStreamRemember(const TextRangeT &inRange)/*	Remember newly typed characters as indicated by inRange.*/{	Ptr		destination;		destination = (Ptr) mNewCharacters.Append(NULL, inRange.length);	ThrowIfNULL_(destination);	TextGetThruPtr(inRange, (Ptr)destination);}void	LTextEngine::KeyStreamRememberAppend(const TextRangeT &inRange)/*	Remember text about to be forward deleted.		InRange indicates the text being removed.  That text will be appended	to mRemovedText.		NOTE:	This routine requires modification for typing undo for styled			text.  mRemovedText must be augmented by a mechanism to			contain style information.*/{	Ptr		destination;		mUseIndexes = true;	mTypeCharIndex2 += inRange.length;	destination = (Ptr) mRemovedText.Append(NULL, inRange.length);	ThrowIfNULL_(destination);	TextGetThruPtr(inRange, destination);}void	LTextEngine::KeyStreamRememberPrepend(const TextRangeT &inRange)/*	Remember text about to be deleted (via back space or selection replacement.		InRange is either an initial selection in a typing sequence, or text	being back spaced over.		If the text being removed corresponds to text in mNewCharacters, that text	is removed from mNewCharacters and forgotten.  Otherwise the text is	inserted at the beginning of mRemovedText.		NOTE:	This routine requires modification for typing undo for styled			text.  mRemovedText must be augmented by a mechanism to			contain style information.*/{	Ptr			destination;	Int32		n;	TextRangeT	range = inRange;		if (mNewCharacters.GetSize() > 0) {		n = URange32::Min(range.length, mNewCharacters.GetSize());				mNewCharacters.Delete(max_Int32, n);				range.length -= n;	}		if (range.length > 0) {		destination = (Ptr) mRemovedText.Prepend(NULL, range.length);		ThrowIfNULL_(destination);		TextGetThruPtr(range, destination);	}}void	LTextEngine::KeyStreamRememberBackspace(void)/*	Remember the text part about to be backspace over.		This method is called only when the selection has a length of zero.		If "back" deletion of items other than characters are permitted (ie. a	word), this routine will have to be overridden to test for appropriate	modifiers and correct calling of KeyStreamRememberPrepend.*/{	TextRangeT	range;		GetSelectionRange(&range);		Assert_(range.length == 0);		if (range.start == 0)		return;		range.length = 1;	range.start--;	if (mNewCharacters.GetSize() == 0) {		mUseIndexes = true;		mTypeCharIndex1 -= range.length;	}		if (false) {	//	false should be test for 2-byte character		Assert_(range.start > 0);		range.start--;		range.length = 2;	}	sExpectedLength -= range.length;		KeyStreamRememberPrepend(range);}void 	LTextEngine::KeyStreamRememberRubout(void)/*	Remember the text part about to be rubbed out (forward delete).		This method is called only when the selection has a length of zero.		If "forward" deletion of items other than characters are permitted	(ie. a word), this routine will have to be overridden to test for	appropriate modifiers and correct calling of KeyStreamRememberAppend.*/{	TextRangeT	range, totRange;		GetSelectionRange(&range);	GetTotalRange(&totRange);		Assert_(range.length == 0);		if (range.start >= totRange.length)		return;		sExpectedLength -= range.length;	range.length = 1;	if (false) {	//	false should be test for 2-byte character		Assert_(range.start < totRange.length -1);		range.length = 2;	}	KeyStreamRememberAppend(range);}void 	LTextEngine::KeyStreamRememberClear(void)/*	The Macintosh Human Interface Guidelines defines no action for the	clear key on an empty text selection.		Because of this, this method should probably be left as is.*/{	//	do nothing}