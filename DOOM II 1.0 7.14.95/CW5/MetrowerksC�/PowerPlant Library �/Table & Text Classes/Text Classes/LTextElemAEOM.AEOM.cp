//	===========================================================================//	LTextElemAEOM.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LTextElemAEOM.h"#include	"LNTextEdit.h"#include	<UAEDesc.h>#include	<UAppleEventsMgr.h>#include	<UMemoryMgr.h>#include	<TextUtils.h>#include	<LStyleSet.h>//	===========================================================================//	AEOM supportInt32	LTextElemAEOM::CountSubModels(DescType inModelID) const{	switch (inModelID) {		case cParagraph:		case cLine:		case cWord:		case cChar:			return mText->CountParts(mRange, inModelID);			break;//		case cText:			?//		case cTextFlow:		?//			break;		default:			return inherited::CountSubModels(inModelID);			break;	}}LCoreAEOM *	LTextElemAEOM::GetSubModelForInsertion(	DescType		inInsertPosition,	LModelObject*	inTargetObject) const{	TextRangeT		range;	Boolean 		inclusive;	LTextElemAEOM	*rval,					*textObj = (LTextElemAEOM *) inTargetObject;//	Assert_(member(textObj, LTextElemAEOM));	FindInsertionRange(inInsertPosition, textObj, &range, &inclusive);	if (URange32::RangesSame(range, mRange)) {		rval = textObj;	} else {		rval = new LTextElemAEOM(textObj, textObj->GetModelKind(), mTextFlow, range);	}	return rval;}void	LTextElemAEOM::GetSubModelByPosition(	DescType		inModelID,	Int32			inPosition,	AEDesc			&outToken) const{	LTextElemAEOM	*submodel = NULL;	TextRangeT		range;	DescType		partFoundType;		//	Maybe unnecessary since submodel is based										//	off this rather than mTextLink.  But, it										//	is safer.		switch (inModelID) {		case cParagraph:		case cLine:		case cWord:		case cChar:						partFoundType = mText->FindNthPart(mRange, inModelID, inPosition, &range);			submodel = new LTextElemAEOM((LModelObject *)this, partFoundType, mTextFlow, range);			PutInToken(submodel, outToken);			break;				default:			inherited::GetSubModelByPosition(inModelID, inPosition, outToken);			break;	}}void	LTextElemAEOM::GetModelByRelativePosition(	DescType		inModelID,	OSType			inRelativePosition,	AEDesc			&outToken) const{	switch (inRelativePosition) {		case kAEBeginning:		case kAEBefore:		case kAEEnd:		case kAEAfter:		{			TextRangeT		range;			LTextElemAEOM	*p;						range.length = 0;			switch (inRelativePosition) {				case kAEBeginning:				case kAEBefore:					range.start = mRange.start;					break;				case kAEEnd:				case kAEAfter:					range.start = mRange.start + mRange.length;					break;			}			p = new LTextElemAEOM(((LTextElemAEOM *)this)->GetSuperModel(), cChar, mTextFlow, range);						PutInToken(p, outToken);			break;		}		default:			LCoreAEOM::GetModelByRelativePosition(inModelID, inRelativePosition, outToken);			break;	}}void	LTextElemAEOM::GetSubModelByComplexKey(	DescType		inModelID,	DescType		inKeyForm,	const AEDesc	&inKeyData,	AEDesc			&outToken) const{	StAEDescriptor	ospec1,					ospec2;	StAEDescriptor	token1,					token2;	LTextElemAEOM	*submodel = NULL,					*obj1 = NULL,					*obj2 = NULL;	TextRangeT		range,					range1,					range2;	DescType		rangePartType,					partType1,					partType2;	OSErr			err;													switch (inKeyForm) {		case formRange:		{			Try_ {				StAEDescriptor	keyData;								err = AECoerceDesc(&inKeyData, typeAERecord, &keyData.mDesc);					//	Load boundary data				//		See IM-IAC 6-20 for (AERecord *) coercion information).				err = AEGetKeyDesc((AERecord *)&keyData.mDesc, keyAERangeStart, typeObjectSpecifier, &ospec1.mDesc);				ThrowIfOSErr_(err);				err = AEGetKeyDesc((AERecord *)&keyData.mDesc, keyAERangeStop, typeObjectSpecifier, &ospec2.mDesc);				ThrowIfOSErr_(err);				err = AEResolve(&ospec1.mDesc, kAEIDoMinimum, &token1.mDesc);				ThrowIfOSErr_(err);				err = AEResolve(&ospec2.mDesc, kAEIDoMinimum, &token2.mDesc);				ThrowIfOSErr_(err);				obj1 = (LTextElemAEOM *)GetModelFromToken(token1.mDesc);				obj2 = (LTextElemAEOM *)GetModelFromToken(token2.mDesc);				Assert_(obj1);	//	Assert_(member(obj1, LTextElemAEOM));				Assert_(obj2);	//	Assert_(member(obj2, LTextElemAEOM));				obj1->GetRange(&range1);				obj2->GetRange(&range2);				partType1 = obj1->GetModelKind();				partType2 = obj2->GetModelKind();				Assert_(range1.start <= range2.start);								//	Make corresponding LTextElemAEOM submodel.				range.start = range1.start;				range.length = URange32::Max(	range1.length,									range2.start + range2.length - range1.start	);				if (partType1 == partType2)					rangePartType = partType1;				else					rangePartType = cChar;				submodel = new LTextElemAEOM((LModelObject *)this, rangePartType, mTextFlow, range);				PutInToken(submodel, outToken);				obj1->Finalize();				obj2->Finalize();			} Catch_(err) {				if (obj1)					obj1->Finalize();	//	ie delete				if (obj2)					obj2->Finalize();	//	ie delete				Throw_(err);			} EndCatch_;			break;		}		case formTest:		default:			LCoreAEOM::GetSubModelByComplexKey(inModelID, inKeyForm, inKeyData, outToken);			break;	}}Int32	LTextElemAEOM::GetPositionOfSubModel(	DescType		inModelID,	const LModelObject	*inSubModel) const{	switch (inModelID) {		case cParagraph:		case cLine:		case cWord:		case cChar:		{			const LTextElemAEOM*	p = (LTextElemAEOM *)inSubModel;			TextRangeT				partRange;			Int32					index1, index2;			//			Assert_(member(p, LTextElemAEOM));			p->GetRange(&partRange);						mText->FindSubRangePartIndices(mRange, partRange, inModelID, &index1, &index2);			Assert_(index1 == index2);			return index1;			break;		}					default:			return inherited::GetPositionOfSubModel(inModelID, inSubModel);			break;	}}void	LTextElemAEOM::MakeSpecifier(	AEDesc	&outSpecifier) const{#if	1	LModelObject	*super = ((LModelObject *)this)->GetSuperModel(),					*supersuper;	ThrowIfNULL_(super);	//	Skip link object unless that's the specifier requested....	if (super == mTextFlow->mTextLink) {		StAEDescriptor	superSpecifier;		supersuper = (LModelObject *)super->GetSuperModel();		ThrowIfNULL_(supersuper);		supersuper->MakeSpecifier(superSpecifier.mDesc);				MakeSelfSpecifier(superSpecifier.mDesc, outSpecifier);	} else {		LCoreAEOM::MakeSpecifier(outSpecifier);	}#else	//	Don't record the link object	if (this == mTextFlow->mTextLink) {		ThrowIfNULL_(mSuperModel);		mSuperModel->MakeSpecifier(outSpecifier);	} else {		LCoreAEOM::MakeSpecifier(outSpecifier);	}#endif}void	LTextElemAEOM::MakeSelfSpecifier(	AEDesc	&inSuperSpecifier,	AEDesc	&outSelfSpecifier) const{	Int32			index1,					index2;	TextRangeT		superRange;	StAEDescriptor	tempOSpec;	AEDesc			*rangeDescPtr,					*subDescPtr;	Boolean			doMakeIndexSpec = false;	Boolean			doInsertion = false;	DescType		relType,					partKind = GetModelKind(),					partKindTry2;	OSErr			err;	/*	//	Don't make specifier for text link object	if (this == mTextFlow->mTextLink)		return;*/		//	Find do's / indices	GetSuperRange(&superRange);	Assert_(URange32::RangeWithinRange(mRange, superRange));	if (mRange.length == 0) {		doInsertion = true;		if (mRange.start == superRange.start) {			relType = kAEBeginning;		} else if (mRange.start == (superRange.start + superRange.length)) {			relType = kAEEnd;		} else {			relType = kAEBefore;			doMakeIndexSpec = true;		}	} else {		doMakeIndexSpec = true;	}	if (doMakeIndexSpec) {		partKind = mText->FindSubRangePartIndices(superRange, mRange, partKind, &index1, &index2);		if (partKind != GetModelKind()) {			partKindTry2 = mText->FindSubRangePartIndices(superRange, mRange, partKind, &index1, &index2);			Assert_(partKindTry2 == partKind);		}	}	rangeDescPtr = doInsertion ? (&tempOSpec.mDesc) : (&outSelfSpecifier);	if (doMakeIndexSpec)		UAEDesc::MakeRange(inSuperSpecifier, partKind, index1, index2, rangeDescPtr);		subDescPtr = doMakeIndexSpec ? (&tempOSpec.mDesc) : (&inSuperSpecifier);	if (doInsertion)		UAEDesc::MakeInsertionLoc(*subDescPtr, relType, &outSelfSpecifier);	Assert_(doMakeIndexSpec || doInsertion);	//	Cleanup since MakeSelfSpecifier is responsible for disposal of inSuperSpecifier...	err = AEDisposeDesc(&inSuperSpecifier);}void	LTextElemAEOM::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	LStyleSet	*style = NULL;	switch (inProperty) {		case cStyleSet:			style = mText->GetStyleSet(mRange);			style->MakeSpecifier(outPropertyDesc);			break;		case pFont:		case pPointSize:		case pTextColor:		case pTextStyles:		case pScriptTag:			style = mText->GetStyleSet(mRange);			style->GetAEProperty(inProperty, inRequestedType, outPropertyDesc);			break;/*		case pUniformStyles:		{			Int32	i;			for (i = 1; i <= mText->CountStylesSets(mRange); i++) {				//	loop through styles				GetRangeAEProperty(mRange, inProperty, inRequestedType, outPropertyDesc);			}			break;		}*//*		case pLength:	//		cLongInteger		-- number of characters of object		case pOffset:	//		cLongInteger		-- characters from beginning of document*/		case pContents:		{			StTempHandle	t(mRange.length);						mText->TextGetThruHandle(mRange, t.mHandle);			StHandleLocker	p(t.mHandle);						UAEDesc::AddPtr(&outPropertyDesc, 0, typeChar, *(t.mHandle), mRange.length);			break;		}		default:			inherited::GetAEProperty(inProperty, inRequestedType, outPropertyDesc);			break;	}}void	LTextElemAEOM::SetAEProperty(	DescType		inProperty,	const AEDesc	&inValue,	AEDesc&			outAEReply){	switch (inProperty) {		case cStyleSet:		{			LStyleSet		*style;			StAEDescriptor	token;			OSErr			err;			err = AEResolve(&inValue, kAEIDoMinimum, &token.mDesc);			ThrowIfOSErr_(err);			style = (LStyleSet *)GetModelFromToken(token.mDesc);			Assert_(style);			if (style->GetModelKind() != cStyleSet) Throw_(paramErr);			mText->SetStyleSet(mRange, style);			break;		}		case pFont:		case pPointSize:		case pScriptTag:		case pTextStyles:		case pUniformStyles:			Assert_(false);//			SetRangeAEProperty(mRange, inProperty, inValue, outAEReply);			break;		case pContents:			Throw_(errAEEventNotHandled);			break;		default:			inherited::SetAEProperty(inProperty, inValue, outAEReply);			break;	}}//	===========================================================================//	Implementationvoid	LTextElemAEOM::GetRangeAEProperty(	const TextRangeT		&inRange,	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{}void	LTextElemAEOM::SetRangeAEProperty(	const TextRangeT		&inRange,	DescType		inProperty,	const AEDesc	&inValue,	AEDesc&			outAEReply) const{}//	===========================================================================//	Verb handling...void	LTextElemAEOM::HandleDelete(	AppleEvent			&outAEReply,	AEDesc				&outResult){	TextRangeT		holeRange = mRange;	OSErr			err;	holeRange.length = 0;	mText->TextDelete(mRange);	AdjustRanges(mRange.start, -mRange.length);	//	Make the extra deletion "hole" location parameter for the reply.	//		This extra ae reply parameter helps PowerPlant with undo.  And	//		is keyed with keyAEInsertHere.	{		StAEDescriptor	holeDesc;		LTextElemAEOM	hole(mTextFlow->mTextLink, cChar, mTextFlow, holeRange);		hole.MakeSpecifier(holeDesc.mDesc);		err = AEPutKeyDesc(&outAEReply, keyAEInsertHere, &holeDesc.mDesc);		ThrowIfOSErr_(err);	}}LModelObject *	LTextElemAEOM::HandleCreateElementEvent(	DescType			inElemClass,	DescType			inInsertPosition,	LModelObject		*inTargetObject,	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply){	LModelObject	*result = NULL;	TextRangeT		resultRange,					targetRange,					queryRange;	Boolean			inclusive;		FindInsertionRange(inInsertPosition, (LTextElemAEOM *) inTargetObject,		&targetRange, &inclusive);	StAEDescriptor	propsDesc;	StAEDescriptor	dataDesc;		propsDesc.GetOptionalParamDesc(inAppleEvent, keyAEPropData, typeAERecord);	if (propsDesc.mDesc.descriptorType != typeNull)		dataDesc.GetOptionalParamDesc(propsDesc.mDesc, pContents, typeChar);		if (dataDesc.mDesc.descriptorType == typeNull)		dataDesc.GetParamDesc(inAppleEvent, keyAEData, typeChar);		if (dataDesc.mDesc.dataHandle == NULL)		Throw_(errAEEventFailed);	mText->TextReplaceByHandle(targetRange, dataDesc.mDesc.dataHandle);	resultRange.start = targetRange.start;	resultRange.length = GetHandleSize(dataDesc.mDesc.dataHandle);	AdjustRanges(targetRange.start, resultRange.length - targetRange.length, inclusive);		/*		This text model doesn't support anything but text elements.  Adjust		inElemClass down if necessary.	*/	switch (inElemClass) {		case cChar:		case cWord:		case cLine:		case cParagraph:			break;		default:			inElemClass = cChar;			break;	}	/*		It is possible the new range is immediately adjacent to a similar part.		If this is the case, the new element part type should be adjusted "down"		to a character or the new part would "blend" in with the existing		part.  This is unacceptable -- especially for selections with associated		undo's.  So... check to see if the part type needs adjustment.	*/	mTextFlow->mTextLink->GetRange(&queryRange);		//	 	inElemClass = mText->FindSubRangePartIndices(queryRange, resultRange,		inElemClass, NULL, NULL);	//	The cloned object...	result = new LTextElemAEOM(			mTextFlow->mTextLink,		//	perhaps this could be more restrained...			inElemClass,				//	if so fix it above   to.			mTextFlow,			resultRange);//	Does this belong here or in a "fixed" LModelDirector?if (inTargetObject) inTargetObject->Finalize();	return result;}void	LTextElemAEOM::FindInsertionRange(	DescType			inInsertPosition,	LTextElemAEOM		*inTargetObject,	TextRangeT			*outRange,	Boolean				*outInclusive) const/*	"This" is the "source" object.*/{	TextRangeT		range = mRange;		*outInclusive = false;		if (inTargetObject) {		inTargetObject->GetRange(&range);	}	switch (inInsertPosition) {		case kAEBeginning:			*outInclusive = true;		case kAEBefore:			range.length = 0;			break;		case kAEEnd:			*outInclusive = true;		case kAEAfter:			range.start = range.start + range.length;			range.length = 0;			break;		case kAEReplace:			*outInclusive = true;			break;		default:			Throw_(errAEBadKeyForm);			break;	}		*outRange = range;}