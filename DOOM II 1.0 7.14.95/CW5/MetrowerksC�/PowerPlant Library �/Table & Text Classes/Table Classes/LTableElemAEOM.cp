//	===========================================================================//	LTableElemAEOM.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LTableElemAEOM.h"#include	<AERegistry.h>#include	<UExtractFromAEDesc.h>#include	<UAEDesc.h>#include	<LTableIterator.h>#include	<UDrawingState.h>#include	<LDataTube.h>#include	<UAppleEventsMgr.h>#include	<LDescTube.h>#define	inheritAEOM	LSelectableItem// ===========================================================================/*	elements:			cell, row, column		element properties:		cObject			pBestType						pClass						pDefaultType								table props:	pName						pProtection						pFormula		//	mainly for spreadsheets -- not implemented						pWidth			//	new to ViewTable						pHeight			//	new to ViewTable		text props:		pColor						pFont						pPointSize						pScriptTag						pTextStyles						pUniformStyles						pJustification	// mainly lines, paragraphs						pName			//	text flows*/// ===========================================================================// ===========================================================================//	LTableElemAEOM:LTableElemAEOM::LTableElemAEOM(){	Assert_(false);		//	Parameters required}LTableElemAEOM::LTableElemAEOM(	LNTable			*inTable,	DescType		inKind,	TableCellT		inIndex)	:	LSelectableItem(inTable, inKind){	mTable = inTable;	mIndex = inIndex;}LTableElemAEOM::~LTableElemAEOM(){}void	LTableElemAEOM::GetRange(TableCellT *outCell){	*outCell = mIndex;}Boolean	LTableElemAEOM::EquivalentTo(const LSelectableItem *inItem){	TableCellT	indexThis, indexThat;	LTableElemAEOM	*that = (LTableElemAEOM *)inItem;		if (inItem == NULL)		return false;		if (this == inItem)		return true;//	if (!member(inItem, LTableElemAEOM))//		return false;			this->GetCellIndex(&indexThis);	that->GetCellIndex(&indexThat);		return(	mTable->EqualCell(mIndex, that->mIndex)	);}Boolean	LTableElemAEOM::IndependentFrom(const LSelectableItem *inItem){	return !EquivalentTo(inItem);}Boolean	LTableElemAEOM::PointInRepresentation(Point inWhere){	TableCellT	cell;		if (!mTable->FetchCellHitBy(inWhere, cell))		return false;	if (mTable->EqualCell(mIndex, cell))		return true;	else		return false;}void	LTableElemAEOM::GetCellIndex(TableCellT *outIndex){	*outIndex = mIndex;}void	LTableElemAEOM::MakeSpecifier(AEDesc &outSpecifier) const{	inheritAEOM::MakeSpecifier(outSpecifier);}void	LTableElemAEOM::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	switch(inProperty) {		case pContents:		{			TableCellT		index;			LTableIterator	iter(mTable, mIndex);			while(iter.Next(index)) {				LCellAEOM	aCell(mTable, index);				LDescTube	tube(&aCell);				UAEDesc::AddDesc(&outPropertyDesc, 0, tube.mDesc.mDesc);			}			break;		}				default:			inheritAEOM::GetAEProperty(inProperty, inRequestedType, outPropertyDesc);			break;	}}void	LTableElemAEOM::SetAEProperty(	DescType		inProperty,	const AEDesc	&inValue,	AEDesc&			outAEReply){	switch(inProperty) {		case pContents:		{			TableCellT		index;			LTableIterator	iter(mTable, mIndex);						while(iter.Next(index)) {				LCellAEOM	aCell(mTable, index);				LDescTube	tube(inValue);								mTable->ReceiveDataFrom(index, &tube);			}			break;		}		default:			inheritAEOM::SetAEProperty(inProperty, inValue, outAEReply);			break;	}}void	LTableElemAEOM::MakeSelfSpecifier(			AEDesc &inSuperSpecifier,			AEDesc &outSelfSpecifier) const{	inheritAEOM::MakeSelfSpecifier(inSuperSpecifier, outSelfSpecifier);}//	===========================================================================//	Data draggingvoid	LTableElemAEOM::AddFlavorTypesTo(LDataTube *inTube)/*	When overriding, remember to "inherit" any superclass methods as they might	do useful things -- like adding the object specifier flavor for an	LSelectableItem.		Also, if this method is being overridden by something that is a collection	of other tubeable items (like LSelection), this is the method where sub-	tubes should be added.		Do not have a tube which merely has a single sub-tube.*/{	mTable->AddFlavorTypesTo(mIndex, inTube);	inherited::AddFlavorTypesTo(inTube);	//	AEOM descriptor}Boolean	LTableElemAEOM::SendFlavorTo(FlavorType inFlavor, LDataTube *inTube){	Boolean	rval = inherited::SendFlavorTo(inFlavor, inTube);	if (!rval)		rval = mTable->SendFlavorTo(inFlavor, mIndex, inTube);	//	Pick up AEOM descriptor		return rval;}FlavorType	LTableElemAEOM::PickFlavorFrom(const LDataTube *inTube){	return mTable->PickFlavorFrom(mIndex, inTube);}void	LTableElemAEOM::ReceiveDataFrom(LDataTube *inTube){	mTable->ReceiveDataFrom(mIndex, inTube);}// ===========================================================================//	LCellAEOMLCellAEOM::LCellAEOM(){	Assert_(false);		//	Parameters required}LCellAEOM::LCellAEOM(	LNTable		*inTable,	TableCellT		inIndex)	:	LTableElemAEOM(inTable, cCell, inIndex){	Assert_(inTable->IsValidCell(inIndex));}LCellAEOM::~LCellAEOM(){}void	LCellAEOM::DrawSelf(void){	mTable->DrawCell(mIndex);}void	LCellAEOM::DrawSelfSelected(void){	Rect		cellFrame;		if (mTable->FetchLocalCellFrame(mIndex, cellFrame)) {		//	if (pen is invisible)		if (UQDGlobals::GetCurrentPort()->pnVis != 0) {			//	irritation so regions will be built properly...			FrameRect(&cellFrame);		} else {			PrimeHiliteMode_();			InvertRect(&cellFrame);		}		}}void	LCellAEOM::DrawSelfLatent(void){	Rect		cellFrame;		if (mTable->FetchLocalCellFrame(mIndex, cellFrame)) {//		cellFrame.right--;//		cellFrame.bottom--;		StColorPenState::Normalize();		PenMode(srcXor);		PrimeHiliteMode_();		FrameRect(&cellFrame);	}}void	LCellAEOM::DrawSelfReceiver(void){	DrawSelfLatent();	LSelectableItem::DrawSelfReceiver();}//	===========================================================================//	Verb handling...void	LCellAEOM::HandleDelete(	AppleEvent			&outAEReply,	AEDesc				&outResult)/*	It makes no sense to delete a single cell.  Instead this HandleDelete	calls the table's default clear cell method.*/{	OSErr			err;	mTable->ClearCell(mIndex);	//	hole descriptor is helpful for undo.	StAEDescriptor	holeDesc;	this->MakeSpecifier(holeDesc.mDesc);	err = AEPutKeyDesc(&outAEReply, keyAEInsertHere, &holeDesc.mDesc);	ThrowIfOSErr_(err);}// ===========================================================================//	LRowAEOMLRowAEOM::LRowAEOM(){	Assert_(false);}LRowAEOM::LRowAEOM(LNTable *inTable, TableCellT inIndex) 	:	LTableElemAEOM(inTable, cRow, inIndex){}LRowAEOM::~LRowAEOM(){}void	LRowAEOM::GetSubModelByPosition(	DescType		inModelID,	Int32			inPosition,	AEDesc			&outToken) const{	LModelObject	*theSubModel = nil;	TableCellT		cell;		if (inModelID == cCell) {		cell.row = mIndex.row;		cell.col = inPosition;		if (mTable->IsValidCell(cell)) {			theSubModel = new LCellAEOM(mTable, cell);		}	}	if (theSubModel == NULL)		LModelObject::GetSubModelByPosition(inModelID, inPosition, outToken);	else		PutInToken(theSubModel, outToken);}long	LRowAEOM::CountSubModels(DescType inModelID) const{	Int32	rows, cols;			if (inModelID == cCell) {		mTable->GetTableSize(rows, cols);		return cols;	}		return inheritAEOM::CountSubModels(inModelID);}// ===========================================================================//	LColumnAEOMLColumnAEOM::LColumnAEOM(){	Assert_(false);}LColumnAEOM::LColumnAEOM(LNTable *inTable, TableCellT inIndex)	:	LTableElemAEOM(inTable, cColumn, inIndex){}LColumnAEOM::~LColumnAEOM(){}void	LColumnAEOM::GetSubModelByPosition(	DescType		inModelID,	Int32			inPosition,	AEDesc			&outToken) const{	LModelObject	*theSubModel = nil;	TableCellT		cell;		if (inModelID == cCell) {		cell.col = mIndex.col;		cell.row = inPosition;		if (mTable->IsValidCell(cell)) {			theSubModel = new LCellAEOM(mTable, cell);		}	}	if (theSubModel == NULL)		LModelObject::GetSubModelByPosition(inModelID, inPosition, outToken);	else		PutInToken(theSubModel, outToken);}long	LColumnAEOM::CountSubModels(DescType inModelID) const{	Int32	rows, cols;			if (inModelID == cCell) {		mTable->GetTableSize(rows, cols);		return rows;	}		return inheritAEOM::CountSubModels(inModelID);}