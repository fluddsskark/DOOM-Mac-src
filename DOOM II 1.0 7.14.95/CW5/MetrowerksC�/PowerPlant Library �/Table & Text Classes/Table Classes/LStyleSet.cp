//	===========================================================================//	LStyleSet.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LStyleSet.h"#include	<UAppleEventsMgr.h>#include	<UAEGizmos.h>#include	<UExtractFromAEDesc.h>#include	<UAEDesc.h>#include	<AERegistry.h>#include	<String_Utils.h>#include	<LNTextEdit.h>LStyleSet::LStyleSet(){	Assert_(false);	//	Must provide parameters}LStyleSet::LStyleSet(LNTextEdit *inTextView, LStyleSet *inOriginal):	LCoreAEOM((LModelObject *)inTextView, cStyleSet){	mName[0] = 0;	SetLaziness(false);}LStyleSet::~LStyleSet(){}void	LStyleSet::Finalize(void){	if (OwnershipCount() <= 0)		LCoreAEOM::Finalize();}const StringPtr	LStyleSet::GetModelNamePtr(void) const{	if (mName[0])		return (StringPtr)mName;	else		return NULL;}void	LStyleSet::HandleDelete(	AppleEvent			&outAEReply,	AEDesc				&outResult){	if (OwnershipCount() > 1) {		Throw_(errAEEventNotHandled);	//	Can't delete if outstanding claims.	} else {		SetLaziness(true);	//	A "lazy" way to delete :)  Object will be finalized by caller.	}}Int16	LStyleSet::GetFontId(const Str255 inFontName){	Int16	rval;		GetFNum(inFontName, &rval);		if (rval == 0) {		Str255		fontZeroName;		GetFontName(0, fontZeroName);		if (!EqualString(inFontName, fontZeroName, false, false))			Throw_(fontNotDeclared);	}		return rval;}void	LStyleSet::GetFontName(Int16 inFontId, Str255 inFontName){	::GetFontName(inFontId, inFontName);}void	LStyleSet::GetTextTraits(TextTraitsRecord *inTraits){	ThrowIfNULL_(inTraits);		StAEDescriptor	size,					styles,					color,					fontName,					bogusType;		GetAEProperty(pColor, bogusType, color.mDesc);	GetAEProperty(pFont, bogusType, fontName.mDesc);	GetAEProperty(pPointSize, bogusType, size.mDesc);	GetAEProperty(pTextStyles, bogusType, styles.mDesc);	UExtractFromAEDesc::TheRGBColor(color, inTraits->color);	UExtractFromAEDesc::ThePString(fontName, inTraits->fontName);	inTraits->fontNumber = GetFontId(inTraits->fontName);	UExtractFromAEDesc::TheInt16(size, inTraits->size);	inTraits->style = StylesToInt(styles);	}void	LStyleSet::SetTextTraits(const TextTraitsRecord &inTraits){	StAEDescriptor	size(inTraits.size),					styles,					color(cRGBColor, &inTraits.color, sizeof(inTraits.color)),					bogusReply;		IntToStyles(inTraits.style, &styles.mDesc);		SetAEProperty(pColor, color, bogusReply.mDesc);	if (inTraits.fontName[0] != 0) {		StAEDescriptor	fontName((StringPtr)inTraits.fontName);				SetAEProperty(pFont, fontName, bogusReply.mDesc);	} else {		Str255	font;				GetFontName(inTraits.fontNumber, font);				if (font[0] == 0)			Throw_(paramErr);					StAEDescriptor	fontName(font);				SetAEProperty(pFont, fontName, bogusReply.mDesc);	}	SetAEProperty(pPointSize, size, bogusReply.mDesc);	SetAEProperty(pTextStyles, styles, bogusReply.mDesc);}void	LStyleSet::WriteStyles(LAEStream &outStream, Int32 inFaces){//	outStream.OpenList();	if (inFaces == normal) {		outStream.WriteEnum(kAEPlain);	} else {		if (inFaces & bold)			outStream.WriteEnum(kAEBold);		if (inFaces & italic)		outStream.WriteEnum(kAEItalic);		if (inFaces & outline)		outStream.WriteEnum(kAEOutline);		if (inFaces & shadow)		outStream.WriteEnum(kAEShadow);		if (inFaces & underline)	outStream.WriteEnum(kAEUnderline);		if (inFaces & condense)		outStream.WriteEnum(kAECondensed);		if (inFaces & extend)		outStream.WriteEnum(kAEExpanded);	}//	outStream.CloseList();}Int32	LStyleSet::StylesToInt(const AEDesc &inStyles){	Int32		rval = normal;	LAESubDesc	ae(inStyles),				val;	OSType		theEnum;	Int32		i,				n;		if (!ae.IsListOrRecord())		Throw_(paramErr);		n = ae.CountItems();		for (i = 1; i <= n; i++) {		ae.NthItem(i, NULL, &val.mSubDesc);		val.GetData(&theEnum, sizeof(theEnum));		switch (theEnum) {			case kAEBold:			rval |=	bold;			break;			case kAEItalic:			rval |=	italic;			break;			case kAEOutline:		rval |=	outline;		break;			case kAEShadow:			rval |=	shadow;			break;			case kAEUnderline:		rval |=	underline;		break;			case kAECondensed:		rval |=	condense;		break;			case kAEExpanded:		rval |=	extend;			break;		}	}		return rval;}void	LStyleSet::IntToStyles(Int32 inOnFaces, AEDesc *outStyles, Int32 inOffFaces){	LAEStream	aeStream(outStyles);		if (inOffFaces == 0)		inOffFaces = ~inOnFaces;		aeStream.OpenRecord(typeTextStyles);		//	On styles	aeStream.WriteKey(keyAEOnStyles);	aeStream.OpenList();	WriteStyles(aeStream, inOnFaces);	aeStream.CloseList();		//	Off styles	aeStream.WriteKey(keyAEOffStyles);	aeStream.OpenList();	WriteStyles(aeStream, inOffFaces);	aeStream.CloseList();	aeStream.CloseRecord();}void	LStyleSet::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	switch (inProperty) {		case pName:		{			LAEStream	out(&outPropertyDesc);					out.WriteDesc(typeChar, mName + 1, mName[0]);			break;		}		default:			break;	}}void	LStyleSet::SetAEProperty(	DescType		inProperty,	const AEDesc	&inValue,	AEDesc			&outAEReply){	switch (inProperty) {		case pName:		{			Str255	str;						UExtractFromAEDesc::ThePString(inValue, str);			CopyPStr(str, mName, sizeof(mName));			break;		}		default:			break;	}}void	LStyleSet::MakeSelfSpecifier(AEDesc &inSuperSpecifier, AEDesc &outSelfSpecifier) const{	if (mName[0] == 0) {		LCoreAEOM::MakeSelfSpecifier(inSuperSpecifier, outSelfSpecifier);	} else {		OSErr			err;		StAEDescriptor	desc(typeChar, (char *)(mName + 1), mName[0]);			err = CreateObjSpecifier(cStyleSet, &inSuperSpecifier, 			formName, &desc.mDesc, false, &outSelfSpecifier);		ThrowIfOSErr_(err);	}}