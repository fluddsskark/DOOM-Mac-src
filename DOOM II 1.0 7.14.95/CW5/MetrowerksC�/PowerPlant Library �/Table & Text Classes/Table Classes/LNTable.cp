//	===========================================================================//	LNTable.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LNTable.h"#include	<LSelectableItem.h>#include	<LSelection.h>#include	<LTableElemAEOM.h>#include	<LDescTube.h>#include	<LStream.h>#include	<LModelProperty.h>#include	<UAppleEventsMgr.h>#include	<UExtractFromAEDesc.h>#include	<UMemoryMgr.h>#include	<UDrawingState.h>#include	<UCursor.h>#include	<LTableHandler.h>#include	<AppleEvents.h>#include	<Errors.h>#include	<AERegistry.h>#include	<AEObjects.h>#include	<AEPackObject.h>//	===========================================================================//	MaintenanceLNTable::LNTable(LStream *inStream)		: LSelectHandlerView(inStream){	mArray = NULL;mColWidth = 40;mRowHeight = 20;mClipToCellFrames = false;}LNTable::LNTable(LModelObject *inSuperModel)	:	LSelectHandlerView(inSuperModel, cTable)//		mColWidths(sizeof(Int16)),//		mRowHeights(sizeof(Int16)),{//	inSuperModel->AddSubModel(this);	//	now done in LModelObject	mArray = NULL;mColWidth = 40;mRowHeight = 20;mClipToCellFrames = false;}LNTable::~LNTable(){}L2dDynamicArray*	LNTable::Get2dArray(void){	return mArray;}void	LNTable::Set2dArray(L2dDynamicArray *inArray){	mArray = inArray;		CheckSizes();	Refresh();}//	===========================================================================//	Overridesvoid	LNTable::DrawCell(	const TableCellT	&inCell){	Assert_(false);}void	LNTable::ClearCell(	const TableCellT	&inCell)/*	clear data then call this inherited method to update the display.*/{	RefreshCell(inCell);}void	LNTable::SetCellDataByDesc(			const TableCellT	&inCell,	//	Cell to change.			const AEDesc		&inValue)	//	Value to set cell to{	Assert_(false);	//	must override}void	LNTable::GetCellDataAsDesc(			const TableCellT	&inCell,			//	Cell to get data from			const DescType		inRequestedType,	//	Can be ignored			AEDesc				&outValue)	const	//	Resulting cell data{	Assert_(false);	//	must override}//	===========================================================================//	Data tube i/o:FlavorType	LNTable::PickFlavorFrom(	const TableCellT	&inCell,	const LDataTube		*inTube)//	OVERRIDE{	return typeNull;}void	LNTable::AddFlavorTypesTo(	const TableCellT	&inCell,	LDataTube			*inTube)//	OVERRIDE{}Boolean	LNTable::SendFlavorTo(	FlavorType			inFlavor,	const TableCellT	&inCell,	LDataTube			*inTube)//	OVERRIDE/*	This default method maps back to the arcaic GetCellDataAsDesc.  If you're	writing new code, you should not use GetCellDataAsDesc or SetCellDataByDesc.*/{	StAEDescriptor	type;	StAEDescriptor	value;	OSErr			err;		err = AECreateDesc(typeType, &inFlavor, sizeof(inFlavor), &type.mDesc);	ThrowIfOSErr_(err);		GetCellDataAsDesc(inCell, type.mDesc.descriptorType, value.mDesc);		StHandleLocker	lock(value.mDesc.dataHandle);	inTube->SetFlavorData(inFlavor, *(value.mDesc.dataHandle), GetHandleSize(value.mDesc.dataHandle));	return true;}void	LNTable::ReceiveDataFrom(	const TableCellT	&inCell,	LDataTube			*inTube)//	OVERRIDE/*	This default method maps back to the arcaic SetCellDataByDesc.  If you're	writing new code, you should not use GetCellDataAsDesc or SetCellDataByDesc.*/{	//	Newer programs not using Get/SetCellData..Desc will override	//	ReceiveDataFrom -- this code should never be called.  If it is called,	//	it is presumably being used in a AE context.	Assert_(inTube);	LDescTube	*aeTube = (LDescTube *)inTube;	if (inTube->GetFlavorForType() != flavorForAEDesc)		Throw_(paramErr);		SetCellDataByDesc(inCell, aeTube->mDesc.mDesc);}//	===========================================================================//	LSelectHandlerView overrides:LSelectableItem *	LNTable::OverItem(Point inWhere){	LSelectableItem	*rval = inherited::OverItem(inWhere);	TableCellT		cell;		if (rval)		return rval;	//	Is there a corresponding cell?	if (!FetchCellHitBy(inWhere, cell))		return NULL;	rval = new LCellAEOM(this, cell);	return(rval);}void	LNTable::NoteOverNewThing(LManipulator *inThing){	if (inThing) {		switch(inThing->ItemType()) {			case kManipulator:				UCursor::Reset();	//	Override as necessary.									//	(Will be fixed for cell size adjustors				break;			case kSelectableItem:				UCursor::Tick(cu_Plus);				break;			case kSelection:				inherited::NoteOverNewThing(inThing);	//	Ie. data drag "hand"				break;		}	} else {		UCursor::Reset();	}}//	===========================================================================//	Queryvoid	LNTable::GetTableSize(	TableIndexT	&outRows,	TableIndexT	&outCols){	outRows = mRows;	outCols = mCols;}Boolean	LNTable::IsValidCell(	const TableCellT	&inCell){	return ( (inCell.row > 0) && (inCell.row <= mRows) &&			 (inCell.col > 0) && (inCell.col <= mCols) );}Boolean	LNTable::EqualCell(	const TableCellT	&inCellA,	const TableCellT	&inCellB){	return ( (inCellA.row == inCellB.row) &&			 (inCellA.col == inCellB.col) );}Boolean	LNTable::FetchCellHitBy(	const Point		&inPoint,	TableCellT		&outCell){	SPoint32	imagePt;		LocalToImagePoint(inPoint, imagePt);		return FetchCellHitBy(imagePt, outCell);}Boolean	LNTable::FetchCellHitBy(	const SPoint32	&inImagePt,	TableCellT		&outCell){	outCell.row = (inImagePt.v - 1) / mRowHeight + 1;	outCell.col = (inImagePt.h - 1) / mColWidth + 1;		if (inImagePt.h < 0)		return false;		if (inImagePt.h >= (mImageSize.width))		return false;			if (inImagePt.v < 0)		return false;		if (inImagePt.v >= (mImageSize.height))		return false;			return true;}Boolean	LNTable::FetchLocalCellFrame(	const TableCellT	&inCell,	Rect				&outCellFrame){								// Get Top-Left in Image coordinates	SPoint32	cellImage;	cellImage.h = (inCell.col - 1) * mColWidth;	cellImage.v = (inCell.row - 1) * mRowHeight;									// Check if Cell intersects the Frame	Boolean	intersectsFrame = ImageRectIntersectsFrame(									cellImage.h, cellImage.v,									cellImage.h + mColWidth,									cellImage.v + mRowHeight);		if (intersectsFrame) {		// Convert to Local coordinates		ImageToLocalPoint(cellImage, topLeft(outCellFrame));		outCellFrame.right = outCellFrame.left + mColWidth;		outCellFrame.bottom = outCellFrame.top + mRowHeight;	}		return intersectsFrame;}//	===========================================================================//	Semantic operationsvoid	LNTable::InsertRows(Int32 inHowMany, TableIndexT inAfterRow, void *inCellData){	CheckSizes();}void	LNTable::InsertCols(Int32 inHowMany, TableIndexT inAfterCol, void *inCellData){	CheckSizes();}void	LNTable::RemoveRows(Int32 inHowMany, TableIndexT inFromRow){	CheckSizes();}void	LNTable::RemoveCols(Int32 inHowMany, TableIndexT inFromCol){	CheckSizes();}void	LNTable::SetCellData(const TableCellT &inCell, void *inData){	mArray->SetItemAt2d(inCell.col, inCell.row, inData);	CheckSizes();	RefreshCell(inCell);}void	LNTable::GetCellData(const TableCellT &inCell, void *outData){	mArray->FetchItemAt2d(inCell.col, inCell.row, outData);}	//	===========================================================================//	Appearancevoid	LNTable::SetRowHeight(Int16 inHeight, TableIndexT inFrom, TableIndexT inTo){mRowHeight = inHeight;	CheckSizes();	Refresh();}void	LNTable::SetColWidth(Int16 inWidth, TableIndexT inFrom, TableIndexT inTo){mColWidth = inWidth;	CheckSizes();	Refresh();}//	===========================================================================//	Implementationvoid	LNTable::CheckSizes(void){	SDimension32	size, imSize;		mArray->GetDimensions(mRows, mCols);		size.width = mCols * mColWidth;	size.height = mRows * mRowHeight;		GetImageSize(imSize);	if ((size.width != imSize.width) || (size.height != imSize.height))		ResizeImageTo(size.width, size.height, true);	}void	LNTable::DrawSelf(){	RgnHandle	saveClip = NewRgn();	ThrowIfNULL_(saveClip);	RgnHandle	tempRgn = NewRgn();	ThrowIfNULL_(tempRgn);	Try_ {		GetClip(saveClip);		ThrowIfMemError_();		// Determine cells that need updating. Rather than checking		// on a cell by cell basis, we just see which cells intersect		// the bounding box of the update region. This is relatively		// fast, but may result in unnecessary cell updates for		// non-rectangular update regions.			RgnHandle	localUpdateRgnH = GetLocalUpdateRgn();		Rect		updateRect = (**localUpdateRgnH).rgnBBox;		DisposeRgn(localUpdateRgnH);										// Find cell at top left of update rect		SPoint32	topLeftUpdate;		TableCellT	topLeftCell;		LocalToImagePoint(topLeft(updateRect), topLeftUpdate);		FetchCellHitBy(topLeftUpdate, topLeftCell);		if (topLeftCell.row < 1) {	// Lower bound is cell (1,1)			topLeftCell.row = 1;		}		if (topLeftCell.col < 1) {			topLeftCell.col = 1;		}										// Find cell at bottom right of update rect		SPoint32	botRightUpdate;		TableCellT	botRightCell;		LocalToImagePoint(botRight(updateRect), botRightUpdate);		FetchCellHitBy(botRightUpdate, botRightCell);									// Upper bound is cell (mRows,mCols)		if (botRightCell.row > mRows) {			botRightCell.row = mRows;		}		if (botRightCell.col > mCols) {			botRightCell.col = mCols;		}											// Draw each cell within the update rect		TableCellT	cell;		Rect		r;		Boolean		b;				if (!mClipToCellFrames) {			for (cell.row = topLeftCell.row; cell.row <= botRightCell.row; cell.row++) {				for (cell.col = topLeftCell.col; cell.col <= botRightCell.col; cell.col++) {					DrawCell(cell);				}			}		} else {			for (cell.row = topLeftCell.row; cell.row <= botRightCell.row; cell.row++) {				for (cell.col = topLeftCell.col; cell.col <= botRightCell.col; cell.col++) {					b = FetchLocalCellFrame(cell, r);					Assert_(b);					RectRgn(tempRgn, &r);														ThrowIfOSErr_(QDError());					SectRgn(saveClip, tempRgn, tempRgn);														ThrowIfOSErr_(QDError());					SetClip(tempRgn);														ThrowIfOSErr_(QDError());					DrawCell(cell);				}			}		}		SetClip(saveClip);		DisposeRgn(saveClip);		DisposeRgn(tempRgn);	} Catch_(err) {		SetClip(saveClip);		DisposeRgn(saveClip);		DisposeRgn(tempRgn);		Throw_(err);	} EndCatch_;}void	LNTable::RefreshCell(const TableCellT	&inCell){	Rect	r;	FocusDraw();	//	Precaution	if (FetchLocalCellFrame(inCell, r)) {		LocalToPortPoint(topLeft(r));		LocalToPortPoint(botRight(r));		InvalPortRect(&r);		//	helpfull for debugging...		#if	0			StColorPenState	save;						RGBColor	red = {0xffff,0,0};			RGBForeColor(&red);			PenMode(patCopy);			PaintRect(&r);		#endif		//	Without this InvalPortRect messes up the focus		OutOfFocus(NULL);		FocusDraw();	}}//	===========================================================================//	AEOMLModelProperty*LNTable::GetModelProperty(	DescType	inProperty){	LModelProperty	*theProperty = nil;		switch (inProperty) {		default:			theProperty = inheritAEOM::GetModelProperty(inProperty);	}		return theProperty;}voidLNTable::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	switch (inProperty) {		case pBestType:		case pClass:		case pDefaultType:		case pName:		case pProtection://			UAEDesc::MakeBooleanDesc(IsVisible(), &outPropertyDesc);//			break;		default:			LModelObject::GetAEProperty(inProperty, inRequestedType,											outPropertyDesc);			break;	}}voidLNTable::SetAEProperty(	DescType		inProperty,	const AEDesc	&inValue,	AEDesc&			outAEReply){	switch (inProperty) {		case pVisible:		{			Boolean	makeVisible;			UExtractFromAEDesc::TheBoolean(inValue, makeVisible);			if (makeVisible) {				Show();			} else {				Hide();			}			break;		}				default:			LModelObject::SetAEProperty(inProperty, inValue, outAEReply);			break;	}}voidLNTable::GetSubModelByPosition(	DescType		inModelID,	Int32			inPosition,	AEDesc			&outToken) const{	LModelObject	*theSubModel = nil;	TableCellT		p = {0, 0};	switch (inModelID) {		case cCell:			p.row = (inPosition -1) / mCols +1;			p.col = (inPosition -1) % mCols +1;			break;		case cRow:			p.row = inPosition;			break;		case cColumn:			p.col = inPosition;			break;	}	switch (inModelID) {		case cCell:			theSubModel = new LCellAEOM((LNTable *)this, p);			break;		case cRow:			theSubModel = new LRowAEOM((LNTable *)this, p);			break;		case cColumn:			theSubModel = new LColumnAEOM((LNTable *)this, p);			break;	}		if (theSubModel == NULL)		LModelObject::GetSubModelByPosition(inModelID, inPosition, outToken);	else		PutInToken(theSubModel, outToken);}									voidLNTable::GetSubModelByName(	DescType		inModelID,	Str255			inName,	AEDesc			&outToken) const{	LModelObject	*theSubModel = nil;		switch (inModelID) {			case cCell:		{/*			TableCellT	n = {inPosition % 1, inPosition / 1};							//	1 above should be width of table						//	Get cell			//	Create row or column			theSubModel = new LCellAEOM(this, n);*/			break;		}					case cRow:		case cColumn:			//	Get key//			theSubModel = new LColRowAEOM(this, inModelID == cRow, inPosition);			break;		case cSelection:			theSubModel = mSelection;			break;	}		if (theSubModel == NULL)		LModelObject::GetSubModelByName(inModelID, inName, outToken);	else		PutInToken(theSubModel, outToken);}long	LNTable::CountSubModels(DescType inModelID) const{	switch(inModelID) {		case cCell:			return mRows * mCols;			break;		case cRow:			return mRows;			break;		case cColumn:			return mCols;			break;		case cSelection:			return 1;			break;		default:			return LModelObject::CountSubModels(inModelID);			break;	}}Int32	LNTable::GetPositionOfSubModel(			DescType			inModelID,			const LModelObject	*inSubModel) const{	LTableElemAEOM	*p = (LTableElemAEOM *) inSubModel;	Int32			rval;	TableCellT		index;		inModelID = inSubModel->GetModelKind();		switch(inModelID) {		case cCell:			p->GetCellIndex(&index);			rval = (index.row -1) * mCols + index.col;			break;		case cRow:			p->GetCellIndex(&index);			rval = index.row;			break;		case cColumn:			p->GetCellIndex(&index);			rval = index.col;			break;		case cSelection:			rval = 1;			break;		default:			rval = LModelObject::GetPositionOfSubModel(inModelID, inSubModel);			break;	}		return rval;}									LModelObject *	LNTable::HandleCreateElementEvent(	DescType			inElemClass,	DescType			inInsertPosition,	LModelObject		*inTargetObject,	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply)/*	For a cell, this event just defaults to a set contents event.*/{	LModelObject	*rval = NULL;	StAEDescriptor	propsDesc;	StAEDescriptor	dataDesc;		propsDesc.GetOptionalParamDesc(inAppleEvent, keyAEPropData, typeAERecord);	if (propsDesc.mDesc.descriptorType != typeNull)		dataDesc.GetOptionalParamDesc(propsDesc.mDesc, pContents, typeChar);		if (dataDesc.mDesc.descriptorType == typeNull)		dataDesc.GetParamDesc(inAppleEvent, keyAEData, typeWildCard);		if (dataDesc.mDesc.dataHandle == NULL)		Throw_(errAEEventFailed);		switch(inElemClass) {		default:			//	Fall through acceptance/coercion to cell.			//	This should change in the future.					case cCell:		{			Assert_(inTargetObject);			TableCellT	index;			LCellAEOM	*cell = (LCellAEOM *) inTargetObject;			LDescTube	tube(dataDesc.mDesc);			//			Assert_(member(cell, LCellAEOM));			cell->GetRange(&index);			cell->ReceiveDataFrom(&tube);//			SetCellDataByDesc(index, dataDesc.mDesc);			//	delete inTargetObject -- Not, the cell is the target object and it is			//	about to be returned.			rval = inTargetObject;			break;		}	}		return rval;}