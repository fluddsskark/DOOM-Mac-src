//	===========================================================================//	LDragTube.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================//	For routine descriptions see LDataTube.cp.#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LDragTube.h"#include	<UMemoryMgr.h>#include	<Errors.h>#include	<LDynamicArray.h>#include	<LTubeableItem.h>LDragTube::LDragTube(){	Assert_(false);		//	Parameters required}/*LDragTube::LDragTube(	DragReference	inDragRef,	ItemReference	inDragItem){	mDragRef = inDragRef;	mDragItem = inDragItem;}*/LDragTube::LDragTube(	DragReference	inDragRef)/*	Make a tube from the given drag reference.		Implementation note:			When initialized with this constructor, the tube has no		mTubeableItem -- the mItemRef may be from another app domain		and have no "object" realization.*/{	unsigned short	count;	OSErr			err;		mDragRef = inDragRef;	mTubeableItem = NULL;		err = CountDragItems(mDragRef, &count);	ThrowIfOSErr_(err);		if (count == 1) {		err = GetDragItemReferenceNumber(mDragRef, 1, &mItemRef);		ThrowIfOSErr_(err);	} else {		//	Instantiate subtubes?		Assert_(false);		//	Unimplemented feature.		Throw_(featureUnsupported);	}}LDragTube::LDragTube(	DragReference		inDragRef,	const LTubeableItem	*inTubeableItem,	Boolean				inReqdFlavorsOnly):	LDataTube(inTubeableItem, inReqdFlavorsOnly)/*	For creating drag item data.*/{	OSErr			err;	unsigned short	count;		mDragRef = inDragRef;	mItemRef = (ItemReference)mTubeableItem;	//	One and the same value		//	A precaution	err = CountDragItems(mDragRef, &count);	ThrowIfOSErr_(err);	Assert_(count == 0);		Assert_(mTubeableItem);	mTubeableItem->AddFlavorTypesTo(this);}LDragTube::~LDragTube(){}void	LDragTube::AddFlavor(FlavorType inFlavor){	OSErr	err;		err = AddDragItemFlavor(mDragRef, mItemRef, inFlavor, NULL, 0, 0);	ThrowIfOSErr_(err);}Boolean	LDragTube::FlavorExists(FlavorType inFlavor) const{	OSErr		err;	FlavorFlags	flags;		err = GetFlavorFlags(mDragRef, mItemRef, inFlavor, &flags);	if (err == badDragFlavorErr)		return false;	ThrowIfOSErr_(err);		return true;}Size	LDragTube::GetFlavorSize(FlavorType inFlavor){	OSErr		err;	Size		dataSize;		err = GetFlavorDataSize(mDragRef, mItemRef, inFlavor, &dataSize);		//	for debugging...	if (err != noErr) {		OSErr			err2;		short			i;		unsigned short	numItems;		ItemReference	item;		LTubeableItem	*tubeItem;				Assert_(false);		err2 = CountDragItems(mDragRef, &numItems);				for (i = 1; i <= numItems; i++)  {			err2 = GetDragItemReferenceNumber(mDragRef, i, &item);			tubeItem = (LTubeableItem *) item;		}	}		ThrowIfOSErr_(err);		return dataSize;}void *	LDragTube::GetFlavorData(	FlavorType	inFlavor,	void		*outFlavorData,	Int32		inOffset,	Int32		inAmount)//	For routine description see LDataTube.cp.{	OSErr		err;	Size		preDataSize, dataSize;		Assert_(outFlavorData);		preDataSize = dataSize = GetFlavorSize(inFlavor);		err = ::GetFlavorData(mDragRef, mItemRef, inFlavor, outFlavorData, &dataSize, 0);	ThrowIfOSErr_(err);		Assert_(dataSize == preDataSize);		return NULL;}void	LDragTube::SetFlavorData(	FlavorType	inFlavor,	void		*inFlavorData,	Int32		inFlavorSize,	Int32		inOffset,	Int32		inAmount)//	For routine description see LDataTube.cp./*	Don't call this routine unless you really want the data!  Otherwise, "something"	will automatically call it.*/{	OSErr		err;		//	for debugging	#if	0	{		unsigned short	count,						i;		ItemReference	item;		Boolean			found = false;				err = CountDragItems(inDrag, &count);		ThrowIfOSErr_(err);				for (i = 1; i <= count; i++) {			err = GetDragItemReferenceNumber(inDrag, i, &item);			ThrowIfOSErr_(err);						if (item == (ItemReference) this) {				found = true;				break;			}		}				Assert_(found);	//	Discovery!  If this fails or something above						//	throws a -48 error, it is most likely a sign						//	the Drag Mgr has died -- time to reboot.	}	#endif		err = SetDragItemFlavorData(mDragRef, mItemRef, inFlavor, inFlavorData, inFlavorSize, 0);	ThrowIfOSErr_(err);	//	If -48 see note above.}Int32	LDragTube::GetSubTubeCount(void){	OSErr			err;	unsigned short	count;		Assert_(false);	//	Unimplemented feature	Throw_(featureUnsupported);	err = CountDragItems(mDragRef, &count);	ThrowIfOSErr_(err);		if (count == 1)		return 0;	else		return count;}LDataTube *	LDragTube::GetSubTube(Int32 inTubeIndex){	Assert_(false);	//	Unimplemented feature	Throw_(featureUnsupported);	return NULL;}LDataTube *	LDragTube::MakeNewSubTubeFor(LTubeableItem *inItem){	Assert_(inItem != mTubeableItem);		Assert_(false);	//	Unimplemented feature	Throw_(featureUnsupported);	return NULL;}void	LDragTube::AddSubTube(LDataTube *inTube){	Assert_(false);	//	Unimplemented feature	Throw_(featureUnsupported);}