//	===========================================================================//	LDataTube.cp					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include	<PP_Prefix.h>#include	"LDataTube.h"#include	<UMemoryMgr.h>#include	<LTubeableItem.h>LDataTube::LDataTube(){	mTubeableItem = NULL;	mReqdFlavorsOnly = false;}LDataTube::LDataTube(	const LTubeableItem	*inTubeableItem,	Boolean				inReqdFlavorsOnly){	mTubeableItem = (LTubeableItem *) inTubeableItem;	mReqdFlavorsOnly = inReqdFlavorsOnly;}LDataTube::~LDataTube(){}Boolean	LDataTube::GetOnlyReqdFlavors(void){	return mReqdFlavorsOnly;}FlavorForT	LDataTube::GetFlavorForType(void){	return flavorForClipboard;}void	LDataTube::AddFlavor(FlavorType inFlavor){	Assert_(false);}Boolean	LDataTube::FlavorExists(FlavorType inFlavor) const{	return false;}Int32	LDataTube::GetFlavorSize(FlavorType inFlavor){	return 0;}void *	LDataTube::GetFlavorData(	FlavorType	inFlavor,	void		*outFlavorData,	Int32		inOffset,	Int32		inAmount)/*	InOffset and inAmount are optional parameters for "spooled data"...		For "spooled data," inOffset indicates the flavor data offset position	to transfer inAmount bytes to outFlavorData.		If outFlavorData is NULL, the data tube will attempt to return a	pointer to its own copy of the flavor data.  If the flavor is internally	represented as a handle or is discontinuous, NULL will be returned.	In that case, you must call GetFlavorData again with a non-NULL	outFlavorData.*/{	return NULL;}void	LDataTube::SetFlavorData(	FlavorType	inFlavor,	void		*inFlavorData,	Int32		inFlavorSize,	Int32		inOffset,	Int32		inAmount)/*	Set functions should only be called by initialization routines	or a tubeable item in response to a send flavor message.	InOffset and inAmount are optional parameters for "spooled data"...		For "spooled data," inOffset indicates the flavor data offset position	to transfer inAmount bytes from inFlavorData.*/{	Assert_(false);}void	LDataTube::GetFlavorHandle(FlavorType inFlavor, Handle outFlavorData){	Size			dataSize;	Assert_(outFlavorData);		dataSize = GetFlavorSize(inFlavor);		if (GetHandleSize(outFlavorData) != dataSize)		SetHandleSize(outFlavorData, dataSize);	ThrowIfMemError_();	Assert_(*outFlavorData);		StHandleLocker	lock(outFlavorData);		GetFlavorData(inFlavor, *outFlavorData);}void	LDataTube::SetFlavorHandle(FlavorType inFlavor, Handle inFlavorData)/*	Set functions should only be called by initialization routines	or a tubeable item in response to a send flavor message.*/{	StHandleLocker	h(inFlavorData);	Size			dataSize = GetHandleSize(inFlavorData);		SetFlavorData(inFlavor, *inFlavorData, dataSize);}void	LDataTube::GetFlavorAsDesc(FlavorType inFlavor, AEDesc *outFlavorDesc){	Uint32			size = GetFlavorSize(inFlavor);	StPointerBlock	data(size);	OSErr			err;		GetFlavorData(inFlavor, data.mPtr);		err = AECreateDesc(inFlavor, data.mPtr, size, outFlavorDesc);	ThrowIfOSErr_(err);  }void	LDataTube::SetFlavorByDesc(FlavorType inFlavor, const AEDesc &inFlavorDesc){	Assert_(inFlavorDesc.dataHandle != NULL);	StHandleLocker	lock(inFlavorDesc.dataHandle);	Uint32			size = GetHandleSize(inFlavorDesc.dataHandle);		SetFlavorData(inFlavor, *(inFlavorDesc.dataHandle), size);}Int32	LDataTube::GetSubTubeCount(void){	return 0;}LDataTube *	LDataTube::GetSubTube(Int32 inTubeIndex){	return this;}LDataTube *	LDataTube::MakeNewSubTubeFor(LTubeableItem *inItem){	Assert_(false);	return NULL;}void	LDataTube::AddSubTube(LDataTube *inTube){	Assert_(false);}