//	===========================================================================//	LDataTube.h					©1994 Metrowerks Inc. All rights reserved.//	===========================================================================#pragma	once#include	<Drag.h>#include	<AppleEvents.h>class	LTubeableItem;//	---------------------------------------------------------------------------/*	Data tubes constitute an abstract i/o interface for "tubeable items."	As a result, tubeable item data i/o is simplified since a tubeable item	need not be concerned with wether i/o is to a drag, clipboard, file, or	whatever.		Tube instances come in two varieties:			"tube filling"			fill structures (file | clipboard | drag) with								data from a tubeable item.				"data item extraction"	get data from existing structures (file |								clipboard | drag).		These varieties are determined at tube construction time with tube filling	constructors typically having a tubeable item parameter.*/		/*	Sometimes, a given flavor type could refer to different types of data	depending on the source of the data.  This overlap should never be	designed into a system.  But, if a legacy system or legacy file format is	being worked with, the flavors must be distinguished.  Use	GetFlavorForType to do that distinguishing.  Associated enumerations...*/             typedef enum {	flavorForClipboard,	flavorForDrag,	flavorForFile,	flavorForAEDesc} FlavorForT;//	===========================================================================//	Abstract data tubeclass	LDataTube{public:				//	Maintenance						LDataTube();						LDataTube(							const LTubeableItem	*inTubeableItem,							Boolean				inReqdFlavorsOnly = false);	virtual				~LDataTube();	virtual FlavorForT	GetFlavorForType(void)						= 0;	virtual Boolean		GetOnlyReqdFlavors(void);				//	New features	virtual void		AddFlavor(FlavorType inFlavor)				= 0;	virtual	Boolean		FlavorExists(FlavorType inFlavor) const		= 0;	virtual	Int32		GetFlavorSize(FlavorType inFlavor);	virtual void *		GetFlavorData(							FlavorType	inFlavor,							void		*outFlavorData,							Int32		inOffset = 0,							Int32		inAmount = max_Int32)		= 0;	virtual void		SetFlavorData(							FlavorType	inFlavor,							void		*inFlavorData,							Int32		inFlavorSize,							Int32		inOffset = 0,							Int32		inAmount = max_Int32)		 = 0;	virtual void		GetFlavorHandle(FlavorType inFlavor, Handle outFlavorData);	virtual void		SetFlavorHandle(FlavorType inFlavor, Handle inFlavorData);	virtual void		GetFlavorAsDesc(FlavorType inFlavor, AEDesc *outFlavorDesc);	virtual void		SetFlavorByDesc(FlavorType inFlavor, const AEDesc &inFlavorDesc);										//	Hierarchical tubes:  avoid using -- experimental	virtual	Int32		GetSubTubeCount(void);	virtual LDataTube *	GetSubTube(Int32 inTubeIndex);	virtual LDataTube *	MakeNewSubTubeFor(LTubeableItem *inItem);	virtual void		AddSubTube(LDataTube *inTube);	protected:	LTubeableItem		*mTubeableItem;	Boolean				mReqdFlavorsOnly;};