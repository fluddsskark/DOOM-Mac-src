// ===========================================================================//	LTabGroup.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	A TabGroup switches the Target amongst its SubCommanders in response to//	Tab and Shift-Tab key presses. A SubCommander is responsible for//	passing up Tab key presses to its SuperCommander if it wants to be//	usuable with a TabGroup.////	USAGE NOTE://	By default, the first SubCommander of a TabGroup will be the Target//	when the Window containing the TabGroup is activated. If there is//	more than one TabGroup in a Window, then the last TabGroup will be//	the one on duty.////	To make a paricular Commander be the Target when its Window is//	activated, call SetLatentSub() for that Commander.#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LTabGroup.h>#include <LList.h>#include <LListIterator.h>#include <LStream.h>#include <LView.h>#include <PP_KeyCodes.h>#include <PP_Messages.h>const Uint16	mask_NonShiftModifiers	= cmdKey + optionKey + controlKey;// ---------------------------------------------------------------------------//		¥ CreateTabGroupStream// ---------------------------------------------------------------------------//	Create a new TabGroup. Used when building objects from a data Stream.LTabGroup*LTabGroup::CreateTabGroupStream(	LStream	*inStream){	return (new LTabGroup);}// ---------------------------------------------------------------------------//		¥ LTabGroup// ---------------------------------------------------------------------------//	Default ConstructorLTabGroup::LTabGroup(){		// TabGroup wants to be on duty when its SuperCommander		// is put on duty.			if (mSuperCommander != nil) {		mSuperCommander->SetLatentSub(this);	}}// ---------------------------------------------------------------------------//		¥ LTabGroup(LCommander*)// ---------------------------------------------------------------------------//	Constructor specifying SuperCommanderLTabGroup::LTabGroup(	LCommander	*inSuper)		: LCommander(inSuper){		// TabGroup wants to be on duty when its SuperCommander		// is put on duty.			if (mSuperCommander != nil) {		mSuperCommander->SetLatentSub(this);	}}// ---------------------------------------------------------------------------//		¥ ~LTabGroup// ---------------------------------------------------------------------------//	DestructorLTabGroup::~LTabGroup(){}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Tab switches the Target to the next item in the TabGroup.//	Shift-Tab to the previous item.//	All other keystrokes (and Tabs with modifiers other than Shift)//		get passed up.BooleanLTabGroup::HandleKeyPress(	const EventRecord	&inKeyEvent){	Boolean	keyHandled = true;	Char16	theChar = inKeyEvent.message & charCodeMask;			// Process Tab or Shift-Tab. Pass up if there are any other		// modifiers keys pressed.		if ((theChar == char_Tab) &&		((inKeyEvent.modifiers & mask_NonShiftModifiers) == 0)) {				RotateTarget((inKeyEvent.modifiers & shiftKey) != 0);		} else {		keyHandled = LCommander::HandleKeyPress(inKeyEvent);	}	return keyHandled;}// ---------------------------------------------------------------------------//		¥ RotateTarget// ---------------------------------------------------------------------------//	Switch Target to another SubCommander, either the one before or after//	the current onevoidLTabGroup::RotateTarget(	Boolean	inBackward){	LCommander	*onDutySub = GetOnDutySub();	SignalIf_(onDutySub == nil);		// Must be an on duty sub											// Find position of on duty sub	Int32	pos = mSubCommanders.FetchIndexOf(&onDutySub);		LCommander	*newTarget = onDutySub;	Boolean		switched = false;	do {		if (inBackward) {			if (--pos <= 0) {										// Wrap around to last cmdr				pos = mSubCommanders.GetCount();			}					} else {			if (++pos > mSubCommanders.GetCount()) {				pos = 1;				// Wrap around to first cmdr			}		}				mSubCommanders.FetchItemAt(pos, &newTarget);		switched = newTarget->ProcessCommand(msg_TabSelect);		} while (!switched && (newTarget != onDutySub));			if (switched) {						// Set new target		SwitchTarget(newTarget);	}}// ---------------------------------------------------------------------------//		¥ AddSubCommander// ---------------------------------------------------------------------------//	Add a SubCommander to a TabGroupvoidLTabGroup::AddSubCommander(	LCommander	*inSub){	LCommander::AddSubCommander(inSub);			// First SubCommander of a TabGroup will be on duty when the		// TabGroup is put on duty.	if (mSubCommanders.GetCount() == 1) {		SetLatentSub(inSub);	}}// ---------------------------------------------------------------------------//		¥ BeTarget// ---------------------------------------------------------------------------//	TabGroup has become the Target.////	A TabGroup is only a mediator for its SubCommanders, so it doesn't//	make sense for it to be the Target.voidLTabGroup::BeTarget(){	if (mSuperCommander != nil) {		SwitchTarget(mSuperCommander);	}}// ---------------------------------------------------------------------------//		¥ GetOnDutySub// ---------------------------------------------------------------------------//	Return the on duty SubCommander of a TabGroupLCommander*LTabGroup::GetOnDutySub(){	LCommander	*onDutySub = nil;	LListIterator iterator(mSubCommanders, iterate_FromStart);	LCommander	*theSub;	while (iterator.Next(&theSub)) {		if (theSub->IsOnDuty()) {			onDutySub = theSub;			break;		}	}		return onDutySub;}