// ===========================================================================//	LRadioGroup.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	Manages a group of Controls by ensuring that only one Control in a//	group is "on" at any time. This is the standard behavior of a set of//	Radio Buttons.////	Although you will normally use this class with StdRadioButton objects,//	the group members can be any kind of Control. Therefore, you can group//	your own custom Control objects. This class assumes the "off" value is//	zero, and the "on" value is one.////	RadioGroup and its Controls have a Listener/Broadcaster relationship.#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LRadioGroup.h>#include <LControl.h>#include <LView.h>#include <LList.h>#include <LStream.h>#include <PP_Messages.h>// ---------------------------------------------------------------------------//		¥ CreateRadioGroupStream [static]// ---------------------------------------------------------------------------//	Create a new RadioGroup, initializing it with data from a StreamLRadioGroup*LRadioGroup::CreateRadioGroupStream(	LStream	*inStream){	return (new LRadioGroup(inStream));}// ---------------------------------------------------------------------------//		¥ LRadioGroup// ---------------------------------------------------------------------------//	Default constructorLRadioGroup::LRadioGroup(){	mCurrentRadio = nil;}// ---------------------------------------------------------------------------//		¥ LRadioGroup// ---------------------------------------------------------------------------//	Construct a RadioGroup from a Stream////	Stream data is a list of PaneID numbers for the Controls in the group.//	The Controls must already have been created and must be contained within//	the current default view.LRadioGroup::LRadioGroup(	LStream	*inStream){	mCurrentRadio = nil;	Int16	numberOfRadios;	inStream->ReadData(&numberOfRadios, sizeof(Int16));		LView	*defaultView = LPane::GetDefaultView();		::HidePen();	for (Int16 i = 1; i <= numberOfRadios; i++) {		PaneIDT		radioID;		inStream->ReadData(&radioID, sizeof(PaneIDT));		AddRadio((LControl*) defaultView->FindPaneByID(radioID));	}	::ShowPen();}// ---------------------------------------------------------------------------//		¥ ~LRadioGroup// ---------------------------------------------------------------------------//	DestructorLRadioGroup::~LRadioGroup(){}// ---------------------------------------------------------------------------//		¥ AddRadio// ---------------------------------------------------------------------------//	Add a Control to a RadioGroup////	If the Control is "on" it becomes the current radio, turning off the//	former current radio.voidLRadioGroup::AddRadio(	LControl	*inRadio){	if (inRadio == nil) {		return;	}	inRadio->AddListener(this);			// Attach Radio to this Group		if (mCurrentRadio == nil) {			// First Radio added is turned on		inRadio->SetValue(Button_On);	//   and becomes the current Radio		mCurrentRadio = inRadio;			} else if (inRadio->GetValue() == Button_On) {										// In any subsequent Radio is on,										//   handle same as a click (which										//   will change the current radio)		ListenToMessage(msg_ControlClicked, inRadio);	}}// ---------------------------------------------------------------------------//		¥ GetCurrentRadioID// ---------------------------------------------------------------------------//	Return the PaneID of the current RadioButton in the GroupPaneIDTLRadioGroup::GetCurrentRadioID(){	PaneIDT	currentID = 0;	if (mCurrentRadio != nil) {		currentID = mCurrentRadio->GetPaneID();	}	return currentID; }// ---------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------//	React to Messages from its Broadcasters, which must be the Controls//	in the group.voidLRadioGroup::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	switch (inMessage) {			case msg_BroadcasterDied:			if (mBroadcasters.GetCount() == 1) {										// Last Broadcaster is dying.				delete this;			// Nothing left in group, so										//   delete this RadioGroup			}			break;					case msg_ControlClicked:		// Control clicked was turned on, so										//   we must switch current Radios			LControl	*theRadio = (LControl*) ioParam;			SignalIf_(theRadio == nil);						if (theRadio != mCurrentRadio) {										// Turn off current On button				if (mCurrentRadio != nil) {					mCurrentRadio->SetValue(Button_Off);				}				mCurrentRadio = theRadio;			}			break;	}}