// ===========================================================================//	LGrowZone.cp					©1994 Metrowerks Inc. All rights reserved.// ===========================================================================////	A class for managing low memory situations. The System calls a GrowZone//	function when it wants to allocate more memory than is currently//	available in the heap.////	To monitor memory usage, this class maintains a memory reserve (a//	Handle). When the System calls the GrowZone function, we know that//	memory is running low. We can then empty the reserve to free up some//	memory, and in the process set flags and notify interested parties//	that memory is low.////	This class inherits from LBroadcaster. Objects which are able to free//	memory when needed should be Listeners which attach themselves to the//	GrowZone object so they will be notified when memory is low.////		LGrowZone::GetGrowZone()->AddListerner(myObject);////	This attaches "myObject" as a Listener to the GrowZone. When memory//	is needed, "myObject" will receive a ListenToMessage call with a//	msg_GrowZone message and pointer to the number of bytes needed.////	For example, suppose MyClass stores a myCache Handle with data//	generated from a lengthy calculation. If memory gets low, it//	can dispose of the cache, meaning that it will have to recalculate//	the data if it needs it later. This is a common trade-off://	memory vs. speed.////		MyClass::ListenToMessage(MessageT inMessage, void *ioParam)//		{//			if (inMessage == msg_GrowZone) {//								// Memory is low, free our cache//				Int32 freedBytes = GetHandleSize(myCache);//				DisposeHandle(myCache);//				myCache = nil;//				*(Int32*)ioParam = freedBytes;	// Pass back bytes freed//			}//		}#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LGrowZone.h>#include <LListIterator.h>#include <LListener.h>#include <PP_Messages.h>#include <PP_Resources.h>#ifndef __OSUTILS__#include <OSUtils.h>#endif#ifndef __DIALOGS__#include <Dialogs.h>#endif#ifndef __RESOURCES__#include <Resources.h>#endif// === Static Class Variables ===LGrowZone*		LGrowZone::sGrowZone;GrowZoneUPP		LGrowZone::sGrowZoneUPP;// ---------------------------------------------------------------------------//		¥ LGrowZone// ---------------------------------------------------------------------------//	Constructor////	Allocates a memory reserve of the specified size and installs//	a GrowZone functionLGrowZone::LGrowZone(	Size	inReserveSize){	mLocalReserve = ::NewHandle(inReserveSize);	mReserveSize = inReserveSize;	mGiveWarning = false;	sGrowZone = this;	sGrowZoneUPP = NewGrowZoneProc(GrowZoneCallBack);	::SetGrowZone(sGrowZoneUPP);}// ---------------------------------------------------------------------------//		¥ ~LGrowZone// ---------------------------------------------------------------------------//	Destructor////	Deallocates memory reserve and de-installs GrowZone functionLGrowZone::~LGrowZone(){	if (mLocalReserve != nil) {		::DisposeHandle(mLocalReserve);	}	::SetGrowZone(nil);	DisposeRoutineDescriptor(sGrowZoneUPP);	sGrowZoneUPP = nil;}// ---------------------------------------------------------------------------//		¥ GetGrowZone [static]// ---------------------------------------------------------------------------//	Return pointer to current GrowZone objectLGrowZone*LGrowZone::GetGrowZone(){	return sGrowZone;}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Try to reallocate our memory reserve if necessary and warn user if//	memory is getting low////	Call this routine each time through the main event loopvoidLGrowZone::SpendTime(	const EventRecord	&inMacEvent){	if ((mLocalReserve == nil) || (*mLocalReserve == nil)) {		if (::MaxBlock() > mReserveSize + 2048) {			::ReallocateHandle(mLocalReserve, mReserveSize);			if (!MemError()) {				mGiveWarning = false;			}		}	}		if (mGiveWarning) {		if (::GetResource('ALRT', ALRT_LowMemory) != nil) {			::CautionAlert(ALRT_LowMemory, nil);		}		mGiveWarning = false;	}}// ---------------------------------------------------------------------------//		¥ MemoryIsLow// ---------------------------------------------------------------------------//	Return whether our memory reserve has been used////	Clients can call this routine if they wish to behave differently in//	low memory situations. For example, a program could disable the "New"//	and "Open" commands to prevent new Documents from being created when//	memory is low.BooleanLGrowZone::MemoryIsLow(){	return ((mLocalReserve == nil) || (*mLocalReserve == nil));}// ---------------------------------------------------------------------------//		¥ DoGrowZone// ---------------------------------------------------------------------------//	Called by our Toolbox GrowZone function when the system needs more//	memoryInt32LGrowZone::DoGrowZone(	Size	inBytesNeeded){	Int32	bytesFreed = AskListenersToFree(inBytesNeeded);		bytesFreed += UseLocalReserve(inBytesNeeded);	return bytesFreed;}// ---------------------------------------------------------------------------//		¥ UseLocalReserve// ---------------------------------------------------------------------------//	Empty our local memory reserve in order to free up some memoryInt32LGrowZone::UseLocalReserve(	Size	inBytesNeeded){	Int32	bytesFreed = 0;		if ( (mLocalReserve != nil) &&		 (*mLocalReserve != nil) &&		 (mLocalReserve != GZSaveHnd()) ) {		 		::EmptyHandle(mLocalReserve);		bytesFreed = mReserveSize;		mGiveWarning = true;	}		return bytesFreed;}// ---------------------------------------------------------------------------//		¥ AskListenersToFree// ---------------------------------------------------------------------------//	Broadcast message to listeners that they should free up some memoryInt32LGrowZone::AskListenersToFree(	Size	inBytesNeeded){		// Send a msg_GrowZone message to each Listener. The parameter		// is a pointer to the number of bytes needed. On exit,		// Listeners should set this to the number bytes which they freed.		// We keep a running count of the bytes needed, which could be		// negative if some Listener frees more than we need.			Int32	bytesFreed = 0;	Int32	byteCount = inBytesNeeded;	if (mIsBroadcasting) {		LListIterator	iterator(mListeners, iterate_FromStart);		LListener		*theListener;		while (iterator.Next(&theListener)) {			if (theListener->IsListening()) {				byteCount = inBytesNeeded - bytesFreed;				theListener->ListenToMessage(msg_GrowZone, &byteCount);				bytesFreed += byteCount;			}		}	}		return bytesFreed;}// ---------------------------------------------------------------------------//		¥ GrowZoneCallBack [static]// ---------------------------------------------------------------------------//	This is the "real" GrowZone function registered with the System. It//	sets up the A5 world (68K) so we can access globals, then calls a//	virtual function for the LGrowZone class.pascal Int32LGrowZone::GrowZoneCallBack(	Size	inBytesNeeded){	Int32	theA5 = SetCurrentA5();		Int32	bytesFreed = sGrowZone->DoGrowZone(inBytesNeeded);		SetA5(theA5);		return bytesFreed;}