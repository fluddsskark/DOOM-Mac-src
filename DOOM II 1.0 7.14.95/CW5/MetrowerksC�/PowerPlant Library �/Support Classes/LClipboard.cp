// ===========================================================================//	LClipboard.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	Manages the Clipboard////	This implementation gets and sets data using the global Toolbox//	clipboard (aka Scrap). Create a subclass if you wish to maintain a//	private scrap to more efficiently manage the data used by your//	program.#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LClipboard.h>#include <UMemoryMgr.h>#ifndef __SCRAP__#include <Scrap.h>#endif#ifndef __ERRORS__#include <Errors.h>#endif// === Static Class VariablesLClipboard*	LClipboard::sClipboard;// ---------------------------------------------------------------------------//		¥ LClipboard// ---------------------------------------------------------------------------//	Default ConstructorLClipboard::LClipboard(){	sClipboard = this;	mImportPending = true;	mExportPending = false;}// ---------------------------------------------------------------------------//		¥ ~LClipboard// ---------------------------------------------------------------------------//	DestructorLClipboard::~LClipboard(){	if (sClipboard == this) {		sClipboard = nil;	}}// ---------------------------------------------------------------------------//		¥ SetData// ---------------------------------------------------------------------------//	Set the Clipboard contents to the data in a Handle////	inReset specifies whether to clear the existing contents of the//	Clipboard before storing the new data.voidLClipboard::SetData(	ResType	inDataType,	Handle	inDataH,	Boolean	inReset){	StHandleLocker	lock(inDataH);	SetData(inDataType, *inDataH, GetHandleSize(inDataH), inReset);}// ---------------------------------------------------------------------------//		¥ SetData// ---------------------------------------------------------------------------//	Set the Clipboard contents to the data specified by a pointer and length////	inReset specifies whether to clear the existing contents of the//	Clipboard before storing the new data.voidLClipboard::SetData(	ResType	inDataType,	Ptr		inDataPtr,	Int32	inDataLength,	Boolean	inReset){	SetDataSelf(inDataType, inDataPtr, inDataLength, inReset);	mImportPending = false;	mExportPending = true;}// ---------------------------------------------------------------------------//		¥ GetData// ---------------------------------------------------------------------------//	Pass back the data in the Clipboard of the specified type in a Handle//	and return the size of the data////	If ioDataH is nil, the data is not passed data, but its size is returned//	Otherwise, ioDataH is resized if necessary to hold all the data////	This is a wrapper function which imports the global scrap if necessary//	then calls a lower level function to actually retrieve the dataInt32LClipboard::GetData(	ResType	inDataType,	Handle	ioDataH){	if (mImportPending) {		ImportSelf();	}		return GetDataSelf(inDataType, ioDataH);}// ---------------------------------------------------------------------------//		¥ Resume// ---------------------------------------------------------------------------//	Call when the program receives a Resume event with the "convert//	clipboard" flag set////	This function sets a flag to indicate that we need to import the//	global scrap before handling the next "GetData" request. By just//	setting a flag, we avoid the overhead of converting from the//	global scrap to our local one until the data is actually requested.voidLClipboard::Resume(){	mImportPending = true;}// ---------------------------------------------------------------------------//		¥ Suspend// ---------------------------------------------------------------------------//	Call when the program receives a Suspend event and before quitting////	This function exports our local scrap data to the global scrap if//	our local scrap contains new datavoidLClipboard::Suspend(){	if (mExportPending) {		ExportSelf();	}}// ---------------------------------------------------------------------------//		¥ GetDataSelf// ---------------------------------------------------------------------------//	Pass back the data in the Clipboard of the specified type in a Handle//	and return the size of the data////	If ioDataH is nil, the data is not passed data, but its size is returned//	Otherwise, ioDataH is resized if necessary to hold all the data////	This implementation gets the data from the global scrap. Subclasses//	should override to maintain a local scrap.Int32LClipboard::GetDataSelf(	ResType	inDataType,	Handle	ioDataH){	Int32	offset;	Int32	byteCount = ::GetScrap(ioDataH, inDataType, &offset);		if (byteCount == noTypeErr) {	// Requested Type not available		byteCount = 0;	} else if (byteCount < 0) {		// Negative byteCount is an error code		ThrowOSErr_(byteCount);	}		return byteCount;}// ---------------------------------------------------------------------------//		¥ SetDataSelf// ---------------------------------------------------------------------------//	Set the Clipboard contents to the data specified by a pointer and length////	inReset specifies whether to clear the existing contents of the//	Clipboard before storing the new data.////	This implementation sets the data in the global scrap. Subclasses//	should override to maintain a local scrap.voidLClipboard::SetDataSelf(	ResType	inDataType,	Ptr		inDataPtr,	Int32	inDataLength,	Boolean	inReset){	if (inReset) {		ThrowIfOSErr_( ::ZeroScrap() );	}		ThrowIfOSErr_( ::PutScrap(inDataLength, inDataType, inDataPtr) );}// ---------------------------------------------------------------------------//		¥ ImportSelf// ---------------------------------------------------------------------------//	Import the data in the global scrap to a local scrap////	This implementation does nothing since this class uses the global//	scrap when setting and getting clipboard data. Subclasses should//	override if they maintain a local scrap.voidLClipboard::ImportSelf(){}// ---------------------------------------------------------------------------//		¥ ExportSelf// ---------------------------------------------------------------------------//	Export the data in a local scrap to the global scrap////	This implementation does nothing since this class uses the global//	scrap when setting and getting clipboard data. Subclasses should//	override if they maintain a local scrap.voidLClipboard::ExportSelf(){}// ---------------------------------------------------------------------------//		¥ GetClipboard [static]// ---------------------------------------------------------------------------//	Returns a pointer the current Clipboard objectLClipboard*LClipboard::GetClipboard(){	return sClipboard;}