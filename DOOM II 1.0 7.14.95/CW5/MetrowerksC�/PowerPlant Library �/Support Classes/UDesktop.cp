// ===========================================================================//	UDesktop.cp						©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	Standard window manipulation routines.////	Implementation://		For the most part, these wrapper funtions just call the standard//		Window Manager traps. There is little or no overhead when using//		this class as compared with using direct Window Manager calls.////	Usage Note://		When using the PowerPlant LWindow class, you must include some//		file in your project which implements the class defined in//		UDesktop.h. You can use UDesktop.cp or UFloatingDesktop.cp, but//		not both (or you will get a link error for multiple definitions//		of the same class). Or, you can write your own implementation.#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <UDesktop.h>#include <LWindow.h>#include <UEnvironment.h>#ifndef __LOWMEM__#include <LowMem.h>#endif// ---------------------------------------------------------------------------//		¥ NewDeskWindow// ---------------------------------------------------------------------------//	Return a newly created Toolbox Window for a Window object////	Creates a color window for machines that support colorWindowPtrUDesktop::NewDeskWindow(	LWindow		*inWindow,	Int16		inWINDid,	WindowPtr	inBehind){	WindowPtr	macWindowP;	if (UEnvironment::HasFeature(env_SupportsColor)) {		macWindowP = GetNewCWindow(inWINDid, nil, inBehind);	} else {		macWindowP = GetNewWindow(inWINDid, nil, inBehind);	}			return macWindowP;}	// ---------------------------------------------------------------------------//		¥ WindowIsSelected// ---------------------------------------------------------------------------//	Return whether a Window is selected, i.e., it is the front windowBooleanUDesktop::WindowIsSelected(	LWindow	*inWindow){	return (inWindow->GetMacPort() == FrontWindow());}// ---------------------------------------------------------------------------//		¥ SelectDeskWindow// ---------------------------------------------------------------------------//	Select a Window by bringing to the frontvoidUDesktop::SelectDeskWindow(	LWindow	*inWindow){	if (!WindowIsSelected(inWindow)) {		SelectWindow(inWindow->GetMacPort());	}}// ---------------------------------------------------------------------------//		¥ ShowDeskWindow// ---------------------------------------------------------------------------//	Make a Window visiblevoidUDesktop::ShowDeskWindow(	LWindow	*inWindow){	ShowWindow((WindowPtr) inWindow->GetMacPort());}// ---------------------------------------------------------------------------//		¥ HideDeskWindow// ---------------------------------------------------------------------------//	Make a Window invisiblevoidUDesktop::HideDeskWindow(	LWindow	*inWindow){	HideWindow((WindowPtr) inWindow->GetMacPort());}// ---------------------------------------------------------------------------//		¥ DragDeskWindow// ---------------------------------------------------------------------------//	Move the position of a WindowvoidUDesktop::DragDeskWindow(	LWindow				*inWindow,	const EventRecord	&inMacEvent,	const Rect			&inDragRect){	DragWindow((WindowPtr) inWindow->GetMacPort(), inMacEvent.where,				&inDragRect);}// ---------------------------------------------------------------------------//		¥ Suspend// ---------------------------------------------------------------------------//	Call this function when the application receives a suspend event.voidUDesktop::Suspend(){	Deactivate();						// Suspended Desktop is inactive}	// ---------------------------------------------------------------------------//		¥ Resume// ---------------------------------------------------------------------------//	Call this function when the application receives a resume event.voidUDesktop::Resume(){	Activate();							// Activate Desktop upon Resume}// ---------------------------------------------------------------------------//		¥ Deactivate// ---------------------------------------------------------------------------//	Deactivate the front window. Call this function before displaying a//	modal window.////	ModalDialog (and all Alert traps) take over event handling. The//	deactivate event for the front window will not get handled unless//	you install a filter proc that properly dispatches the event.//	However, dismissing the modal dialog generates an activate event//	that does get handled (because the modal dialog is no longer around//	to intercept events).voidUDesktop::Deactivate(){	LWindow	*theWindow = LWindow::FetchWindowObject(FrontWindow());	if (theWindow != nil) {		theWindow->Deactivate();	}	::InitCursor();					// Show arrow cursor}// ---------------------------------------------------------------------------//		¥ Activate// ---------------------------------------------------------------------------//	Activate the front window. Call this function after dismissing a//	modal window.////	Although the front window will normally receive an Activate event//	when necessary [see Deactivate above], we explicitly Activate it//	here. Activating a window that's already active does nothing, so//	it doesn't hurt to call this function whenever you want to Activate//	the Desktop.voidUDesktop::Activate(){	LWindow	*theWindow = LWindow::FetchWindowObject(FrontWindow());	if (theWindow != nil) {		theWindow->Activate();	}}// ---------------------------------------------------------------------------//		¥ FetchTopRegular// ---------------------------------------------------------------------------//	Returns the topmost visible Regular WindowLWindow*UDesktop::FetchTopRegular(){		// Start with FrontWindow (which always returns a visible		// window) and search thru window list until finding the		// first visible regular window.			WindowPtr	macWindowP = FrontWindow();	LWindow*	theWindow;	while ((theWindow = LWindow::FetchWindowObject(macWindowP)) != nil) {		if ( theWindow->HasAttribute(windAttr_Regular)  &&			 ((WindowPeek) macWindowP)->visible ) {			break;		}		macWindowP = (WindowPtr) ((WindowPeek) macWindowP)->nextWindow;	}	return theWindow;}// ---------------------------------------------------------------------------//		¥ FetchTopFloater// ---------------------------------------------------------------------------//	Returns the topmost visible Floating WindowLWindow*UDesktop::FetchTopFloater(){	return nil;						// No Floaters for UDesktop}// ---------------------------------------------------------------------------//		¥ FetchBottomFloater// ---------------------------------------------------------------------------//	Returns the bottommost floating Window (visible or not)LWindow*UDesktop::FetchBottomFloater(){	return nil;						// No floaters for UDesktop}// ---------------------------------------------------------------------------//		¥ FetchTopModal// ---------------------------------------------------------------------------//	Returns the topmost visible Modal WindowLWindow*UDesktop::FetchTopModal(){		// Modal Windows must be in front of all others. Therefore, we		// only have to check the FrontWindow. If it's Modal, then it's		// the top Modal. If it's not Modal, then there is no top Modal.			LWindow		*topModal = nil;	LWindow		*theWindow = LWindow::FetchWindowObject(FrontWindow());	if ( (theWindow != nil) && theWindow->HasAttribute(windAttr_Modal) ) {		topModal = theWindow;	}		return topModal; }// ---------------------------------------------------------------------------//		¥ FetchBottomModal// ---------------------------------------------------------------------------//	Returns the bottommost modal Window (visible or not)LWindow*UDesktop::FetchBottomModal(){		// Ugh. We have to use the Low Memory global WindowList to		// get the frontmost window (since FrontWindow() only returns		// the first *visible* window). There is no way to search from		// back to front, so we have to search the entire window list		// from front to back and remember the last modal that		// we find.			WindowPtr	macWindowP = (WindowPtr) LMGetWindowList();	LWindow*	bottomModal = nil;	LWindow*	theWindow;	while ((theWindow = LWindow::FetchWindowObject(macWindowP)) != nil) {		if (theWindow->HasAttribute(windAttr_Modal)) {			bottomModal = theWindow;		}		macWindowP = (WindowPtr) ((WindowPeek) macWindowP)->nextWindow;	}		return bottomModal;}// ---------------------------------------------------------------------------//		¥ FrontWindowIsModal// ---------------------------------------------------------------------------//	Return whether the front window is modalBooleanUDesktop::FrontWindowIsModal(){	Boolean		modalInFront = false;	WindowPtr	macWindowP = FrontWindow();		if (macWindowP != nil) {			// There is a front window		LWindow*	ppWindow = LWindow::FetchWindowObject(macWindowP);		if (ppWindow != nil) {			// Front window is a PowerPlant window										//   so check the Modal attribute			modalInFront = ppWindow->HasAttribute(windAttr_Modal);		} else {						// Front window is a Toolbox window										//   so check the window kind field			modalInFront = ((WindowPeek)macWindowP)->windowKind == dialogKind;		}	}		return modalInFront;}// ---------------------------------------------------------------------------//		¥ NormalizeWindowOrder// ---------------------------------------------------------------------------//	Put windows in the proper order////	This function does nothing since the standard Desktop class does not//	support multiple window layersvoidUDesktop::NormalizeWindowOrder(){}