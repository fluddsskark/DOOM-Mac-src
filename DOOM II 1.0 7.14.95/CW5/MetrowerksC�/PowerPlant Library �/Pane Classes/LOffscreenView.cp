// ===========================================================================//	LOffscreenView.cp				©1994 Metrowerks Inc. All rights reserved.// ===========================================================================////	A View whose image draws offscreen and then gets copied to the screen#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LOffscreenView.h>#include <LListIterator.h>#include <UGWorld.h>#include <PP_Messages.h>LOffscreenView*LOffscreenView::CreateOffscreenViewStream(	LStream	*inStream){	return (new LOffscreenView(inStream));}LOffscreenView::LOffscreenView(){	mDrawingSelf = false;}LOffscreenView::LOffscreenView(	const SPaneInfo	&inPaneInfo,	const SViewInfo	&inViewInfo)		: LView(inPaneInfo, inViewInfo){	mDrawingSelf = false;}LOffscreenView::LOffscreenView(	LStream	*inStream)		: LView(inStream){	mDrawingSelf = false;}LOffscreenView::~LOffscreenView(){}// ---------------------------------------------------------------------------//		¥ EstablishPort// ---------------------------------------------------------------------------//	Set current port to the OffscreenView////	If this View is being drawn, the current port has already been set to//	an Offscreen GWorld, so we do nothing. Otherwise, some subpane is//	trying to draw itself directly (not in response to an update event)//	so we call the inherited function to do the normal thing.voidLOffscreenView::EstablishPort(){	if (!mDrawingSelf) {		LView::EstablishPort();	}}// ---------------------------------------------------------------------------//		¥ Draw// ---------------------------------------------------------------------------//	Draw contents of View to an Offscreen World, then copy bits all at//	once to the normal portvoidLOffscreenView::Draw(	RgnHandle	inSuperDrawRgnH){									// Don't draw if invisible or unable									//   to put in focus	if (IsVisible() && FocusDraw()) {									// Area of this View to draw is the									//   intersection of inSuperDrawRgnH									//   with the Revealed area of this View		::RectRgn(mUpdateRgnH, &mRevealedRect);		if (inSuperDrawRgnH != nil) {			::SectRgn(inSuperDrawRgnH, mUpdateRgnH, mUpdateRgnH);		}		if (!::EmptyRgn(mUpdateRgnH)) {									// Some portion needs to be drawn									// Set up Offscreen World for drawing																		// Bounds of Offscreen World are the									//   bounds of the region of this View									//   that needs to be redrawn			Rect	offBounds = (**mUpdateRgnH).rgnBBox;			::OffsetRect(&offBounds, mPortOrigin.h, mPortOrigin.v);																		// Save portRect of the current Port			GrafPtr	currentPort;			::GetPort(&currentPort);			Rect	onscreenPortRect = currentPort->portRect;												// Allocate a stack-based Offscreen World									// Subsequent drawing will take place in									//   this Offscreen World			StOffscreenGWorld	offWorld(offBounds);												// To keep coord systems in synch, set									//   the portRect of the Offscreen World									//   to that of the original port			GWorldPtr	theGWorld = offWorld.GetMacGWorld();			theGWorld->portRect = onscreenPortRect;						mDrawingSelf = true;	// Prevents subpanes from changing Ports			OutOfFocus(nil);		// Offscreen World needs to be focused			FocusDraw();									// Draw this view and its subpanes									// into the Offscreen World. Offscreen									// image will be copied to original port									// when offWorld's destructor is called.			Rect	frame;			CalcLocalFrameRect(frame);			if (ExecuteAttachments(msg_DrawOrPrint, &frame)) {				FrameRect(&frame);				DrawSelf();			}			LListIterator iterator(mSubPanes, iterate_FromStart);			LPane	*theSub;			while (iterator.Next(&theSub)) {				theSub->Draw(mUpdateRgnH);			}						mDrawingSelf = false;		}		SetEmptyRgn(mUpdateRgnH);	// Emptying update region frees up memory									//   if this region wasn't rectangular	}}