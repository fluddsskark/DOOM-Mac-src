// ===========================================================================//	LControl.cp						©1993 Metrowerks Inc. All rights reserved.// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LControl.h>#include <LStream.h>#include <String_Utils.h>#include <PP_Messages.h>#ifndef __MEMORY__#include <Memory.h>#endif// === Constants ===const long	simulateClick_Duration	= 8;	// Keep hot spot hilited for											// this many ticks when simulating											// a click (HIG p205)// ---------------------------------------------------------------------------//		¥ LControl// ---------------------------------------------------------------------------//	Default ConstructorLControl::LControl(){	mValueMessage = cmd_Nothing;	mValue = mMaxValue = mMinValue = 0;}// ---------------------------------------------------------------------------//		¥ LControl(const LControl&)// ---------------------------------------------------------------------------//	Copy ConstructorLControl::LControl(	const LControl	&inOriginal)		: LPane(inOriginal){	mValueMessage = inOriginal.mValueMessage;	mValue = inOriginal.mValue;	mMinValue = inOriginal.mMinValue;	mMaxValue = inOriginal.mMaxValue;}// ---------------------------------------------------------------------------//		¥ LControl(SPaneInfo&, MessageT, Int32, Int32, Int32)// ---------------------------------------------------------------------------//	Construct from input parametersLControl::LControl(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	Int32			inValue,	Int32			inMinValue,	Int32			inMaxValue)		: LPane(inPaneInfo){	mValueMessage = inValueMessage;	mValue = inValue;	mMinValue = inMinValue;	mMaxValue = inMaxValue;}// ---------------------------------------------------------------------------//		¥ LControl(LStream*)// ---------------------------------------------------------------------------//	Construct from a data streamLControl::LControl(	LStream	*inStream)		: LPane(inStream){	SControlInfo	controlInfo;	inStream->ReadData(&controlInfo, sizeof(SControlInfo));	mValueMessage = controlInfo.valueMessage;	mValue = controlInfo.value;	mMinValue = controlInfo.minValue;	mMaxValue = controlInfo.maxValue;}// ---------------------------------------------------------------------------//		¥ ~LControl// ---------------------------------------------------------------------------//	DestructorLControl::~LControl(){}// ---------------------------------------------------------------------------//		¥ GetValueMessage// ---------------------------------------------------------------------------//	Return the message that gets sent when a Control's value changesMessageTLControl::GetValueMessage() const{	return mValueMessage;}// ---------------------------------------------------------------------------//		¥ SetValueMessage// ---------------------------------------------------------------------------//	Specify the message to send when a Control's value changesvoidLControl::SetValueMessage(	MessageT	inValueMessage){	mValueMessage = inValueMessage;}// ---------------------------------------------------------------------------//		¥ GetValue// ---------------------------------------------------------------------------//	Return the value of a ControlInt32LControl::GetValue() const{	return mValue;}// ---------------------------------------------------------------------------//		¥ SetValue// ---------------------------------------------------------------------------//	Specify the value for a Control////	You will usually override this function to redraw the control to//	reflect the new value setting. Normally, you'll call this function//	at the beginning of the overriding function. For example:////	void MyControl::SetValue(Int32 inValue)//	{//		LControl::SetValue(inValue);//			// ... Add code here to redraw control//	}voidLControl::SetValue(	Int32	inValue){	if (inValue < mMinValue) {		// Enforce min/max range		inValue = mMinValue;	} else if (inValue > mMaxValue) {		inValue = mMaxValue;	}	if (mValue != inValue) {		// If value is not the current value		mValue = inValue;			//   Store new value		BroadcastValueMessage();	//   Inform Listeners of value change	}}voidLControl::IncrementValue(	Int32	inIncrement){	SetValue(mValue + inIncrement);}Int32LControl::GetMinValue() const{	return mMinValue;}voidLControl::SetMinValue(	Int32	inMinValue){	mMinValue = inMinValue;	if (mValue < inMinValue) {			// Adjust value if less than new		SetValue(inMinValue);			//   minimum value	}}Int32LControl::GetMaxValue() const{	return mMaxValue;}voidLControl::SetMaxValue(	Int32	inMaxValue){	mMaxValue = inMaxValue;	if (mValue > inMaxValue) {			// Adjust value if greater than new		SetValue(inMaxValue);			//   maximum value	}}voidLControl::BroadcastValueMessage(){	if (mValueMessage != cmd_Nothing) {		Int32	value = mValue;		BroadcastMessage(mValueMessage, (void*) &value);	}}// ---------------------------------------------------------------------------//		¥ FindHotSpot// ---------------------------------------------------------------------------//	Determine which hot spot, if any, contains the specified point////		inPoint is in the local coordinates for the Control////		Valid hot spot numbers are > 0. Return 0 if no hot spot is hit.//		Controls can use any positive integers to number hot spots. Typical//		would be to number hot spots sequentially beginning with 1, and to//		store the hot spot locations in an array of rectangles.Int16LControl::FindHotSpot(	Point	inPoint){	return	1;			// The entire control is a single hot spot, number 1}// ---------------------------------------------------------------------------//		¥ PointInHotSpot// ---------------------------------------------------------------------------//	Determine if a point is within a specified hot spot////		inPoint is in the local coordinates for the Control//		inHotSpot is the hot spot number////		Return true if the point is within the hot spot////		This function is called to check if the mouse is still within a//		hot spot during mouse down trackingBooleanLControl::PointInHotSpot(	Point 	inPoint,	Int16	inHotSpot){	Point	portPt = inPoint;	LocalToPortPoint(portPt);	return PointIsInFrame(portPt.h, portPt.v);}// ---------------------------------------------------------------------------//		¥ TrackHotSpot// ---------------------------------------------------------------------------//	Track the mouse while it is down after clicking in a Control HotSpot////	Returns whether the mouse is released within the HotSpotBooleanLControl::TrackHotSpot(	Int16	inHotSpot,	Point 	inPoint){									// For the initial mouse down, the									// mouse is currently inside the HotSpot									// when it was previously outside	Boolean		currInside = true;	Boolean		prevInside = false;	HotSpotAction(inHotSpot, currInside, prevInside);										// Track the mouse while it is down	Point	currPt = inPoint;	while (StillDown()) {		GetMouse(&currPt);			// Must keep track if mouse moves from		prevInside = currInside;	// In-to-Out or Out-To-In		currInside = PointInHotSpot(currPt, inHotSpot);		HotSpotAction(inHotSpot, currInside, prevInside);	}		EventRecord	macEvent;			// Get location from MouseUp event	if (GetOSEvent(mUpMask, &macEvent)) {		currPt = macEvent.where;		GlobalToLocal(&currPt);	}									// Check if MouseUp occurred in HotSpot	return PointInHotSpot(currPt, inHotSpot);}// ---------------------------------------------------------------------------//		¥ HotSpotAction// ---------------------------------------------------------------------------//	Take action during mouse down tracking////	inCurrInside tells whether the mouse is currently inside the HotSpot//	inPrevInside tells whether the mouse was inside the HotSpot on the//		previous call to this function////	Override to change the Control's visual appearance depending on//	whether the mouse is inside or outside the HotSpot.////	Override to continuously perform some action while the mouse is down//	within a ControlvoidLControl::HotSpotAction(	Int16		inHotSpot,	Boolean		inCurrInside,	Boolean		inPrevInside){}// ---------------------------------------------------------------------------//		¥ HotSpotResult// ---------------------------------------------------------------------------//	Perform result of clicking and releasing mouse inside a HotSpot////	Subclasses should usually override this function to implement//	behavior associated with clicking in a Control HotSpot.voidLControl::HotSpotResult(	Int16	inHotSpot){}// ---------------------------------------------------------------------------//		¥ SimulateHotSpotClick// ---------------------------------------------------------------------------//	Simulate a mouse click within a HotSpot////	Provide the same visual feedback and result as if the user clicked//	inside a particular HotSpot of a Control. This function may be used//	to implement keystroke equivalents for Control clicks.voidLControl::SimulateHotSpotClick(	Int16	inHotSpot){	if (IsEnabled()) {		long	ticks;				HotSpotAction(inHotSpot, true, false);	// Do action for click inside		::Delay(simulateClick_Duration, &ticks);// Wait so user can see effect		HotSpotAction(inHotSpot, false, true);	// Undo visual effect		HotSpotResult(inHotSpot);				// Perform result of click	}}// ---------------------------------------------------------------------------//		¥ ClickSelf// ---------------------------------------------------------------------------//	Handle a mouse click inside a Control////	Controls have special areas, called HotSpots, that respond to mouse//	clicks. When a mouse is clicked with a HotSpot, the mouse is tracked//	and the Control can provide visual feedback. If the mouse is released//	while inside the same HotSpot in which the original click occurred, a//	result function is called.voidLControl::ClickSelf(	const SMouseDownEvent	&inMouseDown){									// Determine which HotSpot was clicked	Int16	theHotSpot = FindHotSpot(inMouseDown.whereLocal);		if (theHotSpot > 0) {		FocusDraw();									// Track mouse while it is down		if (TrackHotSpot(theHotSpot, inMouseDown.whereLocal)) {									// Mouse released inside HotSpot			HotSpotResult(theHotSpot);		}	}}