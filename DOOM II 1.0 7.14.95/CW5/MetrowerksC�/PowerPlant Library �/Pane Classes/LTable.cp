// ===========================================================================//	LTable.cp					   © 1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	A two-dimensional array of rectangular cells.#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LTable.h>#include <LDynamicArray.h>#include <LStream.h>#include <UDrawingState.h>#ifndef __LOWMEM__#include <LowMem.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif// ---------------------------------------------------------------------------//		¥ CreateTableStream [static]// ---------------------------------------------------------------------------//	Return a new Table object initialized using data from a StreamLTable*LTable::CreateTableStream(	LStream	*inStream){	return (new LTable(inStream));}// ---------------------------------------------------------------------------//		¥ LTable// ---------------------------------------------------------------------------//	Default ConstructorLTable::LTable(){	InitTable(0, 0, 16, 100, 0);}// ---------------------------------------------------------------------------//		¥ LTable// ---------------------------------------------------------------------------//	Construct from input parametersLTable::LTable(	const SPaneInfo	&inPaneInfo,	const SViewInfo	&inViewInfo,	Int32			inNumberOfRows,	Int32			inNumberOfCols,	Int32			inRowHeight,	Int32			inColWidth,	Int32			inCellDataSize)		: LView(inPaneInfo, inViewInfo){	InitTable(inNumberOfRows, inNumberOfCols, inRowHeight, inColWidth,				inCellDataSize);}// ---------------------------------------------------------------------------//		¥ LTable(LStream*)// ---------------------------------------------------------------------------//	Construct from the data in a StreamLTable::LTable(	LStream	*inStream)		: LView(inStream){	STableInfo	tableInfo;	inStream->ReadData(&tableInfo, sizeof(STableInfo));		InitTable(tableInfo.numberOfRows, tableInfo.numberOfCols,			tableInfo.rowHeight, tableInfo.colWidth, tableInfo.cellDataSize);}LTable::~LTable(){	delete mCellData;}voidLTable::InitTable(	Int32			inNumberOfRows,	Int32			inNumberOfCols,	Int32			inRowHeight,	Int32			inColWidth,	Int32			inCellDataSize){	mRowHeight = inRowHeight;	mColWidth = inColWidth;	mCellData = nil;	mSelectedCell.row = mSelectedCell.col = 0;		mRows = mCols = 0;	InsertRows(inNumberOfRows, 0, nil);	InsertCols(inNumberOfCols, 0, nil);		SetCellDataSize(inCellDataSize);}voidLTable::GetTableSize(	TableIndexT	&outRows,	TableIndexT	&outCols){	outRows = mRows;	outCols = mCols;}BooleanLTable::IsValidCell(	const TableCellT	&inCell){	return ( (inCell.row > 0) && (inCell.row <= mRows) &&			 (inCell.col > 0) && (inCell.col <= mCols) );}BooleanLTable::EqualCell(	const TableCellT	&inCellA,	const TableCellT	&inCellB){	return ( (inCellA.row == inCellB.row) &&			 (inCellA.col == inCellB.col) );}voidLTable::InsertRows(	Int32		inHowMany,	TableIndexT	inAfterRow,	void		*inCellData){		// +++ Bounds check input params		if (mCellData != nil) {		mCellData->InsertItemsAt(inHowMany * mCols, inAfterRow * mCols + 1,									inCellData);	}									mRows += inHowMany;		ResizeImageBy(0, inHowMany * mRowHeight, true);}voidLTable::InsertCols(	Int32		inHowMany,	TableIndexT	inAfterCol,	void		*inCellData){		// +++ Bounds check input params		if (mCellData != nil) {		Int32	insertAtIndex = inAfterCol + 1;		for (TableIndexT row = 1; row <= mRows; row++) {			mCellData->InsertItemsAt(inHowMany, insertAtIndex, inCellData);			insertAtIndex += mCols;		}	}		mCols += inHowMany;		ResizeImageBy(inHowMany * mColWidth, 0, true);}voidLTable::RemoveRows(	Int32		inHowMany,	TableIndexT	inFromRow){		// +++ Bounds check input params		if (mCellData != nil) {		mCellData->RemoveItemsAt(inHowMany * mCols,									(inFromRow - 1) * mCols + 1);	}	mRows -= inHowMany;		ResizeImageBy(0, -inHowMany * mRowHeight, true);}voidLTable::RemoveCols(	Int32		inHowMany,	TableIndexT	inFromCol){		// +++ Bounds check input params		if (mCellData != nil) {		Int32	removeAtIndex = inFromCol;		for (TableIndexT row = 1; row <= mRows; row++) {			mCellData->RemoveItemsAt(inHowMany, removeAtIndex);			removeAtIndex += mCols;		}	}		mCols -= inHowMany;		ResizeImageBy(-inHowMany * mColWidth, 0, true);}voidLTable::SetRowHeight(	Int16		inHeight,	Int32		inHowMany,	TableIndexT	inFromRow){	mRowHeight = inHeight;}voidLTable::SetColWidth(	Int16		inWidth,	Int32		inHowMany,	TableIndexT	inFromCol){	mColWidth = inWidth;}voidLTable::SetCellDataSize(	Int32	inCellDataSize){			// Create DynamicArray for holding data			// mCellData must not already be allocated	if ((mCellData == nil) && (inCellDataSize > 0)) {		mCellData = new LDynamicArray(inCellDataSize);		mCellData->InsertItemsAt(mRows * mCols, 1, nil);	}}voidLTable::SetCellData(	const TableCellT	&inCell,	void				*inData){	if (mCellData != nil) {		mCellData->SetItemAt(FetchCellDataIndex(inCell), inData);	}}voidLTable::GetCellData(	const TableCellT	&inCell,	void				*outData){	if (mCellData != nil) {		mCellData->FetchItemAt(FetchCellDataIndex(inCell), outData);	}}BooleanLTable::FetchLocalCellFrame(	const TableCellT	&inCell,	Rect				&outCellFrame){								// Get Top-Left in Image coordinates	SPoint32	cellImage;	cellImage.h = (inCell.col - 1) * mColWidth;	cellImage.v = (inCell.row - 1) * mRowHeight;									// Check if Cell intersects the Frame	Boolean	intersectsFrame = ImageRectIntersectsFrame(									cellImage.h, cellImage.v,									cellImage.h + mColWidth,									cellImage.v + mRowHeight);		if (intersectsFrame) {		// Convert to Local coordinates		ImageToLocalPoint(cellImage, topLeft(outCellFrame));		outCellFrame.right = outCellFrame.left + mColWidth;		outCellFrame.bottom = outCellFrame.top + mRowHeight;	}		return intersectsFrame;}voidLTable::FetchCellHitBy(	const SPoint32	&inImagePt,	TableCellT		&outCell){	outCell.row = (inImagePt.v - 1) / mRowHeight + 1;	outCell.col = (inImagePt.h - 1) / mColWidth + 1;}Int32LTable::FetchCellDataIndex(	const TableCellT	&inCell){	return ((inCell.row - 1) * mCols + inCell.col);}voidLTable::ClickSelf(	const SMouseDownEvent &inMouseDown){	TableCellT	hitCell;	SPoint32	imagePt;		LocalToImagePoint(inMouseDown.whereLocal, imagePt);	FetchCellHitBy(imagePt, hitCell);		if (IsValidCell(hitCell)) {		ClickCell(hitCell, inMouseDown);	}}voidLTable::DrawSelf(){		// Determine cells that need updating. Rather than checking		// on a cell by cell basis, we just see which cells intersect		// the bounding box of the update region. This is relatively		// fast, but may result in unnecessary cell updates for		// non-rectangular update regions.									RgnHandle	localUpdateRgnH = GetLocalUpdateRgn();	Rect		updateRect = (**localUpdateRgnH).rgnBBox;	DisposeRgn(localUpdateRgnH);									// Find cell at top left of update rect	SPoint32	topLeftUpdate;	TableCellT	topLeftCell;	LocalToImagePoint(topLeft(updateRect), topLeftUpdate);	FetchCellHitBy(topLeftUpdate, topLeftCell);	if (topLeftCell.row < 1) {	// Lower bound is cell (1,1)		topLeftCell.row = 1;	}	if (topLeftCell.col < 1) {		topLeftCell.col = 1;	}								// Find cell at bottom right of update rect	SPoint32	botRightUpdate;	TableCellT	botRightCell;	LocalToImagePoint(botRight(updateRect), botRightUpdate);	FetchCellHitBy(botRightUpdate, botRightCell);								// Upper bound is cell (mRows,mCols)	if (botRightCell.row > mRows) {		botRightCell.row = mRows;	}	if (botRightCell.col > mCols) {		botRightCell.col = mCols;	}									// Draw each cell within the update rect	TableCellT	cell;	for (cell.row = topLeftCell.row; cell.row <= botRightCell.row; cell.row++) {		for (cell.col = topLeftCell.col; cell.col <= botRightCell.col; cell.col++) {			DrawCell(cell);		}	}		HiliteCell(mSelectedCell);}voidLTable::HiliteCell(	const TableCellT		&inCell){	Rect	cellFrame;	if (IsValidCell(mSelectedCell) &&		FetchLocalCellFrame(mSelectedCell, cellFrame)) {		LMSetHiliteMode(LMGetHiliteMode() & !(1 << hiliteBit));		if (IsActive()) {			InvertRect(&cellFrame);		} else {			StColorPenState::Normalize();			::PenMode(srcXor);			::FrameRect(&cellFrame);		}	}}voidLTable::UnhiliteCell(	const TableCellT		&inCell){	Rect	cellFrame;	if (IsValidCell(mSelectedCell) &&		FetchLocalCellFrame(mSelectedCell, cellFrame)) {		LMSetHiliteMode(LMGetHiliteMode() & !(1 << hiliteBit));		InvertRect(&cellFrame);	}}voidLTable::ClickCell(	const TableCellT		&inCell,	const SMouseDownEvent	&inMouseDown){	SelectCell(inCell);	if (GetClickCount() > 1) SysBeep(1);	// ### Debugging}voidLTable::DrawCell(	const TableCellT	&inCell){								// ### Debugging								// Draw cell row & column number inside								// frame of cell	Rect	cellFrame;	if (FetchLocalCellFrame(inCell, cellFrame)) {		TextFont(applFont);		TextSize(0);		MoveTo(cellFrame.left + 4, cellFrame.bottom - 4);		Str31	str;		NumToString(inCell.row, str);		DrawString(str);		DrawString("\p, ");		NumToString(inCell.col, str);		DrawString(str);	}}voidLTable::ActivateSelf(){	FocusDraw();	Rect	cellFrame;	if (IsValidCell(mSelectedCell) &&		FetchLocalCellFrame(mSelectedCell, cellFrame)) {		LMSetHiliteMode(LMGetHiliteMode() & !(1 << hiliteBit));		StColorPenState::Normalize();	// Undo inactive hiliting		::PenMode(srcXor);		::FrameRect(&cellFrame);											// Do active hiliting		LMSetHiliteMode(LMGetHiliteMode() & !(1 << hiliteBit));		::InvertRect(&cellFrame);	}}voidLTable::DeactivateSelf(){	FocusDraw();	UnhiliteCell(mSelectedCell);	HiliteCell(mSelectedCell);}voidLTable::SelectCell(	const TableCellT	&inCell){	if (!EqualCell(inCell, mSelectedCell)) {		FocusDraw();		UnhiliteCell(mSelectedCell);			mSelectedCell = inCell;		HiliteCell(inCell);	}}voidLTable::GetSelectedCell(	TableCellT	&outCell){	outCell = mSelectedCell;}