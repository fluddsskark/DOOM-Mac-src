// ===========================================================================//	LListBox.cp						©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	A wrapper class for the Toolbox List Manager#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LListBox.h>#include <LStream.h>#include <LFocusBox.h>#include <LView.h>#include <PP_KeyCodes.h>#include <PP_Messages.h>#include <UTextTraits.h>#include <UKeyFilters.h>#include <UDrawingState.h>// ---------------------------------------------------------------------------//		¥ CreateListBoxStream// ---------------------------------------------------------------------------//	Create a new ListBox object, initializing it with data from a StreamLListBox*LListBox::CreateListBoxStream(	LStream	*inStream){	return (new LListBox(inStream));}// ---------------------------------------------------------------------------//		¥ LListBox// ---------------------------------------------------------------------------//	Default ConstructorLListBox::LListBox(){	InitListBox(false, false, false, false, 0, 0, 0);}// ---------------------------------------------------------------------------//		¥ LListBox(const LListBox&)// ---------------------------------------------------------------------------//	Copy Constructor////	The current port must be the window into which to install the copy.////	This function creates a new Toolbox ListHandle for the copy. It copies//	most settings of the original ListHandle, including all cell data,//	selection flags, and scrolling flags. However, it does not copy the//	refCon, lClikLoop, and userHandle.////	Only the first 255 bytes of each cell's data is copied.LListBox::LListBox(	const LListBox	&inOriginal)		: LPane(inOriginal),		  LCommander(inOriginal),		  LBroadcaster(inOriginal){	mDoubleClickMessage = inOriginal.mDoubleClickMessage;	mTextTraitsID = inOriginal.mTextTraitsID;		mFocusBox = nil;	if (inOriginal.mFocusBox != nil) {		mFocusBox = new LFocusBox(*(inOriginal.mFocusBox));	}			ListHandle	origListH = inOriginal.mMacListH;	ListPtr		origListP = *origListH;										// Get info about list size, cell size,									// and scrolling from original ListHandle	Rect	displayRect = origListP->rView;	Rect	dataBounds = origListP->dataBounds;	Point	cellSize = origListP->cellSize;	Boolean	hasGrow = inOriginal.mHasGrow;	Boolean	hasHorizScroll = (origListP->hScroll != nil);	Boolean	hasVertScroll = (origListP->vScroll != nil);										// Create new Toolbox ListHandle using									//   same specifications as original	FocusDraw();	mMacListH = ::LNew(&displayRect, &dataBounds, cellSize, 0,						UQDGlobals::GetCurrentPort(), false, hasGrow,						hasHorizScroll, hasVertScroll);							::LActivate(false, mMacListH);										// Copy data for each cell	if ((dataBounds.right > 0) && (dataBounds.bottom > 0)) {		Cell	theCell = {0, 0};		do {			char		cellData[255];			Int16		dataLen = 255;			::LGetCell(cellData, &dataLen, theCell, origListH);			::LSetCell(cellData, dataLen, theCell, mMacListH);		} while (LNextCell(true, true, &theCell, origListH));	}										// Copy selection and scrolling flags	(**mMacListH).selFlags = (**origListH).selFlags;	(**mMacListH).listFlags = (**origListH).listFlags;		::LSetDrawingMode(true, mMacListH);}// ---------------------------------------------------------------------------//		¥ LListBox// ---------------------------------------------------------------------------//	Construct from input parameters////	Usage Note: The current port *must* be the Window which contains//		the ListBox (required by the Mac Control Manager)LListBox::LListBox(	const SPaneInfo	&inPaneInfo,	Boolean			inHasHorizScroll,	Boolean			inHasVertScroll,	Boolean			inHasGrow,	Boolean			inHasFocusBox,	MessageT		inDoubleClickMessage,	Int16			inTextTraitsID,	Int16			inLDEFid,	LCommander		*inSuper)		: LPane(inPaneInfo),		  LCommander(inSuper){	InitListBox(inHasHorizScroll, inHasVertScroll, inHasGrow,				inHasFocusBox, inDoubleClickMessage, inTextTraitsID,				inLDEFid);		::LSetDrawingMode(true, mMacListH);}// ---------------------------------------------------------------------------//		¥ LListBox(LStream*)// ---------------------------------------------------------------------------//	Initialize a ListBox from the data in a Stream////	Usage Note: The current port *must* be the Window which contains//		the ListBox (required by the Mac Control Manager)LListBox::LListBox(	LStream	*inStream)		: LPane(inStream){	SListBoxInfo	listInfo;	inStream->ReadData(&listInfo, sizeof(SListBoxInfo));		InitListBox(listInfo.hasHorizScroll, listInfo.hasVertScroll,				listInfo.hasGrow, listInfo.hasFocusBox,				listInfo.doubleClickMessage, listInfo.textTraitsID,				listInfo.LDEFid);		if (listInfo.numberOfItems > 0) {		::LAddColumn(1, 0, mMacListH);		::LAddRow(listInfo.numberOfItems, 0, mMacListH);				Cell	theCell = {0, 0};			for (theCell.v = 0; theCell.v < listInfo.numberOfItems; theCell.v++) {			Str255	listItem;			inStream->ReadPString(listItem);			::LSetCell(listItem+1, listItem[0], theCell, mMacListH);		}	}		::LSetDrawingMode(true, mMacListH);}// ---------------------------------------------------------------------------//		¥ ~LListBox// ---------------------------------------------------------------------------//	DestructorLListBox::~LListBox(){	if (mMacListH != nil) {			// Dispose Toolbox ListHandle		FocusDraw();		::LDispose(mMacListH);	}}// ---------------------------------------------------------------------------//		¥ InitListBox// ---------------------------------------------------------------------------//	Private initializervoidLListBox::InitListBox(	Boolean			inHasHorizScroll,	Boolean			inHasVertScroll,	Boolean			inHasGrow,	Boolean			inHasFocusBox,	MessageT		inDoubleClickMessage,	Int16			inTextTraitsID,	Int16			inLDEFid){	mHasGrow = inHasGrow;	mFocusBox = nil;				// Create FocusBox if necessary	if (inHasFocusBox) {		mFocusBox = new LFocusBox;		mFocusBox->Hide();		mFocusBox->AttachPane(this);	}	FocusDraw();	Rect	displayRect;			// Determine size of Toolbox List									//   ListBox has a one-pixel border	CalcLocalFrameRect(displayRect);	::InsetRect(&displayRect, 1, 1);		if (inHasHorizScroll) {			// Adjust size for scroll bars		displayRect.bottom -= 15;	}	if (inHasVertScroll) {		displayRect.right -= 15;	}	mDoubleClickMessage = inDoubleClickMessage;		mTextTraitsID = inTextTraitsID;	// Establish text characteristics	UTextTraits::SetPortTextTraits(inTextTraitsID);										// Create Toolbox ListHandle with:									//   no cells									//   default cell size									//   drawing mode off	Rect	dataBounds = {0, 0, 0, 0};	Point	cellSize = {0, 0};	mMacListH = ::LNew(&displayRect, &dataBounds, cellSize, inLDEFid,						UQDGlobals::GetCurrentPort(), false,						inHasGrow, inHasHorizScroll, inHasVertScroll);							::LActivate(false, mMacListH);				// Toolbox ListManager seems to have a bug. When there is only		// one scroll bar (vertical or horizontal), the scroll bar is		// not indented if inHasGrow is true. As a workaround, we		// manually set the scroll bar size in such cases.		if (inHasGrow) {		if (inHasVertScroll && !inHasHorizScroll) {			// Vert only			(**((**mMacListH).vScroll)).contrlRect.bottom =					displayRect.bottom - 14;					} else if (inHasHorizScroll && !inHasVertScroll) {	// Horiz only			(**((**mMacListH).hScroll)).contrlRect.right =					displayRect.right - 14;		}	}}// ---------------------------------------------------------------------------//		¥ GetMacListH// ---------------------------------------------------------------------------//	Return the Toolbox ListHandle associated with a ListBox object////	You may manipulate the ListHandle using the Toolbox ListManager traps,//	as well as inspect and change certain fields. As documented in Inside//	Mac, you must directly store into certain fields in a ListRecord in//	order to change settings for a List. For example, the selFlags field//	controls how the ListManger handles selections in a List.////	There are some traps you should not call, since there is a LListBox//	function that performs the same task (in a way that's compatible//	with PowerPlant Panes).////		ListManager Trap		LListBox function//		----------------		-----------------//		LDispose				~LListBox//		LSize					ResizeFrameBy//		LDraw					DrawListHandleLListBox::GetMacListH() const{	return mMacListH;}// ---------------------------------------------------------------------------//		¥ GetFocusBox// ---------------------------------------------------------------------------//	Return the FocusBox associated with a ListBoxLFocusBox*LListBox::GetFocusBox(){	return mFocusBox;}// ---------------------------------------------------------------------------//		¥ GetValue// ---------------------------------------------------------------------------//	Return the value of a ListBox.////	The "value" of a ListBox is the row number of the first selected cell,//	with the first row being number 0 (the ListManager uses zero-based//	numbering). If no cells are selected, the value is -1.////	This "value" makes sense for a ListBox with one column, by far the//	most common case.Int32LListBox::GetValue() const{	Int32	value = -1;	Cell	firstSelection = {0, 0};	if (::LGetSelect(true, &firstSelection, mMacListH)) {		value = firstSelection.v;	// Row number of selection	}			return value;}// ---------------------------------------------------------------------------//		¥ SetValue// ---------------------------------------------------------------------------//	Set the value of a ListBox.////	The "value" of a ListBox is the row number of the first selected cell,//	with the first row being number 0 (the ListManager uses zero-based//	numbering). If no cells are selected, the value is -1.////	This "value" makes sense for a ListBox with one column, by far the//	most common case.////	This function selects the cell in row "inValue" and column 1, deselecting//	any previously selected cells.voidLListBox::SetValue(	Int32	inValue){	FocusDraw();									// Deselect all cells. However, don't									//   deselect the target cell if it									//   is already selected.	Cell	theCell = {0, 0};	while (::LGetSelect(true, &theCell, mMacListH)) {		if (theCell.v != inValue) {			::LSetSelect(false, theCell, mMacListH);		} else {			::LNextCell(true, true, &theCell, mMacListH);		}	}		theCell.h = 0;					// First column	theCell.v = inValue;			// Row specified by inValue	::LSetSelect(true, theCell, mMacListH);}// ---------------------------------------------------------------------------//		¥ GetDescriptor// ---------------------------------------------------------------------------//	Return the descriptor of a ListBox, which is the text of the first//	selected cell. The descriptor is an empty string if there are no//	selected cells.////	This function assumes that the cell data is text.StringPtrLListBox::GetDescriptor(	Str255	outDescriptor) const{	outDescriptor[0] = 0;	Cell	firstSelection = {0, 0};	if (::LGetSelect(true, &firstSelection, mMacListH)) {		Int16	dataLen = 255;		::LGetCell(outDescriptor + 1, &dataLen, firstSelection, mMacListH);		outDescriptor[0] = dataLen;	}	return outDescriptor;}// ---------------------------------------------------------------------------//		¥ SetDescriptor// ---------------------------------------------------------------------------//	Set the descriptor of a ListBox, which is the text of the first//	selected cell. Nothing happens if there are no selected cells.////	This function assumes that the cell data is text.voidLListBox::SetDescriptor(	ConstStr255Param	inDescriptor){	Cell	firstSelection = {0, 0};	if (::LGetSelect(true, &firstSelection, mMacListH) && FocusDraw()) {		::LSetCell(inDescriptor+1, inDescriptor[0], firstSelection, mMacListH);	}}// ---------------------------------------------------------------------------//		¥ GetDoubleClickMessage// ---------------------------------------------------------------------------//	Return the message broadcasted when a cell is double-clickedMessageTLListBox::GetDoubleClickMessage() const{	return mDoubleClickMessage;}// ---------------------------------------------------------------------------//		¥ SetDoubleClickMessage// ---------------------------------------------------------------------------//	Specify the message broadcasted when a cell is double-clickedvoidLListBox::SetDoubleClickMessage(	MessageT	inMessage){	mDoubleClickMessage = inMessage;}// ---------------------------------------------------------------------------//		¥ FocusDraw// ---------------------------------------------------------------------------//	Focus drawing. Overrides to use the default Pen state and to//	set the TextTraits used by the ListBoxBooleanLListBox::FocusDraw(){	Boolean	focused = LPane::FocusDraw();	if (focused) {		StColorPenState::Normalize();		UTextTraits::SetPortTextTraits(mTextTraitsID);	}		return focused;}// ---------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------//	Draw ListBoxvoidLListBox::DrawSelf(){		// A Mac ListRec stores a pointer to its owner port  We have to		// change it to the current port in case we are drawing into		// a port that is not the owner port. This happens when we are		// printing or drawing into an offscreen port.			GrafPtr	savePort = (**mMacListH).port;	(**mMacListH).port = UQDGlobals::GetCurrentPort();		RgnHandle	updateRgn = GetLocalUpdateRgn();	::LUpdate(updateRgn, mMacListH);	::DisposeRgn(updateRgn);		(**mMacListH).port = savePort;		Rect	frame;	CalcLocalFrameRect(frame);	StColorPenState::Normalize();	::FrameRect(&frame);}// ---------------------------------------------------------------------------//		¥ ClickSelf// ---------------------------------------------------------------------------//	Respond to Click inside an ListBoxvoidLListBox::ClickSelf(	const SMouseDownEvent	&inMouseDown){	if (SwitchTarget(this)) {		FocusDraw();				if (::LClick(inMouseDown.whereLocal, inMouseDown.macEvent.modifiers,					mMacListH)) {								BroadcastMessage(mDoubleClickMessage, this);		}	}}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Respond to Command messageBooleanLListBox::ObeyCommand(	CommandT	inCommand,	void*		ioParam){	Boolean		cmdHandled = true;		switch (inCommand) {			case msg_TabSelect:			if (!IsEnabled()) {				cmdHandled = false;			}			break;					default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	ListBox supports keyboard navigation and type selectionBooleanLListBox::HandleKeyPress(	const EventRecord	&inKeyEvent){	Boolean	keyHandled = true;	Char16	theKey = inKeyEvent.message & charCodeMask;		FocusDraw();	if (UKeyFilters::IsNavigationKey(theKey)) {		DoNavigationKey(inKeyEvent);		} else if (UKeyFilters::IsPrintingChar(theKey)) {		DoTypeSelection(inKeyEvent);										} else {		keyHandled = LCommander::HandleKeyPress(inKeyEvent);	}				return keyHandled;}// ---------------------------------------------------------------------------//		¥ DoNavigationKey// ---------------------------------------------------------------------------//	Implements keyboard navigation by supporting selection change using//	the arrow keys, page up, page down, home, and endvoidLListBox::DoNavigationKey(	const EventRecord	&inKeyEvent){	char	theKey = inKeyEvent.message & charCodeMask;	Boolean	cmdKeyDown = (inKeyEvent.modifiers & cmdKey) != 0;	Boolean	shiftKeyDown = (inKeyEvent.modifiers & shiftKey) != 0;	Cell	theSelection = {0, 0};	switch (theKey) {		case char_LeftArrow:			if (::LGetSelect(true, &theSelection, mMacListH)) {				if (cmdKeyDown && shiftKeyDown) {									// Select all cells left of the first									//   selected cell					while (--theSelection.h >= 0) {						::LSetSelect(true, theSelection, mMacListH);					}								} else if (cmdKeyDown) {									// Select leftmost cell in the same row as									//   the first selected cell					theSelection.h = 0;					SelectOneCell(theSelection);								} else if (shiftKeyDown) {									// Extend selection by selecting the									//   cell left of the first selected cell					if (theSelection.h > 0) {						theSelection.h -= 1;						::LSetSelect(true, theSelection, mMacListH);					}								} else {			// Select cell to the left of the first									//   selected cell					if(theSelection.h > 0) {						theSelection.h -= 1;					}					SelectOneCell(theSelection);				}				MakeCellVisible(theSelection);			}			break;		case char_RightArrow:			if (GetLastSelectedCell(theSelection)) {				Int16	numColumns = (**mMacListH).dataBounds.right - 1;								if (cmdKeyDown && shiftKeyDown) {									// Select all cells right of the last									//   selected cell					while (++theSelection.h <= numColumns) {						::LSetSelect(true, theSelection, mMacListH);					}														} else if (cmdKeyDown) {									// Select rightmost cell in the same row as									//   the last selected cell					theSelection.h = numColumns;					SelectOneCell(theSelection);														} else if (shiftKeyDown) {									// Extend selection by selecting the cell									//   to the right of the last selected cell					if(theSelection.h < numColumns) {						theSelection.h += 1;						::LSetSelect(true, theSelection, mMacListH);					}					} else {			// Select cell to the right of the last									//   selected cell									if(theSelection.h < numColumns) {						theSelection.h += 1;					}					SelectOneCell(theSelection);				}				MakeCellVisible(theSelection);			}			break;		case char_UpArrow:			if (::LGetSelect(true, &theSelection, mMacListH)) {				if (cmdKeyDown && shiftKeyDown) {									// Select all cells above the first									//   selected cell					while (--theSelection.v >= 0) {						::LSetSelect(true, theSelection, mMacListH);					}								} else if (cmdKeyDown) {									// Select cell at top of column of the									//   first selected cell					theSelection.v = 0;					SelectOneCell(theSelection);								} else if (shiftKeyDown) {									// Extend selection by selecting the									//   cell above the first selected cell					if (theSelection.v > 0) {						theSelection.v -= 1;						::LSetSelect(true, theSelection, mMacListH);					}								} else {			// Select cell one above the first									//   selected cell					if(theSelection.v > 0) {						theSelection.v -= 1;					}					SelectOneCell(theSelection);				}				MakeCellVisible(theSelection);			}			break;		case char_DownArrow:			if (GetLastSelectedCell(theSelection)) {				Int16	numRows = (**mMacListH).dataBounds.bottom - 1;								if (cmdKeyDown && shiftKeyDown) {									// Select all cells below the last									//   selected cell					while (++theSelection.v <= numRows) {						::LSetSelect(true, theSelection, mMacListH);					}														} else if (cmdKeyDown) {									// Select cell at bottom of column of									//   the last selected cell					theSelection.v = numRows;					SelectOneCell(theSelection);														} else if (shiftKeyDown) {									// Extend selection by selecting the									//   cell below the last selected cell					if(theSelection.v < numRows) {						theSelection.v += 1;						::LSetSelect(true, theSelection, mMacListH);					}					} else {			// Select cell one below the last									//   selected cell									if(theSelection.v < numRows) {						theSelection.v += 1;					}					SelectOneCell(theSelection);				}				MakeCellVisible(theSelection);			}			break;					case char_Home:			::LScroll(-16000, -16000, mMacListH);			break;		case char_End:			::LScroll(16000, 16000, mMacListH);			break;					case char_PageUp:		case char_PageDown: {			Int16	dRows = (**mMacListH).visible.bottom -							(**mMacListH).visible.top - 1;			if (theKey == char_PageUp) {				dRows = -dRows;			}			::LScroll(0, dRows, mMacListH);			break;		}	}}	// ---------------------------------------------------------------------------//		¥ DoTypeSelection// ---------------------------------------------------------------------------//	Change selection to the item beginning with the input charactersvoidLListBox::DoTypeSelection(	const EventRecord	&inKeyEvent){}	// +++ Not yet implemented// ---------------------------------------------------------------------------//		¥ SelectOneCell// ---------------------------------------------------------------------------//	Select the specified Cell and deselect all othersvoidLListBox::SelectOneCell(	Cell	inCell){	FocusDraw();	Cell	currentCell = {0, 0};		while (::LGetSelect(true, &currentCell, mMacListH)) {		if (*(Int32*)&currentCell == *(Int32*)&inCell) {									// Cell to select is already selected			::LNextCell(true, true, &currentCell, mMacListH);					} else {					// Deselect this cell			::LSetSelect(false, currentCell, mMacListH);		}	}		::LSetSelect(true, inCell, mMacListH);}// ---------------------------------------------------------------------------//		¥ GetLastSelectedCell// ---------------------------------------------------------------------------//	Pass back the last selected Cell in a ListBox. Returns false if no//	cells are selectedBooleanLListBox::GetLastSelectedCell(	Cell	&outCell){	Cell	currentCell = {0, 0};	Boolean	hasSelection = ::LGetSelect(true, &currentCell, mMacListH);		if (hasSelection) {		do {			outCell = currentCell;		} while (::LNextCell(true, true, &currentCell, mMacListH) &&				 ::LGetSelect(true, &currentCell, mMacListH));	}		return hasSelection;}// ---------------------------------------------------------------------------//		¥ MakeCellVisible// ---------------------------------------------------------------------------//	Scroll the ListBox as little as possible to move the specified Cell//	into viewvoidLListBox::MakeCellVisible(	Cell	inCell){	Rect	visibleCells = (**mMacListH).visible;		if (!::PtInRect(inCell, &visibleCells)) {		Int16	dCols = 0;			// ¥ Horizontal								if (inCell.h > visibleCells.right - 1) {									// Scroll left			dCols = inCell.h - visibleCells.right + 1;					} else if (inCell.h < visibleCells.left) {									// Scroll right			dCols = inCell.h - visibleCells.left;		}				Int16	dRows = 0;			// ¥ Vertical		if (inCell.v > visibleCells.bottom - 1) {									// Scroll up			dRows = inCell.v - visibleCells.bottom + 1;					} else if (inCell.v < visibleCells.top) {									// Scroll down			dRows = inCell.v - visibleCells.top;		}				::LScroll(dCols, dRows, mMacListH);	}}// ---------------------------------------------------------------------------//		¥ BeTarget// ---------------------------------------------------------------------------//	ListBox is becoming the TargetvoidLListBox::BeTarget(){	if (mFocusBox != nil) {		mFocusBox->Show();	}}// ---------------------------------------------------------------------------//		¥ DontBeTarget// ---------------------------------------------------------------------------//	ListBox is no longer the TargetvoidLListBox::DontBeTarget(){	if (mFocusBox != nil) {		mFocusBox->Hide();	}}// ---------------------------------------------------------------------------//		¥ ActivateSelf// ---------------------------------------------------------------------------//	Activate ListBox. The Toolbox shows the selection and scroll bars.voidLListBox::ActivateSelf(){	if (FocusDraw()) {		::LActivate(true, mMacListH);	}}// ---------------------------------------------------------------------------//		¥ DeactivateSelf// ---------------------------------------------------------------------------//	Deactivate ListBox. The Toolbox hides the selection and scroll bars.voidLListBox::DeactivateSelf(){	if (FocusDraw()) {		::LActivate(false, mMacListH);	}}// ---------------------------------------------------------------------------//		¥ ResizeFrameBy// ---------------------------------------------------------------------------//	Change the Frame size by the specified amounts////	Both PowerPlant and the List Manager store a size for the ListBox,//	so we must make sure that both sizes are in synch.voidLListBox::ResizeFrameBy(	Int16		inWidthDelta,	Int16		inHeightDelta,	Boolean		inRefresh){	FocusDraw();									// Prevent List and Control Managers									// from automatically drawing by setting									// an empty clipping region	Rect	emptyRect = {0, 0, 0, 0};	StClipRgnState	saveClip(emptyRect);										// Get current size of ListBox	Rect	displayRect = (**mMacListH).rView;	Rect	bounds = (**mMacListH).dataBounds;			// If the cell width is the default width, adjust the cell		// width so that it will remain at the default width for the		// new width of the ListBox. The default width is the width		// of the ListBox divided by the number of columns.		if (bounds.right > bounds.left) {		Int16	defaultWidth = (displayRect.right - displayRect.left) /									(bounds.right - bounds.left);											if ((**mMacListH).cellSize.h == defaultWidth) {			Point	cellSize = (**mMacListH).cellSize;			cellSize.h = (displayRect.right - displayRect.left + inWidthDelta) /									(bounds.right - bounds.left);			::LCellSize(cellSize, mMacListH);		}	}					// Resize viewing rectangle of Toolbox ListHandle		::LSize(displayRect.right - displayRect.left + inWidthDelta,			displayRect.bottom - displayRect.top + inHeightDelta,			mMacListH);				// Toolbox ListManager seems to have a bug. When there is only		// one scroll bar (vertical or horizontal), the scroll bar is		// not indented if inHasGrow is true. As a workaround, we		// manually set the scroll bar size.	if (mHasGrow) {		if ((**mMacListH).vScroll != nil) {		// Vertical Scroll Bar			(**((**mMacListH).vScroll)).contrlRect.bottom =					(**mMacListH).rView.bottom - 14;		}				if ((**mMacListH).hScroll != nil) {		// Horizontal Scroll bar			(**((**mMacListH).hScroll)).contrlRect.right =					(**mMacListH).rView.right - 14;		}	}									// Resize Pane	LPane::ResizeFrameBy(inWidthDelta, inHeightDelta, inRefresh);}// ---------------------------------------------------------------------------//		¥ MoveBy// ---------------------------------------------------------------------------//	Move the location of the Frame by the specified amounts////	Both PowerPlant and the List Manager store a location for the ListBox,//	so we must make sure that both locations are in synch.voidLListBox::MoveBy(	Int32		inHorizDelta,	Int32		inVertDelta,	Boolean		inRefresh){									// Move Pane	LPane::MoveBy(inHorizDelta, inVertDelta, inRefresh);			// Unfortunately, the Toolbox does not have a call to		// move a List, so we have to directly set the proper		// fields of the ListHandle				// Determine how far to offset ListHandle's view rectangle,		// which we want to be the same as the Frame of the ListBox			Rect	displayRect = (**mMacListH).rView;	Rect	frame;	CalcLocalFrameRect(frame);		Int16	horizMove = frame.left - displayRect.left + 1;	Int16	vertMove = frame.top - displayRect.top + 1;		if ((horizMove == 0) && (vertMove == 0)) {		return;						// No need to move view rectangle	}									// Move view rectangle	::OffsetRect(&(**mMacListH).rView, horizMove, vertMove);										// Move Scroll Bars									// Ugh. We directly offset the rectangle									//   inside the ControlHandle instead									//   of using MoveControl since we don't									//   know what coordinate system the									//   List Manager uses.	if ((**mMacListH).vScroll != nil) {		::OffsetRect(&(**((**mMacListH).vScroll)).contrlRect, horizMove,					vertMove);	}	if ((**mMacListH).hScroll != nil) {		::OffsetRect(&(**((**mMacListH).hScroll)).contrlRect, horizMove,					vertMove);	}}