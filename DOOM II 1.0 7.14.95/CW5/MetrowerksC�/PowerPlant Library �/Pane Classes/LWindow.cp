// ===========================================================================//	LWindow.cp						©1993 Metrowerks Inc. All rights reserved.// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LWindow.h>#include <LModelProperty.h>#include <LStream.h>#include <PP_Messages.h>#include <UAppleEventsMgr.h>#include <UExtractFromAEDesc.h>#include <UDesktop.h>#include <UReanimator.h>#include <UWindows.h>#include <UDrawingUtils.h>#include <UDrawingState.h>#ifndef __WINDOWS__#include <Windows.h>#endif#ifndef __RESOURCES__#include <Resources.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif#ifndef __AEREGISTRY__#include <AERegistry.h>#endif#ifndef __AEOBJECTS__#include <AEObjects.h>#endif#ifndef __AEOBJECTPACKING__#include <AEPackObject.h>#endifconst DescType	pWindowPosition = 'ppos';const Int16		length_Big	= 16000;// ---------------------------------------------------------------------------//		¥ CreateWindow// ---------------------------------------------------------------------------//	Return a newly created Window object initialized from a PPob resourceLWindow*LWindow::CreateWindow(	ResIDT		inWindowID,	LCommander	*inSuperCommander){	SetDefaultCommander(inSuperCommander);	LWindow	*theWindow =			(LWindow*) UReanimator::ReadObjects('PPob', inWindowID);	theWindow->FinishCreate();	if (theWindow->HasAttribute(windAttr_ShowNew)) {		theWindow->Show();	}		return theWindow;}// ---------------------------------------------------------------------------//		¥ CreateWindowStream// ---------------------------------------------------------------------------//	Return a newly created Window object initialized with data from a StreamLWindow*LWindow::CreateWindowStream(	LStream	*inStream){	return (new LWindow(inStream));}// ---------------------------------------------------------------------------//		¥ LWindow// ---------------------------------------------------------------------------//	Default ConstructorLWindow::LWindow(){	mMacWindowP = nil;	SetRect(&mMinMaxSize, 0, 0, length_Big, length_Big);	mStandardSize.width = max_Int16;	mStandardSize.height = max_Int16;	mMoveOnlyUserZoom = false;	mAttributes = windAttr_Regular;}// ---------------------------------------------------------------------------//		¥ LWindow(SWindowInfo&)// ---------------------------------------------------------------------------//	Construct Window from the data in a structLWindow::LWindow(	const SWindowInfo	&inWindowInfo){	InitWindow(inWindowInfo);}// ---------------------------------------------------------------------------//		¥ LWindow(ResIDT, Uint32, LCommander*)// ---------------------------------------------------------------------------//	Construct a Window from a WIND Resource with the specified attributes//	and SuperCommander////	Side Effect: Created window becomes the current portLWindow::LWindow(	ResIDT		inWINDid,	Uint32		inAttributes,	LCommander	*inSuper)		: LCommander(inSuper){	SetRect(&mMinMaxSize, 0, 0, length_Big, length_Big);	mStandardSize.width = max_Int16;	mStandardSize.height = max_Int16;	mMoveOnlyUserZoom = false;	mAttributes = inAttributes;	MakeMacWindow(inWINDid);	EstablishPort();	OutOfFocus(nil);}// ---------------------------------------------------------------------------//		¥ LWindow(LStream*)// ---------------------------------------------------------------------------//	Construct Window from the data in a streamLWindow::LWindow(	LStream	*inStream){	SWindowInfo	windowInfo;	inStream->ReadData(&windowInfo, sizeof(SWindowInfo));	InitWindow(windowInfo);	SetDefaultView(this);}// ---------------------------------------------------------------------------//		¥ ~LWindow// ---------------------------------------------------------------------------//	DestructorLWindow::~LWindow(){	if (mMacWindowP != nil) {										// Hide window to ensure proper										//   ordering of remaining windows		UDesktop::HideDeskWindow(this);					// Delete subpanes *before* disposing of Toolbox WindowRecord.			// The LView destructor will delete subpanes, but it gets			// called after this destructor (since LWindow is derived			// from LView). If we dispose of the Toolbox WindowRecord first,			// it causes problems for Panes based on other Toolbox data			// structures, such as standard Controls and TextEdit, that			// store their own reference to a WindowRecord.					DeleteAllSubPanes();				DisposeWindow(mMacWindowP);		// Kill Toolbox Window		mMacWindowP = nil;	}}// ---------------------------------------------------------------------------//		¥ InitWindow// ---------------------------------------------------------------------------//	Private Initializer from data in a structvoidLWindow::InitWindow(	const SWindowInfo	&inWindowInfo){	mAttributes = inWindowInfo.attributes;									// Set Attribute for Window Layer	EWindAttr	windLayerAttr = windAttr_Regular;	if (inWindowInfo.layer == windLayer_Modal) {		windLayerAttr = windAttr_Modal;	} else if (inWindowInfo.layer == windLayer_Floating) {		windLayerAttr = windAttr_Floating;	}	SetAttribute(windLayerAttr);									// Set Min and Max Window Size	mMinMaxSize.left = inWindowInfo.minimumWidth;	mMinMaxSize.top = inWindowInfo.minimumHeight;	mMinMaxSize.right = inWindowInfo.maximumWidth;	if (mMinMaxSize.right < 0) {		mMinMaxSize.right = length_Big;	}	mMinMaxSize.bottom = inWindowInfo.maximumHeight;	if (mMinMaxSize.bottom < 0) {		mMinMaxSize.bottom = length_Big;	}									// Set Standard Size for Zooming	mStandardSize = inWindowInfo.standardSize;	if (mStandardSize.width < 0) {		mStandardSize.width = max_Int16;	}	if (mStandardSize.height < 0) {		mStandardSize.height = max_Int16;	}	mMoveOnlyUserZoom = false;		SetUserCon(inWindowInfo.userCon);		MakeMacWindow(inWindowInfo.WINDid);	EstablishPort();	OutOfFocus(nil);}// ---------------------------------------------------------------------------//		¥ MakeMacWindow// ---------------------------------------------------------------------------//	Make a new Mac Window from a WIND resource templatevoidLWindow::MakeMacWindow(	Int16		inWINDid){	SetPaneID(inWINDid);	mMacWindowP = UDesktop::NewDeskWindow(this, inWINDid, window_InFront);	ThrowIfNil_(mMacWindowP);			// Inside Mac says that an Application may set the windowKind		// field of a WindowRecord to any value greater than 8 if		// desired. PowerPlant requires that the windowKind for		// windows associated with a LWindow object be >= PP_Window_Kind,		// which is a large constant. For such windows, we PowerPlant		// stores a pointer to the LWindow object in the refCon.		// If you wish to use unique kinds for your windows (it's the		// only way to differentiate LWindow subclasses from just looking		// at a Toolbox WindowRecord), store the kind number in the		// refCon field of the WIND resource.											// Get WIND resource to check refCon	SWINDResourceH	theWIND = (SWINDResourceH) GetResource('WIND', inWINDid);	Int16	kind = (**theWIND).refCon;	if (kind < PP_Window_Kind) {	// Use value from refCon if it is		kind = PP_Window_Kind;		//   greater than our special number	}	((WindowPeek) mMacWindowP)->windowKind = kind;	ReleaseResource((Handle) theWIND);									// Stuff object pointer in refcon	SetWRefCon(mMacWindowP, (long) this);										// Window Frame and Image are the same									//   as its portRect		ResizeFrameTo(mMacWindowP->portRect.right - mMacWindowP->portRect.left,				  mMacWindowP->portRect.bottom - mMacWindowP->portRect.top,				  false);	ResizeImageTo(mMacWindowP->portRect.right - mMacWindowP->portRect.left,				  mMacWindowP->portRect.bottom - mMacWindowP->portRect.top,				  false);		CalcRevealedRect();	CalcPortFrameRect(mUserBounds);	PortToGlobalPoint(topLeft(mUserBounds));	PortToGlobalPoint(botRight(mUserBounds));	mVisible = triState_Off;	mActive = triState_Off;	mEnabled = triState_Off;	if (HasAttribute(windAttr_Enabled)) {		mEnabled = triState_On;	}}// ---------------------------------------------------------------------------//		¥ FetchWindowObject [static]// ---------------------------------------------------------------------------//	Return the PowerPlant Window object associated with a Mac WindowPtr////	Returns nil if the WindowPtr is not a PowerPlant WindowLWindow*LWindow::FetchWindowObject(	WindowPtr	inWindowP){	LWindow	*ppWindow = nil;									// PowerPlant Windows have a special									// windowKind	if ( (inWindowP != nil)  &&		 (((WindowPeek) inWindowP)->windowKind >= PP_Window_Kind) ) {									// Object pointer is in the refCon			ppWindow = (LWindow*) GetWRefCon(inWindowP);	}		return ppWindow;}// ---------------------------------------------------------------------------//		¥ GetMacPort// ---------------------------------------------------------------------------//	Return Toolbox GrafPort associated with a Window objectGrafPtrLWindow::GetMacPort() const{	return mMacWindowP;}// ---------------------------------------------------------------------------//		¥ HasAttribute// ---------------------------------------------------------------------------//	Return whether a Window has the specified attributeBooleanLWindow::HasAttribute(	EWindAttr	inAttribute) const{	return ((mAttributes & inAttribute) != 0);}voidLWindow::SetAttribute(	EWindAttr	inAttribute){	mAttributes |= inAttribute;}voidLWindow::GetMinMaxSize(	Rect	&outRect) const{	outRect = mMinMaxSize;}voidLWindow::SetMinMaxSize(	const Rect	&inRect){	mMinMaxSize = inRect;}voidLWindow::GetStandardSize(	SDimension16	&outStdSize){	outStdSize = mStandardSize;}voidLWindow::SetStandardSize(	SDimension16	inStdSize){	mStandardSize = inStdSize;}StringPtrLWindow::GetDescriptor(	Str255	outDescriptor) const{	GetWTitle(mMacWindowP, outDescriptor);	return outDescriptor;}voidLWindow::SetDescriptor(	ConstStr255Param	inDescriptor){	SetWTitle(mMacWindowP, inDescriptor);}// ---------------------------------------------------------------------------//		¥ HandleClick// ---------------------------------------------------------------------------//	Respond to a click on a Window////	The inPart parameter is the part code returned by the Toolbox FindWindow//	routine.voidLWindow::HandleClick(	const EventRecord	&inMacEvent,	Int16				inPart){	switch (inPart) {			case click_OutsideModal:	// Special case for clicking outside			SysBeep(1);				//   a modal window			break;			case inContent:			ClickInContent(inMacEvent);			break;					case inDrag:			ClickInDrag(inMacEvent);			break;					case inGrow:			ClickInGrow(inMacEvent);			break;					case inGoAway:			ClickInGoAway(inMacEvent);			break;					case inZoomIn:		case inZoomOut:			ClickInZoom(inMacEvent, inPart);			break;	}}// ---------------------------------------------------------------------------//		¥ ClickInContent// ---------------------------------------------------------------------------//	Respond to a click in the content region of a WindowvoidLWindow::ClickInContent(	const EventRecord	&inMacEvent){									// Enabled Windows respond to clicks	Boolean		respondToClick = HasAttribute(windAttr_Enabled);										// Set up our extended event record	SMouseDownEvent		theMouseDown;	theMouseDown.wherePort = inMacEvent.where;	GlobalToPortPoint(theMouseDown.wherePort);	theMouseDown.whereLocal = theMouseDown.wherePort;	theMouseDown.macEvent = inMacEvent;	theMouseDown.delaySelect = false;		if (!UDesktop::WindowIsSelected(this)) {									// Window is not in front, we might									//   need to select it		Boolean	doSelect = true;		if (HasAttribute(windAttr_DelaySelect)) {									// Delay selection until after handling									//   the click (called click-through)			theMouseDown.delaySelect = true;			Click(theMouseDown);												// After click-through, we select the									//   Window if the mouse is still down									//   or the mouse up occurred inside									//   this Window.			EventRecord	mouseUpEvent;			if (!StillDown() && GetOSEvent(mUpMask, &mouseUpEvent)) {									// Check location of mouse up event				WindowPtr	upWindow;				FindWindow(mouseUpEvent.where, &upWindow);				doSelect = (upWindow == mMacWindowP);			}		}				if (doSelect) {				// Selecting a Window brings it to the									//   front of its layer and activates it			Select();			respondToClick = HasAttribute(windAttr_GetSelectClick);		}	}		if (respondToClick && !theMouseDown.delaySelect) {		theMouseDown.delaySelect = false;		Click(theMouseDown);	}}// ---------------------------------------------------------------------------//		¥ ClickInDrag// ---------------------------------------------------------------------------//	Handle click in drag region of a WindowvoidLWindow::ClickInDrag(	const EventRecord	&inMacEvent){										// Save old bounds (content region										//	is in global coords)	Rect	bounds = (*((WindowPeek)mMacWindowP)->contRgn)->rgnBBox;		Rect	dragRect = (**(GetGrayRgn())).rgnBBox;	InsetRect(&dragRect, 4, 4);	UDesktop::DragDeskWindow(this, inMacEvent, dragRect);			// DragWindow will move the window. However, send AppleEvent to		// set the bounds (but don't execute it), so that Script engines		// can record the action.											// Compare old and new bounds	if (!EqualRect(&bounds,					&(*((WindowPeek)mMacWindowP)->contRgn)->rgnBBox)) {															// Send but don't execute										//   SetBounds AppleEvent		SendAESetPosition			(topLeft((*((WindowPeek)mMacWindowP)->contRgn)->rgnBBox),						false);								Point	offset = {0, 0};		// Dragging window offsets the		PortToGlobalPoint(offset);		//   position of the UserBounds		offset.h -= mUserBounds.left;	//   for zooming		offset.v -= mUserBounds.top;		OffsetRect(&mUserBounds, offset.h, offset.v);		mMoveOnlyUserZoom = false;	}}// ---------------------------------------------------------------------------//		¥ ClickInGrow// ---------------------------------------------------------------------------voidLWindow::ClickInGrow(	const EventRecord	&inMacEvent){	Rect	theRect = mMinMaxSize;		// GrowWindow trap is off by one	theRect.right += 1;					//   when growing window to its max	theRect.bottom += 1;				//   size. Mostly likely caused by										//   using the PinRect trap.			  	  			  	  						// Let Toolbox draw the grow image			  	  						//   newSize has the new height in			  	  						//   the hi word, width in lo word	long	newSize = GrowWindow(mMacWindowP, inMacEvent.where, &theRect);		if (newSize != 0) {					// If window size changed ...										// Get current bounds (global coords)		theRect = (*((WindowPeek)mMacWindowP)->contRgn)->rgnBBox;										// Compute new bounds (global coords)		theRect.right = theRect.left + LoWord(newSize);		theRect.bottom = theRect.top + HiWord(newSize);										// Change the window size		SendAESetBounds(&theRect, true);	}}// ---------------------------------------------------------------------------//		¥ ClickInGoAway// ---------------------------------------------------------------------------//	Handle a click inside the close box of a WindowvoidLWindow::ClickInGoAway(	const EventRecord	&inMacEvent){	if (TrackGoAway(mMacWindowP, inMacEvent.where)) {		ProcessCommand(cmd_Close);	}}// ---------------------------------------------------------------------------//		¥ ClickInZoom// ---------------------------------------------------------------------------//	Handle a click inside the zoom box of a WindowvoidLWindow::ClickInZoom(	const EventRecord	&inMacEvent,	short				inZoomDirection){	if (TrackBox(mMacWindowP, inMacEvent.where, inZoomDirection)) {		SendAESetZoom();	}}// ---------------------------------------------------------------------------//		¥ UpdatePort// ---------------------------------------------------------------------------//	Redraw invalidated area of the Window////	The Mac WindowPtr maintains an update region that defines the area//	that needs to be redrawn.voidLWindow::UpdatePort(){	GrafPtr		originalPort = UQDGlobals::GetCurrentPort();		::SetPort(mMacWindowP);	::SetOrigin(0,0);	OutOfFocus(nil);		::BeginUpdate(mMacWindowP);		Draw(mMacWindowP->visRgn);		::EndUpdate(mMacWindowP);		::SetPort(originalPort);	OutOfFocus(nil);}// ---------------------------------------------------------------------------//		¥ EstablishPort// ---------------------------------------------------------------------------//	Make Window the current Port////	Usage Note: If you call this function directly, you should call//		LView::OutOfFocus(nil), since changing the current port may//		invalidate the Focus.voidLWindow::EstablishPort(){	if ((mMacWindowP != nil) &&		(UQDGlobals::GetCurrentPort() != mMacWindowP)) {		::SetPort(mMacWindowP);	}}voidLWindow::InvalPortRect(	const Rect	*inRect){	FocusDraw();	::InvalRect(inRect);}voidLWindow::InvalPortRgn(	RgnHandle	inRgnH){	FocusDraw();	::InvalRgn(inRgnH);}voidLWindow::ValidPortRect(	const Rect	*inRect){	FocusDraw();	::ValidRect(inRect);}voidLWindow::ValidPortRgn(	RgnHandle	inRgnH){	FocusDraw();	::ValidRgn(inRgnH);}voidLWindow::Select(){	SendSelfAE(kAEMiscStandards, kAESelect, false);	UDesktop::SelectDeskWindow(this);}voidLWindow::Show(){	if (mVisible == triState_Off) {		mVisible = triState_On;		ShowSelf();		LView::Show();	}}voidLWindow::ShowSelf(){	UDesktop::ShowDeskWindow(this);}voidLWindow::HideSelf(){	UDesktop::HideDeskWindow(this);	Deactivate();}voidLWindow::Activate(){	if (mActive == triState_Off) {		mActive = triState_On;		ActivateSelf();		LView::Activate();					// Normally the active Window contains the Target. If this			// Window can be the Target, restore the Target to what			// it was when the Window was last active. Don't do this			// if the Window is already on duty (which happens when			// the Window is a Superior of a Window that was just			// deactivated).					if (HasAttribute(windAttr_Targetable) && !IsOnDuty()) {			RestoreTarget();		}	}}voidLWindow::ActivateSelf(){	::HiliteWindow(mMacWindowP, true);	DrawSizeBox();}voidLWindow::Deactivate(){	LView::Deactivate();		if (IsOnDuty()) {			// Switch target to SuperCommander to prevent an		// inactive Window from containing the Target				SwitchTarget(GetSuperCommander());	}}voidLWindow::DeactivateSelf(){	::HiliteWindow(mMacWindowP, false);	DrawSizeBox();}voidLWindow::Enable(){	if (mEnabled == triState_Off) {		mEnabled = triState_On;		EnableSelf();		LView::Enable();	}}voidLWindow::Suspend(){	if (HasAttribute(windAttr_HideOnSuspend)) {		SuperHide();	} else if (IsActive()) {		Deactivate();	}}voidLWindow::Resume(){	Boolean	modalInFront = UDesktop::FrontWindowIsModal();	if (HasAttribute(windAttr_HideOnSuspend)) {		SuperShow();	}		if (HasAttribute(windAttr_Floating) && !modalInFront) {		Activate();	}}// ---------------------------------------------------------------------------//		¥ AttemptClose// ---------------------------------------------------------------------------//	Try to close a Window as a result of direct user actionvoidLWindow::AttemptClose(){									// Get approval from SuperCommander	if ((mSuperCommander == nil) || mSuperCommander->AllowSubRemoval(this)) {		 		 							// Send Close AE for recording only		SendSelfAE(kAECoreSuite, kAEClose, false);		delete this;	}}// ---------------------------------------------------------------------------//		¥ DoClose// ---------------------------------------------------------------------------//	Close a WindowvoidLWindow::DoClose(){									// Get approval from SuperCommander	if ((mSuperCommander == nil) || mSuperCommander->AllowSubRemoval(this)) {		delete this;	}}voidLWindow::DrawSelf(){//	PaintRect(&mMacWindowP->portRect);		// DEBUG, for checking update region	if (HasAttribute(windAttr_EraseOnUpdate)) {		EraseRect(&mMacWindowP->portRect);	}		DrawSizeBox();}// ---------------------------------------------------------------------------//		¥ DrawSizeBox// ---------------------------------------------------------------------------//	Draw standard size box for resizable WindowsvoidLWindow::DrawSizeBox(){	if (HasAttribute(windAttr_SizeBox)) {				// The Toolbox trap DrawGrowIcon draws the size box in			// the lower right corner of a Window, but it also outlines			// the typical scroll bar areas at the right and bottom of			// a Window. We want this routine to work for Windows that			// don't necessarily have standard scroll bars, so we			// temporarily change the clipping region to draw just the			// size box.			FocusDraw();				Rect	sizeBox = mMacWindowP->portRect;		sizeBox.left = sizeBox.right - 15;		sizeBox.top = sizeBox.bottom - 15;				StClipRgnState	saveClip(sizeBox);		::DrawGrowIcon(mMacWindowP);	}}// ---------------------------------------------------------------------------//		¥ GlobalToPortPoint// ---------------------------------------------------------------------------//	Convert a point from global (screen) coordinates to a Window's Port//	coordinatesvoidLWindow::GlobalToPortPoint(	Point	&ioPoint) const{		// Windows have a reference to the pixel image of the main screen--		// portBits for B&W and portPixMap for color windows. The bounds		// of the pixel image specify the alignment of the *local* Window		// coordinates with *global* coordinates:		//		localPt = globalPt + topLeft(imageBounds)		//		// To convert from *local* to *port* coordinates, we offset by		// the top left of the Window's port rectangle:		//		portPt = localPt - topLeft(portRect)		//		// Therefore,		//		portPt = globalPt + topLeft(imageBounds) - topLeft(portRect)		//		// Note: We don't use the Toolbox routine GlobalToLocal because		// that routine depends on the current port and the current port		// origin. To use GlobalToLocal we would have to do the following:		//		GrafPtr savePort;		//		GetPort(&savePort);		//		Point	saveOrigin = topLeft(mMacWindowP->portRect);		//		SetPort(mMacWindowP);		//		SetOrigin(0,0);		//		GlobalToLocal(ioPoint);		//		SetOrigin(saveOrigin.h, saveOrigin.v);		//		SetPort(savePort);		// The equation above avoids all this saving/setting/restoring		// of the current port and port origin.									// Assume a B&W Window	Point	localOffset = topLeft(mMacWindowP->portBits.bounds);	if (UDrawingUtils::IsColorGrafPort(mMacWindowP)) {									// Nope, it's a color Window		CGrafPtr	colorPortP = (CGrafPtr) mMacWindowP;		localOffset = topLeft((**(colorPortP->portPixMap)).bounds);	}		ioPoint.h += (localOffset.h - mMacWindowP->portRect.left);	ioPoint.v += (localOffset.v - mMacWindowP->portRect.top);}// ---------------------------------------------------------------------------//		¥ PortToGlobalPoint// ---------------------------------------------------------------------------//	Convert a point from Port to Global (screen) coordinates//		[see discussion above for GlobalToPortPoint() for comments]voidLWindow::PortToGlobalPoint(	Point	&ioPoint) const{									// Assume a B&W Window	Point	localOffset = topLeft(mMacWindowP->portBits.bounds);	if (UDrawingUtils::IsColorGrafPort(mMacWindowP)) {									// Nope, it's a color Window		CGrafPtr	colorPortP = (CGrafPtr) mMacWindowP;		localOffset = topLeft((**(colorPortP->portPixMap)).bounds);	}		ioPoint.h -= (localOffset.h - mMacWindowP->portRect.left);	ioPoint.v -= (localOffset.v - mMacWindowP->portRect.top);}// ---------------------------------------------------------------------------//		¥ ExpandSubPane// ---------------------------------------------------------------------------//	Resize a SubPane so that it is the same size as the Window,//	horizontally and/or verticallyvoidLWindow::ExpandSubPane(	LPane	*inSub,	Boolean	inExpandHoriz,	Boolean	inExpandVert){	SDimension16	subSize;	inSub->GetFrameSize(subSize);	SPoint32		subLocation;	inSub->GetFrameLocation(subLocation);			// SubPane overlaps 1-pixel window border	if (inExpandHoriz) {		subSize.width = mFrameSize.width + 2;		subLocation.h = -1;	}		if (inExpandVert) {		subSize.height = mFrameSize.height + 2;		subLocation.v = -1;	}		inSub->PlaceInSuperFrameAt(subLocation.h, subLocation.v, false);	inSub->ResizeFrameTo(subSize.width, subSize.height, false);}// ===========================================================================// ¥ Sending Apple Events								Sending Apple Events ¥// ===========================================================================// ---------------------------------------------------------------------------//		¥ SendAESetPosition// ---------------------------------------------------------------------------//	AppleEvent for moving a Window to a new position////	inPosition is the location for the top left corner of the Window's//		port rectangle, in Global coordinates//	Set inExecuteAE to true to actually move the Window, false to//	just send the event for script recording purposes. You'll use the//	false value when you have already moved the window in response to//	tracking user actions (the Toolbox trap DragWindow move the Window).voidLWindow::SendAESetPosition(	Point	inPosition,	Boolean	inExecuteAE){	Try_ {		LModelProperty	positionProperty(pWindowPosition, this);		positionProperty.SendSetDataAE(typeQDPoint, (Ptr) &inPosition,											sizeof(Point), inExecuteAE);	}		Catch_(inErr) {		if (inExecuteAE) {			DoSetPosition(inPosition);		}	} EndCatch_}// ---------------------------------------------------------------------------//		¥ SendAESetBounds// ---------------------------------------------------------------------------//	AppleEvent for changing the size of a Window////	inBounds is the new port rectangle for the Window, in Global coordinates.//	Set inExecuteAE to true to actually resize the Window, false to//	just send the event for script recording purposes.voidLWindow::SendAESetBounds(	Rect	*inBounds,					// New bounds in global coords	Boolean	inExecuteAE){	Try_ {		LModelProperty	positionProperty(pBounds, this);		positionProperty.SendSetDataAE(typeQDRectangle, (Ptr) inBounds,											sizeof(Rect), inExecuteAE);	}		Catch_(inErr) {		if (inExecuteAE) {			DoSetBounds(*inBounds);		}	} EndCatch_}// ---------------------------------------------------------------------------//		¥ SendAESetZoom// ---------------------------------------------------------------------------//	AppleEvent for zooming a Window////	This function figures out whether to zoom in or out based on the//	current window size and locationvoidLWindow::SendAESetZoom(){										// Determine zoom direction	Rect	stdBounds;	Boolean	zoomToStdState = !CalcStandardBounds(stdBounds);	Try_ {		LModelProperty	zoomProperty(pIsZoomed, this);		zoomProperty.SendSetDataAE(typeBoolean, (Ptr) &zoomToStdState,											sizeof(Boolean), true);	}		Catch_(inErr) {		DoSetZoom(zoomToStdState);	} EndCatch_}// ---------------------------------------------------------------------------//		¥ ObeyCommand// ---------------------------------------------------------------------------//	Handle a commandBooleanLWindow::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;		switch (inCommand) {				case cmd_Close:			AttemptClose();			break;					default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}			return cmdHandled;}// ---------------------------------------------------------------------------//		¥ FindCommandStatus// ---------------------------------------------------------------------------//	Pass back whether a Command is enabled and/or marked (in a Menu)voidLWindow::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	switch (inCommand) {			case cmd_Close:			outEnabled = true;			outUsesMark = false;			break;					default:			LCommander::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			break;	}}// ===========================================================================// ¥ AppleEvent Object Model Support		 AppleEvent Object Model Support ¥// ===========================================================================DescTypeLWindow::GetModelKind() const{	return cWindow;}// ---------------------------------------------------------------------------//		¥ MakeSelfSpecifier// ---------------------------------------------------------------------------//	Make an Object Specifier for a WindowvoidLWindow::MakeSelfSpecifier(	AEDesc	&inSuperSpecifier,	AEDesc	&outSelfSpecifier) const{	if (mSuperModel == nil) {				// For Windows, we often use an "abbreviated" container			// hierarchy where the SuperModel of a Window is null			// rather than being the Application. In such cases,			// we specify the Window by its absolute front-to-back			// position.					StAEDescriptor	keyData;		Int16	windowIndex = UWindows::FindWindowIndex(mMacWindowP);		OSErr	err = ::CreateOffsetDescriptor(windowIndex, &keyData.mDesc);		ThrowIfOSErr_(err);				err = ::CreateObjSpecifier(cWindow, &inSuperSpecifier,				formAbsolutePosition, &keyData.mDesc, false,				&outSelfSpecifier);		ThrowIfOSErr_(err);			} else {		LModelObject::MakeSelfSpecifier(inSuperSpecifier, outSelfSpecifier);	}}voidLWindow::GetAEProperty(	DescType		inProperty,	const AEDesc	&inRequestedType,	AEDesc			&outPropertyDesc) const{	OSErr	err;	switch (inProperty) {			case pName:					// Window Title			Str255	theName;			GetDescriptor(theName);			err = ::AECreateDesc(typeChar, (Ptr) theName + 1,								StrLength(theName), &outPropertyDesc);			break;			case pWindowPosition:		// Top left of Frame in Global coords			Point	thePosition = {0, 0};			PortToGlobalPoint(thePosition);			err = ::AECreateDesc(typeQDPoint, (Ptr) &thePosition,								sizeof(Point), &outPropertyDesc);			break;					case pBounds:				// Frame in Global coords			Rect	theBounds;			CalcPortFrameRect(theBounds);			PortToGlobalPoint(topLeft(theBounds));			PortToGlobalPoint(botRight(theBounds));			err = ::AECreateDesc(typeQDRectangle, (Ptr) &theBounds,								sizeof(Rect), &outPropertyDesc);			break;					case pIndex:				// Front-to-back position index			Int32	theIndex = UWindows::FindWindowIndex(mMacWindowP);			err = ::AECreateDesc(typeLongInteger, (Ptr) &theIndex,								sizeof(Int32), &outPropertyDesc);			break;					case pIsZoomed:				// Is Window at Standard state?			Rect	stdBounds;			Boolean	isZoomed = CalcStandardBounds(stdBounds);			err = AECreateDesc(typeBoolean, (Ptr) &isZoomed,								sizeof(Boolean), &outPropertyDesc);			break;				case pHasCloseBox:			GetAEWindowAttribute(windAttr_CloseBox, outPropertyDesc);			break;					case pHasTitleBar:			GetAEWindowAttribute(windAttr_TitleBar, outPropertyDesc);			break;					case pIsFloating:			GetAEWindowAttribute(windAttr_Floating, outPropertyDesc);			break;					case pIsModal:			GetAEWindowAttribute(windAttr_Modal, outPropertyDesc);			break;					case pIsResizable:			GetAEWindowAttribute(windAttr_Resizable, outPropertyDesc);			break;					case pIsZoomable:			// Can Window be zoomed?			GetAEWindowAttribute(windAttr_Zoomable, outPropertyDesc);			break;					case pVisible:			Boolean	isVis = IsVisible();			err = AECreateDesc(typeBoolean, (Ptr) &isVis,								sizeof(Boolean), &outPropertyDesc);			break;					default:			LModelObject::GetAEProperty(inProperty, inRequestedType,											outPropertyDesc);			break;	}}voidLWindow::SetAEProperty(	DescType		inProperty,	const AEDesc	&inValue,	AEDesc&			outAEReply){	switch (inProperty) {			case pName:			Str255	theName;			UExtractFromAEDesc::ThePString(inValue, theName);			SetDescriptor(theName);			break;			case pWindowPosition:			Point	thePosition;			UExtractFromAEDesc::ThePoint(inValue, thePosition);			DoSetPosition(thePosition);			break;			case pBounds:			Rect	theBounds;			UExtractFromAEDesc::TheRect(inValue, theBounds);			DoSetBounds(theBounds);			break;					case pIsZoomed:			Boolean	isZoomed;			UExtractFromAEDesc::TheBoolean(inValue, isZoomed);			DoSetZoom(isZoomed);			break;					case pVisible:			Boolean	makeVisible;			UExtractFromAEDesc::TheBoolean(inValue, makeVisible);			if (makeVisible) {				Show();			} else {				Hide();			}			break;					default:			LModelObject::SetAEProperty(inProperty, inValue, outAEReply);			break;	}}voidLWindow::GetAEWindowAttribute(	EWindAttr	inAttribute,	AEDesc		&outPropertyDesc) const{	Boolean	attrIsSet = HasAttribute(inAttribute);	OSErr	err = ::AECreateDesc(typeBoolean, (Ptr) &attrIsSet,								sizeof(Boolean), &outPropertyDesc);	ThrowIfOSErr_(err);}voidLWindow::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	switch (inAENumber) {			case ae_Close:			DoClose();			break;					case ae_Select:			UDesktop::SelectDeskWindow(this);			break;					default:			LModelObject::HandleAppleEvent(inAppleEvent, outAEReply,												outResult, inAENumber);			break;	}}// ---------------------------------------------------------------------------//		¥ DoSetPosition// ---------------------------------------------------------------------------//	Change the location of a Window////	The top left corner of the Window's port rectangle is placed at//	inPosition, which is in global coordinatesvoidLWindow::DoSetPosition(	Point	inPosition)					// Top left in global coords{	MoveWindow(mMacWindowP, inPosition.h, inPosition.v, false);	Point	offset = {0, 0};			// Moving Window changes the	PortToGlobalPoint(offset);			//   UserBounds for zooming	offset.h -= mUserBounds.left;	offset.v -= mUserBounds.top;	OffsetRect(&mUserBounds, offset.h, offset.v);	mMoveOnlyUserZoom = false;}// ---------------------------------------------------------------------------//		¥ CalcStandardBounds// ---------------------------------------------------------------------------//	Calculate the bounds of the Window at standard state and return whether//	it is at standard state. The standard state depends on the screen//	containing the largest area of the Window and the current standard size.////	outStdBounds: Port rectangle of Window at standard size, global coordsBooleanLWindow::CalcStandardBounds(	Rect	&outStdBounds) const{									// Find GDevice containing largest									//   portion of Window	GDHandle	dominantDevice = UWindows::FindDominantDevice(							UWindows::GetWindowStructureRect(mMacWindowP));										// Must compensate for MenuBar on the									//   main screen	Rect		screenRect = (**dominantDevice).gdRect;	if (dominantDevice == ::GetMainDevice()) {		screenRect.top += GetMBarHeight();	}		CalcStandardBoundsForScreen(screenRect, outStdBounds);		return ::EqualRect(&outStdBounds,					   &UWindows::GetWindowContentRect(mMacWindowP));}// ---------------------------------------------------------------------------//		¥ CalcStandardBoundsForScreen// ---------------------------------------------------------------------------//	Calculate the bounds of the Window if it was at a Standard (zoomed out)//	state on a Screen with the specified bounds.////	inScreenBounds: Bounding box of screen in global coordinates//	outStdBounds: Port rectangle of Window at standard size, global coordsvoidLWindow::CalcStandardBoundsForScreen(	const Rect	&inScreenBounds,	Rect		&outStdBounds) const{									// Structure and Content regions are									//   in global coordinates	Rect	strucRect = UWindows::GetWindowStructureRect(mMacWindowP);	Rect	contRect = UWindows::GetWindowContentRect(mMacWindowP);										// Structure can be (and usually is)									//   larger than Content	Rect	border;	border.left = contRect.left - strucRect.left;	border.right = strucRect.right - contRect.right;	border.top = contRect.top - strucRect.top;	border.bottom = strucRect.bottom - contRect.bottom;						 						 			// Don't zoom too close to edge of screen	Int16	screenWidth = inScreenBounds.right - inScreenBounds.left - 4;	Int16	screenHeight = inScreenBounds.bottom - inScreenBounds.top - 4;										// Standard dimensions are the minimum									//   of mStandardSize and the size of									//   the screen	Int16	stdWidth = mStandardSize.width;	if (stdWidth > screenWidth - (border.left + border.right)) {		stdWidth = screenWidth - (border.left + border.right);	}		Int16	stdHeight = mStandardSize.height;	if (stdHeight > screenHeight - (border.top + border.bottom)) {		stdHeight = screenHeight - (border.top + border.bottom);	}									// Standard position is the point closest									//   to the current position at which									//   the Window will be all on screen																		// Move window horizontally so that left									//   or right edge of Struction region is									//   2 pixels from the edge of the screen	Int16	stdLeft = contRect.left;	if (stdLeft < inScreenBounds.left + border.left + 2) {		stdLeft = inScreenBounds.left + border.left + 2;	} else if (stdLeft > inScreenBounds.right - stdWidth - border.right - 2) {		stdLeft = inScreenBounds.right - stdWidth - border.right - 2;	}										// Move window vertically so that top									//   or bottom edge of Struction region is									//   2 pixels from the edge of the screen	Int16	stdTop = contRect.top;	if (stdTop < inScreenBounds.top + border.top + 2) {		stdTop = inScreenBounds.top + border.top + 2;	} else if (stdTop > inScreenBounds.bottom - stdHeight - border.bottom - 2) {		stdTop = inScreenBounds.bottom - stdHeight - border.bottom - 2;	}		outStdBounds.left = stdLeft;	outStdBounds.right = stdLeft + stdWidth;	outStdBounds.top = stdTop;	outStdBounds.bottom = stdTop + stdHeight;}// ---------------------------------------------------------------------------//		¥ DoSetZoom// ---------------------------------------------------------------------------//	Zoom window to either the Standard or User statevoidLWindow::DoSetZoom(	Boolean	inZoomToStdState){	if (!HasAttribute(windAttr_Zoomable)) {		ThrowOSErr_(errAENotModifiable);	}	Rect	currBounds = UWindows::GetWindowContentRect(mMacWindowP);	Rect	zoomBounds;	if (inZoomToStdState) {			// Zoom to Standard state		if (CalcStandardBounds(zoomBounds)) {			return;					// Already at Standard state		}			} else {						// Zoom to User state		zoomBounds = mUserBounds;				if (mMoveOnlyUserZoom) {	// Special case for zooming a Window									//   that is at standard size, but									//   is partially offscreen			zoomBounds.right = zoomBounds.left +								(currBounds.right - currBounds.left);			zoomBounds.bottom = zoomBounds.top +								(currBounds.bottom - currBounds.top);		}	}		Int16	zoomWidth = zoomBounds.right - zoomBounds.left;	Int16	zoomHeight = zoomBounds.bottom - zoomBounds.top;	mMoveOnlyUserZoom = false;			// To avoid unnecessary redraws, we check to see if the		// current and zoom states are either the same size		// or at the same location			if ( ((currBounds.right - currBounds.left) == zoomWidth) &&		 ((currBounds.bottom - currBounds.top) == zoomHeight) ) {									// Same size, just move		MoveWindow(mMacWindowP, zoomBounds.left, zoomBounds.top, false);		mMoveOnlyUserZoom = true;		} else if (EqualPt(topLeft(currBounds), topLeft(zoomBounds))) {									// Same location, just resize		SizeWindow(mMacWindowP, zoomWidth, zoomHeight, false);		ResizeFrameTo(zoomWidth, zoomHeight, true);			} else {						// Different size and location									// Stuff zoom bounds into WindowRecord									//   as standard state and zoom out		WStateDataHandle	wStateH = (WStateDataHandle)			((WindowPeek) mMacWindowP)->dataHandle;		(**wStateH).stdState = zoomBounds;		FocusDraw();		EraseRect(&mMacWindowP->portRect);		ZoomWindow(mMacWindowP, inZoomOut, false);		ResizeFrameTo(zoomWidth, zoomHeight, false);	}}// ---------------------------------------------------------------------------//		¥ DoSetBounds// ---------------------------------------------------------------------------//	Change size and location of a Window////	inBounds, in global coords, specifies the new size and location of//	the Window's port rectanglevoidLWindow::DoSetBounds(	const Rect	&inBounds)			// Bounds in global coords{									// Set size and location of Toolbox									//   WindowRecord	::SizeWindow(mMacWindowP, inBounds.right - inBounds.left,				inBounds.bottom - inBounds.top, false);	::MoveWindow(mMacWindowP, inBounds.left, inBounds.top, false);										// Set our Frame	ResizeFrameTo(inBounds.right - inBounds.left,				inBounds.bottom - inBounds.top, true);	SDimension16	frameSize;		// For Windows, Image is always the	GetFrameSize(frameSize);		//   same size as its Frame	ResizeImageTo(frameSize.width, frameSize.height, false);										// Changing Bounds establishes a									//   new User state for zooming	CalcPortFrameRect(mUserBounds);	PortToGlobalPoint(topLeft(mUserBounds));	PortToGlobalPoint(botRight(mUserBounds));	mMoveOnlyUserZoom = false;}