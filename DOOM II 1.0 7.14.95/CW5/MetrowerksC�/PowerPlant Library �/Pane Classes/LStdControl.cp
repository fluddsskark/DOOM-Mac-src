// ===========================================================================//	LStdControl.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	A wrapper class for standard Mac Controls#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LStdControl.h>#include <LView.h>#include <LStream.h>#include <PP_Messages.h>#include <UTextTraits.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#ifndef __WINDOWS__#include <Windows.h>#endif#ifndef __RESOURCES__#include <Resources.h>#endif// ---------------------------------------------------------------------------//		¥ CreateFromCNTL [static]// ---------------------------------------------------------------------------//	Create a StdControl from a CNTL resourceLStdControl*LStdControl::CreateFromCNTL(	ResIDT		inCNTLid,	MessageT	inValueMessage,	ResIDT		inTextTraitsID,	LView		*inSuperView){	LStdControl	*theStdControl = nil;	HidePen();	inSuperView->FocusDraw();		if (inTextTraitsID != 0) {		// Control does not use System font		UTextTraits::SetPortTextTraits(inTextTraitsID);	}		ControlHandle	macControlH = ::GetNewControl(inCNTLid,												inSuperView->GetMacPort());	ShowPen();	ThrowIfNil_(macControlH);		SCNTLResource	*resP = *(SCNTLResourceH) ::GetResource('CNTL', inCNTLid);		SPaneInfo	thePaneInfo;	thePaneInfo.paneID = inCNTLid;	thePaneInfo.left = resP->bounds.left;	thePaneInfo.top = resP->bounds.top;	thePaneInfo.width = resP->bounds.right - thePaneInfo.left;	thePaneInfo.height = resP->bounds.bottom - thePaneInfo.top;	thePaneInfo.visible = (resP->visible != 0);	thePaneInfo.enabled = true;	thePaneInfo.bindings.left =		thePaneInfo.bindings.top =		thePaneInfo.bindings.right =		thePaneInfo.bindings.bottom = false;	thePaneInfo.userCon = 0;	thePaneInfo.superView = inSuperView;										// Mask off useWFont variation code	Int16	controlKind = (resP->procID & ~((Uint16)useWFont));	switch (controlKind) {			case pushButProc:			theStdControl = new LStdButton(thePaneInfo, inValueMessage,									inTextTraitsID, macControlH);			break;					case checkBoxProc:			theStdControl = new LStdCheckBox(thePaneInfo, inValueMessage,									resP->value, inTextTraitsID, macControlH);			break;					case radioButProc:			theStdControl = new LStdRadioButton(thePaneInfo, inValueMessage,									resP->value, inTextTraitsID, macControlH);			break;					case popupMenuProc:			theStdControl = new LStdPopupMenu(thePaneInfo, inValueMessage,									::GetControlMaximum(macControlH),									inTextTraitsID, macControlH);			break;					default:			theStdControl = new LStdControl(thePaneInfo, inValueMessage,									::GetControlValue(macControlH),									::GetControlMinimum(macControlH),									::GetControlMaximum(macControlH),									controlKind, inTextTraitsID,									macControlH);			break;	}	return theStdControl;}// ---------------------------------------------------------------------------//		¥ CreateStdControlStream [static]// ---------------------------------------------------------------------------//	Create a new StdControl from the data in a StreamLStdControl*LStdControl::CreateStdControlStream(	LStream	*inStream){	return (new LStdControl(inStream));}// ---------------------------------------------------------------------------//		¥ LStdControl// ---------------------------------------------------------------------------//	Default ConstructorLStdControl::LStdControl(){	mMacControlH = nil;	mControlKind = -1;				// Illegal control kind	mThumbFunc = nil;	mTextTraitsID = 0;	mUsingBigValues = false;}// ---------------------------------------------------------------------------//		¥ LStdControl(const LStdControl&)// ---------------------------------------------------------------------------//	Copy Constructor////	Current port must be the Window into which to install the controlLStdControl::LStdControl(	const LStdControl	&inOriginal)		: LControl(inOriginal){	mControlKind = inOriginal.mControlKind;	mTextTraitsID = inOriginal.mTextTraitsID;	mThumbFunc = inOriginal.mThumbFunc;	mUsingBigValues = inOriginal.mUsingBigValues;	Rect	frame;					// Get Frame in Local coordinates	if (!CalcLocalFrameRect(frame)) {		SDimension16	frameSize;		GetFrameSize(frameSize);				// Frame is outside of QuickDraw space. NewControl requires			// a rectangle in QuickDraw space, so we have to use an			// artificial location. The Control won't get drawn until			// its SuperView scrolls it into view.					frame.left = 0;		frame.top = 0;		frame.right = frameSize.width;		frame.bottom = frameSize.height;	}		Int16	controlKind = mControlKind;	if (mTextTraitsID != 0) {		// Control does not use System font		controlKind += useWFont;		UTextTraits::SetPortTextTraits(mTextTraitsID);	}		HidePen();						// Don't let the Control Manager draw		StHandleLocker	lock((Handle) inOriginal.mMacControlH);	ControlRecord	*controlP = *inOriginal.mMacControlH;		mMacControlH = ::NewControl(UQDGlobals::GetCurrentPort(), &frame,								controlP->contrlTitle, IsVisible(),								controlP->contrlValue,								controlP->contrlMin, controlP->contrlMax,								mControlKind, 0);		ShowPen();	ThrowIf_(mMacControlH == nil);}// ---------------------------------------------------------------------------//		¥ LStdControl(Int16)// ---------------------------------------------------------------------------//	Construct a StdControl for a particular kind of Toolbox Control////	Current port must be the Window into which to install the controlLStdControl::LStdControl(	Int16	inControlKind){	mThumbFunc = nil;	mUsingBigValues = false;		InitStdControl(inControlKind, 0, "\p", 0);}// ---------------------------------------------------------------------------//		¥ LStdControl// ---------------------------------------------------------------------------//	Construct StdControl from input parameters////	Current port must be the Window into which to install the controlLStdControl::LStdControl(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	Int32			inValue,	Int32			inMinValue,	Int32			inMaxValue,	Int16			inControlKind,	ResIDT			inTextTraitsID,	Str255			inTitle,	Int32			inMacRefCon)		: LControl(inPaneInfo, inValueMessage, inValue,						inMinValue, inMaxValue){	mThumbFunc = nil;	mUsingBigValues = false;		InitStdControl(inControlKind, inTextTraitsID, inTitle, inMacRefCon);}// ---------------------------------------------------------------------------//		¥ LStdControl// ---------------------------------------------------------------------------//	Construct from input parameters and an existing ControlHandleLStdControl::LStdControl(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	Int32			inValue,	Int32			inMinValue,	Int32			inMaxValue,	Int16			inControlKind,	ResIDT			inTextTraitsID,	ControlHandle	inMacControlH)		: LControl(inPaneInfo, inValueMessage, inValue,						inMinValue, inMaxValue){	mMacControlH = inMacControlH;	mThumbFunc = nil;	mControlKind = inControlKind;	mTextTraitsID = inTextTraitsID;	mUsingBigValues = false;}// ---------------------------------------------------------------------------//		¥ LStdControl(LStream*)// ---------------------------------------------------------------------------//	Construct StdControl from a data stream////	Current port must be the Window into which to install the controlLStdControl::LStdControl(	LStream	*inStream)		: LControl(inStream){	Int16	controlKind;	ResIDT	textTraitsID;	Str255	title;	Int32	macRefCon;		inStream->ReadData(&controlKind, sizeof(Int16));	inStream->ReadData(&textTraitsID, sizeof(ResIDT));	inStream->ReadPString(title);	inStream->ReadData(&macRefCon, sizeof(Int32));		mThumbFunc = nil;	mUsingBigValues = false;	InitStdControl(controlKind, textTraitsID, title, macRefCon);}// ---------------------------------------------------------------------------//		¥ InitStdControl// ---------------------------------------------------------------------------//	Private initializer which creates the Toolbox ControlvoidLStdControl::InitStdControl(	Int16	inControlKind,	ResIDT	inTextTraitsID,	Str255	inTitle,	Int32	inMacRefCon){	mControlKind = inControlKind;	// Store ControlKind before changing									//   var code (if using window font)		mTextTraitsID = inTextTraitsID;		if (inTextTraitsID != 0) {		// Control does not use System font		inControlKind += useWFont;		UTextTraits::SetPortTextTraits(inTextTraitsID);	}	Rect	frame;					// Get Frame in Local coordinates	if (!CalcLocalFrameRect(frame)) {				// Frame is outside of QuickDraw space. NewControl requires			// a rectangle in QuickDraw space, so we have to use an			// artificial location. The Control won't get drawn until			// its SuperView scrolls it into view.					frame.left = 0;		frame.top = 0;		frame.right = mFrameSize.width;		frame.bottom = mFrameSize.height;	}		HidePen();						// Don't let the Control Manager draw										// Create Toolbox Control	mMacControlH = ::NewControl(UQDGlobals::GetCurrentPort(), &frame, inTitle,								IsVisible(), mValue, mMinValue, mMaxValue,								inControlKind, inMacRefCon);						// Set Control value, minimum, and maximum, performing			// any necessary scaling or shifting for 32-bit values.			// Don't do this for PopupMenus, which use the values			// for different purposes.	if ((inControlKind < popupMenuProc) ||		(inControlKind > popupMenuProc + 15)) {				SetStdMinAndMax();		Int32	macValue = mValue;		if (mUsingBigValues) {			macValue = CalcSmallValue(macValue);		}		SetControlValue(mMacControlH, macValue);	}		if (mEnabled != triState_On) {		::HiliteControl(mMacControlH, 255);	}		ShowPen();}// ---------------------------------------------------------------------------//		¥ ~LStdControl// ---------------------------------------------------------------------------//	DestructorLStdControl::~LStdControl(){	if (mMacControlH != nil) {		::HidePen();		::DisposeControl(mMacControlH);		::ShowPen();		mMacControlH = nil;	}}ControlHandleLStdControl::GetMacControl(){	return mMacControlH;}// ---------------------------------------------------------------------------//		¥ AlignControlRect// ---------------------------------------------------------------------------//	Set the rectangle inside the Toolbox ControlRecord to the Frame rectangle//	of the StdControl.////	At (almost) all times, the contrlRect field of the Toolbox ControlRecord//	must be the same as the Frame rectangle of the StdControl object. We store//	directly to the ControlRecord rather than using the SizeControl and//	MoveControl traps because we want to bypass the automatic drawing//	(and the need to set the port and coordinate system) performed by//	those traps.////	The contrlRect is not the same as the Frame rectangle if the latter is//	outside the 16-bit QuickDraw coordinate space.voidLStdControl::AlignControlRect(){	if (mMacControlH != nil) {		Rect	frame;		if (CalcLocalFrameRect(frame)) {			(**mMacControlH).contrlRect = frame;		}	}}// ---------------------------------------------------------------------------//		¥ GetDescriptor// ---------------------------------------------------------------------------//	Return the Descriptor, which is the Title, of a StdControlStringPtrLStdControl::GetDescriptor(	Str255	outDescriptor) const{	GetControlTitle(mMacControlH, outDescriptor);	return outDescriptor;}// ---------------------------------------------------------------------------//		¥ SetDescriptor// ---------------------------------------------------------------------------//	Set the Descriptor, which is the Title, of a StdControlvoidLStdControl::SetDescriptor(	ConstStr255Param	inDescriptor){	FocusDraw();	SetControlTitle(mMacControlH, inDescriptor);}// ---------------------------------------------------------------------------//		¥ ResizeFrameBy// ---------------------------------------------------------------------------//	Change the Frame size by the specified amounts////		Override to update the Mac ControlHandlevoidLStdControl::ResizeFrameBy(	Int16		inWidthDelta,	Int16		inHeightDelta,	Boolean		inRefresh){	LPane::ResizeFrameBy(inWidthDelta, inHeightDelta, inRefresh);	AlignControlRect();}// ---------------------------------------------------------------------------//		¥ MoveBy// ---------------------------------------------------------------------------//	Move the location of the Frame by the specified amounts////		Override to update the Mac ControlHandlevoidLStdControl::MoveBy(	Int32		inLeftDelta,	Int32		inTopDelta,	Boolean		inRefresh){	LPane::MoveBy(inLeftDelta, inTopDelta, inRefresh);	AlignControlRect();}// ---------------------------------------------------------------------------//		¥ ValueIsInStdRange [static]// ---------------------------------------------------------------------------//	Return whether a value is within the range supported by the Mac//	Control ManagerBooleanLStdControl::ValueIsInStdRange(	Int32	inValue){	return ((inValue >= min_Int16) && (inValue <= max_Int16));}// ---------------------------------------------------------------------------//		¥ CalcSmallValue// ---------------------------------------------------------------------------//	Map from Big to Small value when using 32 bit values////	Call this function only when mUsingBigValues is true. Control class//	uses Big (32 bit) values, but the Mac Control Manager only supports//	Small (16 bit) values. See the discussion for the SetStdMinAndMax//	function.Int16LStdControl::CalcSmallValue(	Int32	inBigValue){	Int16	smallValue;	Int32	range = mMaxValue - mMinValue;	if (range > max_Int16) {		// Big range									//   Scale factor is the ratio of									//   their ranges		double	ratio = (double) max_Int16 / range;		smallValue = (inBigValue - mMinValue) * ratio;			} else {						// Small range									// Small value is how far Big value is									//   from its minimum value		smallValue = inBigValue - mMinValue;	}	return smallValue;}// ---------------------------------------------------------------------------//		¥ CalcBigValue// ---------------------------------------------------------------------------//	Map from Small to Big value when using 32 bit values////	Call this function only when mUsingBigValues is true. Control class//	uses Big (32 bit) values, but the Mac Control Manager only supports//	Small (16 bit) values. See the discussion for the SetStdMinAndMax//	function.Int32LStdControl::CalcBigValue(	Int16	inSmallValue){	Int32	bigValue;	Int32	range = mMaxValue - mMinValue;	if (range > max_Int16) {		// Big range									//   Scale factor is the ratio of									//   their ranges		double	ratio = (double) range / max_Int16;		bigValue = mMinValue + inSmallValue * ratio;		} else {						// Small range									// Small value is how far Big value is									//   from its minimum value		bigValue = mMinValue + inSmallValue;	}	return bigValue;}// ---------------------------------------------------------------------------//		¥ SetValue// ---------------------------------------------------------------------------//	Set the value of a Standard Control////	Overrides inherited function to map from 32 bit numbers to the 16 bit//	numbers supported by the Mac Control ManagervoidLStdControl::SetValue(	Int32	inValue){	if (inValue < mMinValue) {		// Enforce min/max range		inValue = mMinValue;	} else if (inValue > mMaxValue) {		inValue = mMaxValue;	}		if (inValue != mValue) {		// Do nothing if not changing value			Int16	ctlValue = inValue;		if (mUsingBigValues) {	// Scale from 32 to 16 bit value			ctlValue = CalcSmallValue(inValue);		}					FocusDraw();		::SetControlValue(mMacControlH, ctlValue);									// Let base class adjust value		LControl::SetValue(inValue);	}}// ---------------------------------------------------------------------------//		¥ SetStdMinAndMax// ---------------------------------------------------------------------------//	Sets the minimum and maximum values for the standard Mac control//	associated with a StdControl object////	The Control class uses Big (32 bit) values, but the Mac Control Manager//	only supports Small (16 bit) values. So this StdControl class has//	to map between Big and Small values.////	Using Big Values://	When either the minimum or maximum value is outside 16 bit range//	(below -32,768 or above 32,767), we set mUsingBigValues to true.//	In that case, you must call CalcSmallValue and CalcBigValue to//	map between the Small values used by the Mac Control Manager and the//	Big values used by this class.////	Mapping Strategy://	When using big values, we always set the minimum value for the//	Mac Control to zero. There are two cases for the maximum value,//	depending on whether the difference between the Big Max and Min//	is greater than or less than 32,767. If greater, we set the Mac//	Control maximum to 32,767. If less, we set the Mac Control maximum//	to that difference. These choices simplify the math for converting//	between Big and Small values.////	Here are the mapping equations for the two cases:////	(1) BigMax - BigMin > 32,767////		SmallValue      BigValue - BigMin//		-----------  =  ------------------//		   32,767       (BigMax - BigMin)////	(2) BigMax - BigMin <= 32,767////		SmallValue = BigValue - BigMin////	The functions CalcSmallValue and CalcBigValue use the above equations//	to convert between Big and Small values.voidLStdControl::SetStdMinAndMax(){	FocusDraw();					// Control Manager could redraw		if (ValueIsInStdRange(mMinValue) && ValueIsInStdRange(mMaxValue)) {									// Both Min and Max are in 16 bit range									// Use actual values		mUsingBigValues = false;		SetControlMinimum(mMacControlH, mMinValue);		SetControlMaximum(mMacControlH, mMaxValue);		} else {						// Min and/or Max is out of range		mUsingBigValues = true;									// Always set Min to zero when using									//   Big values		SetControlMinimum(mMacControlH, 0);											// Check difference between Max and Min									//   If difference is in 16 bit range,									//   set Max to the difference		Int32	max = mMaxValue - mMinValue;		if (max > max_Int16) {		//   If difference is out of 16 bit range,			max = max_Int16;		//   set Max to max_Int16		}		SetControlMaximum(mMacControlH, max);	}}voidLStdControl::SetMinValue(	Int32	inMinValue){	if (inMinValue != mMinValue) {		LControl::SetMinValue(inMinValue);		SetStdMinAndMax();	}}voidLStdControl::SetMaxValue(	Int32	inMaxValue){	if (inMaxValue != mMaxValue) {		LControl::SetMaxValue(inMaxValue);		SetStdMinAndMax();	}}voidLStdControl::SetActionProc(	ControlActionUPP	inActionProc){	::SetControlAction(mMacControlH, inActionProc);}voidLStdControl::SetThumbFunc(	ThumbActionFunc	inThumbFunc){	mThumbFunc = inThumbFunc;}BooleanLStdControl::FocusDraw(){	Boolean	focused = LControl::FocusDraw();	if (focused) {		StColorPenState::Normalize();		if (mTextTraitsID != 0) {			UTextTraits::SetPortTextTraits(mTextTraitsID);		}	}	return focused;}			shortLStdControl::FindHotSpot(	Point	inPoint){	return ::TestControl(mMacControlH, inPoint);}BooleanLStdControl::PointInHotSpot(	Point 	inPoint,	Int16	inHotSpot){	return (inHotSpot == ::TestControl(mMacControlH, inPoint));}// ---------------------------------------------------------------------------//		¥ TrackHotSpot// ---------------------------------------------------------------------------//	Track the mouse while it is down after clicking in a Control HotSpot////	Returns whether the mouse is released within the HotSpotBooleanLStdControl::TrackHotSpot(	Int16	inHotSpot,	Point 	inPoint){		// For some bizarre reason, the actionProc for a thumb (indicator)		// has different parameters than that for other parts. This		// class uses the actionProc in the ControlRecord for non-thumb		// parts, and the member variable mThumbFunc for the thumb.		// (ProcPtr)(-1) is a special flag that tells the ControlManager		// to use the actionProc in the ControlRecord.		ControlActionUPP	actionProc;	if (inHotSpot >= inThumb) {		actionProc = (ControlActionUPP) mThumbFunc;	} else {		actionProc = (ControlActionUPP) (-1);	}			// TrackControl handles tracking and returns zero		// if the mouse is released outside the HotSpot		Int16	origValue = ::GetControlValue(mMacControlH);	Boolean	releasedInHotSpot =		::TrackControl(mMacControlH, inPoint, actionProc) != 0;				// Control Manager can change the value while tracking.		// If it did, we need to call SetValue() to update the		// class's copy of the value.			Int32	currValue = ::GetControlValue(mMacControlH);	if (currValue != origValue) {		Int32	newValue = currValue;		if (mUsingBigValues) {		// Scale from 16 to 32 bit value			newValue = CalcBigValue(currValue);		}				SetValue(newValue);	}		return releasedInHotSpot;}// ---------------------------------------------------------------------------//		¥ HotSpotAction// ---------------------------------------------------------------------------//	Take action during mouse down tracking////	inCurrInside tells whether the mouse is currently inside the HotSpot//	inPrevInside tells whether the mouse was inside the HotSpot on the//		previous call to this function////	StdControls use Control Manager callbacks for tracking. This function//	simulates the effect of tracking by hilighting the hot spot.voidLStdControl::HotSpotAction(	Int16		inHotSpot,	Boolean		inCurrInside,	Boolean		inPrevInside){									// If in-out state has changed ...	if (inCurrInside != inPrevInside) {		FocusDraw();										// If inside, hilite the hot spot,									// If outside, unhilite the entire control		::HiliteControl(mMacControlH, inCurrInside ? inHotSpot : 0);	}}// ---------------------------------------------------------------------------//		¥ HotSpotResult// ---------------------------------------------------------------------------//	Perform result of clicking and releasing mouse inside a HotSpotvoidLStdControl::HotSpotResult(	Int16	inHotSpot){	if (inHotSpot >= inThumb) {		BroadcastMessage(msg_ThumbDragged, (void*) this);	}}// ---------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------//	Draw a StdControlvoidLStdControl::DrawSelf(){		// A Mac ControlRecord stores a pointer to its owner window		// port. We have to change it to the current port in case		// we are drawing into a port that is not the owner window. This		// happens when we are printing or drawing into an offscreen port.			WindowPtr	saveOwner = (**mMacControlH).contrlOwner;	(**mMacControlH).contrlOwner = UQDGlobals::GetCurrentPort();	::Draw1Control(mMacControlH);		(**mMacControlH).contrlOwner = saveOwner;}voidLStdControl::ShowSelf(void){	FocusDraw();								// Prevent Control Manager from drawing	Rect	zeroRect = {0, 0, 0, 0};	::ClipRect(&zeroRect);	::ShowControl(mMacControlH);		LView::OutOfFocus(nil);	Refresh();}voidLStdControl::HideSelf(void){	FocusDraw();	::HideControl(mMacControlH);}voidLStdControl::EnableSelf(void){	FocusDraw();	::HiliteControl(mMacControlH, 0);}voidLStdControl::DisableSelf(void){	FocusDraw();	::HiliteControl(mMacControlH, 255);}// ===========================================================================// ¥ LStdButton													  LStdButton ¥// ===========================================================================LStdButton*LStdButton::CreateStdButtonStream(	LStream	*inStream){	return (new LStdButton(inStream));}// ---------------------------------------------------------------------------//		¥ LStdButton// ---------------------------------------------------------------------------//	Default ConstructorLStdButton::LStdButton()	: LStdControl((Int16)pushButProc){}// ---------------------------------------------------------------------------//		¥ LStdButton(LStdButton&)// ---------------------------------------------------------------------------//	Copy ConstructorLStdButton::LStdButton(	const LStdButton	&inOriginal)		: LStdControl(inOriginal){}// ---------------------------------------------------------------------------//		¥ LStdButton// ---------------------------------------------------------------------------//	Construct from input parametersLStdButton::LStdButton(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	ResIDT			inTextTraitsID,	Str255			inTitle)		: LStdControl(inPaneInfo, inValueMessage, 0, 0, 0, pushButProc,						inTextTraitsID, inTitle, 0){}// ---------------------------------------------------------------------------//		¥ LStdButton// ---------------------------------------------------------------------------//	Construct from input parameters and an existing ControlHandleLStdButton::LStdButton(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	ResIDT			inTextTraitsID,	ControlHandle	inMacControlH)		: LStdControl(inPaneInfo, inValueMessage, 0, 0, 0, pushButProc,						inTextTraitsID, inMacControlH){}// ---------------------------------------------------------------------------//		¥ LStdButton(LStream*)// ---------------------------------------------------------------------------//	Construct from data in a StreamLStdButton::LStdButton(	LStream	*inStream)		: LStdControl(inStream){}// ---------------------------------------------------------------------------//		¥ HotSpotResult// ---------------------------------------------------------------------------//	Respond to a click in a StdButtonvoidLStdButton::HotSpotResult(	Int16	inHotSpot){	BroadcastValueMessage();		// Although value doesn't change,									//   send message to inform Listeners									//   that button was clicked}// ===========================================================================// ¥ LDefaultOutline										 LDefaultOutline ¥// ===========================================================================// ---------------------------------------------------------------------------//		¥ LDefaultOutline// ---------------------------------------------------------------------------//	Construct an Outline for the specified host PaneLDefaultOutline::LDefaultOutline(	LPane	*inHostPane){	SDimension16	hostSize;	SPoint32		hostLocation;	inHostPane->GetFrameSize(hostSize);	inHostPane->GetFrameLocation(hostLocation);										// Size and location of Outline depend									//    on Host size and location	PutInside(inHostPane->GetSuperView());	ResizeFrameTo(hostSize.width + 8, hostSize.height + 8, false);		SPoint32		superLocation;	mSuperView->GetFrameLocation(superLocation);	PlaceInSuperFrameAt(hostLocation.h - superLocation.h - 4,						hostLocation.v - superLocation.v - 4, false);										// Use same FrameBinding as host	inHostPane->GetFrameBinding(mFrameBinding);	mEnabled = triState_Off;}// ---------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------//	Draw a LDefaultOutlinevoidLDefaultOutline::DrawSelf(){		// Outline is a three-pixel thick rounded rectangle		// The curvature of the corner is 1/2 the height of the host Pane			Rect	frame;	if (CalcLocalFrameRect(frame)) {		Int16	roundCorner = (mFrameSize.height - 8) / 2;		if (roundCorner < 16) {			roundCorner = 16;		}		StColorPenState::Normalize();		::PenSize(3, 3);		::FrameRoundRect(&frame, roundCorner, roundCorner);	}		}// ===========================================================================// ¥ LStdCheckBox												LStdCheckBox ¥// ===========================================================================LStdCheckBox*LStdCheckBox::CreateStdCheckBoxStream(	LStream	*inStream){	return (new LStdCheckBox(inStream));}// ---------------------------------------------------------------------------//		¥ LStdCheckBox// ---------------------------------------------------------------------------//	Default ConstructorLStdCheckBox::LStdCheckBox()	: LStdControl(checkBoxProc){	SetMaxValue(1);}// ---------------------------------------------------------------------------//		¥ LStdCheckBox(LStdCheckBox&)// ---------------------------------------------------------------------------//	Copy ConstructorLStdCheckBox::LStdCheckBox(	const LStdCheckBox	&inOriginal)		: LStdControl(inOriginal){}// ---------------------------------------------------------------------------//		¥ LStdCheckBox// ---------------------------------------------------------------------------//	Construct from input parametersLStdCheckBox::LStdCheckBox(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	Int32			inValue,			// Must be 0 or 1	ResIDT			inTextTraitsID,	Str255			inTitle)		: LStdControl(inPaneInfo, inValueMessage, inValue, 0, 1,				checkBoxProc, inTextTraitsID, inTitle, 0){}	// ---------------------------------------------------------------------------//		¥ LStdCheckBox// ---------------------------------------------------------------------------//	Construct from input parameters and an existing ControlHandleLStdCheckBox::LStdCheckBox(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	Int32			inValue,			// Must be 0 or 1	ResIDT			inTextTraitsID,	ControlHandle	inMacControlH)		: LStdControl(inPaneInfo, inValueMessage, inValue, 0, 1,						checkBoxProc, inTextTraitsID, inMacControlH){}// ---------------------------------------------------------------------------//		¥ LStdCheckBox(LStream*)// ---------------------------------------------------------------------------//	Construct from data in a StreamLStdCheckBox::LStdCheckBox(	LStream	*inStream)		: LStdControl(inStream){}// ---------------------------------------------------------------------------//		¥ HotSpotResult// ---------------------------------------------------------------------------//	Respond to a click in a StdCheckBox by toggling it between//	checked (value = 0) and unchecked (value = 1)voidLStdCheckBox::HotSpotResult(	Int16	inHotSpot){	SetValue(1 - GetValue());}// ===========================================================================// ¥ LStdRadioButton										 LStdRadioButton ¥// ===========================================================================LStdRadioButton*LStdRadioButton::CreateStdRadioButtonStream(	LStream	*inStream){	return (new LStdRadioButton(inStream));}// ---------------------------------------------------------------------------//		¥ LStdRadioButton// ---------------------------------------------------------------------------//	Default ConstructorLStdRadioButton::LStdRadioButton()	: LStdControl(radioButProc){	SetMaxValue(1);}// ---------------------------------------------------------------------------//		¥ LStdRadioButton(LStdRadioButton&)// ---------------------------------------------------------------------------//	Copy ConstructorLStdRadioButton::LStdRadioButton(	const LStdRadioButton	&inOriginal)		: LStdControl(inOriginal){}// ---------------------------------------------------------------------------//		¥ LStdRadioButton// ---------------------------------------------------------------------------//	Construct from input parametersLStdRadioButton::LStdRadioButton(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	Int32			inValue,			// Must be 0 or 1	ResIDT			inTextTraitsID,	Str255			inTitle)		: LStdControl(inPaneInfo, inValueMessage, inValue, 0, 1,				radioButProc, inTextTraitsID, inTitle, 0){}	// ---------------------------------------------------------------------------//		¥ LStdRadioButton// ---------------------------------------------------------------------------//	Construct from input parameters and an existing ControlHandleLStdRadioButton::LStdRadioButton(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	Int32			inValue,			// Must be 0 or 1	ResIDT			inTextTraitsID,	ControlHandle	inMacControlH)		: LStdControl(inPaneInfo, inValueMessage, inValue, 0, 1,						radioButProc, inTextTraitsID, inMacControlH){}// ---------------------------------------------------------------------------//		¥ LStdRadioButton(LStream*)// ---------------------------------------------------------------------------//	Construct from data in a StreamLStdRadioButton::LStdRadioButton(	LStream	*inStream)		: LStdControl(inStream){}// ---------------------------------------------------------------------------//		¥ HotSpotResult// ---------------------------------------------------------------------------//	Respond to a click in a StdRadioButtonvoidLStdRadioButton::HotSpotResult(	Int16	inHotSpot){		// In the Mac interface, clicking on a RadioButton always		// turns it on (or leaves it on). The standard way to turn		// off a RadioButton is to turn on another one in the		// same Radio Group. A Radio Group will normally be a		// Listener of a RadioButton.		 	SetValue(1);					// Turn button ON	BroadcastMessage(msg_ControlClicked, (void*) this);}// ===========================================================================// ¥ LStdPopupMenu											   LStdPopupMenu ¥// ===========================================================================LStdPopupMenu*LStdPopupMenu::CreateStdPopupMenuStream(	LStream	*inStream){	return (new LStdPopupMenu(inStream));}// ---------------------------------------------------------------------------//		¥ LStdPopupMenu// ---------------------------------------------------------------------------//	Construct from input parametersLStdPopupMenu::LStdPopupMenu(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	Int16			inTitleOptions,	ResIDT			inMENUid,	Int16			inTitleWidth,	Int16			inPopupVariation,	ResIDT			inTextTraitsID,	Str255			inTitle,	OSType			inResTypeMENU,	Int16			inInitialMenuItem)		: LStdControl(inPaneInfo, inValueMessage, inTitleOptions,				inMENUid, inTitleWidth, inPopupVariation, inTextTraitsID,				inTitle, inResTypeMENU){	InitStdPopupMenu(inInitialMenuItem);}// ---------------------------------------------------------------------------//		¥ LStdPopupMenu// ---------------------------------------------------------------------------//	Construct from input parameters and an existing ControlHandleLStdPopupMenu::LStdPopupMenu(	const SPaneInfo	&inPaneInfo,	MessageT		inValueMessage,	Int32			inMaxValue,	ResIDT			inTextTraitsID,	ControlHandle	inMacControlH)		: LStdControl(inPaneInfo, inValueMessage, 1, 1, inMaxValue,						popupMenuProc, inTextTraitsID, inMacControlH){	mValue = 1;					// New popup is always on first menu item}// ---------------------------------------------------------------------------//		¥ LStdPopupMenu(LStream*)// ---------------------------------------------------------------------------//	Construct from data in a StreamLStdPopupMenu::LStdPopupMenu(	LStream	*inStream)		: LStdControl(inStream){		Int16	initialMenuItem;	inStream->ReadData(&initialMenuItem, sizeof(Int16));		InitStdPopupMenu(initialMenuItem);}LStdPopupMenu::~LStdPopupMenu(){	PopupPrivateDataHandle	dataH =		(PopupPrivateDataHandle) (**GetMacControl()).contrlData;	(**dataH).mHandle = nil;	(**dataH).mID = 0;}// ---------------------------------------------------------------------------//		¥ InitStdPopupMenu// ---------------------------------------------------------------------------//	Private initializervoidLStdPopupMenu::InitStdPopupMenu(	Int16	inInitialMenuItem){		// Popups use the initial values for other purposes. Control Manager		// determines min/max from the size of the Menu. So now we have to		// adjust the value, min, and max stored by LControl.			mValue = ::GetControlValue(mMacControlH);	mMinValue = ::GetControlMinimum(mMacControlH);	mMaxValue = ::GetControlMaximum(mMacControlH);			if (inInitialMenuItem != mValue) {		::SetControlValue(mMacControlH, inInitialMenuItem);		mValue = ::GetControlValue(mMacControlH);	}}// ---------------------------------------------------------------------------//		¥ GetMacMenuH// ---------------------------------------------------------------------------//	Return the MenuHandle associated with a StdPopupMenuMenuHandleLStdPopupMenu::GetMacMenuH(){	PopupPrivateDataHandle	dataH =		(PopupPrivateDataHandle) (**GetMacControl()).contrlData;	return (**dataH).mHandle;}