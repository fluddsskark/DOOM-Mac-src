// ===========================================================================//	LScroller.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================////	A Scroller controls the position of another View and may have a//	horizontal and/or vertical scroll bar#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LScroller.h>#include <LStdControl.h>#include <LStream.h>#include <UReanimator.h>#include <UDrawingState.h>#include <PP_Messages.h>// === Universal ProcPtrs for Callback functions ===static ControlActionUPP	sVertSBarAction = nil;static ControlActionUPP	sHorizSBarAction = nil;// ---------------------------------------------------------------------------//		¥ CreateScrollerStream// ---------------------------------------------------------------------------//	Create a new Scroller object, initializing with data from a StreamLScroller*LScroller::CreateScrollerStream(	LStream *inStream){	return (new LScroller(inStream));}// ---------------------------------------------------------------------------//		¥ LScroller// ---------------------------------------------------------------------------//	Default ConstructorLScroller::LScroller(){	mScrollingView = nil;	mScrollingViewID = -1;	mVerticalBar = nil;	mHorizontalBar = nil;}// ---------------------------------------------------------------------------//		¥ LScroller(const LScroller&)// ---------------------------------------------------------------------------//	Copy ConstructorLScroller::LScroller(	const LScroller	&inOriginal)		: LView(inOriginal),		  LListener(inOriginal){	mScrollingView = nil;		mVerticalBar = nil;				// Copy Vertical Scroll Bar	if (inOriginal.mVerticalBar != nil) {		mVerticalBar = new LStdControl(*inOriginal.mVerticalBar);	}		mHorizontalBar = nil;			// Copy Horizontal Scroll Bar	if (inOriginal.mHorizontalBar != nil) {		mHorizontalBar = new LStdControl(*inOriginal.mHorizontalBar);	}}// ---------------------------------------------------------------------------//		¥ LScroller// ---------------------------------------------------------------------------//	Construct a Scroller from input parametersLScroller::LScroller(	const SPaneInfo	&inPaneInfo,	const SViewInfo	&inViewInfo,	Int16			inHorizBarLeftIndent,	Int16			inHorizBarRightIndent,	Int16			inVertBarTopIndent,	Int16			inVertBarBottomIndent,	LView			*inScrollingView)		: LView(inPaneInfo, inViewInfo){	MakeScrollBars(inHorizBarLeftIndent, inHorizBarRightIndent,				   inVertBarTopIndent, inVertBarBottomIndent);		mScrollingViewID = PaneIDT_Undefined;	if (inScrollingView != nil) {		mScrollingViewID = inScrollingView->GetPaneID();		InstallView(inScrollingView);	}}// ---------------------------------------------------------------------------//		¥ LScroller(LStream*)// ---------------------------------------------------------------------------//	Construct a Scroller from the data in a StreamLScroller::LScroller(	LStream	*inStream)		: LView(inStream){	SScrollerInfo	scrollerInfo;	inStream->ReadData(&scrollerInfo, sizeof(SScrollerInfo));			// ScrollingView has not yet been created, since SuperViews are		// created before their subviews when building Panes from a Stream.		// Therefore, we store the ID of the ScrollingView so that the		// FinishCreateSelf function can set up the proper connections.			mScrollingViewID = scrollerInfo.scrollingViewID;	mScrollingView = nil;		MakeScrollBars(scrollerInfo.horizBarLeftIndent,				   scrollerInfo.horizBarRightIndent,				   scrollerInfo.vertBarTopIndent,				   scrollerInfo.vertBarBottomIndent);}// ---------------------------------------------------------------------------//		¥ ~LScroller// ---------------------------------------------------------------------------//	DestructorLScroller::~LScroller(){}voidLScroller::MakeScrollBars(	Int16			inHorizBarLeftIndent,	Int16			inHorizBarRightIndent,	Int16			inVertBarTopIndent,	Int16			inVertBarBottomIndent){	SPaneInfo	barInfo;				// Common information for ScrollBars	barInfo.visible = false;			// ScrollBars aren't visible until	barInfo.enabled = true;				//    Scroller is activated	barInfo.userCon = 0;	barInfo.superView = this;		mHorizontalBar = nil;	if (inHorizBarLeftIndent >= 0) {										// Create Horizontal ScrollBar		barInfo.paneID = PaneIDT_HorizontalScrollBar;			barInfo.width = mFrameSize.width - inHorizBarLeftIndent -										   inHorizBarRightIndent;		barInfo.height = 16;		barInfo.bindings.left = true;		barInfo.bindings.right = true;		barInfo.bindings.top = false;		barInfo.bindings.bottom = true;		barInfo.left = inHorizBarLeftIndent;		barInfo.top = mFrameSize.height - 16;		mHorizontalBar = new LStdControl(barInfo, msg_Nothing, 0, 0, 0,									scrollBarProc, 0, "\p", (Int32) this);													if (sHorizSBarAction == nil) {	// Allocate UPP if necessary			sHorizSBarAction = NewControlActionProc((ProcPtr) HorizSBarAction);		}		mHorizontalBar->SetActionProc(sHorizSBarAction);		mHorizontalBar->AddListener(this);	}		mVerticalBar = nil;	if (inVertBarTopIndent >= 0) {										// Create Vertical ScrollBar		barInfo.paneID = PaneIDT_VerticalScrollBar;			barInfo.width = 16;		barInfo.height = mFrameSize.height - inVertBarTopIndent -											 inVertBarBottomIndent;		barInfo.bindings.left = false;		barInfo.bindings.right = true;		barInfo.bindings.top = true;		barInfo.bindings.bottom = true;		barInfo.left = mFrameSize.width - 16;		barInfo.top = inVertBarTopIndent;		mVerticalBar = new LStdControl(barInfo, msg_Nothing, 0, 0, 0,									scrollBarProc, 0, "\p", (Int32) this);													if (sVertSBarAction == nil) {	// Allocate UPP if necessary			sVertSBarAction = NewControlActionProc((ProcPtr) VertSBarAction);		}		mVerticalBar->SetActionProc(sVertSBarAction);		mVerticalBar->AddListener(this);	}}// ---------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------//	Finish creation of a Scroller by installing its ScrollingViewvoidLScroller::FinishCreateSelf(){	LView	*mScrollingView = (LView*) FindPaneByID(mScrollingViewID);	if (mScrollingView != nil) {		InstallView(mScrollingView);	}}// ---------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------//	Draw a ScrollervoidLScroller::DrawSelf(){	Rect	frame;					// Scroller has a one pixel border	CalcLocalFrameRect(frame);	StColorPenState::Normalize();	::FrameRect(&frame);		if (mVerticalBar != nil) {		MoveTo(frame.right - 16, frame.top);		LineTo(frame.right - 16, frame.bottom - 1);	}		if (mHorizontalBar != nil) {		MoveTo(frame.left, frame.bottom - 16);		LineTo(frame.right - 1, frame.bottom - 16);	}			// When inactive, ScrollBars are hidden. Just outline		// the ScrollBar locations with one pixel borders.		if (!IsActive()) {		if (mVerticalBar != nil) {			mVerticalBar->CalcPortFrameRect(frame);			PortToLocalPoint(topLeft(frame));			PortToLocalPoint(botRight(frame));			::FrameRect(&frame);			::InsetRect(&frame, 1, 1);			::EraseRect(&frame);		}		if (mHorizontalBar != nil) {			mHorizontalBar->CalcPortFrameRect(frame);			PortToLocalPoint(topLeft(frame));			PortToLocalPoint(botRight(frame));			::FrameRect(&frame);			::InsetRect(&frame, 1, 1);			::EraseRect(&frame);		}	}}// ---------------------------------------------------------------------------//		¥ ActivateSelf// ---------------------------------------------------------------------------//	Activate Scroller////	Show ScrollBars that were hidden when DeactivatedvoidLScroller::ActivateSelf(){	if (mVerticalBar != nil) {		mVerticalBar->Show();	}		if (mHorizontalBar != nil) {		mHorizontalBar->Show();	}}// ---------------------------------------------------------------------------//		¥ DeactivateSelf// ---------------------------------------------------------------------------//	Deactivate Scroller////	According to Mac Human Interface Guidelines, ScrollBars in inactive//	windows are hidden.voidLScroller::DeactivateSelf(){		// Suppress drawing, otherwise Control Manager will erase		// the ScrollBars immediately which will cause ugly		// flashes (area is erased to white, then redrawn).		if (FocusDraw()) {		::HidePen();	}		if (mVerticalBar != nil) {		mVerticalBar->Hide();		Rect	frame;		mVerticalBar->CalcPortFrameRect(frame);		ValidPortRect(&frame);	}		if (mHorizontalBar != nil) {		mHorizontalBar->Hide();		Rect	frame;		mHorizontalBar->CalcPortFrameRect(frame);		ValidPortRect(&frame);	}		if (FocusDraw()) {		::ShowPen();		DrawSelf();	}}// ---------------------------------------------------------------------------//		¥ InstallView// ---------------------------------------------------------------------------//	Install a Scrolling View within this ScrollervoidLScroller::InstallView(	LView	*inScrollingView){	mScrollingView = inScrollingView;	AdjustScrollBars();}voidLScroller::ExpandSubPane(	LPane	*inSub,	Boolean	inExpandHoriz,	Boolean	inExpandVert){	SDimension16	subSize;	inSub->GetFrameSize(subSize);	SPoint32		subLocation;	inSub->GetFrameLocation(subLocation);	if (inExpandHoriz) {		subSize.width = mFrameSize.width - 2;		if (mVerticalBar != nil) {			subSize.width -= 15;		}		subLocation.h = 1;	}		if (inExpandVert) {		subSize.height = mFrameSize.height - 2;		if (mHorizontalBar != nil) {			subSize.height -= 15;		}		subLocation.v = 1;	}		inSub->PlaceInSuperFrameAt(subLocation.h, subLocation.v, false);	inSub->ResizeFrameTo(subSize.width, subSize.height, false);}// ---------------------------------------------------------------------------//		¥ AdjustScrollBars// ---------------------------------------------------------------------------//	Adjust the ScrollBars (value, min, and max) according to the current//	state of the Scroller and ScrollingViewvoidLScroller::AdjustScrollBars(){	if (mScrollingView == nil) return;	SPoint32		scrollUnit;	SDimension16	scrollFrameSize;	SDimension32	scrollImageSize;	SPoint32		scrollPosition;	mScrollingView->GetScrollUnit(scrollUnit);	mScrollingView->GetFrameSize(scrollFrameSize);	mScrollingView->GetImageSize(scrollImageSize);	mScrollingView->GetScrollPosition(scrollPosition);		if (mVerticalBar != nil) {		Int32	vertDiff = scrollImageSize.height - scrollFrameSize.height;		if (scrollPosition.v > vertDiff) {			vertDiff = scrollPosition.v;		}		Int32	vertMax = 0;		if (vertDiff > 0) {			vertMax = (vertDiff + scrollUnit.v - 1) / scrollUnit.v;		}		mVerticalBar->SetMaxValue(vertMax);		mVerticalBar->SetValue((scrollPosition.v + scrollUnit.v - 1)									 / scrollUnit.v);	}		if (mHorizontalBar != nil) {		Int32	horizDiff = scrollImageSize.width - scrollFrameSize.width;		if (scrollPosition.h > horizDiff) {			horizDiff = scrollPosition.h;		}		Int32	horizMax = 0;		if (horizDiff > 0) {			horizMax = (horizDiff + scrollUnit.h - 1) / scrollUnit.h;		}		mHorizontalBar->SetMaxValue(horizMax);		mHorizontalBar->SetValue((scrollPosition.h + scrollUnit.h - 1)									/ scrollUnit.h);	}}// ---------------------------------------------------------------------------//		¥ ResizeFrameBy// ---------------------------------------------------------------------------//	Change the Frame size by the specified amountsvoidLScroller::ResizeFrameBy(	Int16		inWidthDelta,	Int16		inHeightDelta,	Boolean		inRefresh){		// Let LView do all the work. All Scroller has to do is		// adjust the ScrollBars to account for the new size		// of the Scroller and resize its Image so it matches		// its Frame size.			LView::ResizeFrameBy(inWidthDelta, inHeightDelta, inRefresh);		AdjustScrollBars();	ResizeImageBy(inWidthDelta, inHeightDelta, false);}// ---------------------------------------------------------------------------//		¥ SubImageChanged// ---------------------------------------------------------------------------//	Adjust state when the Image of the ScrollingView changes////	ScrollBar settings depend on the ScrollingView Image, so adjust them//	to match the current state.voidLScroller::SubImageChanged(	LView	*inSubView){	if (inSubView == mScrollingView) {		AdjustScrollBars();	}}// ---------------------------------------------------------------------------//		¥ ListenToMessage// ---------------------------------------------------------------------------//	Respond to messages from Broadcasters////	The ScrollBars of a Scroller broadcast a message after the user drags//	the thumbvoidLScroller::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	if (inMessage == msg_ThumbDragged) {		LStdControl		*theSBar = (LStdControl*) ioParam;		Int32			scrollValue = theSBar->GetValue();		SPoint32		scrollUnit;		mScrollingView->GetScrollUnit(scrollUnit);		SPoint32		scrollPosition;		mScrollingView->GetScrollPosition(scrollPosition);		if (theSBar == mVerticalBar) {			scrollPosition.v = scrollValue * scrollUnit.v;		} else if (theSBar == mHorizontalBar) {			scrollPosition.h = scrollValue * scrollUnit.h;		}		mScrollingView->ScrollImageTo(scrollPosition.h, scrollPosition.v,										true);		AdjustScrollBars();	}}// ---------------------------------------------------------------------------//		¥ VertScroll// ---------------------------------------------------------------------------//	Function called to scroll vertically while clicking and holding inside//	the vertical scroll barvoidLScroller::VertScroll(	const Int16		inPart){	SPoint32		scrollUnit;	SDimension16	scrollFrameSize;	Int16			vertUnits = 0;		mScrollingView->GetScrollUnit(scrollUnit);	mScrollingView->GetFrameSize(scrollFrameSize);		switch (inPart) {				// Determine how much to scroll			case inUpButton:			// Scroll up one unit			vertUnits = -1;			break;					case inDownButton:			// Scroll down one unit			vertUnits = 1;			break;					case inPageUp:				// Scroll up by Frame height									//   less one unit of overlap			vertUnits = (1 - scrollFrameSize.height) / scrollUnit.v;			if (vertUnits >= 0) {				vertUnits = -1;			}			break;					case inPageDown:			// Scroll down by Frame height									//   less one unit of overlap			vertUnits = (scrollFrameSize.height - 1) / scrollUnit.v;			if (vertUnits <= 0) {				vertUnits = 1;			}			break;	}		if (vertUnits != 0) {		mVerticalBar->IncrementValue(vertUnits);		mScrollingView->ScrollPinnedImageBy(0, vertUnits * scrollUnit.v, true);									// Scrolling changes the focus. The									// Mac Control Manager will be very									// unhappy if we don't restore focus									// to the ScrollBar		mVerticalBar->FocusDraw();	}}// ---------------------------------------------------------------------------//		¥ HorizScroll// ---------------------------------------------------------------------------//	Function called to scroll horizontally while clicking and holding inside//	the horizontal scroll barvoidLScroller::HorizScroll(	const Int16		inPart){	SPoint32		scrollUnit;	SDimension16	scrollFrameSize;	Int16			horizUnits = 0;		mScrollingView->GetScrollUnit(scrollUnit);	mScrollingView->GetFrameSize(scrollFrameSize);		switch (inPart) {				// Determine how much to scroll			case inUpButton:			// Scroll left one unit			horizUnits = -1;			break;					case inDownButton:			// Scroll right one unit			horizUnits = 1;			break;					case inPageUp:				// Scroll left by Frame width									//   less one unit of overlap			horizUnits = (1 - scrollFrameSize.width) / scrollUnit.h;			if (horizUnits >= 0) {				horizUnits = -1;			}			break;					case inPageDown:			// Scroll right by Frame width									//   less one unit of overlap			horizUnits = (scrollFrameSize.width - 1) / scrollUnit.h;			if (horizUnits <= 0) {				horizUnits = 1;			}			break;	}		if (horizUnits != 0) {		mHorizontalBar->IncrementValue(horizUnits);		mScrollingView->ScrollPinnedImageBy(horizUnits * scrollUnit.h, 0, true);									// Scrolling changes the focus, the									// Mac Control Manager will be very									// unhappy if we don't restore focus									// to the ScrollBar		mHorizontalBar->FocusDraw();	}}// ---------------------------------------------------------------------------//		¥ VertSBarAction// ---------------------------------------------------------------------------//	Toolbox callback function for the action to take will tracking a mouse//	click in a vertical scroll barpascal voidLScroller::VertSBarAction(	ControlHandle	inMacControl,	Int16			inPart){		LScroller		*theScroller =							(LScroller *) GetControlReference(inMacControl);	theScroller->VertScroll(inPart);}// ---------------------------------------------------------------------------//		¥ HorizSBarAction// ---------------------------------------------------------------------------//	Toolbox callback function for the action to take will tracking a mouse//	click in a horizontal scroll barpascal voidLScroller::HorizSBarAction(	ControlHandle	inMacControl,	Int16			inPart){	LScroller		*theScroller =							(LScroller *) GetControlReference(inMacControl);	theScroller->HorizScroll(inPart);}