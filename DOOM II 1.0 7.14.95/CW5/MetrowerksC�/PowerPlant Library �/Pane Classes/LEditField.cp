// ===========================================================================//	LEditField.cp					©1993 Metrowerks Inc. All rights reserved.// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <LEditField.h>#include <LStream.h>#include <UTextTraits.h>#include <UDrawingState.h>#include <PP_Messages.h>#include <PP_KeyCodes.h>#ifndef __MEMORY__#include <Memory.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif#ifndef __SCRIPT__#include <Script.h>#endif#ifndef __SCRAP__#include <Scrap.h>#endifconst Uint8	editFlag_Box		= 0x80;const Uint8	editFlag_WordWrap	= 0x40;// ---------------------------------------------------------------------------//		¥ CreateEditFieldStream// ---------------------------------------------------------------------------//	Create a new EditField object from the data in a StreamLEditField*LEditField::CreateEditFieldStream(	LStream	*inStream){	return (new LEditField(inStream));}// ---------------------------------------------------------------------------//		¥ LEditField// ---------------------------------------------------------------------------//	Default ContructorLEditField::LEditField(){	InitEditField();			// Initialize member variables}// ---------------------------------------------------------------------------//		¥ LEditField(LEditField&)// ---------------------------------------------------------------------------//	Copy ContructorLEditField::LEditField(	const LEditField	&inOriginal)		: LPane(inOriginal),		  LCommander(inOriginal){	mKeyFilter = inOriginal.mKeyFilter;	mMaxChars = inOriginal.mMaxChars;	mHasBox = inOriginal.mHasBox;	mHasWordWrap = inOriginal.mHasWordWrap;		Rect	viewRect = {0, 0, 0, 0};	mTextEditH = ::TENew(&viewRect, &viewRect);		SetTextTraitsID(inOriginal.mTextTraitsID);		Str255	theText;	SetDescriptor(inOriginal.GetDescriptor(theText));		AlignTextEditRects();}// ---------------------------------------------------------------------------//		¥ LEditField// ---------------------------------------------------------------------------//	Contruct from input parametersLEditField::LEditField(	const SPaneInfo	&inPaneInfo,	Str255			inString,	ResIDT			inTextTraitsID,	Int16			inMaxChars,	Boolean			inHasBox,	Boolean			inHasWordWrap,	KeyFilterFunc	inKeyFilter,	LCommander		*inSuper)		: LPane(inPaneInfo),		  LCommander(inSuper){	InitEditField();	TESetText(inString + 1, inString[0], mTextEditH);	SetTextTraitsID(inTextTraitsID);	mMaxChars = inMaxChars;	mHasBox = inHasBox;	mHasWordWrap = inHasWordWrap;	mKeyFilter = inKeyFilter;		AlignTextEditRects();	SelectAll();}// ---------------------------------------------------------------------------//		¥ LEditField(LStream*)// ---------------------------------------------------------------------------//	Contruct an EditField from the data in a StreamLEditField::LEditField(	LStream	*inStream)		: LPane(inStream){	InitEditField();		Str255	initialText;	inStream->ReadPString(initialText);	TESetText(initialText+1, initialText[0], mTextEditH);		inStream->ReadData(&mTextTraitsID, sizeof(ResIDT));	SetTextTraitsID(mTextTraitsID);	inStream->ReadData(&mMaxChars, sizeof(Int16));		Uint8	flags;	inStream->ReadData(&flags, sizeof(Uint8));	mHasBox = (flags & editFlag_Box) != 0;	mHasWordWrap = (flags & editFlag_WordWrap) != 0;		Int8	keyFilterID;	inStream->ReadData(&keyFilterID, sizeof(Int8));		switch (keyFilterID) {			case keyFilter_Integer:			mKeyFilter = (KeyFilterFunc) UKeyFilters::IntegerField;			break;					case keyFilter_AlphaNumeric:			mKeyFilter = (KeyFilterFunc) UKeyFilters::AlphaNumericField;			break;					case keyFilter_PrintingChar:			mKeyFilter = (KeyFilterFunc) UKeyFilters::PrintingCharField;			break;	}		AlignTextEditRects();	SelectAll();}// ---------------------------------------------------------------------------//		¥ InitEditField// ---------------------------------------------------------------------------//	Initialize member variables of a EditField to default valuesvoidLEditField::InitEditField(){	Rect	viewRect = {0, 0, 0, 0};	mTextEditH = TENew(&viewRect, &viewRect);		mKeyFilter = nil;	mMaxChars = 255;	mTextTraitsID = 0;	mHasBox = true;	mHasWordWrap = false;}// ---------------------------------------------------------------------------//		¥ ~LEditField// ---------------------------------------------------------------------------//	DestructorLEditField::~LEditField(){	if (mTextEditH != nil) {		::TEDispose(mTextEditH);	}}// ---------------------------------------------------------------------------//		¥ GetDescriptor// ---------------------------------------------------------------------------//	Return the first 255 characters of the EditField as a Pascal string////	Caller must allocate a Str255 variable for storing the stringStringPtrLEditField::GetDescriptor(	Str255	outDescriptor) const{	CharsHandle	theText = ::TEGetText(mTextEditH);	long	len = ::GetHandleSize(theText);	if (len > 255) {					// String is limited to 255 chars 		len = 255;	}	::BlockMove(*theText, outDescriptor+1, len);	outDescriptor[0] = len;	return outDescriptor;}// ---------------------------------------------------------------------------//		¥ SetDescriptor// ---------------------------------------------------------------------------//	Set the contents of an EditField from a Pascal stringvoidLEditField::SetDescriptor(	ConstStr255Param	inDescriptor){	::TESetText(inDescriptor+1, StrLength(inDescriptor), mTextEditH);	Refresh();}// ---------------------------------------------------------------------------//		¥ GetValue// ---------------------------------------------------------------------------//	Return the integer value represented by the contents of an EditField////	An empty or non-numerical EditField evaluates to zeroInt32LEditField::GetValue() const{	Int32	theNumber = 0;	Str255	str;		GetDescriptor(str);	if (str[0] > 0) {		::StringToNum(str, &theNumber);	}	return theNumber;}// ---------------------------------------------------------------------------//		¥ SetValue// ---------------------------------------------------------------------------//	Set the contents of an EditField to the string representation of a//	specified integer numbervoidLEditField::SetValue(	Int32	inValue){	Str255	numberAsString;	::NumToString(inValue, numberAsString);	SetDescriptor(numberAsString);}// ---------------------------------------------------------------------------//		¥ GetMacTEH// ---------------------------------------------------------------------------//	Return a Handle to the Mac TextEdit Record associated with an EditField////	Caller may change record fields, and is responsible for redrawing the//	EditField as necessary to reflect any changes. However, caller must//	not dispose of the TEHandle.TEHandleLEditField::GetMacTEH(){	return mTextEditH;}// ---------------------------------------------------------------------------//		¥ SetMaxChars// ---------------------------------------------------------------------------//	Specify the maximum number of characters that an EditField can containvoidLEditField::SetMaxChars(	Int16	inMaxChars){	mMaxChars = inMaxChars;}// ---------------------------------------------------------------------------//		¥ SetTextTraitsID// ---------------------------------------------------------------------------//	Specify the resource ID of the TextTraits for an EditField////	This function updates the line height to fit the text characteristics.voidLEditField::SetTextTraitsID(	ResIDT	inTextTraitsID){	FocusDraw();	mTextTraitsID = inTextTraitsID;	UTextTraits::SetTETextTraits(mTextTraitsID, mTextEditH);}// ---------------------------------------------------------------------------//		¥ UseWordWrap// ---------------------------------------------------------------------------//	Specify whether the EditField word wraps to its framevoidLEditField::UseWordWrap(	Boolean	inSetting){	if (mHasWordWrap != inSetting) {		mHasWordWrap = inSetting;		AlignTextEditRects();		Refresh();	}}BooleanLEditField::FocusDraw(){	Boolean	focused = LPane::FocusDraw();	if (focused) {		StColorPenState::Normalize();		UTextTraits::SetPortTextTraits(mTextTraitsID);	}		return focused;}// ---------------------------------------------------------------------------//		¥ DrawSelf// ---------------------------------------------------------------------------//	Draw an EditFieldvoidLEditField::DrawSelf(){	Rect	frame;	CalcLocalFrameRect(frame);		if (mHasBox) {				// Draw Border if necessary		::FrameRect(&frame);		::InsetRect(&frame, 2, 2);	}		// A Mac TERec stores a pointer to its owner port  We have to		// change it to the current port in case we are drawing into		// a port that is not the owner port. This happens when we are		// printing or drawing into an offscreen port.			GrafPtr	savePort = (**mTextEditH).inPort;	(**mTextEditH).inPort = UQDGlobals::GetCurrentPort();	::TEUpdate(&frame, mTextEditH);		(**mTextEditH).inPort = savePort;}// ---------------------------------------------------------------------------//		¥ HideSelf// ---------------------------------------------------------------------------//	Hide an EditField. An invisible EditField can't be OnDuty.voidLEditField::HideSelf(){	LPane::HideSelf();	if (IsOnDuty()) {				// Invisible EditField can't be on duty		SwitchTarget(GetSuperCommander());	}}// ---------------------------------------------------------------------------//		¥ ClickSelf// ---------------------------------------------------------------------------//	Respond to Click inside an EditFieldvoidLEditField::ClickSelf(	const SMouseDownEvent	&inMouseDown){	if (!IsTarget()) {				// If not the Target, clicking in an									//   EditField makes it the Target.									// Since TEClick will set a new selection									//   range, clear the current selection									//   range to avoid an ugly flash.		::TESetSelect(0, 0, mTextEditH);		SwitchTarget(this);	}		if (IsTarget()) {		FocusDraw();		::TEClick(inMouseDown.whereLocal,					((inMouseDown.macEvent.modifiers & shiftKey) != 0),					mTextEditH);	}}// ---------------------------------------------------------------------------//		¥ AdjustCursorSelf// ---------------------------------------------------------------------------//	EditField uses the standard I-Beam cursorvoidLEditField::AdjustCursorSelf(	Point				inPortPt,	const EventRecord	&inMacEvent){	CursHandle	theCursH = ::GetCursor(iBeamCursor);	if (theCursH != nil) {		::SetCursor(*theCursH);	}}BooleanLEditField::ObeyCommand(	CommandT	inCommand,	void*		ioParam){	Boolean		cmdHandled = true;		switch (inCommand) {				// For Cut, Copy, and Paste, we must remember to keep the			// local TextEdit Scrap and the Global Scrap in synch			// by calling TEToScrap/TEFromScrap.			case cmd_Cut:			::TECut(mTextEditH);			::ZeroScrap();			::TEToScrap();			UserChangedText();			break;					case cmd_Copy:			::TECopy(mTextEditH);			::ZeroScrap();			::TEToScrap();			break;					case cmd_Paste:			::TEFromScrap();			if (TooManyCharacters(TEGetScrapLength())) {				::SysBeep(1);			// Paste would exceed max field size			} else {				::TEPaste(mTextEditH);				UserChangedText();			}			break;					case cmd_Clear: {			LAction	*theAction = new LAction('Clr ', "\pUndo Clear", this,										SaveStateForUndo());			::TEDelete(mTextEditH);			if (!mSuperCommander->ObeyCommand(msg_ActionDone, theAction)) {				delete theAction;			}			UserChangedText();			break;		}					case msg_TabSelect:			if (!IsEnabled()) {				cmdHandled = false;				break;			} // else FALL THRU to SelectAll()					case cmd_SelectAll:			SelectAll();			break;					default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}		return cmdHandled;}voidLEditField::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	Char16		&outMark,	Str255		outName){	outUsesMark = false;	switch (inCommand) {			case cmd_Cut:				// Cut, Copy, and Clear enabled		case cmd_Copy:				//   if something is selected		case cmd_Clear:			outEnabled = ((**mTextEditH).selStart != (**mTextEditH).selEnd);			break;							case cmd_Paste: {			// Check if TEXT is in the Scrap			Int32	offset;			outEnabled = (::GetScrap(nil, 'TEXT', &offset) > 0);			break;		}				case cmd_SelectAll:			// Check if any characters are present			outEnabled = (**mTextEditH).teLength > 0;			break;					default:			LCommander::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			break;	}}voidLEditField::SetKeyFilter(	KeyFilterFunc	inKeyFilter){	mKeyFilter = inKeyFilter;}// ---------------------------------------------------------------------------//		¥ HandleKeyPress// ---------------------------------------------------------------------------//	Handle key stroke directed at an EditField////	Return true if the EditField handles the keystrokeBooleanLEditField::HandleKeyPress(	const EventRecord&	inKeyEvent){	Boolean		keyHandled = true;	EKeyStatus	theKeyStatus = keyStatus_Input;	Int16		theKey = inKeyEvent.message & charCodeMask;		if (inKeyEvent.modifiers & cmdKey) {	// Always pass up when the command		theKeyStatus = keyStatus_PassUp;	//   key is down		} else if (mKeyFilter != nil) {		theKeyStatus = (*mKeyFilter)(inKeyEvent);	}		switch (theKeyStatus) {			case keyStatus_Input:				// Check if we are at the character limit				// ### Not two-byte char compatible			if (TooManyCharacters(1)) {				SysBeep(1);				break;			}			// Fall thru !!					case keyStatus_TEDelete:			// +++ Set up Action for Undo			FocusDraw();			::TEKey(theKey, mTextEditH);			UserChangedText();			break;					case keyStatus_TECursor:			FocusDraw();			::TEKey(theKey, mTextEditH);			break;					case keyStatus_ExtraEdit:			FocusDraw();			switch (theKey) {								case char_Home:					::TESetSelect(0, 0, mTextEditH);					break;									case char_End:					::TESetSelect(max_Int16, max_Int16, mTextEditH);					break;									case char_FwdDelete:					if (((**mTextEditH).selStart == (**mTextEditH).selEnd) &&						((**mTextEditH).selStart < (**mTextEditH).teLength) ) {						::TESetSelect((**mTextEditH).selStart + 1,										(**mTextEditH).selStart + 1,										mTextEditH);						::TEKey(char_Backspace, mTextEditH);					} else {						::TEDelete(mTextEditH);					}					break;									default:					keyHandled = LCommander::HandleKeyPress(inKeyEvent);					break;			}			break;					case keyStatus_Reject:			// +++ Do something			SysBeep(1);			break;					case keyStatus_PassUp:			keyHandled = LCommander::HandleKeyPress(inKeyEvent);			break;	}		return keyHandled;}// ---------------------------------------------------------------------------//		¥ SelectAll// ---------------------------------------------------------------------------//	Select entire contents of an EditFieldvoidLEditField::SelectAll(){	FocusDraw();	::TESetSelect(0, max_Int16, mTextEditH);}// ---------------------------------------------------------------------------//		¥ AlignTextEditRects// ---------------------------------------------------------------------------//	Align the view and destination rectangles of the Toolbox TextEdit//	record with the Frame of an EditFieldvoidLEditField::AlignTextEditRects(){	Rect	textFrame;	if (CalcLocalFrameRect(textFrame)) {		if (mHasBox) {			::InsetRect(&textFrame, 2, 2);		}									// Set TextEdit view and dest rectangles									//   to be the same as the Frame		(**mTextEditH).viewRect = textFrame;		(**mTextEditH).destRect = textFrame;				if (!mHasWordWrap) {		// If word wrap is off,									//   make the dest rect very wide so that									//   text will autoscroll beyond the edge									//   of the Frame			Int16	destWidth = max_Int16 / 2;												// Direction to extend dest rect depends									//   on the text justification			Int16	just = (**mTextEditH).just;			if (just == teFlushDefault) {									// For left justificaton, GetSysDirection									//    returns teFlushDefault									//    For right, teFlushRight				just = GetSysDirection();			}						switch ((**mTextEditH).just) {							case teFlushLeft:		// Text is fixed on the left and				case teFlushDefault:	//   grows to the right					(**mTextEditH).destRect.right = destWidth;					break;									case teFlushRight:		// Text grows to the left					(**mTextEditH).destRect.left = -destWidth;					break;									case teCenter: {		// Text grows left and right					Int16	center = (textFrame.left + textFrame.right) / 2;					(**mTextEditH).destRect.left = center - destWidth;					(**mTextEditH).destRect.right = center + destWidth;					break;				}			}							}		::TECalText(mTextEditH);	// Let TextEdit adjust line breaks	}}// ---------------------------------------------------------------------------//		¥ TooManyCharacters// ---------------------------------------------------------------------------//	Return whether adding the specified number of characters will exceed//	the maximum allowed. This function assumes that the characters being//	added will replace the current selection.BooleanLEditField::TooManyCharacters(	Int16	inCharsToAdd){	return ( ((**mTextEditH).teLength +			  inCharsToAdd -			  ((**mTextEditH).selEnd - (**mTextEditH).selStart))			 > mMaxChars );}// ---------------------------------------------------------------------------//		¥ ResizeFrameBy// ---------------------------------------------------------------------------//	Change the Frame size by the specified amounts////		inWidthDelta and inHeightDelta specify, in pixels, how much larger//		to make the Frame. Positive deltas increase the size, negative deltas//		reduce the size.voidLEditField::ResizeFrameBy(	Int16		inWidthDelta,	Int16		inHeightDelta,	Boolean		inRefresh){									// Resize Pane	LPane::ResizeFrameBy(inWidthDelta, inHeightDelta, inRefresh);	AlignTextEditRects();}// ---------------------------------------------------------------------------//		¥ MoveBy// ---------------------------------------------------------------------------//	Move the location of the Frame by the specified amounts////		inHorizDelta and inVertDelta specify, in pixels, how far to move the//		Frame (within its surrounding Image). Positive horiz deltas move to//		the left, negative to the right. Positive vert deltas move down,//		negative up.voidLEditField::MoveBy(	Int32		inHorizDelta,	Int32		inVertDelta,	Boolean		inRefresh){	LPane::MoveBy(inHorizDelta, inVertDelta, inRefresh);	AlignTextEditRects();}// ---------------------------------------------------------------------------//		¥ BeTarget// ---------------------------------------------------------------------------//	EditField is becoming the TargetvoidLEditField::BeTarget(){	if (FocusDraw()) {				// Show active selection		::TEActivate(mTextEditH);	// ??? What if we can't Focus ???	}	StartIdling();					// Idle time used to flash the cursor}// ---------------------------------------------------------------------------//		¥ DontBeTarget// ---------------------------------------------------------------------------//	EditField is no longer the Target////	Remove EditField from IdleQueuevoidLEditField::DontBeTarget(){	if (FocusDraw()) {				// Show inactive selection		::TEDeactivate(mTextEditH);	}	StopIdling();					// Stop flashing the cursor}// ---------------------------------------------------------------------------//		¥ SpendTime// ---------------------------------------------------------------------------//	Idle time: Flash the insertion cursorvoidLEditField::SpendTime(	const EventRecord	&inMacEvent){	if (FocusDraw() & IsVisible()) {	// ### Visible check		::TEIdle(mTextEditH);	}}// ---------------------------------------------------------------------------//		¥ UserChangedText// ---------------------------------------------------------------------------//	Text of EditField has changed as a result of user action////	Override to validate field and/or dynamically update as the user//	types. This function is not called by SetDescriptor, which is typically//	used to programatically change the text.voidLEditField::UserChangedText(){}voidLEditField::UndoAction(	ActionIDT	inActionID,	void		*inUndoData){	LAction		*theAction;		switch (inActionID) {			case 'Clr ':			theAction = new LAction('RClr', "\pRedo Clear", this,										SaveStateForUndo());			break;				case 'RClr':			theAction = new LAction('Clr ', "\pUndo Clear", this,										SaveStateForUndo());			break;	}		SEditFieldUndoH	theUndoH = (SEditFieldUndoH) inUndoData;	(**mTextEditH).hText = (**theUndoH).textH;	::TECalText(mTextEditH);	::TESetSelect((**theUndoH).selStart, (**theUndoH).selEnd, mTextEditH);	Refresh();		if (!mSuperCommander->ObeyCommand(msg_ActionDone, theAction)) {		delete theAction;	}}voidLEditField::FinalizeAction(	ActionIDT	inActionID,	void		*inUndoData){	DisposeHandle((Handle) inUndoData);}SEditFieldUndoHLEditField::SaveStateForUndo(){	SEditFieldUndoH	theUndoH = (SEditFieldUndoH)									::NewHandle(sizeof(SEditFieldUndo));	ThrowIfMemFail_(theUndoH);		Handle	currTextH = (**mTextEditH).hText;	::HandToHand(&currTextH);	(**theUndoH).textH = currTextH;	(**theUndoH).selStart = (**mTextEditH).selStart;	(**theUndoH).selEnd = (**mTextEditH).selEnd;		return theUndoH;}voidLEditField::SavePlace(	LStream		*outPlace){	LPane::SavePlace(outPlace);		Rect	viewRect = (**mTextEditH).viewRect;	outPlace->WriteData(&viewRect, sizeof(Rect));	Rect	destRect = (**mTextEditH).destRect;	outPlace->WriteData(&destRect, sizeof(Rect));}voidLEditField::RestorePlace(	LStream		*inPlace){	LPane::RestorePlace(inPlace);	Rect	viewRect;	inPlace->ReadData(&viewRect, sizeof(Rect));	(**mTextEditH).viewRect = viewRect;	Rect	destRect;	inPlace->ReadData(&destRect, sizeof(Rect));	(**mTextEditH).destRect = destRect;}