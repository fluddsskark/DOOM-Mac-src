// ===========================================================================//	UGWorld.cp				 		©1994 Metrowerks Inc. All rights reserved.// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <UGWorld.h>#include <UDrawingState.h>// ===========================================================================//	¥ StOffscreenGWorld Class// ===========================================================================//	Use this class to create temporary GWorlds for offscreen drawing////	Constructor creates an offscreen GWorld and prepares it for drawing//	Destructor copies offscreen image and destroys offscreen GWorld//////	Example with PowerPlant Panes:////	void MyPane::DrawSelf()//	{//		Rect	frame;//		CalcLocalFrameRect(frame);////			// Allocate offscreen GWorld where subsequent drawing//			// operations will take place////		StOffscreenGWorld	offWorld(frame);////		PaintRect(&frame);			// With offscreen drawing, we won't//		InsetRect(&frame, 8, 8);	// see the flash when the white oval//		EraseOval(&frame);			// gets drawn over the black rectangle//		//			// offWorld goes out of scope at end of function//			// It's Destructor gets called, which copies the//			// offscreen image into the Pane and then destroys//			// the offscreen GWorld//	}////	Please note that nothing in the StOffscreenGWorld class depends on the//	PowerPlant Pane system. The only thing you need to do is to properly//	set the current port before declaring a StOffscrenGWorld object.// ---------------------------------------------------------------------------//		¥ StOffscreenGWorld// ---------------------------------------------------------------------------//	Constructor////	Upon entry, the current port must to set to where you want to copy//	the offscreen image when the StOffscreenGWorld object is destroyed////	The inPixelDepth, inFlags, inCTableH, and inGDeviceH parameters//	all have default values (see the header file), so you don't need//	to specify them.////	However, in some cases, you may want to specify an absolute//	pixel depth. It may also be useful to set the useTempMem flag//	so that the offscreen pixels are allocated in temporary memory.//	This is appropriate because StOffscreenGWorlds are meant to be//	temporary, stack-based, objects.StOffscreenGWorld::StOffscreenGWorld(	const Rect	&inBounds,	Int16		inPixelDepth,	GWorldFlags	inFlags,	CTabHandle	inCTableH,	GDHandle	inGDeviceH){		// We need to save the current GWorld because the image from		// the offscreen GWorld will be copied into this GWorld		// in the Destructor.			::GetGWorld(&mSavePort, &mSaveDevice);		mBounds = inBounds;			// NewGWorld interprets the bounds in global coordinates		// when specifying a zero pixel depth. It uses the maximum		// depth of all screen devices intersected by the bounds.		Rect	gwRect = inBounds;	if (inPixelDepth == 0) {		LocalToGlobal(&topLeft(gwRect));		LocalToGlobal(&botRight(gwRect));	}		QDErr	err = ::NewGWorld(&mMacGWorld, inPixelDepth, &gwRect,								inCTableH, inGDeviceH, inFlags);							ThrowIfOSErr_(err);	ThrowIfNil_(mMacGWorld);			// Make offscreen GWorld the current one and prepare it		// for drawing by setting the coordinate system, and locking		// and erasing the pixels.		::SetGWorld(mMacGWorld, nil);	::SetOrigin(mBounds.left, mBounds.top);	::LockPixels(::GetGWorldPixMap(mMacGWorld));	::EraseRect(&mBounds);}// ---------------------------------------------------------------------------//		¥ ~StOffscreenGWorld// ---------------------------------------------------------------------------//	Destructor////	Restores the current Port to what it was before the StOffscreenGWorld//	was created and copies the offscreen image to that PortStOffscreenGWorld::~StOffscreenGWorld(){		// Restore current GWorld to the one which was current		// when the Constructor was called			::SetGWorld(mSavePort, mSaveDevice);			// Copy image from the offscreen GWorld to the current GWorld,		// then destroy the offscreen GWorld		if (mMacGWorld != nil) {		StColorState::Normalize();	// CopyBits wants this		::CopyBits(&((GrafPtr)mMacGWorld)->portBits,					&((GrafPtr)mSavePort)->portBits,					&mBounds, &mBounds, srcCopy, nil);		::UnlockPixels(::GetGWorldPixMap(mMacGWorld));		::DisposeGWorld(mMacGWorld);	}}// ---------------------------------------------------------------------------//		¥ GetMacGWorld// ---------------------------------------------------------------------------//	Return a pointer to the offscreen GWorldGWorldPtrStOffscreenGWorld::GetMacGWorld(){	return mMacGWorld;}// ===========================================================================//	¥ LGWorld Class// ===========================================================================//	Use this class to create GWorlds for offscreen drawing, when you want//	to keep the GWorld for longer than the execution of a single function.////	A typical use would be to create a new LGWorld object (in the heap)//	from the Constructor of a Pane and delete the LGWorld object in the//	Destructor of the Pane. You could then use the LGWorld to store the//	visual image of the Pane.////	For example:////	MyPane::MyPane() {//		Rect	frame;//		CalcLocalFrameRect(frame);//		mGWorld = new LGWorld(frame, 8);//	}////	MyPane::~MyPane() {//		delete mGWorld;//	}////	MyPane::DrawSelf() {//		Rect	frame;//		CalcLocalFrameRect(frame);//		mGWorld->CopyImage(GetMacPort(), frame);//	}////	MyPane::AddRectToImage(Rect &inRect) {//		mGWorld->BeginDrawing();		// Draw to offscreem GWorld//		PaintRect(&inRect);//		mGWorld->EndDrawing();////		Rect	pRect = inRect;			// Force update of new drawing//		LocalToPortPoint(&topleft(pRect));//		LocalToPortPoint(&botRight(pRect));//		InvalPortRect(&pRect);//	}////	With this MyPane class, The AddRectToImage function draws a rectangle to//	the offscreen image and forces an update of the newly drawn area.//	The DrawSelf function just copies the image from the offscreen image//	into the frame of the Pane. All the rectangles painted by calling//	AddRectToImage are accumulated in the offscreen GWorld, so they will//	get redrawn properly on any subsequent screen update.// ---------------------------------------------------------------------------//		¥ LGWorld// ---------------------------------------------------------------------------//	Constructor////	The inPixelDepth, inFlags, inCTableH, and inGDeviceH parameters//	all have default values (see the header file), so you don't need//	to specify them.LGWorld::LGWorld(	const Rect	&inBounds,	Int16		inPixelDepth,	GWorldFlags	inFlags,	CTabHandle	inCTableH,	GDHandle	inGDeviceH){	::GetGWorld(&mSavePort, &mSaveDevice);	mBounds = inBounds;			// NewGWorld interprets the bounds in global coordinates		// when specifying a zero pixel depth. It uses the maximum		// depth of all screen devices intersected by the bounds.		Rect	gwRect = inBounds;	if (inPixelDepth == 0) {		LocalToGlobal(&topLeft(gwRect));		LocalToGlobal(&botRight(gwRect));	}	QDErr	err = ::NewGWorld(&mMacGWorld, inPixelDepth, &gwRect,								inCTableH, inGDeviceH, inFlags);							ThrowIfOSErr_(err);	ThrowIfNil_(mMacGWorld);			// Set up coordinates and erase pixels in GWorld		::SetGWorld(mMacGWorld, nil);	::SetOrigin(mBounds.left, mBounds.top);	::LockPixels(::GetGWorldPixMap(mMacGWorld));	::EraseRect(&mBounds);	::UnlockPixels(::GetGWorldPixMap(mMacGWorld));	::SetGWorld(mSavePort, mSaveDevice);}// ---------------------------------------------------------------------------//		¥ ~LGWorld// ---------------------------------------------------------------------------//	DestructorLGWorld::~LGWorld(){	if (mMacGWorld != nil) {		::DisposeGWorld(mMacGWorld);	}}// ---------------------------------------------------------------------------//		¥ GetMacGWorld// ---------------------------------------------------------------------------//	Return a pointer to the offscreen GWorldGWorldPtrLGWorld::GetMacGWorld(){	return mMacGWorld;}// ---------------------------------------------------------------------------//		¥ BeginDrawing// ---------------------------------------------------------------------------//	Sets the current port to the offscreen GWorld and locks its pixels////	Returns false if the offscreen pixels can't be locked. This will//	happen if the pixPurge flag was set and the pixels were purged//	from memory. If so, you might want to try to reallocate the pixels//	by calling the Toolbox routine UpdateGWorld.////	Every BeginDrawing call must be balanced by a corresponding//	EndDrawing call.BooleanLGWorld::BeginDrawing(){	::GetGWorld(&mSavePort, &mSaveDevice);	::SetGWorld(mMacGWorld, nil);	return ::LockPixels(::GetGWorldPixMap(mMacGWorld));}// ---------------------------------------------------------------------------//		¥ EndDrawing// ---------------------------------------------------------------------------//	Unlocks the GWorld's pixels and restores the current port to what//	it was before BeginDrawing was called.////	Every EndDrawing call must be preceded by a corresponding//	BeginDrawing call.voidLGWorld::EndDrawing(){	::UnlockPixels(::GetGWorldPixMap(mMacGWorld));	::SetGWorld(mSavePort, mSaveDevice);}// ---------------------------------------------------------------------------//		¥ CopyImage// ---------------------------------------------------------------------------//	Copies an image from the offscreen GWorld to the specified Port////	NOTE: You will want to make sure that the foreground color is black//	and the background color is white before calling this function.//	CopyBits() can be unreliable if this is not the case. We don't do//	this automatically here because we want this routine to be fast//	(that's why you usually use offscreen drawing).voidLGWorld::CopyImage(	GrafPtr		inDestPort,	const Rect	&inDestRect,	Int16		inXferMode,	RgnHandle	inMaskRgn){	::CopyBits(&((GrafPtr)mMacGWorld)->portBits,				&inDestPort->portBits,				&mBounds, &inDestRect, inXferMode, inMaskRgn);}