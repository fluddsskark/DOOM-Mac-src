/************************************************************************************ *																																									* *	Offscreen.c																																			* *																																									* *	Movie Compressor's Offscreen graphics environment functions.										* *																																									* *	Copyright (C) 1994 Lion Entertainment, Inc. All Rights Reserved Worldwide.			* *																																									* *	This material contains the valuable proprietary and trade secret								* *	information of Lion Entertainment, Inc. ("Lion") of Austin,	Texas,							* *	U.S.A..; No part of such information may be disclosed, used, reproduced,				* *	or transmitted in any form or by any means -- electronic, mechanical,						* *	or otherwise -- including: photocopying and recording in connection							* *	with any information storage or retrieval system, without permission in					* *	writing from Lion.																															* *																																									* *	Developed by Lion Entertainment.																								* *	Design & Programming by Douglas Grounds.																				* *																																									* *	Created				01/18/94																													* *																																									* ************************************************************************************/#define global extern#include <Errors.h>#include <GestaltEqu.h>#include <Memory.h>#include <OSUtils.h>#include <QuickDraw.h>#include <Types.h>#include <Windows.h>#include "LionDoom.h"#include <Lion.h>#include "offscreen.h"// #include "lionUtils.h" /****************************************************** *	MyStdBits.																				* *																										* *	"StdBits" low-level function that allows a 				* *	DrawPicture or CopyBits that does not remap				* *	pixel values. See the function below for an				* *	example of its use.																* ******************************************************/pascal void MyStdBits (BitMap *srcBits, Rect *srcRect, Rect *dstRect, tWord mode, 	RgnHandle mask){	GrafPtr				destPort;	PixMapHandle	destPixels;	CTabHandle		sourceColors;	tWord					temp;		GetPort(&destPort);	temp = 0;		if ((destPort->portBits.rowBytes & 0x8000) & (srcBits->rowBytes & 0x8000))	{		destPixels = ((CGrafPtr)destPort)->portPixMap;		sourceColors = ((PixMapPtr)srcBits)->pmTable;		/*		if (gMakeCopyOfCTable == TRUE)		{			gMakeCopyOfCTable = kFalse;			gPictCTable = (CTabHandle)CopyOfHandle((tHandle)sourceColors);		}		*/				temp = (**sourceColors).ctSeed;		(**sourceColors).ctSeed = (**(**destPixels).pmTable).ctSeed;	}		StdBits(srcBits, srcRect, dstRect, mode, mask);	if (temp)		(**sourceColors).ctSeed = temp;} /****************************************************** *	DrawPicOffscreen.																	* *																										* *	Given a picture handle, a pointer to a GrafPort		* *	and a destination rectangle, draw a picture				* *	offscreen without remapping pixel values. Uses		* *	"MyStdBits" function above.												* ******************************************************/void DrawPicOffscreen (PicHandle pic, GrafPtr gPtr, Rect *destRect){	GrafPtr			oldPort;	CQDProcs		qd;		if (!gPtr)		return;	GetPort(&oldPort);	SetPort(gPtr);			SetStdCProcs(&qd);		qd.bitsProc = NewQDBitsProc(MyStdBits);		gPtr->grafProcs = (QDProcs *)&qd;		DrawPicture(pic, destRect);		gPtr->grafProcs = NULL;			SetPort(oldPort);}/****************************************************** *	CreateOffScreen.																	* *																										* *	Creates an offscreen environment, including the		* *	Color Graphics port and GDevice handle.						* ******************************************************/ OSErr CreateOffScreen (    Rect       *bounds,     /* Bounding rectangle of off-screen */    tWord      depth,       /* Desired number of bits per pixel in off-screen */    CTabHandle colors,      /* Color table to assign to off-screen */    CGrafPtr   *retPort,    /* Returns a pointer to the new CGrafPort */    GDHandle   *retGDevice) /* Returns a handle to the new GDevice */{	CGrafPtr			newPort;     /* Pointer to the new off-screen CGrafPort */	PixMapHandle	newPixMap;   /* Handle to the new off-screen PixMap */	GDHandle			newDevice;   /* Handle to the new off-screen GDevice */	tLong					qdVersion;   /* Version of QuickDraw currently in use */	GrafPtr				savedPort;   /* Pointer to GrafPort used for save/restore */	tByte					savedState;  /* Saved state of color table handle */	tWord					bytesPerRow; /* Number of bytes per row in the PixMap */	OSErr					error;       /* Returns error code */    	/* Initialize a few things before we begin */	newPort = NULL;	newPixMap = NULL;	newDevice = NULL;	error = noErr;    	/* Save the color table’s current state and make sure it isn’t purgeable */	if (colors != NULL)	{		savedState = HGetState((Handle)colors);		HNoPurge((Handle)colors);	}    	/* Calculate the number of bytes per row in the off-screen PixMap */	bytesPerRow = ((depth * (bounds->right - bounds->left) + 31) >> 5) << 2;    	/* Get the current QuickDraw version */	(void)Gestalt(gestaltQuickdrawVersion, &qdVersion);    	/* Make sure depth is indexed or depth is direct and 32-Bit QD installed */	if (depth == 1 || depth == 2 || depth == 4 || depth == 8 ||		((depth == 16 || depth == 32) && qdVersion >= gestalt32BitQD))	{		/* Maximum number of bytes per row is 16,382; make sure within range */		if (bytesPerRow > kMaxRowBytes)			error = paramErr;	}	else		/* Pixel depth isn’t valid; is parameter error */		error = paramErr;	/* If sanity checks succeed, then allocate a new CGrafPort */	if (error == noErr)	{		newPort = (CGrafPtr)NewPtr(sizeof (CGrafPort));		if (newPort != NULL)		{			/* Save the current port */			GetPort(&savedPort);						/* Initialize the new CGrafPort and make it the current port */			OpenCPort(newPort);			/* Set portRect, visRgn, and clipRgn to the given bounds rect */			newPort->portRect = *bounds;			RectRgn(newPort->visRgn, bounds);			ClipRect(bounds);			/* Initialize the new PixMap for off-screen drawing */			error = SetUpPixMap(depth, bounds, colors, bytesPerRow, newPort->portPixMap);			if (error == noErr)			{				/* Grab the initialized PixMap handle */				newPixMap = newPort->portPixMap;								/* Allocate and initialize a new GDevice */				error = CreateGDevice(newPixMap, &newDevice);			}			/* Restore the saved port */			SetPort(savedPort);		}		else			error = MemError();	}	/* Restore the given state of the color table */	if (colors != NULL)		HSetState((Handle)colors, savedState);	/* One Last Look Around The House Before We Go… */	if (error != noErr)	{		/* Some error occurred; dispose of everything we allocated */		if (newPixMap != NULL)		{			DisposCTable((**newPixMap).pmTable);			DisposPtr((**newPixMap).baseAddr);		}		if (newDevice != NULL)		{			DisposHandle((Handle)(**newDevice).gdITable);			DisposHandle((Handle)newDevice);		}		if (newPort != NULL)		{			CloseCPort(newPort);			DisposPtr((Ptr)newPort);		}	}	else	{		/* Everything’s OK; return refs to off-screen CGrafPort and GDevice */		*retPort = newPort;		*retGDevice = newDevice;	}		return error;}/****************************************************** *	SetUpPixMap.																			* *																										* *	Creates an offscreen environment, including the		* *	Color Graphics port and GDevice handle.						* ******************************************************/ OSErr SetUpPixMap (		tWord					depth,       /* Desired number of bits/pixel in off-screen */		Rect					*bounds,     /* Bounding rectangle of off-screen */		CTabHandle		colors,      /* Color table to assign to off-screen */		tWord					bytesPerRow, /* Number of bytes per row in the PixMap */		PixMapHandle	aPixMap)     /* Handle to the PixMap being initialized */{	CTabHandle	newColors;   /* Color table used for the off-screen PixMap */	Ptr					offBaseAddr; /* Pointer to the off-screen pixel image */	OSErr				error;       /* Returns error code */	tULong			offBaseAddrSize;	error = noErr;	newColors = NULL;	offBaseAddr = NULL;		/* Clone the clut if indexed color; allocate a dummy clut if direct color */	if ((colors != NULL) && (depth <= 8))	{		newColors = colors;		error = HandToHand((Handle *)&newColors);	}	else	{		newColors = (CTabHandle)NewHandle(sizeof(ColorTable) - sizeof(CSpecArray));		error = MemError();	}		if (error == noErr)	{		/* Allocate pixel image; long integer multiplication avoids overflow */		offBaseAddrSize = (tULong)bytesPerRow * (bounds->bottom - bounds->top);/*		offBaseAddr = NewPtr( offBaseAddrSize );				THIS IS A DUMMY ONLY! DON'T USE IT! We're going to assign "screens[0]" to		"baseAddr".*/		goto FakeOffBaseAddr;				if (offBaseAddr != NULL)		{		FakeOffBaseAddr :			/* Initialize fields common to indexed and direct PixMaps */			(**aPixMap).baseAddr = NULL; // offBaseAddr;  /* Point to image */			(**aPixMap).rowBytes = bytesPerRow | /* MSB set for PixMap */				0x8000;			(**aPixMap).bounds = *bounds;        /* Use given bounds */			(**aPixMap).pmVersion = 0;           /* No special stuff */			(**aPixMap).packType = 0;            /* Default PICT pack */			(**aPixMap).packSize = 0;            /* Always zero in mem */			(**aPixMap).hRes = kDefaultRes;      /* 72 DPI default res */			(**aPixMap).vRes = kDefaultRes;      /* 72 DPI default res */			(**aPixMap).pixelSize = depth;       /* Set # bits/pixel */			(**aPixMap).planeBytes = 0;          /* Not used */			(**aPixMap).pmReserved = 0;          /* Not used */			/* Initialize fields specific to indexed and direct PixMaps */			if (depth <= 8)			{				/* PixMap is indexed */				(**aPixMap).pixelType = 0;       /* Indicates indexed */				(**aPixMap).cmpCount = 1;        /* Have 1 component */				(**aPixMap).cmpSize = depth;     /* Component size=depth */				(**aPixMap).pmTable = newColors; /* Handle to CLUT */			}			else			{				/* PixMap is direct */				(**aPixMap).pixelType = RGBDirect; /* Indicates direct */				(**aPixMap).cmpCount = 3;          /* Have 3 components */				if (depth == 16)					(**aPixMap).cmpSize = 5;         /* 5 bits/component */				else					(**aPixMap).cmpSize = 8;         /* 8 bits/component */				(**newColors).ctSeed = 3 * (**aPixMap).cmpSize;				(**newColors).ctFlags = 0;				(**newColors).ctSize = 0;				(**aPixMap).pmTable = newColors;			}		}		else			error = MemError();	}	else		newColors = NULL;	/* If no errors occurred, return a handle to the new off-screen PixMap */	if (error != noErr)	{		if (newColors != NULL)			DisposCTable(newColors);	}	/* Return the error code */	return error;}/****************************************************** *	CreateGDevice.																		* *																										* *	Creates the graphics device.											* ******************************************************/ OSErr CreateGDevice (		PixMapHandle	basePixMap,  /* Handle to the PixMap to base GDevice on */		GDHandle			*retGDevice) /* Returns a handle to the new GDevice */{	GDHandle			newDevice;  /* Handle to the new GDevice */	ITabHandle		embryoITab; /* Handle to the embryonic inverse table */	Rect					deviceRect; /* Rectangle of GDevice */	OSErr					error;      /* Error code */		/* Initialize a few things before we begin */	error = noErr;	newDevice = NULL;	embryoITab = NULL;	/* Allocate memory for the new GDevice */	newDevice = (GDHandle)NewHandle(sizeof (GDevice));	if (newDevice != NULL)	{		/* Allocate the embryonic inverse table */		embryoITab = (ITabHandle)NewHandleClear(2);		if (embryoITab != NULL)		{			/* Set rectangle of device to PixMap bounds */			deviceRect = (**basePixMap).bounds;			/* Initialize the new GDevice fields */			(**newDevice).gdRefNum = 0;            /* Only used for screens */			(**newDevice).gdID = 0;                /* Won’t normally use */			if ((**basePixMap).pixelSize <= 8)				(**newDevice).gdType = clutType;   /* Depth≤8; clut device */			else				(**newDevice).gdType = directType; /* Depth>8; direct device */			(**newDevice).gdITable = embryoITab;   /* 2-byte handle for now */			(**newDevice).gdResPref = kITabRes;    /* Normal inv table res */			(**newDevice).gdSearchProc = NULL;      /* No color-search proc */			(**newDevice).gdCompProc = NULL;        /* No complement proc */			(**newDevice).gdFlags = 0;             /* Will set these later */			(**newDevice).gdPMap = basePixMap;     /* Reference our PixMap */			(**newDevice).gdRefCon = 0;            /* Won’t normally use */			(**newDevice).gdNextGD = NULL;          /* Not in GDevice list */			(**newDevice).gdRect = deviceRect;     /* Use PixMap dimensions */			(**newDevice).gdMode = -1;             /* For nonscreens */			(**newDevice).gdCCBytes = 0;           /* Only used for screens */			(**newDevice).gdCCDepth = 0;           /* Only used for screens */			(**newDevice).gdCCXData = 0;           /* Only used for screens */			(**newDevice).gdCCXMask = 0;           /* Only used for screens */			(**newDevice).gdReserved = 0;          /* Currently unused */			/* Set color-device bit if PixMap isn’t black & white */			if ((**basePixMap).pixelSize > 1)				SetDeviceAttribute(newDevice, gdDevType, true);			/* Set bit to indicate that the GDevice has no video driver */			SetDeviceAttribute(newDevice, noDriver, true);			/* Initialize the inverse table */			if ((**basePixMap).pixelSize <= 8)			{				MakeITable((**basePixMap).pmTable, (**newDevice).gdITable,					(**newDevice).gdResPref);				error = QDError();			}		}		else			error = MemError();	}	else		error = MemError();	/* Handle any errors along the way */	if (error != noErr)	{		if (embryoITab != NULL)			DisposHandle((Handle)embryoITab);		if (newDevice != NULL)			DisposHandle((Handle)newDevice);	}	else		*retGDevice = newDevice;	/* Return a handle to the new GDevice */	return error;}/****************************************************** *	DisposeOffScreen.																	* *																										* *	Disposes of an allocated offscreen color graphics	* *	port and graphics device.													* ******************************************************/ void DisposeOffScreen (	CGrafPtr		doomedPort,    /* Pointer to the CGrafPort to be disposed of */	GDHandle		doomedGDevice) /* Handle to the GDevice to be disposed of */{	CGrafPtr currPort;    /* Pointer to the current port */	GDHandle currGDevice; /* Handle to the current GDevice */		/* Check to see whether the doomed CGrafPort is the current port */	GetPort((GrafPtr *)&currPort);	if (currPort == doomedPort)	{		/* It is; set current port to Window Manager CGrafPort */		GetCWMgrPort(&currPort);		SetPort((GrafPtr)currPort);	}	/* Check to see whether the doomed GDevice is the current GDevice */	currGDevice = GetGDevice();	if (currGDevice == doomedGDevice)		/* It is; set current GDevice to the main screen’s GDevice */		SetGDevice(GetMainDevice());		/* Throw everything away */	(**doomedGDevice).gdPMap = NULL;	DisposeHandle((Handle)(**doomedGDevice).gdITable);	(**doomedGDevice).gdITable = NULL;	DisposGDevice(doomedGDevice);	DisposPtr((**doomedPort->portPixMap).baseAddr);	if ((**doomedPort->portPixMap).pmTable != NULL)		DisposCTable((**doomedPort->portPixMap).pmTable);	CloseCPort(doomedPort);	DisposPtr((Ptr)doomedPort);}