#include "LionDoom.h"#include "Lion.h"#include <Files.h>#include <Folders.h>#include <Errors.h>#if GENERATINGPOWERPC	#pragma options align=mac68k#endif#include <stdlib.h>#include <ctype.h>#include <strings.h>#include "doomdef.h"#include "hu_stuff.h"#include "M_MISC.PROTO.H"#include "R_DATA.PROTO.H"int		rndindex = 0;int 	prndindex = 0;#define kPrefFileName					"\pDoom II Preferences"#define kChatStrSize	64extern void CopyPStr (void *strA, void *strB);extern void AppendPStr (void *dstStr, void *srcStr);extern int		useMouse;extern short	gAppVRefNum;extern long		gAppDirId;extern patch_t	*hu_font[HU_FONTSIZE];typedef unsigned char ChatStr[kChatStrSize];unsigned char rndtable[256] = {	0,   8, 109, 220, 222, 241, 149, 107,  75, 248, 254, 140,  16,  66 ,	74,  21, 211,  47,  80, 242, 154,  27, 205, 128, 161,  89,  77,  36 ,	95, 110,  85,  48, 212, 140, 211, 249,  22,  79, 200,  50,  28, 188 ,	52, 140, 202, 120,  68, 145,  62,  70, 184, 190,  91, 197, 152, 224 ,	149, 104,  25, 178, 252, 182, 202, 182, 141, 197,   4,  81, 181, 242 ,	145,  42,  39, 227, 156, 198, 225, 193, 219,  93, 122, 175, 249,   0 ,	175, 143,  70, 239,  46, 246, 163,  53, 163, 109, 168, 135,   2, 235 ,	25,  92,  20, 145, 138,  77,  69, 166,  78, 176, 173, 212, 166, 113 ,	94, 161,  41,  50, 239,  49, 111, 164,  70,  60,   2,  37, 171,  75 ,	136, 156,  11,  56,  42, 146, 138, 229,  73, 146,  77,  61,  98, 196 ,	135, 106,  63, 197, 195,  86,  96, 203, 113, 101, 170, 247, 181, 113 ,	80, 250, 108,   7, 255, 237, 129, 226,  79, 107, 112, 166, 103, 241 ,	24, 223, 239, 120, 198,  58,  60,  82, 128,   3, 184,  66, 143, 224 ,	145, 224,  81, 206, 163,  45,  63,  90, 168, 114,  59,  33, 159,  95 ,	28, 139, 123,  98, 125, 196,  15,  70, 194, 253,  54,  14, 109, 226 ,	71,  17, 161,  93, 186,  87, 244, 138,  20,  52, 123, 251,  26,  36 ,	17,  46,  52, 231, 232,  76,  31, 221,  84,  37, 216, 165, 212, 106 ,	197, 242,  98,  43,  39, 175, 254, 145, 190,  84, 118, 222, 187, 136 ,	120, 163, 236, 249 };/*====================== M_DrawText== Returns the final X coordinate= HU_Init must have been called to init the font====================*/int M_DrawText (int x, int y, boolean direct, char *string){	int 	c, w;	while (*string)	{		c = toupper(*string) - HU_FONTSTART;		string++;		if (c < 0 || c > HU_FONTSIZE)		{			x += 4;			continue;		}				w = SHORT (hu_font[c]->width);		if (x + w > kScreenWidth)			break;		V_DrawPatchLRes(x, y, 0, hu_font[c]);		x += w;	}    return x;}/* ================== = = P_Random=================== */ int P_Random (void){	prndindex = (prndindex + 1) & 0xFF;	return rndtable[prndindex];}/* ================== = = M_Random=================== */ int M_Random (void){	rndindex = (rndindex + 1) & 0xFF;	return rndtable[rndindex];}/* ================== = = M_ClearRandom=================== */ void M_ClearRandom (void){	rndindex = prndindex = 0;}/* ================== = = M_ClearBox=================== */ void M_ClearBox (fixed_t *box){	box[BOXTOP] = box[BOXRIGHT] = MININT;	box[BOXBOTTOM] = box[BOXLEFT] = MAXINT;}/* ================== = = M_AddToBox=================== */ void M_AddToBox (fixed_t *box, fixed_t x, fixed_t y){	if (x<box[BOXLEFT])		box[BOXLEFT] = x;	else if (x>box[BOXRIGHT])		box[BOXRIGHT] = x;	if (y<box[BOXBOTTOM])		box[BOXBOTTOM] = y;	else if (y>box[BOXTOP])		box[BOXTOP] = y;}/* ================== = = M_WriteFile=================== */  #ifndef O_BINARY#define O_BINARY 0#endifboolean M_WriteFile (char const *name, void *source, int length){	Str255		tempName;	FSSpec		fileSpec;	short		err, fileRefNum;	long		count;		strcpy((char *)tempName, name);	c2pstr((char *)tempName);		err = FSMakeFSSpec(gAppVRefNum, gAppDirId, tempName, &fileSpec);	if (err == fnfErr)	{		err = FSpCreate(&fileSpec, 'idSW', 'idDt', 0);		if (err != noErr)			return FALSE;	}	else if (err != noErr)		return FALSE;		err = FSpOpenDF(&fileSpec, fsRdWrPerm, &fileRefNum);	if (err != noErr)		return FALSE;		count = length;	err = FSWrite(fileRefNum, &count, source);	if (err != noErr)		return FALSE;		err = FSClose(fileRefNum);	if (err != noErr)		return FALSE;	return TRUE;}/* ================== = = M_ReadFile=================== */  int M_ReadFile (char const *name, byte **buffer){	Str255		tempName;	FSSpec		fileSpec;	short		err, fileRefNum;	long		count, eof;	byte		*buf;		strcpy((char *)tempName, name);	c2pstr((char *)tempName);		err = FSMakeFSSpec(gAppVRefNum, gAppDirId, tempName, &fileSpec);	if (err != noErr)		I_Error ("Couldn't make FSSpec for file %s", name);		err = FSpOpenDF(&fileSpec, fsRdWrPerm, &fileRefNum);	if (err != noErr)		I_Error ("Couldn't open file %s", name);		err = GetEOF(fileRefNum, &eof);	if (err != noErr)		I_Error ("Couldn't read eof %s", name);		buf = Z_Malloc (eof, PU_STATIC, NULL);		count = eof;	err = FSRead(fileRefNum, &count, buf);	if (err != noErr)		I_Error ("Couldn't read file %s", name);		err = FSClose(fileRefNum);	if (err != noErr)		I_Error ("Couldn't close file %s", name);	*buffer = buf;	return count;}/* ==============================================================================  							DEFAULTS  ============================================================================== */ int					usejoystick = 0;extern	int			key_right, key_left, key_up, key_down;extern	int			key_strafeleft, key_straferight;extern	int			key_fire, key_use, key_strafe, key_speed;extern	int			mousebfire;extern	int			mousebstrafe;extern	int			mousebforward;extern	int			joybfire;extern	int			joybstrafe;extern	int			joybuse;extern	int			joybspeed;extern	int			viewwidth, viewheight;extern	int			mouseSensitivity;extern	int			showMessages;extern	int			sfxVolume;extern	int			musicVolume;extern	int			detailLevel;extern	int			screenblocks;extern	int			showMessages;// machine-independent sound paramsextern	int			gNumChannels;typedef unsigned char chatStr[64];extern  chatStr 	chat_macros[10];extern Boolean	gMusicOff;extern int			gSndSfxVolume;// From I_Main.cextern Boolean	gKillFinder;extern Boolean	gLargeGraphics;extern int		turboparm;extern int		gTurboScale;// From KeyConfig.cextern int			gDoomMoveConfig;extern int			gActionKeyCharCode;extern int			gActionKeyScanCode;extern int			gFireKeyCharCode;extern int			gFireKeyScanCode;extern int			gFastKey;extern int			gStrafeKey;typedef struct {	int			id;	int			moveConfig;	int			actionKeyCharCode;	int			actionKeyScanCode;	int			fireKeyCharCode;	int			fireKeyScanCode;	int			fastKey;	int			strafeKey;	int			killFinder;	int			largeGraphics;	int			musicOff;	int			turbo;	int			nomonsters;	int			respawn;	int			mouse_sensitivity;	int			sfx_volume;	int			music_volume;	int			show_messages;	int			key_right;	int			key_left;	int			key_up;	int			key_down;	int			key_strafeleft;	int			key_straferight;	int			key_fire;	int			key_use;	int			key_strafe;	int			key_speed;	int			screenblocks;	int			detaillevel;	int			turboScale;	int			expansion[ 63 ];	ChatStr		chatMacros[10];} tPrefs, *tPrefsPtr, **tPrefsHndl;tPrefsHndl				gPrefs = NULL;tPrefsHndl LoadPreferences (void);Boolean PrefsWriteFile (Handle fileData, FSSpec *fSpec, OSType creator, OSType type);Handle PrefsReadFile (FSSpec *fSpec);short SavePreferences (tPrefsHndl prefs);void SetPrefs (tPrefsHndl prefs);/*typedef struct{	char	*name;	int		*location;	int		defaultvalue;	int		scantranslate;		// PC scan code hack	int		untranslated;		// lousy hack} default_t;default_t	defaults[] ={{"mouse_sensitivity",&mouseSensitivity, 5},{"sfx_volume",&sfxVolume, 8},{"music_volume",&musicVolume, 8},{"show_messages",&showMessages, 1},#ifdef __WATCOMC__#define SC_UPARROW              0x48 #define SC_DOWNARROW    		0x50 #define SC_LEFTARROW            0x4b #define SC_RIGHTARROW   		0x4d #define SC_RCTRL		   		0x1d #define SC_RALT			   		0x38 #define SC_RSHIFT		   		0x36 #define SC_SPACE		   		0x39 #define SC_COMMA		   		0x33 #define SC_PERIOD		   		0x34 {"key_right",&key_right, SC_RIGHTARROW,1},{"key_left",&key_left, SC_LEFTARROW,1},{"key_up",&key_up, SC_UPARROW,1},{"key_down",&key_down, SC_DOWNARROW,1},{"key_strafeleft",&key_strafeleft, SC_COMMA,1},{"key_straferight",&key_straferight, SC_PERIOD,1},{"key_fire",&key_fire, SC_RCTRL,1},{"key_use",&key_use, SC_SPACE,1},{"key_strafe",&key_strafe, SC_RALT,1},{"key_speed",&key_speed, SC_RSHIFT,1},#endif#ifdef __NeXT__{"key_right",&key_right, KEY_RIGHTARROW},{"key_left",&key_left, KEY_LEFTARROW},{"key_up",&key_up, KEY_UPARROW},{"key_down",&key_down, KEY_DOWNARROW},{"key_strafeleft",&key_strafeleft, ','},{"key_straferight",&key_straferight, '.'},{"key_fire",&key_fire, ' ',1},{"key_use",&key_use, 'x',1},{"key_strafe",&key_strafe, 'c',1},{"key_speed",&key_speed, 'z',1},#endif#ifdef NORMALUNIX{"key_right",&key_right, KEY_RIGHTARROW},{"key_left",&key_left, KEY_LEFTARROW},{"key_up",&key_up, KEY_UPARROW},{"key_down",&key_down, KEY_DOWNARROW},{"key_strafeleft",&key_strafeleft, ','},{"key_straferight",&key_straferight, '.'},{"key_fire",&key_fire, KEY_RCTRL},{"key_use",&key_use, ' '},{"key_strafe",&key_strafe, KEY_RALT},{"key_speed",&key_speed, KEY_RSHIFT},{"sndserver", (int *) &sndserver_filename, (int) "sndserver"},{"mb_used", &mb_used, 2},#endif{"use_mouse",&usemouse, 1},{"mouseb_fire",&mousebfire,0},{"mouseb_strafe",&mousebstrafe,1},{"mouseb_forward",&mousebforward,2},{"use_joystick",&usejoystick, 0},{"joyb_fire",&joybfire,0},{"joyb_strafe",&joybstrafe,1},{"joyb_use",&joybuse,3},{"joyb_speed",&joybspeed,2},{"screenblocks",&screenblocks, 9},{"detaillevel",&detailLevel, 0},{"snd_channels",&gNumChannels, 3},#ifdef __WATCOMC__{"snd_musicdevice", &snd_DesiredMusicDevice, 0},{"snd_sfxdevice", &snd_DesiredSfxDevice, 0},{"snd_sbport", &snd_SBport, 0x220},{"snd_sbirq", &snd_SBirq, 5},{"snd_sbdma", &snd_SBdma, 1},{"snd_mport", &snd_Mport, 0x330},#endif{"usegamma",&usegamma, 0},{"chatmacro0", (int *) &chat_macros[0], (int) HUSTR_CHATMACRO0 },{"chatmacro1", (int *) &chat_macros[1], (int) HUSTR_CHATMACRO1 },{"chatmacro2", (int *) &chat_macros[2], (int) HUSTR_CHATMACRO2 },{"chatmacro3", (int *) &chat_macros[3], (int) HUSTR_CHATMACRO3 },{"chatmacro4", (int *) &chat_macros[4], (int) HUSTR_CHATMACRO4 },{"chatmacro5", (int *) &chat_macros[5], (int) HUSTR_CHATMACRO5 },{"chatmacro6", (int *) &chat_macros[6], (int) HUSTR_CHATMACRO6 },{"chatmacro7", (int *) &chat_macros[7], (int) HUSTR_CHATMACRO7 },{"chatmacro8", (int *) &chat_macros[8], (int) HUSTR_CHATMACRO8 },{"chatmacro9", (int *) &chat_macros[9], (int) HUSTR_CHATMACRO9 }};// chat_macros[0] = (int)HUSTR_CHATMACRO0;*//*************************************************************** * CopyString * * Copies up to length characters from str1 to str2 * ***************************************************************/static void CopyString(char *str1, char *str2, int length){	int index;		index = 0;		while(index < length && str1[index])	{		str2[index] = str1[index];		index++;	}	str2[index] = '\0';}/*================ M_SaveDefaults===============*/void M_SaveDefaults (void){	if (gPrefs == NULL)		return;		SetPrefs(gPrefs);	(void) SavePreferences(gPrefs);}void SetPrefs (tPrefsHndl prefs){	short			i;	(**prefs).id = 'idD2';	(**prefs).moveConfig = gDoomMoveConfig;	(**prefs).actionKeyCharCode = gActionKeyCharCode;	(**prefs).actionKeyScanCode = gActionKeyScanCode;	(**prefs).fireKeyCharCode = gFireKeyCharCode;	(**prefs).fireKeyScanCode = gFireKeyScanCode;	(**prefs).fastKey = gFastKey;	(**prefs).strafeKey = gStrafeKey;	(**prefs).killFinder = gKillFinder;	(**prefs).largeGraphics = gLargeGraphics;	(**prefs).musicOff = gMusicOff;	(**prefs).turbo = turboparm;	(**prefs).turboScale = gTurboScale;	(**prefs).nomonsters = nomonsters;	(**prefs).respawn = respawnparm;	(**prefs).mouse_sensitivity = mouseSensitivity;	(**prefs).sfx_volume = sfxVolume;	(**prefs).music_volume = musicVolume;	(**prefs).show_messages = showMessages;	(**prefs).key_right = key_right;	(**prefs).key_left = key_left;	(**prefs).key_up = key_up;	(**prefs).key_down = key_down;	(**prefs).key_strafeleft = key_strafeleft;	(**prefs).key_straferight = key_straferight;	(**prefs).key_fire = key_fire;	(**prefs).key_use = key_use;	(**prefs).key_strafe = key_strafe;	(**prefs).key_speed = key_speed;	(**prefs).screenblocks = screenblocks;	(**prefs).detaillevel = detailLevel;		for (i = 0; i < 63; i++)		(**prefs).expansion[i] = 0;	for (i = 0; i < 10; i++)	{		CopyString(&chat_macros[i], (**prefs).chatMacros[i],kChatStrSize);	}	}/*================ M_LoadDefaults===============*/void M_LoadDefaults (void){	int	i;		// set everything to base values	mouseSensitivity = 5;	sfxVolume = 8;	musicVolume = 8;	showMessages = 1;	useMouse = 0;	mousebfire = 0;	mousebstrafe = 1;	mousebforward = 2;	usejoystick = 0;	joybfire = 0;	joybstrafe = 1;	joybuse = 3;	joybspeed = 2;	detailLevel = 0;	screenblocks = 9;	gNumChannels = 3;	usegamma = 0;	gKillFinder = 0;	respawnparm = 1;	gTurboScale = 200;		// Load the preferences.		gPrefs = LoadPreferences();		if (gPrefs != NULL)	{		gDoomMoveConfig = (**gPrefs).moveConfig;		gActionKeyCharCode = (**gPrefs).actionKeyCharCode;		gActionKeyScanCode = (**gPrefs).actionKeyScanCode;		gFireKeyCharCode = (**gPrefs).fireKeyCharCode;		gFireKeyScanCode = (**gPrefs).fireKeyScanCode;		gFastKey = (**gPrefs).fastKey;		gStrafeKey = (**gPrefs).strafeKey;		gLargeGraphics = (**gPrefs).largeGraphics;		gKillFinder = (**gPrefs).killFinder;		gMusicOff = (**gPrefs).musicOff;		turboparm = (**gPrefs).turbo;		gTurboScale = (**gPrefs).turboScale;		nomonsters = (**gPrefs).nomonsters;		respawnparm = (**gPrefs).respawn;		mouseSensitivity = (**gPrefs).mouse_sensitivity;		sfxVolume = (**gPrefs).sfx_volume;		musicVolume = (**gPrefs).music_volume;		showMessages = (**gPrefs).show_messages;		key_right = (**gPrefs).key_right;		key_left = (**gPrefs).key_left;		key_up = (**gPrefs).key_up;		key_down = (**gPrefs).key_down;		key_strafeleft = (**gPrefs).key_strafeleft;		key_straferight = (**gPrefs).key_straferight;		key_fire = (**gPrefs).key_fire;		key_use = (**gPrefs).key_use;		key_strafe = (**gPrefs).key_strafe;		key_speed = (**gPrefs).key_speed;		screenblocks = (**gPrefs).screenblocks;		detailLevel = (**gPrefs).detaillevel;		for (i = 0; i < 10; i++)		{			CopyString((**gPrefs).chatMacros[i], &(chat_macros[i]), kChatStrSize);		}	}} /****************************************************** *	SavePreferences.																	* *																										* *	Save the preferences into the preferences file		* *	in the System 7's Preferences folder.							* ******************************************************/short SavePreferences (tPrefsHndl prefs){	OSErr			err;	tWord			vRefNum;	tLong			dirID;	FSSpec		fSpec;		err = FindFolder(kOnSystemDisk, kPreferencesFolderType, kCreateFolder, 		&vRefNum, &dirID);		if (err == noErr)	{		err = FSMakeFSSpec(vRefNum, dirID, kPrefFileName, &fSpec);				if (err == noErr)		{			if (PrefsWriteFile((Handle)prefs, &fSpec, 'idSW', 'pref') == FALSE)				err = 1;		}	}		return err;}/****************************************************** *	LoadPreferences.																	* *																										* *	Load the preferences from the System 7's					* *	Preferences folder, or create preferences and			* *	write them out.																		* ******************************************************/tPrefsHndl LoadPreferences (void){	OSErr								err;	tWord								vRefNum;	tLong								dirID;	tPrefsHndl					prefs;	FSSpec							fSpec;	Str255							prefsFileName;			prefs = NULL;		CopyPStr(kPrefFileName, prefsFileName);		err = FindFolder(kOnSystemDisk, kPreferencesFolderType, kCreateFolder, 		&vRefNum, &dirID);		if (err == noErr)	{		err = FSMakeFSSpec(vRefNum, dirID, prefsFileName, &fSpec);				if (err == noErr)			prefs = (tPrefsHndl) PrefsReadFile(&fSpec);	}		// Create default preferences and save to disk.		if ((prefs == NULL) || (GetHandleSize((Handle)prefs) != sizeof(tPrefs)))	{		if (prefs != NULL)			DisposeHandle((Handle)prefs);				prefs = (tPrefsHndl) NewHandle(sizeof(tPrefs));		if (prefs == NULL)			return NULL;		else		{			SetPrefs(prefs);						err = FSMakeFSSpec(vRefNum, dirID, prefsFileName, &fSpec);							if ((err == fnfErr) || (err == noErr))				(void) PrefsWriteFile((Handle)prefs, &fSpec, 'idSW', 'pref');			else			{				DisposeHandle((Handle)prefs);				prefs = NULL;			}		}	}		return prefs;}/****************************************************** *	PrefsReadFile.																		* *																										* *	Reads an entire file into memory and returns a		* *	handle to the data file's contents.								* ******************************************************/Handle PrefsReadFile (FSSpec *fSpec){	OSErr			err;	tWord			fRefNum;	Handle		fData;	tLong			curEOF;		fData = NULL;		err = FSpOpenDF(fSpec, fsCurPerm, &fRefNum);	if (err == noErr)	{		err = GetEOF(fRefNum, &curEOF);		if (err == noErr)		{			fData = NewHandle(curEOF);						if (fData != NULL)			{				MoveHHi(fData);				HLock(fData);								err = FSRead(fRefNum, &curEOF, *fData);								HUnlock(fData);								if (err != noErr)				{					DisposeHandle(fData);					fData = NULL;				}								err = FSClose(fRefNum);			}		}	}		return fData;}/****************************************************** *	PrefsWriteFile.																		* *																										* *	Writes out the specified data to a file that is		* *	specified by a file spec. Performs a "safe" save	* *	if the specified file already exists.							* ******************************************************/Boolean PrefsWriteFile (Handle fileData, FSSpec *fSpec, OSType creator, OSType type){	OSErr				err;	FInfo				fndrInfo;	tWord				fRefNum;	tLong				count;	tByte				state;	Str255			fName;	Boolean			fileExists;	FSSpec			writeFile;		writeFile = *fSpec;		// Does the file currently exist?		err = FSpGetFInfo(fSpec, &fndrInfo);	if (err == noErr)	{		Str255		tempStr;				fileExists = TRUE;		CopyPStr(fSpec->name, fName);		count = TickCount();		NumToString(count, tempStr);		AppendPStr(writeFile.name, tempStr);	}	else if (err == fnfErr)		fileExists = FALSE;	else		return FALSE;		err = FSpCreate(&writeFile, creator, type, smSystemScript);	if (err != noErr)		return FALSE;		err = FSpOpenDF(&writeFile, fsRdWrPerm, &fRefNum);	if (err == noErr)	{		count = GetHandleSize(fileData);				state = HGetState(fileData);		MoveHHi(fileData);		HLock(fileData);				err = FSWrite(fRefNum, &count, *fileData);		if (err)		{			HSetState(fileData, state);			err = FSClose(fRefNum);			return FALSE;		}				HSetState(fileData, state);				err = FSClose(fRefNum);		if (err != noErr)			return FALSE;	}	else		return FALSE;		if (fileExists)	{		err = FSpDelete(fSpec);		if (err != noErr)			return FALSE;				err = FSpRename(&writeFile, fSpec->name);		if (err != noErr)			return FALSE;	}		return TRUE;}