#include "LionDoom.h"#include <stdlib.h>#include <stdio.h>#include <Movies.h>#include <Resources.h>#include <Sound.h>#include <Strings.h>#if GENERATINGPOWERPC	#pragma options align=mac68k#endif#include "doomdef.h"#include "p_local.h"#include "S_SOUND.PROTO.H"#define kMaxMacChannels			4/*  * *	External Globals * */extern int						gSndSfxVolume;				// maximum volume of a sound effectextern int						gSndMusicVolume;			// maximum volume of musicextern Boolean				gQuickTimeInstalled;extern Boolean				gQuickTimeLoaded;extern short					gAppVRefNum;extern long						gAppDirId;extern SndChannelPtr	gMacSndChannels[kMaxMacChannels];extern Boolean				gMusicOff;/* * *	Globals * */ channel_t					*gDoomSndChannels = NULL;		// the set of channels availablemusicinfo_t				*gCurrSongPlaying = NULL;		// music currently being playedboolean						gMusicPaused = 0L;						// whether songs are pausedBoolean						gOnCD = 0;static int				nextcleanup = 0L;// following is set by the defaults code in M_miscint								gNumChannels = kMaxMacChannels;						// number of channels availableint								gLastSongStarted;int								gLastSongLooping;/****************************************************** *	S_SetMusicVolume.																	* *																										* *	Calls I_SetMusicVolume in order to set the				* *	volume for the music currently being played.			* *	The acceptable ranges are 0 through 127.					* ******************************************************/void S_SetMusicVolume (int volume){	if (volume < 0 || volume > 127)		I_Error("Attempt to set music volume at %d", volume);		I_SetMusicVolume(volume);	gSndMusicVolume = volume;}/****************************************************** *	S_StopMusic.																			* *																										* *	Stops any music currently being played.						* ******************************************************/void S_StopMusic (void){	if (gCurrSongPlaying)	{		I_StopSong( gCurrSongPlaying->data );				gCurrSongPlaying->data = NULL;	// I_StopSong disposes of movie.		gCurrSongPlaying = NULL;	}}/****************************************************** *	S_ChangeMusic.																		* *																										* *	Starts some music with the music id found in			* *	"sounds.h". Note that this function does not			* *	load from the .WAD file, but rather remaps into		* *	a file name for a QuickTime movie.								* ******************************************************/void S_ChangeMusic (int musicnum, int looping){	musicinfo_t		*music;	char					musicName[60];	OSErr					err;	FSSpec				myFSpec;	short					fRefNum, movieResFile;	Movie					aMovie;		gLastSongStarted = musicnum;	gLastSongLooping = looping;		if (!gQuickTimeInstalled || !gQuickTimeLoaded)		return;		if ((musicnum <= mus_None) || (musicnum >= NUMMUSIC))		I_Error("Bad music number %d", musicnum);	else		music = &S_music[musicnum];		if (gCurrSongPlaying == music)		return;		// stop previous.	S_StopMusic();		if (gOnCD)		goto TryCDRom;		// Try loading the movie from the application directory, i.e.,	// :MIDI:<moviename>.MID!		strcpy(musicName, ":Music:");	strcat(musicName, music->name);	strcat(musicName, ".MID!");	c2pstr(musicName);		err = FSMakeFSSpec(gAppVRefNum, gAppDirId, (unsigned char *)musicName, &myFSpec);		if (err != noErr)		return;		err = OpenMovieFile(&myFSpec, &fRefNum, fsCurPerm);		if (err != noErr)	{	TryCDRom :	// Try looking on the CD/ROM		strcpy(musicName, "Doom II:Music:");		strcat(musicName, music->name);		strcat(musicName, ".MID!");		strcpy((char *)myFSpec.name, musicName);		c2pstr((char *)myFSpec.name);				myFSpec.vRefNum = 0;		myFSpec.parID = 0L;				err = OpenMovieFile(&myFSpec, &fRefNum, fsCurPerm);				if (err != noErr)			return;				gOnCD = TRUE;	}		aMovie = NULL;	movieResFile = 0;		err = NewMovieFromFile (&aMovie, fRefNum, &movieResFile,											(StringPtr)NULL,		// movieName, 											newMovieActive,			// flags											NULL);		if (err != noErr)	{	DeallocateCloseAndReturn :		DisposeMovie(aMovie);		(void) CloseMovieFile(fRefNum);		return;	}		err = LoadMovieIntoRam(aMovie, GetMovieTime(aMovie, 0L), 		GetMovieDuration(aMovie), 0);		if (err != noErr)		goto DeallocateCloseAndReturn;		err = CloseMovieFile(fRefNum);		if (err != noErr)	{	DeallocateAndReturn :		DisposeMovie(aMovie);		return;	}		GoToBeginningOfMovie(aMovie);	if (GetMoviesError() != noErr)		goto DeallocateAndReturn;		music->data = (void *) aMovie;		SetMovieActive(aMovie, TRUE);		if ((err = GetMoviesError()) != noErr)		goto DeallocateAndReturn;		if (gMusicOff == FALSE)	{		StartMovie(aMovie);		if (GetMoviesError() != noErr)			goto DeallocateAndReturn;	}		SetMovieVolume(aMovie, (gSndMusicVolume + 1) * 2);		if (GetMoviesError() != noErr)		goto DeallocateAndReturn;		gCurrSongPlaying = music;}/****************************************************** *	S_StartMusic.																			* *																										* *	Merely calls "S_ChangeMusic" except that anything	* *	that calls this function merely plays a song			* *	once, whereas the call to S_ChangeMusic allows		* *	the music to be specified as looping or not.			* ******************************************************/void S_StartMusic (int m_id){	S_ChangeMusic(m_id, false);}/****************************************************** *	S_StopChannel.																		* *																										* *	Stops the specified channel.											* ******************************************************/void S_StopChannel (int cnum){	int					i;	channel_t		*c = &gDoomSndChannels[cnum];	if (c->sfxinfo)	{		// stop the sound playing		if (I_SoundIsPlaying(c->handle))		{	#ifdef SAWDEBUG			if (c->sfxinfo == &S_sfx[sfx_sawful])				fprintf(stderr, "stopped\n");	#endif			I_StopSound(c->handle);		}		// check to see if other channels are playing the sound		for (i = 0; i < kMaxMacChannels; i++)			if (cnum != i && c->sfxinfo == gDoomSndChannels[i].sfxinfo)				break;		// degrade the sound data's usefulness		c->sfxinfo->usefulness--;		c->sfxinfo = 0;	}}/* *  Changes volume, stereo-separation, and pitch variables from the norm *  of a sound effect to be played.  If the sound is not audible, returns *  a 0.  Otherwise, modifies parameters and returns 1. */int S_AdjustSoundParams (mobj_t *listener, mobj_t *source, int *vol,  int *sep, int *pitch){	fixed_t		approx_dist, adx, ady;	angle_t		angle;	// calculate the sound's distance and clip it if necessary	adx = abs(listener->x - source->x);	ady = abs(listener->y - source->y);	approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1); // _GG1_ p.428	if (gamemap != 8 && approx_dist > S_CLIPPING_DIST)		return 0;	// angle of source to listener	angle = R_PointToAngle2(listener->x, listener->y, source->x, source->y);	if (angle > listener->angle)		angle = angle - listener->angle;	else		angle = angle + (0xffffffff - listener->angle);	angle >>= ANGLETOFINESHIFT;	// stereo separation	*sep = 128 - (FixedMul(S_STEREO_SWING, finesine[angle]) >> FRACBITS);	// volume calculation	if (approx_dist < S_CLOSE_DIST)		*vol = gSndSfxVolume;	else if (gamemap == 8)	{		if (approx_dist > S_CLIPPING_DIST)			approx_dist = S_CLIPPING_DIST;		*vol = 15 + ((gSndSfxVolume-15) *			((S_CLIPPING_DIST - approx_dist) >> FRACBITS)) / S_ATTENUATOR;	}	else		*vol = (gSndSfxVolume * ((S_CLIPPING_DIST - approx_dist) >> FRACBITS))			/ S_ATTENUATOR; // distance effect	return (*vol > 0);}void S_SetSfxVolume (int volume){	short			err, i;	SndCommand		sCmd;		gSndSfxVolume = volume;		for (i = 0; i < kMaxMacChannels; i++)	{		sCmd.cmd = ampCmd;		sCmd.param1 = (255L * (long)gSndSfxVolume) / 127L;		err = SndDoImmediate(gMacSndChannels[i], &sCmd);	}}void S_PauseSound (void){	if (gCurrSongPlaying && !gMusicPaused)	{		I_PauseSong(gCurrSongPlaying->data);		gMusicPaused = true;	}}void S_ResumeSound (void){	if (gCurrSongPlaying && gMusicPaused)	{		I_ResumeSong(gCurrSongPlaying->data);		gMusicPaused = false;	}}void S_StopSound (void *origin){	int		cnum;	for (cnum = 0; cnum < kMaxMacChannels; cnum++)		if (gDoomSndChannels[cnum].sfxinfo && gDoomSndChannels[cnum].origin == origin)		{			S_StopChannel(cnum);			break;		}}/* * * S_getChannel : If none available, return -1.  Otherwise channel #. * */int S_getChannel (void *origin, sfxinfo_t *sfxinfo){	int			cnum;		// channel number to use	channel_t	*c;	// Find an open channel	for (cnum = 0; cnum < kMaxMacChannels ; cnum++)	{		if (!gDoomSndChannels[cnum].sfxinfo)			break;		else if (origin && (gDoomSndChannels[cnum].origin == origin))		{			S_StopChannel(cnum);			break;		}	}	// None available	if (cnum == kMaxMacChannels)	{		// Look for lower priority		for (cnum = 0; cnum < kMaxMacChannels; cnum++)			if (gDoomSndChannels[cnum].sfxinfo->priority >= sfxinfo->priority)				break;		// FUCK!  No lower priority.  Sorry, Charlie.		if (cnum == kMaxMacChannels)			return -1;		// Otherwise, kick out lower priority		else			S_StopChannel(cnum);	}		c = &gDoomSndChannels[cnum];		// channel is decided to be cnum.	c->sfxinfo = sfxinfo;	c->origin = origin;		return cnum;}// #define __WRITE_SOUND_RESOURCE		1void S_StartSoundAtVolume (void *origin_p, int sfx_id, int volume){  int					rc, sep, pitch, priority;  sfxinfo_t		*sfx;  int					cnum;  mobj_t			*origin = (mobj_t *) origin_p;	if (gSndSfxVolume == 0)		return;#ifdef RANGECHECKING	// check for bogus sound #	if (sfx_id < 1 || sfx_id > NUMSFX)		I_Error("Bad sfx #: %d", sfx_id);#endif		sfx = &S_sfx[sfx_id];	// Initialize sound parameters	if (sfx->link)	{		pitch = sfx->pitch;		priority = sfx->priority;		volume += sfx->volume;		if (volume < 1)			return;		if (volume > gSndSfxVolume)			volume = gSndSfxVolume;	}	else	{		pitch = NORM_PITCH;		priority = NORM_PRIORITY;	}	// Check to see if it's audible, and if not, modify the params	if (origin && origin != players[consoleplayer].mo)	{		rc = S_AdjustSoundParams(players[consoleplayer].mo, origin, &volume,			&sep, &pitch);		if (	origin->x == players[consoleplayer].mo->x			&&	origin->y == players[consoleplayer].mo->y)			sep = NORM_SEP;		if (!rc)			return;	}	else	{		sep = NORM_SEP;	}	// hacks to vary the sfx pitches	if (sfx_id >= sfx_sawup && sfx_id <= sfx_sawhit)	{		pitch += 8 - (M_Random()&15);		if (pitch < 0)			pitch = 0;		else if (pitch > 255)			pitch = 255;	}	else if (sfx_id != sfx_itemup && sfx_id != sfx_tink)	{		pitch += 16 - (M_Random() & 31);		if (pitch < 0)			pitch = 0;		else if (pitch > 255)			pitch = 255;	}	// kill old sound	S_StopSound(origin);	// try to find a channel	cnum = S_getChannel(origin, sfx);	if (cnum < 0)		return;	// get lumpnum if necessary	if (sfx->lumpnum < 0)		sfx->lumpnum = I_GetSfxLumpNum(sfx);		// cache data if necessary	if (!sfx->data)		sfx->data = (void *) W_CacheLumpNum(sfx->lumpnum, PU_MUSIC);#ifdef __WRITE_SOUND_RESOURCE	if (sfx_id == sfx_pistol)	{		Handle		myHandle;		int				howbig;				myHandle = NewHandle( howbig = W_LumpLength(sfx->lumpnum) );		BlockMoveData(sfx->data, *myHandle, howbig);		AddResource(myHandle, 'idXX', 128, "\p");		if (ResError() == noErr)		{			UpdateResFile(HomeResFile(myHandle));			SysBeep(1);		}		else			DisposeHandle((Handle)myHandle);	}#endif	// increase the usefulness	if (sfx->usefulness++ < 0)		sfx->usefulness = 1;	gDoomSndChannels[cnum].handle =		I_StartSound(cnum /* sfx_id */, sfx->data, volume, sep, pitch, priority,			lumpinfo[sfx->lumpnum].size);}void S_StartSound (void *origin, int sfx_id){#ifdef SAWDEBUG	// if (sfx_id == sfx_sawful)		sfx_id = sfx_itemup;#endif	S_StartSoundAtVolume(origin, sfx_id, gSndSfxVolume);	#ifdef SAWDEBUG	{		int				i, n;		static mobj_t	*last_saw_origins[10] = {1,1,1,1,1,1,1,1,1,1};		static int		first_saw = 0;		static int		next_saw = 0;				if (sfx_id == sfx_sawidl || sfx_id == sfx_sawful || sfx_id == sfx_sawhit)		{			for (i = first_saw; i != next_saw; i = (i + 1) % 10)				if (last_saw_origins[i] != origin)					fprintf(stderr, "old origin 0x%lx != origin 0x%lx for sfx %d\n",			last_saw_origins[i], origin, sfx_id);			last_saw_origins[next_saw] = origin;			next_saw = (next_saw + 1) % 10;			if (next_saw == first_saw)				first_saw = (first_saw + 1) % 10;			for (n = i = 0; i < kMaxMacChannels; i++)			{				if (gDoomSndChannels[i].sfxinfo == &S_sfx[sfx_sawidl]						|| gDoomSndChannels[i].sfxinfo == &S_sfx[sfx_sawful]						|| gDoomSndChannels[i].sfxinfo == &S_sfx[sfx_sawhit])					n++;			}			if (n > 1)			{				for (i = 0; i < kMaxMacChannels; i++)				{					if (gDoomSndChannels[i].sfxinfo == &S_sfx[sfx_sawidl]						|| gDoomSndChannels[i].sfxinfo == &S_sfx[sfx_sawful]						|| gDoomSndChannels[i].sfxinfo == &S_sfx[sfx_sawhit])					{						fprintf(stderr, "chn: sfxinfo=0x%lx, origin=0x%lx, handle=%d\n",							gDoomSndChannels[i].sfxinfo, gDoomSndChannels[i].origin, gDoomSndChannels[i].handle);					}				}				fprintf(stderr, "\n");			}		}	}#endif}void S_ServiceMusic (void){	// service QuickTime music	if (gCurrSongPlaying && !gMusicPaused && !gMusicOff)	{		if (gCurrSongPlaying->data)		{		// ее Optimize: set timer from beginning!			if (IsMovieDone((Movie)gCurrSongPlaying->data))			{				if (gLastSongLooping)				{					GoToBeginningOfMovie((Movie)gCurrSongPlaying->data);					StartMovie((Movie)gCurrSongPlaying->data);					MoviesTask((Movie)gCurrSongPlaying->data, 4L);				}				else				{					S_StopMusic();				}			}						if (!gMusicOff && !gMusicPaused && (gCurrSongPlaying != NULL))			{				MoviesTask((Movie)gCurrSongPlaying->data, 4L);			}		}	}}void S_UpdateSounds (void *listener_p){	int					i;	int					audible, cnum;	int					volume, sep, pitch;	sfxinfo_t		*sfx;	channel_t		*c;	mobj_t			*listener = (mobj_t*)listener_p;		// clean up unused data	if (gametic > nextcleanup)	{		for (i = 1; i < NUMSFX; i++)		{			if (S_sfx[i].usefulness < 1 && S_sfx[i].usefulness > -1)				if (--S_sfx[i].usefulness == -1)				{					Z_ChangeTag(S_sfx[i].data, PU_CACHE);					S_sfx[i].data = 0;				}		}		nextcleanup = gametic + 15;				if (gQuickTimeInstalled && gQuickTimeLoaded)		{			S_ServiceMusic();				// kill music if it's a single-play && finished			if (gMusicOff == FALSE)				if (gCurrSongPlaying && !gLastSongLooping && !I_QrySongPlaying(gCurrSongPlaying) && !gMusicPaused )					S_StopMusic();		}	}		for (cnum = 0; cnum < kMaxMacChannels; cnum++)	{		c = &gDoomSndChannels[cnum];		sfx = c->sfxinfo;		if (c->sfxinfo)		{			if (I_SoundIsPlaying(c->handle))			{				// initialize parameters				volume = gSndSfxVolume;				pitch = NORM_PITCH;				sep = NORM_SEP;				if (sfx->link)				{					pitch = sfx->pitch;					volume += sfx->volume;					if (volume < 1)					{						S_StopChannel(cnum);						continue;					}					else if (volume > gSndSfxVolume)						volume = gSndSfxVolume;				}				// check non-local sounds for distance clipping or modify their params				if (c->origin && listener_p != c->origin)				{					audible = S_AdjustSoundParams(listener, c->origin, &volume, &sep,						&pitch);					if (!audible)					{						S_StopChannel(cnum);					}					else						I_UpdateSoundParams(c->handle, volume, sep, pitch);				}				// if channel is allocated but sound has stopped, free it			}			else S_StopChannel(cnum);		}	}}void S_Init (int sfxVolume, int musicVolume){	int			i;	// I_SetChannels(numChannels);	S_SetSfxVolume(sfxVolume);	S_SetMusicVolume(musicVolume);  	gDoomSndChannels =		(channel_t *) NewPtrClear(kMaxMacChannels * sizeof(channel_t));		// free all channels for use	for (i = 0; i < kMaxMacChannels; i++)		gDoomSndChannels[i].sfxinfo = 0;		// no sounds are playing, and they ain't gMusicPaused	gMusicPaused = 0;	for (i = 1; i < NUMSFX; i++)		S_sfx[i].lumpnum = S_sfx[i].usefulness = -1;}void S_Start (void){	int		cnum;	int		mnum;	// kill all playing sounds at start of level (trust me- a good idea)	for (cnum = 0; cnum < kMaxMacChannels; cnum++)		if (gDoomSndChannels[cnum].sfxinfo)			S_StopChannel(cnum);		// start new music for the level	gMusicPaused = 0;		if (commercial)		mnum = mus_runnin + gamemap - 1;	else		mnum = mus_e1m1 + ((gameepisode - 1) * 9) + (gamemap - 1);	S_ChangeMusic(mnum, true);	nextcleanup = 15;}