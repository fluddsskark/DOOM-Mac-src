#ifndef __MPW_VERSION__	#if defined(powerc) || defined (__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#else	#include <Files.h>	#include <Dialogs.h>#endif#include "LionDoom.h"#include <stdlib.h>#if __profile__	#include "profiler.h"#endif#include <Connections.h>#include "PCMacNet.h"// D_main.c#ifdef __WATCOMC__#include <dos.h>#include <io.h>#include <stdlib.h>#endif#ifdef __NeXT__#include <libc.h>#endif#ifdef NORMALUNIX#include <stdio.h>#include <stdlib.h>#include <unistd.h>#endif#include "doomdef.h"#include "dutils.h"#include "DebugSwitches.h"void mprintf(char *string);/* * *	External Globals. * */extern Boolean		gPlayAlone;extern Rect			gDrawRect;extern Boolean		gNeedsUpdate;extern Boolean		gLoadGamePending;extern Boolean		gInitialLoadGame;extern int			gOneTimeFullUpdate;extern int			gOldGHiRes;extern int			forwardmove[2];extern int			sidemove[2];extern int			gMacStartTicks;extern  int			sfxVolume;extern  int			musicVolume;extern  boolean		inhelpscreens;extern  boolean		setsizeneeded;extern  int			showMessages;extern WindowPtr	gDoomWindow;extern  boolean		demorecording;extern boolean		novideo;extern int			useMouse;extern short		gCursID;extern void CloseStatusDialog (void);extern void StatusDialog (long total, long current);extern void DrawStatusDialog (Boolean forUpdate);extern void MyInitCursor (void);extern void StatusParamText(char *one, char *two, char *three, char *four);/* * *	File-Level Globals. * */ int					demosequence = 0;int					pagetic = 0;char				*pagename = NULL;boolean				shareware = 0;			// true if only episode 1 presentboolean				registered = 0;			// true if complete versionboolean				commercial = 0;			// true if DOOM II: Hell On Earthboolean				devparm = 0;			// started game with -devparmextern boolean		nomonsters;			// checkparm of -nomonstersextern boolean		respawnparm;		// checkparm of -respawnextern boolean		fastparm;			// checkparm of -fastboolean				drone = 0;boolean				singletics = false;		// debug flag to cancel adaptivenessboolean				modifiedgame = 0;		// set if homebrew stuff has been addedskill_t				startskill = sk_medium;int					startepisode = 1, startmap = 1;boolean				autostart = 0;#if __DO_DEBUG__	FILE			*debugfile = NULL;#endifboolean				advancedemo = 0;// wipegamestate can be set to -1 to force a wipe on the next drawgamestate_t			wipegamestate = GS_DEMOSCREEN;#define MAXWADFILES             8char    wadfile[1024];          // primary wad filechar    mapdir[1024];           // directory of development mapschar    basedefault[1024];      // default fileFSSpec	gWadFiles[MAXWADFILES];int		gNumWads = 0;#include "D_MAIN.PROTO.H"extern void MySetCursor (short cursID);void D_CheckNetGame (void);void D_ProcessEvents (void);void G_BuildTiccmd (ticcmd_t *cmd);void D_DoAdvanceDemo (void);void UpdateDoomWindow (void);/*===============================================================================							EVENT HANDLINGEvents are asyncronous inputs generally generated by the game user. Events can be discarded if no responder claims them===============================================================================*/event_t         events[MAXEVENTS] = { { 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 },					{ 0, 0, 0, 0 }, { 0, 0, 0, 0 } };int             eventhead = 0, eventtail = 0;/*====================== D_PostEvent== Called by the I/O functions when input is detected====================*/void D_PostEvent (event_t *ev){	events[eventhead] = *ev;	eventhead = (++eventhead) & (MAXEVENTS - 1);}/*====================== D_ProcessEvents== Send all the events of the given timestamp down the responder chain====================*/void D_ProcessEvents (void){	event_t         *ev;		// IF STORE DEMO, DON'T ACCEPT INPUT	if (commercial && (W_CheckNumForName("map01") < 0))		return;		for ( ; eventtail != eventhead ; eventtail = (++eventtail)&(MAXEVENTS - 1) )	{		ev = &events[eventtail];		if (M_Responder (ev))			continue;               // menu ate the event		G_Responder (ev);	}}//=============================================================================/* ¥¥JDMfixed_t FixedDiv (fixed_t a, fixed_t b){	if ( (abs(a) >> 14) >= abs(b))		return (a ^ b) < 0 ? MININT : MAXINT;		return (fixed_t) FixDiv (a, b);}*///=============================================================================/*=============== D_Display== draw current display, possibly wiping it from the previous=============*/void R_ExecuteSetViewSize (void);void D_Display (void){	static  boolean         viewactivestate = false;	static  boolean         menuactivestate = false;	static  boolean         inhelpscreensstate = false;	static  boolean         fullscreen = false;	static  gamestate_t     oldgamestate = -1;	static  int             borderdrawcount;	int                     nowtime, tics;	int                     wipestart, y;	boolean                 done, wipe, redrawsbar;	Boolean					oldHiRes;		if (nodrawers)		return;                    // for comparative timing / profiling	/*	if (gStatusDialog)		CloseStatusDialog();*/		redrawsbar = false;	//// change the view size if needed//	if (setsizeneeded)	{		R_ExecuteSetViewSize ();		oldgamestate = -1;                      // force background redraw		borderdrawcount = 3;	}//// save the current screen if about to wipe//	if (gamestate != wipegamestate)	{		wipe = true;		wipe_StartScreen(0, 0, kScreenWidth, kScreenHeight);	}	else		wipe = false;		if (gamestate == GS_LEVEL && gametic)		HU_Erase();//// do buffered drawing//	switch (gamestate)	{		case GS_LEVEL:			if (!gametic)				break;			if (automapactive)				AM_Drawer ();						if (inhelpscreensstate && !inhelpscreens)				redrawsbar = true;              // just put away the help screen						if (gHiRes)			{				if (wipe || (viewheight != kHiResScreenHeight && fullscreen) )					redrawsbar = true;								ST_Drawer (viewheight == kHiResScreenHeight, redrawsbar );				fullscreen = viewheight == kHiResScreenHeight;			}			else			{				if (wipe || (viewheight != kScreenHeight && fullscreen) )					redrawsbar = true;								ST_Drawer (viewheight == kScreenHeight, redrawsbar );				fullscreen = viewheight == kScreenHeight;			}						break;				case GS_INTERMISSION:			WI_Drawer ();			break;				case GS_FINALE:			F_Drawer ();			break;				case GS_DEMOSCREEN:			D_PageDrawer ();			break;	}//// draw buffered stuff to screen//	// I_UpdateNoBlit ();//// draw the view directly//	if (gamestate == GS_LEVEL && !automapactive && gametic)		R_RenderPlayerView (&players[displayplayer]);	if (gamestate == GS_LEVEL && gametic)		HU_Drawer ();	//// clean up border stuff//	if (gamestate != oldgamestate && gamestate != GS_LEVEL)		I_SetPalette (W_CacheLumpName ("PLAYPAL",PU_CACHE));	// see if the border needs to be initially drawn	if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL)	{		viewactivestate = false;    // view wasn't active		R_FillBackScreen ();    	// draw the pattern into the back screen	}	// see if the border needs to be updated to the screen		if (TRUE)	{		Boolean		tempCheck;				if (gHiRes)			tempCheck = scaledviewwidth != kHiResScreenWidth;		else			tempCheck = scaledviewwidth != kScreenWidth;		// 	if (gamestate == GS_LEVEL && !automapactive && scaledviewwidth != 320)		if (gamestate == GS_LEVEL && !automapactive && tempCheck)		{			if (menuactive || menuactivestate || !viewactivestate)				borderdrawcount = 3;			if (borderdrawcount)			{				R_DrawViewBorder ();    // erase old menu stuff				borderdrawcount--;			}			}	}	menuactivestate = menuactive;	viewactivestate = viewactive;	inhelpscreensstate = inhelpscreens;	oldgamestate = wipegamestate = gamestate;//// draw pause pic//	if (paused)	{		if (automapactive)			y = 4;		else			y = viewwindowy + 4;		if (gHiRes || (automapactive && gOldGHiRes))			V_DrawPatchLRes ((viewwindowx >> 1) + ((scaledviewwidth >> 1) - 68) / 2, (viewwindowy>>1) + 4, 0				,W_CacheLumpName ("M_PAUSE", PU_CACHE));		else			V_DrawPatchLRes (viewwindowx + (scaledviewwidth-68) / 2, y, 0				,W_CacheLumpName ("M_PAUSE", PU_CACHE));	}//// menus go directly to the screen//	M_Drawer ();          // menu is drawn even on top of everything	NetUpdate ();         // send out any new accumulation		if (novideo)			// not in foreground		return;// normal update	if (!wipe)	{		if (gamestate != GS_LEVEL)			gOneTimeFullUpdate = 1;		I_FinishUpdate ();              // page flip or blit buffer		return;	}//// wipe update//	wipe_EndScreen(0, 0, kScreenWidth, kScreenHeight);		wipestart = I_GetTime () - 1;		oldHiRes = gHiRes;	gHiRes = 0;	do	{		do		{			nowtime = I_GetTime ();			tics = nowtime - wipestart;		}		while (!tics);				wipestart = nowtime;				done = wipe_ScreenWipe(wipe_Melt, 0, 0, kScreenWidth, kScreenHeight, tics);				gOneTimeFullUpdate = 1;		M_Drawer ();                            // menu is drawn even on top of wipes		if (!novideo)			I_FinishUpdate ();                  // blit buffer	}	while (!done);		if (gHiRes != oldHiRes)	{		if (gHiRes)			V_CopyRect(0, 0, 0, 640, 400, 0, 0, 3);		else			BlockMoveData(screens[0], screens[3], kScreenWidth * kScreenHeight);				gHiRes = oldHiRes;		// Restore to proper depth		if (gHiRes)			V_CopyRect(0, 0, 3, 320, 200, 0, 0, 0);		else			BlockMoveData(screens[3], screens[0], kScreenWidth * kScreenHeight);	}	else	{		gHiRes = oldHiRes;	}}void UpdateDoomWindow (void){	Rect	doomr, r;		gNeedsUpdate = FALSE;		BeginUpdate((WindowPtr)gDoomWindow);	// DrawControls((WindowPtr)gDoomWindow);		doomr = gDoomWindow->portRect;		// draw black around the draw rect, if there is any.		if (gDrawRect.top != 0)	{		r.left = 0;		r.top = 0;		r.right = doomr.right;		r.bottom = gDrawRect.top;		PaintRect(&r);	}		if (gDrawRect.left != 0)	{		r.left = 0;		r.top = gDrawRect.top;		r.right = gDrawRect.left;		r.bottom = doomr.bottom;		PaintRect(&r);	}		if (gDrawRect.right != doomr.right)	{		r.left = gDrawRect.right;		r.top = gDrawRect.top;		r.right = doomr.right;		r.bottom = doomr.bottom;		PaintRect(&r);	}		if (gDrawRect.bottom != doomr.bottom)	{		r.left = gDrawRect.left;		r.top = gDrawRect.bottom;		r.right = gDrawRect.right;		r.bottom = doomr.bottom;		PaintRect(&r);	}		gOneTimeFullUpdate = 1;	I_FinishUpdate();	EndUpdate((WindowPtr)gDoomWindow);}/*================================================================================= D_DoomLoop================================================================================*/void D_DoomLoop (void){	int			periodicCount = 0;		I_InitGraphics();	CloseStatusDialog();		SetPort(gDoomWindow);	PaintRect(&gDoomWindow->portRect);			FlushEvents( keyDownMask | keyUpMask | mDownMask | mUpMask | autoKeyMask, 0);	while (TRUE)	{                                                               		TryRunTics ();                  // will run at least one tic				#ifdef RANGECHECK		Z_CheckHeap();					// checks the entire Doom heap zone#endif				periodicCount = ++periodicCount & 0x03;				if (!periodicCount)			S_UpdateSounds (players[consoleplayer].mo);// move positional sounds				D_Display ();				if (gNetType == kCTBNet)		{			CMIdle(gConn);		}		if (gNeedsUpdate)			UpdateDoomWindow();	}}/*===============================================================================						DEMO LOOP===============================================================================*//*================== D_PageTicker== Handles timing for warped projection=================*/void D_PageTicker (void){	if (--pagetic < 0)		D_AdvanceDemo ();}/*================== D_PageDrawer=================*/void D_PageDrawer (void){	// Draws the title picture, the credits, or others.	V_DrawPatchLRes (0, 0, 0, W_CacheLumpName(pagename, PU_CACHE)); // HR1}/*=================== D_AdvanceDemo== Called after each demo or intro demosequence finishes=================*/void D_AdvanceDemo (void){	advancedemo = true;}void D_DoAdvanceDemo (void){	players[consoleplayer].playerstate = PST_LIVE;  // don't reborn	advancedemo = false;	usergame = false;               // can't save / end game here	paused = false;	gameaction = ga_nothing;	demosequence = (demosequence + 1) % 6;		switch (demosequence)	{	case 0:		if (commercial)			pagetic = 35 * 11;		else			pagetic = 170;		gamestate = GS_DEMOSCREEN;		pagename = "TITLEPIC";		commercial ? S_StartMusic(mus_dm2ttl):S_StartMusic (mus_intro);		break;	case 1:		G_DeferedPlayDemo ("demo1");    		break;	case 2:		pagetic = 200;		gamestate = GS_DEMOSCREEN;		pagename = "CREDIT";		break;	case 3:		G_DeferedPlayDemo ("demo2");    		break;	case 4:		gamestate = GS_DEMOSCREEN;		if (commercial)		{			pagetic = 35 * 11;			pagename = "TITLEPIC";			S_StartMusic(mus_dm2ttl);		}		else		{			pagetic = 200;			pagename = "HELP2";		}		break;	case 5:		G_DeferedPlayDemo ("demo3");    		break;	}}/*=================== D_StartTitle==================*/void D_StartTitle (void){	gameaction = ga_nothing;	demosequence = -1;	D_AdvanceDemo ();}#ifdef __WATCOMC__//====================================================//// Print (in color) a string////====================================================int getx(void){   union REGS r;   r.h.ah = 3;   r.h.bh = 0;   int386(0x10,&r,&r);   return r.h.dl;}int gety(void){   union REGS r;   r.h.ah = 3;   r.h.bh = 0;   int386(0x10,&r,&r);   return r.h.dh;}void setxy(int x,int y){   union REGS r;	r.h.ah = 2;	r.h.bh = 0;	r.h.dh = y;	r.h.dl = x;	int386(0x10,&r,&r);}void dprint(char *string,int fg,int bg){   union REGS r;   int   i,x,y;   char  color;   color = (bg << 4) | fg;	x = getx();	y = gety();   for (i = 0; i < strlen(string); i++)   {      r.h.ah = 9;      r.h.al = string[i];      r.h.bh = 0;      r.h.bl = color;      r.w.cx = 1;      int386(0x10,&r,&r);      x++;      if (x > 79)	 x = 0;		setxy(x,y);   }}#endif////      print title for every printed line//char            title[128];void mprintf(char *string){#ifdef __WATCOMC__	int x;	int     y;#endif		// printf(string);#ifdef __WATCOMC__	x = getx();	y = gety();	setxy(0,0);     	dprint (title,15,4);	setxy(x,y);#endif}/*=============== IdentifyVersion==============*/void IdentifyVersion (void){/*	char *doom1wad, *doomwad, *doom2wad;#ifdef NORMALUNIX	char *home;	char *doomwaddir;	doomwaddir = getenv("DOOMWADDIR");	if (!doomwaddir)#ifdef SGI		doomwaddir = "/usr/demos/IndiZone/.data/doom";#else		doomwaddir = ".";#endif	doom1wad = malloc(strlen(doomwaddir)+1+9+1);	sprintf(doom1wad, "%s/doom1.wad", doomwaddir);	doom2wad = malloc(strlen(doomwaddir)+1+9+1);	sprintf(doom2wad, "%s/doom2.wad", doomwaddir);	doomwad = malloc(strlen(doomwaddir)+1+8+1);	sprintf(doomwad, "%s/doom.wad", doomwaddir);	home = getenv("HOME");	if (!home) I_Error("Please set $HOME to your home directory");	sprintf(basedefault, "%s/.doomrc", home);#else	strcpy (basedefault,"default.cfg");	doom1wad = "doom1.wad";	#ifdef FRENCH	doom2wad = "doom2f.wad";	#else	doom2wad = "doom2.wad";	#endif	doomwad = "doom.wad";#endif	if (M_CheckParm ("-shdev"))	{		registered = false;		shareware = true;		devparm = true;		D_AddFile (DEVDATA"doom1.wad");		D_AddFile (DEVMAPS"data/texture1.lmp");		D_AddFile (DEVMAPS"data/pnames.lmp");		strcpy (basedefault,DEVDATA"default.cfg");		return;	}	if (M_CheckParm ("-regdev"))	{		registered = true;		devparm = true;		D_AddFile (DEVDATA"doom.wad");		D_AddFile (DEVMAPS"data/texture1.lmp");		D_AddFile (DEVMAPS"data/texture2.lmp");		D_AddFile (DEVMAPS"data/pnames.lmp");		strcpy (basedefault,DEVDATA"default.cfg");		return;	}	if (M_CheckParm ("-comdev"))	{		commercial = true;		devparm = true;		D_AddFile (DEVDATA"doom2.wad");		D_AddFile (DEVMAPS"cdata/texture1.lmp");		D_AddFile (DEVMAPS"cdata/pnames.lmp");		strcpy (basedefault,DEVDATA"default.cfg");		return;	}	if ( !access (doom2wad,R_OK) )	{		commercial = true;		D_AddFile (doom2wad);		return;	}	if (! access (doomwad,R_OK) )	{		registered = true;		D_AddFile (doomwad);		return;	}	if ( !access (doom1wad,R_OK) )	{		shareware = true;		D_AddFile (doom1wad);		return;	}	I_Error ("Game mode indeterminate\n");*/	// commercial = true;}/*=============== CheckBetaTest==============*/void CheckBetaTest (void){#ifdef BETATEST//// check password and date stamp for bad beta testers// struct dosdate_t d; char   *p, *check; p = check = W_CacheLumpName ("bpas",PU_CACHE); while (*check > ' ')	check++; *check = 0;	if (!M_CheckParm (p))		I_Error ("Corrupt wadfile"); _dos_getdate(&d);if (d.year > 1993 || d.day > 20)		I_Error ("Bad wadfile");#endif}//========================================================////      Find a Response File////========================================================void FindResponseFile (void){#ifndef __MAC_VERSION__	int             i;	#define MAXARGVS        100		for (i = 1;i < myargc;i++)		if (myargv[i][0] == '@')		{			FILE *          handle;			int             size;			int             k;			int             index;			int             indexinfile;			char    *infile;			char    *file;			char    *moreargs[20];			char    *firstargv;						// READ THE RESPONSE FILE INTO MEMORY			handle = fopen (&myargv[i][1],"rb");			if (!handle)			{        				I_Error ("\nNo such response file!");			}			// printf("Found response file %s!\n",&myargv[i][1]);			fseek (handle,0,SEEK_END);			size = ftell(handle);			fseek (handle,0,SEEK_SET);			file = (char *) malloc (size);			fread (file,size,1,handle);			fclose (handle);						// KEEP ALL CMDLINE ARGS FOLLOWING @RESPONSEFILE ARG			for (index = 0,k = i+1; k < myargc; k++)				moreargs[index++] = myargv[k];						firstargv = myargv[0];			// Bad practice?			myargv = (char **) malloc(sizeof(char *)*MAXARGVS);			memset(myargv,0,sizeof(char *)*MAXARGVS);			myargv[0] = firstargv;						infile = file;			indexinfile = k = 0;			indexinfile++;  // SKIP PAST ARGV[0] (KEEP IT)			do			{				myargv[indexinfile++] = infile+k;				while(k < size &&  					((*(infile+k)>= ' '+1) && (*(infile+k)<='z')))					k++;				*(infile+k) = 0;				while(k < size &&					((*(infile+k)<= ' ') || (*(infile+k)>'z')))					k++;			} while(k < size);						for (k = 0;k < index;k++)				myargv[indexinfile++] = moreargs[k];			myargc = indexinfile;				// DISPLAY ARGS			// printf("%d command-line args:\n",myargc);			for (k=1;k<myargc;k++)				; // printf("%s\n",myargv[k]);			break;		}#endif}extern int  turboparm;/*=============== D_DoomMain==============*/void D_DoomMain (void){	int             p;	char            file[256];			FindResponseFile ();	IdentifyVersion ();		StatusDialog(80, 12);		// setbuf (stdout, NULL);	modifiedgame = false;		// nomonsters = FALSE;	// respawnparm = FALSE;	// fastparm = FALSE;	devparm = FALSE;		/*	if (M_CheckParm ("-altdeath"))		deathmatch = 2;	else if (M_CheckParm ("-deathmatch"))		deathmatch = 1;	*/	///////*	if (!commercial)	sprintf (title,"                          DOOM System Startup v%i.%i                          ",VERSION/100,VERSION%100);	else	sprintf (title,"                         DOOM 2: Hell on Earth v%i.%i                          ",VERSION/100,VERSION%100);*/////////// turbo option//		if (turboparm)	{		forwardmove[0] = forwardmove[0] << 1;		forwardmove[1] = forwardmove[1] << 1;		sidemove[0] = sidemove[0] << 1;		sidemove[1] = sidemove[1] << 1;	}//// add any files specified on the command line with -file wadfile to// the wad list//	// convenience hack to allow -wart e m to add a wad file	// prepend a tilde to the filename so wadfile will be reloadable	/*	p = M_CheckParm ("-wart");	if (p)	{		myargv[p][4] = 'p';     // big hack, change to -warp		if (commercial)		{			p = atoi (myargv[p+1]);			if (p<10)				sprintf (file,"~"DEVMAPS"cdata/map0%i.wad", p);			else				sprintf (file,"~"DEVMAPS"cdata/map%i.wad", p);		}		else		{			sprintf (file,"~"DEVMAPS"E%cM%c.wad", myargv[p+1][0], myargv[p+2][0]);			printf("Warping to Episode %s, Map %s.\n",myargv[p+1],myargv[p+2]);		}		D_AddFile (file);	}		p = M_CheckParm ("-file");	if (p)	{   // the parms after p are wadfile/lump names, until end of parms		// or another - preceded parm 		modifiedgame = true;            // homebrew levels		while (++p != myargc && myargv[p][0] != '-')			D_AddFile (myargv[p]);	}	p = M_CheckParm ("-playdemo");	if (!p)		p = M_CheckParm ("-timedemo");	if (p && p < myargc-1)	{		sprintf (file,"%s.lmp", myargv[p+1]);		D_AddFile (file);		printf("Playing demo %s.lmp.\n",myargv[p+1]);	}	*///// get skill / episode / map from parms//	// startskill = sk_medium;	// startepisode = 1;	// startmap = 1;		now set in I_MAIN.C @ options dialog	// autostart = false;	   "                        "	/*	p = M_CheckParm ("-skill");	if (p && p < myargc-1)	{		startskill = myargv[p+1][0]-'1';		autostart = true;	}	p = M_CheckParm ("-episode");	if (p && p < myargc-1)	{		startepisode = myargv[p+1][0]-'0';		startmap = 1;		autostart = true;	}		p = M_CheckParm ("-timer");	if (p && p < myargc-1 && deathmatch)	{		int     time;		time = atoi(myargv[p+1]);		printf("Levels will end after %d minute",time);		if (time>1)			printf("s");		printf(".\n");	}	p = M_CheckParm ("-avg");	if (p && p < myargc-1 && deathmatch)		printf("Austin Virtual Gaming: Levels will end after 20 minutes\n");	p = M_CheckParm ("-warp");	if (p && p < myargc-1)	{		if (commercial)			startmap = atoi (myargv[p+1]);		else		{			startepisode = myargv[p+1][0]-'0';			startmap = myargv[p+2][0]-'0';		}		autostart = true;	}	*///// init subsystems//		StatusParamText("\pInitializing WAD files...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	W_InitMultipleFiles ();	StatusDialog(80, 14);		//	// Check for -file in shareware	//	if (modifiedgame)	{	/*		char name[23][8]=		{				"e2m1","e2m2","e2m3","e2m4","e2m5","e2m6","e2m7","e2m8","e2m9",				"e3m1","e3m3","e3m3","e3m4","e3m5","e3m6","e3m7","e3m8","e3m9",				"dphoof","bfgga0","heada1","cybra1","spida1d1"		};		int i;			if (shareware)			I_Error("\nYou cannot -file with the shareware "					"version. Register!");			if (registered)			for (i = 0;i < 23; i++)				if (W_CheckNumForName(name[i]) < 0)					I_Error("\nThis is not the registered version.");	*/	}	//// print modified banner//	if (modifiedgame)	{ /*		printf ("===========================================================================\n""ATTENTION:  This version of DOOM has been modified.  If you would like to\n""get a copy of the original game, call 1-800-IDGAMES or see the readme file.\n""        You will not receive technical support for modified games.\n""                      press enter to continue\n""===========================================================================\n"		);		getchar ();	*/ }	//// check which version//	if (registered)	{		mprintf ("	registered version.\n");		mprintf ("===========================================================================\n""             This version is NOT SHAREWARE, do not distribute!\n""         Please report software piracy to the SPA: 1-800-388-PIR8\n""===========================================================================\n"	);	}		if (shareware)		mprintf ("	shareware version.\n");	if (commercial)	{	/*		mprintf ("	commercial version.\n");		mprintf ("===========================================================================\n""                            Do not distribute!\n""         Please report software piracy to the SPA: 1-800-388-PIR8\n""===========================================================================\n"	);//              shareware = false;	*/	}		MySetCursor(watchCursor);	StatusParamText("\pInitializing menus...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	M_Init ();	StatusDialog(80, 16);	StatusParamText("\pInitializing rendering...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	R_Init ();	StatusParamText("\pInitializing players...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	P_Init ();		StatusParamText("\pInitializing timers...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	I_Init ();		StatusParamText("\pChecking network...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	D_CheckNetGame ();	StatusDialog(80, 72);		StatusParamText("\pInitializing graphics...", "\p", "\p", "\p");	DrawStatusDialog(TRUE);	HU_Init ();	ST_Init ();	StatusDialog(80, 80);		CheckBetaTest ();		MyInitCursor();//// start the apropriate game based on parms///*	p = M_CheckParm ("-record");	if (p && p < myargc-1)	{		G_RecordDemo (myargv[p+1]);		autostart = true;	}		p = M_CheckParm ("-playdemo");	if (p && p < myargc-1)	{		singledemo = true;              // quit after one demo		G_DeferedPlayDemo (myargv[p+1]);		D_DoomLoop ();  // never returns	}		p = M_CheckParm ("-timedemo");	if (p && p < myargc-1)	{		G_TimeDemo (myargv[p+1]);		D_DoomLoop ();  // never returns	}		p = M_CheckParm ("-loadgame");	if (p && p < myargc-1)	{		if (M_CheckParm("-cdrom"))			sprintf(file, "c:\\doomdata\\"SAVEGAMENAME"%c.dsg",myargv[p+1][0]);		else			sprintf(file, SAVEGAMENAME"%c.dsg",myargv[p+1][0]);		G_LoadGame (file);	}*/		if (gameaction != ga_loadgame && !gLoadGamePending)	{		if (autostart || netgame)			G_InitNew (startskill, startepisode, startmap);		else			D_StartTitle ();                // start up intro loop	}		if (gLoadGamePending && (gPlayAlone == FALSE))		gInitialLoadGame = TRUE;	else		gInitialLoadGame = FALSE;		if (1)	{		long	*longPtr;		long	totalMem = kHiResRowBytes * kHiResScreenHeight;				longPtr = (long *) screens[0];		totalMem >>= 2;		while (totalMem--)			*longPtr++ = 0xFFFFFFFF;	}	#if __profile__	ProfilerSetStatus(1);#endif	gMacStartTicks = TickCount() >> 1;	if(useMouse)	{		InitCursor();		gCursID = 0;		HideCursor();	}	else		MyInitCursor();		D_DoomLoop ();  // never returns}