/* 	File:		CMApplication.h  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __CMAPPLICATION__#define __CMAPPLICATION__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __QUICKDRAW__#include <Quickdraw.h>#endif/*	#include <MixedMode.h>										*//*	#include <QuickdrawText.h>									*/#ifndef __WINDOWS__#include <Windows.h>#endif/*	#include <Memory.h>											*//*	#include <Events.h>											*//*		#include <OSUtils.h>									*//*	#include <Controls.h>										*//*		#include <Menus.h>										*/#ifndef __PRINTING__#include <Printing.h>#endif/*	#include <Errors.h>											*//*	#include <Dialogs.h>										*//*		#include <TextEdit.h>									*/#ifdef __cplusplusextern "C" {#endif#if GENERATINGPOWERPC#pragma options align=mac68k#endif#ifdef __CFM68K__#pragma lib_export on#endifenum {	CMTrap						= 0xABEE};/* PicComments */enum {	CMBeginProfile				= 220,	CMEndProfile				= 221,	CMEnableMatching			= 222,	CMDisableMatching			= 223};/* Defines for fieldMask in profile search record */enum {	kMatchCMMType				= 0x00000001,	kMatchApplProfileVersion	= 0x00000002,	kMatchDataType				= 0x00000004,	kMatchDeviceType			= 0x00000008,	kMatchDeviceManufacturer	= 0x00000010,	kMatchDeviceModel			= 0x00000020,	kMatchDeviceAttributes		= 0x00000040,	kMatchFlags					= 0x00000080,	kMatchOptions				= 0x00000100,	kMatchWhite					= 0x00000200,	kMatchBlack					= 0x00000400};/* Profile Header version */enum {	kCMApplProfileVersion		= 0x0100};/* Data types */enum {	rgbData						= 'RGB ',	cmykData					= 'CMYK',	grayData					= 'GRAY',	xyzData						= 'XYZ '};/* Device types */enum {	monitorDevice				= 'mntr',	scannerDevice				= 'scnr',	printerDevice				= 'prtr',	qdSystemDevice				= 'sys ',	qdGDevice					= 'gdev'};/* Profile flags */enum {	CMNativeMatchingPreferred	= 0x00000001,					/* Default to native not preferred */	CMTurnOffCache				= 0x00000002					/* Default to turn on CMM cache */};typedef long CMMatchFlag;/* Profile options */enum {	CMPerceptualMatch			= 0x0000,						/* Default. For photographic images */	CMColorimetricMatch			= 0x0001,						/* Exact matching when possible */	CMSaturationMatch			= 0x0002						/* For solid colors */};typedef long CMMatchOption;typedef long CMMatchRef;typedef long CWorld;/* ColorSync result codes */enum {	CMNoError					= 0,	CMProfileError				= -170,	CMMethodError				= -171,	CMMemFullError				= -172,	CMUnimplementedError		= -173,	CMParamError				= -174,	CMMethodNotFound			= -175,							/* CMM not present */	CMProfileNotFound			= -176,							/* Responder error */	CMProfilesIdentical			= -177,							/* Profiles the same */	CMCantConcatenateError		= -178,							/* Profile can't be concatenated */	CMCantXYZ					= -179,							/* CMM cant handle XYZ space */	CMCantDeleteProfile			= -180,							/* Responder error */	CMUnsupportedDataType		= -181,							/* Responder error */	CMNoCurrentProfile			= -182							/* Responder error */};typedef long CMError;/*** Types*/struct XYZColor {	unsigned short					X;							/* 1.15 bit unsigned fixed numbers */	unsigned short					Y;	unsigned short					Z;};typedef struct XYZColor XYZColor;struct CMYKColor {	unsigned short					cyan;	unsigned short					magenta;	unsigned short					yellow;	unsigned short					black;};typedef struct CMYKColor CMYKColor;union CMColor {	RGBColor						rgb;	XYZColor						xyz;	CMYKColor						cmyk;};typedef union CMColor CMColor, *CMColorList;typedef long *CMGamutResult;struct CMHeader {	unsigned long					size;						/* This is the total size of the Profile including custom data */	OSType							CMMType;					/* Corresponding CMM */	unsigned long					applProfileVersion;			/* Version of CMProfile format */	OSType							dataType;					/* rgbData, etc. */	OSType							deviceType;					/* monitorDevice, etc. */	OSType							deviceManufacturer;			/* Registered with DTS */	unsigned long					deviceModel;				/* Specific to Manufacturer */	unsigned long					deviceAttributes[2];		/* Attributes like paper, ink, etc. */	unsigned long					profileNameOffset;			/* Offset to profile name from top of data */	unsigned long					customDataOffset;			/* Offset to custom data from top of data */	CMMatchFlag						flags;	CMMatchOption					options;	XYZColor						white;	XYZColor						black;};typedef struct CMHeader CMHeader;struct CMProfileSearchRecord {	CMHeader						header;	unsigned long					fieldMask;	unsigned long					reserved[2];};typedef struct CMProfileSearchRecord CMProfileSearchRecord, **CMProfileSearchRecordHandle;struct CMProfileChromaticities {	XYZColor						red;	XYZColor						green;	XYZColor						blue;	XYZColor						cyan;	XYZColor						magenta;	XYZColor						yellow;};typedef struct CMProfileChromaticities CMProfileChromaticities;typedef unsigned short CMResponseData;struct IString {	ScriptCode						theScript;	Str63							theString;};typedef struct IString IString, *IStringPtr, **IStringHandle;enum {	grayResponse				= 0,	redResponse					= 1,	greenResponse				= 2,	blueResponse				= 3,	cyanResponse				= 4,	magentaResponse				= 5,	yellowResponse				= 6,	ucrResponse					= 7,	bgResponse					= 8,	onePlusLastResponse			= 9};typedef long responseColor;struct CMProfileResponse {	unsigned short					counts[onePlusLastResponse];	CMResponseData					data[1];					/* Variable size */};typedef struct CMProfileResponse CMProfileResponse;struct CMProfile {	CMHeader						header;	CMProfileChromaticities			profile;	CMProfileResponse				response;					/* Variable size */	IString							profileName;				/* Variable size */	SInt8							customData[1];				/* Optional variable length custom CMM data */};typedef struct CMProfile CMProfile, *CMProfilePtr, **CMProfileHandle;typedef pascal Boolean (*PixMapCallBackProcPtr)(long progress, long refCon);#if GENERATINGCFMtypedef UniversalProcPtr PixMapCallBackUPP;#elsetypedef PixMapCallBackProcPtr PixMapCallBackUPP;#endifenum {	uppPixMapCallBackProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long)))};#if GENERATINGCFM#define NewPixMapCallBackProc(userRoutine)		\		(PixMapCallBackUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppPixMapCallBackProcInfo, GetCurrentArchitecture())#else#define NewPixMapCallBackProc(userRoutine)		\		((PixMapCallBackUPP) (userRoutine))#endif#if GENERATINGCFM#define CallPixMapCallBackProc(userRoutine, progress, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppPixMapCallBackProcInfo, (progress), (refCon))#else#define CallPixMapCallBackProc(userRoutine, progress, refCon)		\		(*(userRoutine))((progress), (refCon))#endif/*** Printing Stuff that will be moved later*/enum {	enableColorMatchingOp		= 12,	registerProfileOp			= 13};/* PrGeneral parameter blocks */struct TEnableColorMatchingBlk {	short							iOpCode;	short							iError;	long							lReserved;	THPrint							hPrint;	Boolean							fEnableIt;	SInt8							filler;};typedef struct TEnableColorMatchingBlk TEnableColorMatchingBlk;struct TRegisterProfileBlk {	short							iOpCode;	short							iError;	long							lReserved;	THPrint							hPrint;	Boolean							fRegisterIt;	SInt8							filler;};typedef struct TRegisterProfileBlk TRegisterProfileBlk;/*** High Level Calls*/extern pascal CMError BeginMatching(CMProfileHandle src, CMProfileHandle dst, CMMatchRef *myRef) FOURWORDINLINE(0x203c, 0x000C, 10, 0xABEE);extern pascal void EndMatching(CMMatchRef myRef) FOURWORDINLINE(0x203c, 0x0004, 11, 0xABEE);extern pascal CMError GetProfile(long deviceType, long refNum, CMProfileHandle aProfile, CMProfileHandle *returnedProfile) FOURWORDINLINE(0x203c, 0x0010, 5, 0xABEE);extern pascal CMError SetProfile(long deviceType, long refNum, CMProfileHandle newProfile) FOURWORDINLINE(0x203c, 0x000c, 6, 0xABEE);extern pascal CMError SetProfileDescription(long deviceType, long refNum, long deviceData, CMProfileHandle hProfile) FOURWORDINLINE(0x203c, 0x0010, 16, 0xABEE);extern pascal CMError GetColorSyncFolderSpec(short vRefNum, Boolean createFolder, short *foundVRefNum, long *foundDirID) FOURWORDINLINE(0x203c, 0x000c, 17, 0xABEE);extern pascal CMError GetIndexedProfile(long deviceType, long refNum, CMProfileSearchRecordHandle search, CMProfileHandle *returnProfile, long *index) FOURWORDINLINE(0x203c, 0x0014, 18, 0xABEE);extern pascal CMError DeleteDeviceProfile(long deviceType, long refNum, CMProfileHandle deleteMe) FOURWORDINLINE(0x203c, 0x000C, 19, 0xABEE);/*** Data interchange routines*/extern pascal CMError UseProfile(CMProfileHandle profile) FOURWORDINLINE(0x203c, 0x0004, 8, 0xABEE);extern pascal void DrawMatchedPicture(PicHandle myPicture, CMProfileHandle dst, Rect *myRect) FOURWORDINLINE(0x203c, 0x000C, 9, 0xABEE);extern pascal void EnableMatching(Boolean enableIt) FOURWORDINLINE(0x203c, 0x0002, 13, 0xABEE);/*** Profile concatenation*/extern pascal CMError ConcatenateProfiles(CMProfileHandle thru, CMProfileHandle dst, CMProfileHandle *newDst) FOURWORDINLINE(0x203c, 0x000C, 12, 0xABEE);/*** Profile manipulation routines*/extern pascal void GetProfileName(CMProfileHandle myProfile, IString *IStringResult) FOURWORDINLINE(0x203c, 0x0008, 14, 0xABEE);extern pascal long GetProfileAdditionalDataOffset(CMProfileHandle myProfile) FOURWORDINLINE(0x203c, 0x0004, 15, 0xABEE);/*** Low level color calculation routines*/extern pascal CMError CWNewColorWorld(CWorld *myCWorld, CMProfileHandle src, CMProfileHandle dst) FOURWORDINLINE(0x203c, 0x000C, 0, 0xABEE);extern pascal void CWDisposeColorWorld(CWorld myCWorld) FOURWORDINLINE(0x203c, 0x0004, 1, 0xABEE);extern pascal CMError CWMatchColors(CWorld myCWorld, CMColorList myColors, long count) FOURWORDINLINE(0x203c, 0x000c, 2, 0xABEE);extern pascal CMError CWCheckColors(CWorld myCWorld, CMColorList myColors, long count, CMGamutResult result) FOURWORDINLINE(0x203c, 0x0010, 3, 0xABEE);extern pascal CMError CWMatchPixMap(CWorld myCWorld, PixMap *myPixMap, PixMapCallBackUPP progressProc, long refCon) FOURWORDINLINE(0x203c, 0x0010, 4, 0xABEE);extern pascal CMError CWCheckPixMap(CWorld myCWorld, PixMap *myPixMap, PixMapCallBackUPP progressProc, long refCon, BitMap *resultBitMap) FOURWORDINLINE(0x203c, 0x0014, 7, 0xABEE);#ifdef __CFM68K__#pragma lib_export off#endif#if GENERATINGPOWERPC#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __CMAPPLICATION__ */