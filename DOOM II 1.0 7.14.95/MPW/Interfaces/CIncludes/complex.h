/***  	(c) Copyright 1988-1994 by Dyad Software Corp.** 	All Rights Reserved**** 	 Authors: lwd, geb****	Some portions Copyright © 1994 Apple Computer Inc.*/#ifndef __COMPLEX__#define __COMPLEX__#ifndef __FP__#include <fp.h>#endif#ifndef FLT_TYPE#define FLT_TYPE long double#endif#ifndef   powerc              /*   preserve compatibility with 68k macintoshes    */#define   cLog    clog#endif#ifdef __cplusplusclass ostream;class istream;class complex{ public:   friend FLT_TYPE real ( const complex& );        friend FLT_TYPE imag ( const complex& );        friend complex cos ( const complex& );   friend complex cosh ( const complex& );   friend complex sin ( const complex& );   friend complex sinh ( const complex& );   friend complex tan ( const complex& );   friend complex tanh ( const complex& );   friend complex log ( const complex& );   friend complex log10 ( const complex& );   friend complex sqrt ( const complex& );   friend FLT_TYPE abs ( const complex& );   friend complex conj ( const complex& );   friend FLT_TYPE norm ( const complex& );   friend FLT_TYPE modulus ( const complex& );   friend FLT_TYPE arg ( const complex& );   friend complex asin ( const complex& );   friend complex acos ( const complex& );   friend complex atan ( const complex& );   friend complex asinh ( const complex& );   friend complex atanh ( const complex& );   friend complex exp ( const complex& );   friend complex polar ( FLT_TYPE r, FLT_TYPE theta = 0);   friend complex operator + ( const complex&, const complex& );   friend complex operator + ( FLT_TYPE, const complex& );   friend complex operator + ( const complex&, FLT_TYPE );   friend complex operator - ( const complex&, const complex& );   friend complex operator - ( FLT_TYPE, const complex& );   friend complex operator - ( const complex&, FLT_TYPE );   friend complex operator * ( const complex&, const complex& );   friend complex operator * ( FLT_TYPE, const complex& );   friend complex operator * ( const complex&, FLT_TYPE );   friend complex operator / ( const complex&, const complex& );   friend complex operator / ( FLT_TYPE, const complex& );   friend complex operator / ( const complex&, FLT_TYPE );   friend complex pow( const complex& lhs, FLT_TYPE rhs );   friend complex pow( const complex& lhs, const complex & rhs );   friend complex pow( FLT_TYPE lhs, const complex & rhs);   friend complex pow( const complex& lhs, int rhs);   friend int operator && ( const complex&, const complex& );   friend int operator && ( FLT_TYPE, const complex& );   friend int operator && ( const complex&, FLT_TYPE );   friend int operator || ( const complex&, const complex& );   friend int operator || ( FLT_TYPE, const complex& );   friend int operator || ( const complex&, FLT_TYPE );   friend int operator != ( const complex&, const complex& );   friend int operator != ( FLT_TYPE, const complex& );   friend int operator != ( const complex&, FLT_TYPE );   friend int operator == ( const complex&, const complex& );   friend int operator == ( FLT_TYPE, const complex& );   friend int operator == ( const complex&, FLT_TYPE );   friend ostream& operator << ( ostream& s, const complex& x);   friend istream& operator >> ( istream& s, complex& x); public:   complex ( );   complex ( FLT_TYPE r, FLT_TYPE i ); /*   this is not declared (FLT_TYPE r, FLT_TYPE i = 0)                                        to avoid implicit conversion. Binary operations                                        are explicitly declared thus avoiding potential                                         ambiguities. */   complex ( const complex & );      FLT_TYPE& real ( );   FLT_TYPE& imag ( );      complex& operator = ( const complex& );   complex& operator = ( FLT_TYPE );      complex& operator += ( const complex& );   complex& operator += ( FLT_TYPE );      complex& operator -= ( const complex& );   complex& operator -= ( FLT_TYPE );      complex& operator *= ( const complex& );   complex& operator *= ( FLT_TYPE );      complex& operator /= ( const complex& );   complex& operator /= ( FLT_TYPE );      int operator ! () const;   complex operator - () const;    private:   FLT_TYPE re;   FLT_TYPE im; };inline complex::complex ( ){#if 0  /* remove these comments for initialization to (0,0)     re = im = 0;      */#else    re = im = NAN;#endif}inline complex::complex ( FLT_TYPE r, FLT_TYPE i ): re(r), im(i) {}     inline complex::complex( const complex& z){  re = z.re;  im = z.im;}    inline FLT_TYPE real ( const complex& z){ return z.re; }     inline FLT_TYPE imag ( const complex& z){ return z.im; }     inline FLT_TYPE& complex::real (){ return re; }     inline FLT_TYPE& complex::imag (){ return im; }     /* operator + */inline complex operator + ( const complex& lhs, const complex& rhs ){  return  complex ( lhs.re + rhs.re, lhs.im + rhs.im );}inline complex operator + ( FLT_TYPE  lhs, const complex& rhs ){  return  complex ( lhs + rhs.re, rhs.im );}inline complex operator + ( const complex& lhs, FLT_TYPE rhs ){  return  complex ( lhs.re + rhs, lhs.im );}/* operator - */inline complex operator - ( const complex& lhs, const complex& rhs ){  return  complex ( lhs.re - rhs.re, lhs.im - rhs.im );}inline complex operator - ( FLT_TYPE lhs, const complex& rhs ){  return  complex ( lhs - rhs.re, - rhs.im );}inline complex operator - ( const complex& lhs, FLT_TYPE rhs ){  return  complex ( lhs.re - rhs, lhs.im );}/* operator * */inline complex operator * ( const complex& lhs, const complex& rhs ){  return  complex ( lhs.re * rhs.re - lhs.im * rhs.im, 		   lhs.re * rhs.im + lhs.im*rhs.re );}inline complex operator * ( FLT_TYPE lhs, const complex& rhs ){  return  complex ( lhs * rhs.re, lhs * rhs.im );}inline complex operator * ( const complex& lhs, FLT_TYPE rhs ){  return  complex ( lhs.re * rhs, lhs.im*rhs );}/* operator / */inline complex operator / ( const complex& lhs, FLT_TYPE rhs ){  return complex( lhs.re / rhs, lhs.im /rhs );}/* unary operators */inline complex complex::operator - ( ) const{  return  complex ( -re, -im );}inline int complex::operator ! ( )  const{  return  ( re == 0 ) && ( im == 0 ) ;}    inline complex & complex::operator = ( const complex& z){  re = z.re;  im = z.im;  return  *this;}    inline complex & complex::operator = ( FLT_TYPE x){  re = x;  im = 0;  return  *this;}    /* operator *= */inline complex & complex::operator *= ( const complex& z){  *this = *this * z;  return  *this;}inline complex & complex::operator *= ( FLT_TYPE x ){  re *= x;  im *= x;  return  *this;}inline complex & complex::operator /= ( const complex& z){  *this = *this / z;  return  *this;}    inline complex & complex::operator /= ( FLT_TYPE x){  re /= x;  im /= x;  return  *this;}    inline complex & complex::operator += ( const complex& z){  re += z.re;  im += z.im;  return  *this;}inline complex & complex::operator += ( FLT_TYPE x){  re += x;  return  *this;}inline complex & complex::operator -= ( const complex& z){  re -= z.re;  im -= z.im;  return  *this;}inline complex & complex::operator -= ( FLT_TYPE x){  re -= x;  return  *this;}    /* operator && */inline int operator && ( const complex & lhs, const complex & rhs ){  return  (( lhs.re != 0 ) || ( lhs.im != 0 )) &&    (( rhs.re != 0 ) || ( rhs.im != 0 )) ;}    inline int operator && ( FLT_TYPE lhs, const complex & rhs ){  return  ( lhs != 0 ) && (( rhs.re != 0 ) || ( rhs.im != 0 )) ;}    inline int operator && ( const complex & lhs, FLT_TYPE rhs ){  return  (( lhs.re != 0 ) || ( lhs.im != 0 )) && ( rhs != 0 ) ;}    /* operator || */inline int operator || ( const complex & lhs, const complex & rhs ){  return  (( lhs.re != 0 ) || ( lhs.im != 0 )) ||    (( rhs.re != 0 ) || ( rhs.im != 0 )) ;}inline int operator || ( FLT_TYPE lhs, const complex & rhs ){  return  ( lhs != 0 ) || (( rhs.re != 0 ) || ( rhs.im != 0 )) ;}inline int operator || ( const complex & lhs, FLT_TYPE rhs ){  return  (( lhs.re != 0 ) || ( lhs.im != 0 )) || ( rhs != 0 );}    /* operator != */inline  int operator != ( const complex& lhs, const complex& rhs ){  return  ( lhs.re != rhs.re ) || ( lhs.im != rhs.im );}inline  int operator != ( FLT_TYPE lhs, const complex& rhs ){  return  ( lhs != rhs.re ) || ( 0 != rhs.im );}inline  int operator != ( const complex& lhs, FLT_TYPE rhs ){  return  ( lhs.re != rhs ) || ( lhs.im != 0 );}/* operator == */inline  int operator == ( const complex& lhs, const complex& rhs ){  return  ( lhs.re == rhs.re ) && ( lhs.im == rhs.im );}inline  int operator == ( FLT_TYPE lhs, const complex& rhs ){  return  ( lhs == rhs.re ) && ( 0 == rhs.im );}inline  int operator == ( const complex& lhs, FLT_TYPE rhs ){  return  ( lhs.re == rhs ) && ( lhs.im == 0 );}inline FLT_TYPE arg( const complex& z){  return atan2(z.im,z.re);}inline complex atanh( const complex& z) {  complex iz(-z.im, z.re);  complex ix = atan(iz);  return complex ( ix.im, -ix.re);}inline complex asinh( const complex& z){  complex iz(-z.im, z.re);  complex ix = asin(iz);  return complex ( ix.im, -ix.re);}inline FLT_TYPE norm( const complex& z){  return z.re*z.re + z.im*z.im;}inline FLT_TYPE modulus( const complex& z){  return abs(z);}inline complex conj( const complex& z){  return complex( z.re, -z.im );}inline complex cos( const complex& z ){  return complex( cos(z.re) * cosh( z.im ),  -( sin( z.re) * sinh(z.im)));}inline complex cosh( const complex& z ){  return complex ( cosh(z.re) * cos(z.im), sinh(z.re) * sin(z.im) );}inline complex sin( const complex& z ){  return complex ( sin(z.re) * cosh(z.im), cos(z.re) * sinh(z.im) );}inline complex sinh( const complex& z ){  return complex ( sinh(z.re) * cos(z.im), cosh(z.re) * sin(z.im) );}inline complex tan( const complex& z ){  FLT_TYPE x = 2*z.re;  FLT_TYPE y = 2*z.im;  FLT_TYPE t = 1.0/(cos(x) +cosh(y));    return complex( t*sin(x), t*sinh(y) );}inline complex tanh( const complex& z ){  FLT_TYPE x = 2*z.re;  FLT_TYPE y = 2*z.im;  FLT_TYPE t = 1.0/(cosh(x) +cos(y));    return complex( t*sinh(x), t*sin(y) );}    inline complex exp( const complex& z ){  FLT_TYPE x = exp(z.re);  return complex( x*cos(z.im), x*sin(z.im) );}    inline complex log( const complex& z ){  return complex( log( abs(z) ), arg( z ) );}    inline complex log10( const complex& z ){  return complex( 0.2171472409516259*log( norm(z) ), arg( z ) );}    inline complex polar ( FLT_TYPE r, FLT_TYPE theta ){  return complex ( r * cos(theta), r * sin(theta));}#else	/* __cplusplus *//* Standard ANSI C version of complex.h */struct complex {	double_t	re;	double_t	im;};typedef struct complex complex;#endif	/* __cplusplus */#ifdef __cplusplusextern "C" {#endif/* Standard ANSI complex functions */complex cadd( complex x, complex y );complex csub( complex x, complex y );complex cmul( complex x, complex y );complex cdiv( complex x, complex y );complex xdivc( double_t x, complex y );complex csqrt( complex z );complex csin( complex z );complex ccos( complex z );complex csquare( complex z );complex cexp( complex z );complex cLog( complex z );complex cepwry( double_t x, complex y );complex cxpwri( complex x, long y );complex cxpwre( complex x, double_t y );complex cxpwry( complex x, complex y );complex csinh( complex z );complex ccosh( complex z );complex ctanh( complex z );complex ctan( complex z );complex casin( complex z );complex casinh( complex z );complex cacos( complex z );complex cacosh( complex z );complex catan( complex z );complex catanh( complex z );complex cconj( complex z );double_t cabs( complex z );double_t carg( complex z );#ifdef __cplusplus}	// close the extern "C" declaration#endif#endif