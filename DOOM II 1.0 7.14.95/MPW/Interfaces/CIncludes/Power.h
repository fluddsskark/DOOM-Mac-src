/* 	File:		Power.h  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __POWER__#define __POWER__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __MIXEDMODE__#include <MixedMode.h>#endif#ifdef __cplusplusextern "C" {#endif#if GENERATINGPOWERPC#pragma options align=mac68k#endif#ifdef __CFM68K__#pragma lib_export on#endifenum {/* Bit positions for ModemByte */	modemOnBit					= 0,	ringWakeUpBit				= 2,	modemInstalledBit			= 3,	ringDetectBit				= 4,	modemOnHookBit				= 5,/* masks for ModemByte */	modemOnMask					= 0x1,	ringWakeUpMask				= 0x4,	modemInstalledMask			= 0x8,	ringDetectMask				= 0x10,	modemOnHookMask				= 0x20,/* bit positions for BatteryByte */	chargerConnBit				= 0,	hiChargeBit					= 1,	chargeOverFlowBit			= 2,	batteryDeadBit				= 3,	batteryLowBit				= 4,	connChangedBit				= 5,/* masks for BatteryByte */	chargerConnMask				= 0x1,	hiChargeMask				= 0x2,	chargeOverFlowMask			= 0x4,	batteryDeadMask				= 0x8};enum {	batteryLowMask				= 0x10,	connChangedMask				= 0x20,/* commands to SleepQRec sleepQProc */	sleepRequest				= 1,	sleepDemand					= 2,	sleepWakeUp					= 3,	sleepRevoke					= 4,/* SleepQRec.sleepQFlags */	noCalls						= 1,	noRequest					= 2,	slpQType					= 16,	sleepQType					= 16};/* bits in bitfield returned by PMFeatures */enum {	hasWakeupTimer				= 0,							/* 1=wakeup timer is supported						*/	hasSharedModemPort			= 1,							/* 1=modem port shared by SCC and internal modem	*/	hasProcessorCycling			= 2,							/* 1=processor cycling is supported					*/	mustProcessorCycle			= 3,							/* 1=processor cycling should not be turned off		*/	hasReducedSpeed				= 4,							/* 1=processor can be started up at reduced speed	*/	dynamicSpeedChange			= 5,							/* 1=processor speed can be switched dynamically	*/	hasSCSIDiskMode				= 6,							/* 1=SCSI Disk Mode is supported					*/	canGetBatteryTime			= 7,							/* 1=battery time can be calculated					*/	canWakeupOnRing				= 8,							/* 1=can wakeup when the modem detects a ring		*/	hasDimmingSupport			= 9								/* 1 has dimming support built into the rom			*/};/* bits in bitfield returned by GetIntModemInfo and set by SetIntModemState */enum {	hasInternalModem			= 0,							/* 1=internal modem installed						*/	intModemRingDetect			= 1,							/* 1=internal modem has detected a ring				*/	intModemOffHook				= 2,							/* 1=internal modem is off hook						*/	intModemRingWakeEnb			= 3,							/* 1=wakeup on ring is enabled						*/	extModemSelected			= 4,							/* 1=external modem selected						*/	modemSetBit					= 15							/* 1=set bit, 0=clear bit (SetIntModemState)		*/};/* bits in BatteryInfo.flags 									*//* ("chargerConnected" doesn't mean the charger is plugged in)	*/enum {	batteryInstalled			= 7,							/* 1=battery is currently connected					*/	batteryCharging				= 6,							/* 1=battery is being charged						*/	chargerConnected			= 5								/* 1=charger is connected to the PowerBook			*/};enum {	HDPwrQType					= 'HD'};typedef struct BatteryInfo BatteryInfo;struct BatteryInfo {	UInt8							flags;						/* misc flags (see below)							*/	UInt8							warningLevel;				/* scaled warning level (0-255)						*/	UInt8							reserved;					/* reserved for internal use						*/	UInt8							batteryLevel;				/* scaled battery level (0-255)						*/};typedef SInt8 ModemByte;typedef SInt8 BatteryByte;typedef long PMResultCode;typedef struct SleepQRec SleepQRec, *SleepQRecPtr;typedef struct HDQueueElement HDQueueElement;typedef pascal void (*HDSpindownProcPtr)(HDQueueElement *theElement);/*		SleepQProcPtr uses register based parameters on the 68k and cannot		be written in or called from a high-level language without the help of		mixed mode or assembly glue.		In:		 => message     	D0.L		 => qRecPtr     	A0.L		Out:		 <= return value	D0.L*/#if GENERATINGCFMtypedef UniversalProcPtr HDSpindownUPP;typedef UniversalProcPtr SleepQUPP;#elsetypedef HDSpindownProcPtr HDSpindownUPP;typedef Register68kProcPtr SleepQUPP;#endifstruct HDQueueElement {	Ptr								hdQLink;					/* pointer to next queue element					*/	short							hdQType;					/* queue element type (must be HDQType)				*/	short							hdFlags;					/* miscellaneous flags								*/	HDSpindownUPP					hdProc;						/* pointer to routine to call						*/	long							hdUser;						/* user-defined (variable storage, etc.)			*/};struct SleepQRec {	struct SleepQRec				*sleepQLink;	short							sleepQType;					/* type = 16							*/	SleepQUPP						sleepQProc;					/* Pointer to sleep universal proc ptr	*/	short							sleepQFlags;};/* wakeup time record */typedef struct WakeupTime WakeupTime;struct WakeupTime {	unsigned long					wakeTime;					/* wakeup time (same format as current time)		*/	Boolean							wakeEnabled;				/* 1=enable wakeup timer, 0=disable wakeup timer	*/	SInt8							filler;};/* battery time information (in seconds) */typedef struct BatteryTimeRec BatteryTimeRec;struct BatteryTimeRec {	unsigned long					expectedBatteryTime;		/* estimated battery time remaining				*/	unsigned long					minimumBatteryTime;			/* minimum battery time remaining				*/	unsigned long					maximumBatteryTime;			/* maximum battery time remaining				*/	unsigned long					timeUntilCharged;			/* time until battery is fully charged			*/};extern pascal OSErr DisableWUTime(void);extern pascal OSErr SetWUTime(long WUTime);extern pascal OSErr GetWUTime(long *WUTime, Byte *WUFlag);extern pascal OSErr BatteryStatus(Byte *Status, Byte *Power);extern pascal OSErr ModemStatus(Byte *Status);#if !GENERATINGCFM#pragma parameter __D0 IdleUpdate#endifextern pascal long IdleUpdate(void) ONEWORDINLINE(0xA285);#if !GENERATINGCFM#pragma parameter __D0 GetCPUSpeed#endifextern pascal long GetCPUSpeed(void) TWOWORDINLINE(0x70FF, 0xA485);extern pascal void EnableIdle(void) TWOWORDINLINE(0x7000, 0xA485);extern pascal void DisableIdle(void) TWOWORDINLINE(0x7001, 0xA485);#if !GENERATINGCFM#pragma parameter SleepQInstall(__A0)#endifextern pascal void SleepQInstall(SleepQRecPtr qRecPtr) ONEWORDINLINE(0xA28A);#if !GENERATINGCFM#pragma parameter SleepQRemove(__A0)#endifextern pascal void SleepQRemove(SleepQRecPtr qRecPtr) ONEWORDINLINE(0xA48A);extern pascal void AOn(void) TWOWORDINLINE(0x7004, 0xA685);extern pascal void AOnIgnoreModem(void) TWOWORDINLINE(0x7005, 0xA685);extern pascal void BOn(void) TWOWORDINLINE(0x7000, 0xA685);extern pascal void AOff(void) TWOWORDINLINE(0x7084, 0xA685);extern pascal void BOff(void) TWOWORDINLINE(0x7080, 0xA685);/* Public Power Management API (NEW!) */#if !GENERATINGCFM#pragma parameter __D0 PMSelectorCount#endifextern pascal short PMSelectorCount(void) TWOWORDINLINE(0x7000, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 PMFeatures#endifextern pascal unsigned long PMFeatures(void) TWOWORDINLINE(0x7001, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 GetSleepTimeout#endifextern pascal UInt8 GetSleepTimeout(void) TWOWORDINLINE(0x7002, 0xA09E);#if !GENERATINGCFM#pragma parameter SetSleepTimeout(__D0)#endifextern pascal void SetSleepTimeout(UInt8 timeout) FOURWORDINLINE(0x4840, 0x303C, 0x0003, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 GetHardDiskTimeout#endifextern pascal UInt8 GetHardDiskTimeout(void) TWOWORDINLINE(0x7004, 0xA09E);#if !GENERATINGCFM#pragma parameter SetHardDiskTimeout(__D0)#endifextern pascal void SetHardDiskTimeout(UInt8 timeout) FOURWORDINLINE(0x4840, 0x303C, 0x0005, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 HardDiskPowered#endifextern pascal Boolean HardDiskPowered(void) TWOWORDINLINE(0x7006, 0xA09E);#if !GENERATINGCFM#pragma parameter SpinDownHardDisk#endifextern pascal void SpinDownHardDisk(void) TWOWORDINLINE(0x7007, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 IsSpindownDisabled#endifextern pascal Boolean IsSpindownDisabled(void) TWOWORDINLINE(0x7008, 0xA09E);#if !GENERATINGCFM#pragma parameter SetSpindownDisable(__D0)#endifextern pascal void SetSpindownDisable(Boolean setDisable) FOURWORDINLINE(0x4840, 0x303C, 0x0009, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 HardDiskQInstall(__A0)#endifextern pascal OSErr HardDiskQInstall(HDQueueElement *theElement) TWOWORDINLINE(0x700A, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 HardDiskQRemove(__A0)#endifextern pascal OSErr HardDiskQRemove(HDQueueElement *theElement) TWOWORDINLINE(0x700B, 0xA09E);#if !GENERATINGCFM#pragma parameter GetScaledBatteryInfo(__D0, __A0)#endifextern pascal void GetScaledBatteryInfo(short whichBattery, BatteryInfo *theInfo) FIVEWORDINLINE(0x4840, 0x303C, 0x000C, 0xA09E, 0x2080);#if !GENERATINGCFM#pragma parameter AutoSleepControl(__D0)#endifextern pascal void AutoSleepControl(Boolean enableSleep) FOURWORDINLINE(0x4840, 0x303C, 0x000D, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 GetIntModemInfo#endifextern pascal unsigned long GetIntModemInfo(void) TWOWORDINLINE(0x700E, 0xA09E);#if !GENERATINGCFM#pragma parameter SetIntModemState(__D0)#endifextern pascal void SetIntModemState(short theState) FOURWORDINLINE(0x4840, 0x303C, 0x000F, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 MaximumProcessorSpeed#endifextern pascal short MaximumProcessorSpeed(void) TWOWORDINLINE(0x7010, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 CurrentProcessorSpeed#endifextern pascal short CurrentProcessorSpeed(void) TWOWORDINLINE(0x7011, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 FullProcessorSpeed#endifextern pascal Boolean FullProcessorSpeed(void) TWOWORDINLINE(0x7012, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 SetProcessorSpeed(__D0)#endifextern pascal Boolean SetProcessorSpeed(Boolean fullSpeed) FOURWORDINLINE(0x4840, 0x303C, 0x0013, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 GetSCSIDiskModeAddress#endifextern pascal short GetSCSIDiskModeAddress(void) TWOWORDINLINE(0x7014, 0xA09E);#if !GENERATINGCFM#pragma parameter SetSCSIDiskModeAddress(__D0)#endifextern pascal void SetSCSIDiskModeAddress(short scsiAddress) FOURWORDINLINE(0x4840, 0x303C, 0x0015, 0xA09E);#if !GENERATINGCFM#pragma parameter GetWakeupTimer(__A0)#endifextern pascal void GetWakeupTimer(WakeupTime *theTime) TWOWORDINLINE(0x7016, 0xA09E);#if !GENERATINGCFM#pragma parameter SetWakeupTimer(__A0)#endifextern pascal void SetWakeupTimer(WakeupTime *theTime) TWOWORDINLINE(0x7017, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 IsProcessorCyclingEnabled#endifextern pascal Boolean IsProcessorCyclingEnabled(void) TWOWORDINLINE(0x7018, 0xA09E);#if !GENERATINGCFM#pragma parameter EnableProcessorCycling(__D0)#endifextern pascal void EnableProcessorCycling(Boolean enable) FOURWORDINLINE(0x4840, 0x303C, 0x0019, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 BatteryCount#endifextern pascal short BatteryCount(void) TWOWORDINLINE(0x701A, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 GetBatteryVoltage(__D0)#endifextern pascal Fixed GetBatteryVoltage(short whichBattery) FOURWORDINLINE(0x4840, 0x303C, 0x001B, 0xA09E);#if !GENERATINGCFM#pragma parameter GetBatteryTimes(__D0, __A0)#endifextern pascal void GetBatteryTimes(short whichBattery, BatteryTimeRec *theTimes) FOURWORDINLINE(0x4840, 0x303C, 0x001C, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 GetDimmingTimeout#endifextern pascal UInt8 GetDimmingTimeout(void) TWOWORDINLINE(0x701D, 0xA09E);#if !GENERATINGCFM#pragma parameter SetDimmingTimeout(__D0)#endifextern pascal void SetDimmingTimeout(UInt8 timeout) FOURWORDINLINE(0x4840, 0x303C, 0x001E, 0xA09E);#if !GENERATINGCFM#pragma parameter DimmingControl(__D0)#endifextern pascal void DimmingControl(Boolean enableSleep) FOURWORDINLINE(0x4840, 0x303C, 0x001F, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 IsDimmingControlDisabled#endifextern pascal Boolean IsDimmingControlDisabled(void) TWOWORDINLINE(0x7020, 0xA09E);#if !GENERATINGCFM#pragma parameter __D0 IsAutoSlpControlDisabled#endifextern pascal Boolean IsAutoSlpControlDisabled(void) TWOWORDINLINE(0x7021, 0xA09E);enum {	uppHDSpindownProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(HDQueueElement*))),	uppSleepQProcInfo = kRegisterBased		 | RESULT_SIZE(SIZE_CODE(sizeof(long)))		 | REGISTER_RESULT_LOCATION(kRegisterD0)		 | REGISTER_ROUTINE_PARAMETER(1, kRegisterD0, SIZE_CODE(sizeof(long)))		 | REGISTER_ROUTINE_PARAMETER(2, kRegisterA0, SIZE_CODE(sizeof(SleepQRecPtr)))};#if GENERATINGCFM#define NewHDSpindownProc(userRoutine)		\		(HDSpindownUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppHDSpindownProcInfo, GetCurrentArchitecture())#define NewSleepQProc(userRoutine)		\		(SleepQUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSleepQProcInfo, GetCurrentArchitecture())#else#define NewHDSpindownProc(userRoutine)		\		((HDSpindownUPP) (userRoutine))#define NewSleepQProc(userRoutine)		\		((SleepQUPP) (userRoutine))#endif#if GENERATINGCFM#define CallHDSpindownProc(userRoutine, theElement)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppHDSpindownProcInfo, (theElement))#define CallSleepQProc(userRoutine, message, qRecPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSleepQProcInfo, (message), (qRecPtr))#else#define CallHDSpindownProc(userRoutine, theElement)		\		(*(userRoutine))((theElement))/* (*SleepQProcPtr) cannot be called from a high-level language without the Mixed Mode Manager */#endif#ifdef __CFM68K__#pragma lib_export off#endif#if GENERATINGPOWERPC#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __POWER__ */