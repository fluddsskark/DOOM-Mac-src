/* 	File:		Controls.h  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __CONTROLS__#define __CONTROLS__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __QUICKDRAW__#include <Quickdraw.h>#endif/*	#include <MixedMode.h>										*//*	#include <QuickdrawText.h>									*/#ifndef __MENUS__#include <Menus.h>#endif/*	#include <Memory.h>											*//*	#include <Events.h>											*//*		#include <OSUtils.h>									*/#ifdef __cplusplusextern "C" {#endif#if GENERATINGPOWERPC#pragma options align=mac68k#endif#ifdef __CFM68K__#pragma lib_export on#endif#ifndef STRICT_CONTROLS#define STRICT_CONTROLS 0#endifenum {	pushButProc					= 0,	checkBoxProc				= 1,	radioButProc				= 2,	scrollBarProc				= 16,	popupMenuProc				= 1008};/**//* Standard System 7 CDEF variant codes for use in control creation API's*//**/enum {	useWFont					= 8};#if OLDROUTINENAMESenum {	inLabel						= 1,	inMenu						= 2,	inTriangle					= 4,	inButton					= 10,	inCheckBox					= 11,	inUpButton					= 20,	inDownButton				= 21,	inPageUp					= 22,	inPageDown					= 23,	inThumb						= 129};#endiftypedef UInt8 ControlPartCode;typedef UInt8 ControlHiliteValue;enum {	kNoHiliteControlPart		= 0,	kInLabelControlPart			= 1,	kInMenuControlPart			= 2,	kInTriangleControlPart		= 4,	kInButtonControlPart		= 10,	kInCheckBoxControlPart		= 11,	kInUpButtonControlPart		= 20,	kInDownButtonControlPart	= 21,	kInPageUpControlPart		= 22,	kInPageDownControlPart		= 23,	kInIndicatorControlPart		= 129,	kReservedControlPart		= 254,	kControlInactiveControlPart	= 255};/**//* System 7 Pop-up menu variants*//**/enum {	popupFixedWidth				= 1 << 0,	popupVariableWidth			= 1 << 1,	popupUseAddResMenu			= 1 << 2,	popupUseWFont				= 1 << 3};/**//* System 7 Pop-up menu title styles*//**/enum {	popupTitleBold				= 1 << 8,	popupTitleItalic			= 1 << 9,	popupTitleUnderline			= 1 << 10,	popupTitleOutline			= 1 << 11,	popupTitleShadow			= 1 << 12,	popupTitleCondense			= 1 << 13,	popupTitleExtend			= 1 << 14,	popupTitleNoStyle			= 1 << 15};/**//* System 7 Pop-up menu label justifications*//**/enum {	popupTitleLeftJust			= 0x00000000,	popupTitleCenterJust		= 0x00000001,	popupTitleRightJust			= 0x000000FF};/**//* Axis constraints for DragGrayRgn call*//**/enum {	noConstraint				= kNoConstraint,	hAxisOnly					= 1,	vAxisOnly					= 2};/**//* Messages for the control defproc*//**/typedef SInt16 ControlDefProcMessage;enum {	drawCntl					= 0,	testCntl					= 1,	calcCRgns					= 2,	initCntl					= 3,	dispCntl					= 4,	posCntl						= 5,	thumbCntl					= 6,	dragCntl					= 7,	autoTrack					= 8,	calcCntlRgn					= 10,	calcThumbRgn				= 11,	drawThumbOutline			= 12};/**//* Control color table part codes*//**/enum {	cFrameColor					= 0,	cBodyColor					= 1,	cTextColor					= 2,	cThumbColor					= 3};#if STRICT_CONTROLStypedef struct OpaqueControlRef *ControlRef;typedef ControlRef ControlHandle;#elsetypedef struct ControlRecord ControlRecord, *ControlPtr, **ControlHandle;typedef ControlHandle ControlRef;#endif/**//* Define the main entry point to the standard action proc pointer*//**/typedef pascal long (*ControlDefProcPtr)(short varCode, ControlRef theControl, short message, long param);typedef pascal void (*ControlActionProcPtr)(ControlRef theControl, short partCode);#if GENERATINGCFMtypedef UniversalProcPtr ControlDefUPP;typedef UniversalProcPtr ControlActionUPP;#elsetypedef ControlDefProcPtr ControlDefUPP;typedef ControlActionProcPtr ControlActionUPP;#endifstruct CtlCTab {	long							ccSeed;	short							ccRider;	short							ctSize;	ColorSpec						ctTable[4];};typedef struct CtlCTab CtlCTab;typedef CtlCTab *CCTabPtr, **CCTabHandle;#if !STRICT_CONTROLSstruct ControlRecord {	ControlRef						nextControl;	WindowRef						contrlOwner;	Rect							contrlRect;	UInt8							contrlVis;	UInt8							contrlHilite;	short							contrlValue;	short							contrlMin;	short							contrlMax;	Handle							contrlDefProc;	Handle							contrlData;	ControlActionUPP				contrlAction;	long							contrlRfCon;	Str255							contrlTitle;};/**//* Define private pop-up menu storage (hung off contrlData field in ControlRecord).*//**/struct PopupPrivateData {	MenuHandle						mHandle;	short							mID;};typedef struct PopupPrivateData PopupPrivateData;typedef PopupPrivateData *PopupPrivateDataPtr, **PopupPrivateDataHandle;#endifstruct AuxCtlRec {	Handle							acNext;	ControlRef						acOwner;	CCTabHandle						acCTable;	short							acFlags;	long							acReserved;	long							acRefCon;};typedef struct AuxCtlRec AuxCtlRec;typedef AuxCtlRec *AuxCtlPtr, **AuxCtlHandle;/**//* Structure used in __TrackControl() - See IM I-332*//**/struct IndicatorDragConstraint {	Rect							limitRect;	Rect							slopRect;	DragConstraint					axis;};typedef struct IndicatorDragConstraint IndicatorDragConstraint;typedef IndicatorDragConstraint *IndicatorDragConstraintPtr, **IndicatorDragConstraintHandle;enum {	uppControlDefProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(ControlRef)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long))),	uppControlActionProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(ControlRef)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))};#if GENERATINGCFM#define NewControlDefProc(userRoutine)		\		(ControlDefUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppControlDefProcInfo, GetCurrentArchitecture())#define NewControlActionProc(userRoutine)		\		(ControlActionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppControlActionProcInfo, GetCurrentArchitecture())#else#define NewControlDefProc(userRoutine)		\		((ControlDefUPP) (userRoutine))#define NewControlActionProc(userRoutine)		\		((ControlActionUPP) (userRoutine))#endif#if GENERATINGCFM#define CallControlDefProc(userRoutine, varCode, theControl, message, param)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppControlDefProcInfo, (varCode), (theControl), (message), (param))#define CallControlActionProc(userRoutine, theControl, partCode)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppControlActionProcInfo, (theControl), (partCode))#else#define CallControlDefProc(userRoutine, varCode, theControl, message, param)		\		(*(userRoutine))((varCode), (theControl), (message), (param))#define CallControlActionProc(userRoutine, theControl, partCode)		\		(*(userRoutine))((theControl), (partCode))#endifextern pascal ControlRef NewControl(WindowRef theWindow, const Rect *boundsRect, ConstStr255Param title, Boolean visible, short value, short min, short max, short procID, long refCon) ONEWORDINLINE(0xA954);extern pascal void SetControlTitle(ControlRef theControl, ConstStr255Param title) ONEWORDINLINE(0xA95F);extern pascal void GetControlTitle(ControlRef theControl, Str255 title) ONEWORDINLINE(0xA95E);extern pascal ControlRef GetNewControl(short controlID, WindowRef owner) ONEWORDINLINE(0xA9BE);extern pascal void DisposeControl(ControlRef theControl) ONEWORDINLINE(0xA955);extern pascal void KillControls(WindowRef theWindow) ONEWORDINLINE(0xA956);extern pascal void HideControl(ControlRef theControl) ONEWORDINLINE(0xA958);extern pascal void ShowControl(ControlRef theControl) ONEWORDINLINE(0xA957);extern pascal void DrawControls(WindowRef theWindow) ONEWORDINLINE(0xA969);extern pascal void Draw1Control(ControlRef theControl) ONEWORDINLINE(0xA96D);extern pascal void HiliteControl(ControlRef theControl, short hiliteState) ONEWORDINLINE(0xA95D);extern pascal void UpdateControls(WindowRef theWindow, RgnHandle updateRgn) ONEWORDINLINE(0xA953);extern pascal void MoveControl(ControlRef theControl, short h, short v) ONEWORDINLINE(0xA959);extern pascal void SizeControl(ControlRef theControl, short w, short h) ONEWORDINLINE(0xA95C);extern pascal void SetControlValue(ControlRef theControl, short theValue) ONEWORDINLINE(0xA963);extern pascal short GetControlValue(ControlRef theControl) ONEWORDINLINE(0xA960);extern pascal void SetControlMinimum(ControlRef theControl, short minValue) ONEWORDINLINE(0xA964);extern pascal short GetControlMinimum(ControlRef theControl) ONEWORDINLINE(0xA961);extern pascal void SetControlMaximum(ControlRef theControl, short maxValue) ONEWORDINLINE(0xA965);extern pascal short GetControlMaximum(ControlRef theControl) ONEWORDINLINE(0xA962);#if !STRICT_CONTROLSextern pascal Boolean GetAuxiliaryControlRecord(ControlRef theControl, AuxCtlHandle *acHndl) ONEWORDINLINE(0xAA44);#endifextern pascal void SetControlReference(ControlRef theControl, long data) ONEWORDINLINE(0xA95B);extern pascal long GetControlReference(ControlRef theControl) ONEWORDINLINE(0xA95A);extern pascal void SetControlAction(ControlRef theControl, ControlActionUPP actionProc) ONEWORDINLINE(0xA96B);extern pascal ControlActionUPP GetControlAction(ControlRef theControl) ONEWORDINLINE(0xA96A);extern pascal void DragControl(ControlRef theControl, Point startPt, const Rect *limitRect, const Rect *slopRect, short axis) ONEWORDINLINE(0xA967);extern pascal short TestControl(ControlRef theControl, Point thePt) ONEWORDINLINE(0xA966);extern pascal short FindControl(Point thePoint, WindowRef theWindow, ControlRef *theControl) ONEWORDINLINE(0xA96C);extern pascal void SetControlColor(ControlRef theControl, CCTabHandle newColorTable) ONEWORDINLINE(0xAA43);extern pascal short GetControlVariant(ControlRef theControl) ONEWORDINLINE(0xA809);/*	When using the TrackControl() call when tracking an indicator, the	actionProc parameter (type ControlActionUPP) should be replaced by	a parameter of type DragGrayRgnUPP (defined in Quickdraw.<header>).*/extern pascal short TrackControl(ControlRef theControl, Point thePoint, ControlActionUPP actionProc) ONEWORDINLINE(0xA968);#if CGLUESUPPORTEDextern void dragcontrol(ControlRef theControl, Point *startPt, const Rect *limitRect, const Rect *slopRect, short axis);extern ControlRef newcontrol(WindowRef theWindow, const Rect *boundsRect, const char *title, Boolean visible, short value, short min, short max, short procID, long refCon);extern short findcontrol(Point *thePoint, WindowRef theWindow, ControlRef *theControl);extern void getcontroltitle(ControlRef theControl, char *title);extern void setcontroltitle(ControlRef theControl, const char *title);extern short trackcontrol(ControlRef theControl, Point *thePoint, ControlActionUPP actionProc);extern short testcontrol(ControlRef theControl, Point *thePt);#endif#if OLDROUTINENAMES#define SetCTitle(theControl, title) SetControlTitle(theControl, title)#define GetCTitle(theControl, title) GetControlTitle(theControl, title)#define UpdtControl(theWindow, updateRgn) UpdateControls(theWindow, updateRgn)#define SetCtlValue(theControl, theValue) SetControlValue(theControl, theValue)#define GetCtlValue(theControl) GetControlValue(theControl)#define SetCtlMin(theControl, minValue) SetControlMinimum(theControl, minValue)#define GetCtlMin(theControl) GetControlMinimum(theControl)#define SetCtlMax(theControl, maxValue) SetControlMaximum(theControl, maxValue)#define GetCtlMax(theControl) GetControlMaximum(theControl)#define GetAuxCtl(theControl, acHndl) GetAuxiliaryControlRecord(theControl, acHndl)#define SetCRefCon(theControl, data) SetControlReference(theControl, data)#define GetCRefCon(theControl) GetControlReference(theControl)#define SetCtlAction(theControl, actionProc) SetControlAction(theControl, actionProc)#define GetCtlAction(theControl) GetControlAction(theControl)#define SetCtlColor(theControl, newColorTable) SetControlColor(theControl, newColorTable)#define GetCVariant(theControl) GetControlVariant(theControl)#if CGLUESUPPORTED#define getctitle(theControl, title) getcontroltitle(theControl, title)#define setctitle(theControl, title) setcontroltitle(theControl, title)#endif#endif#ifdef __CFM68K__#pragma lib_export off#endif#if GENERATINGPOWERPC#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __CONTROLS__ */