/* 	File:		MacTCP.h  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __MACTCP__#define __MACTCP__#ifndef __TYPES__#include <Types.h>#endif/*	#include <ConditionalMacros.h>								*/#ifndef __APPLETALK__#include <AppleTalk.h>#endif/*	#include <OSUtils.h>										*//*		#include <MixedMode.h>									*//*		#include <Memory.h>										*/#ifdef __cplusplusextern "C" {#endif#if GENERATINGPOWERPC#pragma options align=mac68k#endif#ifdef __CFM68K__#pragma lib_export on#endifenum {	inProgress					= 1,							/* I/O in progress */	ipBadLapErr					= -23000,						/* bad network configuration */	ipBadCnfgErr				= -23001,						/* bad IP configuration error */	ipNoCnfgErr					= -23002,						/* missing IP or LAP configuration error */	ipLoadErr					= -23003,						/* error in MacTCP load */	ipBadAddr					= -23004,						/* error in getting address */	connectionClosing			= -23005,						/* connection is closing */	invalidLength				= -23006,	connectionExists			= -23007,						/* request conflicts with existing connection */	connectionDoesntExist		= -23008,						/* connection does not exist */	insufficientResources		= -23009,						/* insufficient resources to perform request */	invalidStreamPtr			= -23010,	streamAlreadyOpen			= -23011,	connectionTerminated		= -23012,	invalidBufPtr				= -23013,	invalidRDS					= -23014,	invalidWDS					= -23014,	openFailed					= -23015,	commandTimeout				= -23016,	duplicateSocket				= -23017};/* Error codes from internal IP functions */enum {	ipDontFragErr				= -23032,						/* Packet too large to send w/o fragmenting */	ipDestDeadErr				= -23033,						/* destination not responding */	icmpEchoTimeoutErr			= -23035,						/* ICMP echo timed-out */	ipNoFragMemErr				= -23036,						/* no memory to send fragmented pkt */	ipRouteErr					= -23037,						/* can't route packet off-net */	nameSyntaxErr				= -23041,	cacheFault					= -23042,	noResultProc				= -23043,	noNameServer				= -23044,	authNameErr					= -23045,	noAnsErr					= -23046,	dnrErr						= -23047,	outOfMemory					= -23048};enum {	BYTES_16WORD				= 2,							/* bytes per = 16, bit ip word */	BYTES_32WORD				= 4,							/* bytes per = 32, bit ip word */	BYTES_64WORD				= 8								/* bytes per = 64, bit ip word */};typedef unsigned char b_8;typedef unsigned short b_16;typedef unsigned long b_32;typedef b_32 ip_addr;struct ip_addrbytes {		union {			b_32							addr;			char							byte[4];		}							a;};typedef struct ip_addrbytes ip_addrbytes;struct wdsEntry {	unsigned short					length;						/* length of buffer */	char							*ptr;						/* pointer to buffer */};typedef struct wdsEntry wdsEntry;struct rdsEntry {	unsigned short					length;						/* length of buffer */	char							*ptr;						/* pointer to buffer */};typedef struct rdsEntry rdsEntry;typedef unsigned long BufferPtr;typedef unsigned long StreamPtr;enum {	netUnreach					= 0,	hostUnreach					= 1,	protocolUnreach				= 2,	portUnreach					= 3,	fragReqd					= 4,	sourceRouteFailed			= 5,	timeExceeded				= 6,	parmProblem					= 7,	missingOption				= 8};typedef unsigned short ICMPMsgType;typedef b_16 ip_port;struct ICMPReport {	StreamPtr						streamPtr;	ip_addr							localHost;	ip_port							localPort;	ip_addr							remoteHost;	ip_port							remotePort;	short							reportType;	unsigned short					optionalAddlInfo;	unsigned long					optionalAddlInfoPtr;};typedef struct ICMPReport ICMPReport;typedef OSErr (*OSErrProcPtr)();#if GENERATINGCFMtypedef UniversalProcPtr OSErrUPP;#elsetypedef OSErrProcPtr OSErrUPP;#endifenum {	uppOSErrProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))};#if GENERATINGCFM#define NewOSErrProc(userRoutine)		\		(OSErrUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppOSErrProcInfo, GetCurrentArchitecture())#else#define NewOSErrProc(userRoutine)		\		((OSErrUPP) (userRoutine))#endif#if GENERATINGCFM#define CallOSErrProc(userRoutine)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppOSErrProcInfo)#else#define CallOSErrProc(userRoutine)		\		(*(userRoutine))()#endiftypedef Ptr (*PtrProcPtr)();#if GENERATINGCFMtypedef UniversalProcPtr PtrUPP;#elsetypedef PtrProcPtr PtrUPP;#endifenum {	uppPtrProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Ptr)))};#if GENERATINGCFM#define NewPtrProc(userRoutine)		\		(PtrUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppPtrProcInfo, GetCurrentArchitecture())#else#define NewPtrProc(userRoutine)		\		((PtrUPP) (userRoutine))#endif#if GENERATINGCFM#define CallPtrProc(userRoutine)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppPtrProcInfo)#else#define CallPtrProc(userRoutine)		\		(*(userRoutine))()#endiftypedef Boolean (*BooleanProcPtr)();#if GENERATINGCFMtypedef UniversalProcPtr BooleanUPP;#elsetypedef BooleanProcPtr BooleanUPP;#endifenum {	uppBooleanProcInfo = kCStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))};#if GENERATINGCFM#define NewBooleanProc(userRoutine)		\		(BooleanUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppBooleanProcInfo, GetCurrentArchitecture())#else#define NewBooleanProc(userRoutine)		\		((BooleanUPP) (userRoutine))#endif#if GENERATINGCFM#define CallBooleanProc(userRoutine)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppBooleanProcInfo)#else#define CallBooleanProc(userRoutine)		\		(*(userRoutine))()#endifenum {	NUM_ALT_ADDRS				= 4};struct hostInfo {	long							rtnCode;	char							cname[255];	UInt8							filler;						/* Filler for proper byte alignment	 */	unsigned long					addr[NUM_ALT_ADDRS];};typedef struct hostInfo hostInfo;enum {	A							= 1,	NS							= 2,	CNAME						= 5,	HINFO						= 13,	MX							= 15};typedef unsigned short AddrClasses;struct HInfoRec {	char							cpuType[30];	char							osType[30];};typedef struct HInfoRec HInfoRec;struct MXRec {	unsigned short					preference;	char							exchange[255];};typedef struct MXRec MXRec;struct returnRec {	long							rtnCode;	char							cname[255];	UInt8							filler;						/* Filler for proper byte alignment	 */		union {			unsigned long					addr[NUM_ALT_ADDRS];			struct HInfoRec					hinfo;			struct MXRec					mx;		}							rdata;};struct cacheEntryRecord {	char							*cname;	unsigned short					ctype;	unsigned short					cacheClass;	unsigned long					ttl;		union {			char							*name;			ip_addr							addr;		}							rdata;};typedef struct returnRec returnRec;typedef struct cacheEntryRecord cacheEntryRecord;typedef pascal void (*EnumResultProcPtr)(struct cacheEntryRecord *cacheEntryRecordPtr, char *userDataPtr);#if GENERATINGCFMtypedef UniversalProcPtr EnumResultUPP;#elsetypedef EnumResultProcPtr EnumResultUPP;#endifenum {	uppEnumResultProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct cacheEntryRecord*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*)))};#if GENERATINGCFM#define NewEnumResultProc(userRoutine)		\		(EnumResultUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppEnumResultProcInfo, GetCurrentArchitecture())#else#define NewEnumResultProc(userRoutine)		\		((EnumResultUPP) (userRoutine))#endif#if GENERATINGCFM#define CallEnumResultProc(userRoutine, cacheEntryRecordPtr, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppEnumResultProcInfo, (cacheEntryRecordPtr), (userDataPtr))#else#define CallEnumResultProc(userRoutine, cacheEntryRecordPtr, userDataPtr)		\		(*(userRoutine))((cacheEntryRecordPtr), (userDataPtr))#endiftypedef pascal void (*ResultProcPtr)(struct hostInfo *hostInfoPtr, char *userDataPtr);#if GENERATINGCFMtypedef UniversalProcPtr ResultUPP;#elsetypedef ResultProcPtr ResultUPP;#endifenum {	uppResultProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct hostInfo*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*)))};#if GENERATINGCFM#define NewResultProc(userRoutine)		\		(ResultUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppResultProcInfo, GetCurrentArchitecture())#else#define NewResultProc(userRoutine)		\		((ResultUPP) (userRoutine))#endif#if GENERATINGCFM#define CallResultProc(userRoutine, hostInfoPtr, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppResultProcInfo, (hostInfoPtr), (userDataPtr))#else#define CallResultProc(userRoutine, hostInfoPtr, userDataPtr)		\		(*(userRoutine))((hostInfoPtr), (userDataPtr))#endiftypedef pascal void (*Result2ProcPtr)(struct returnRec *returnRecPtr, char *userDataPtr);#if GENERATINGCFMtypedef UniversalProcPtr Result2UPP;#elsetypedef Result2ProcPtr Result2UPP;#endifenum {	uppResult2ProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct returnRec*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char*)))};#if GENERATINGCFM#define NewResult2Proc(userRoutine)		\		(Result2UPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppResult2ProcInfo, GetCurrentArchitecture())#else#define NewResult2Proc(userRoutine)		\		((Result2UPP) (userRoutine))#endif#if GENERATINGCFM#define CallResult2Proc(userRoutine, returnRecPtr, userDataPtr)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppResult2ProcInfo, (returnRecPtr), (userDataPtr))#else#define CallResult2Proc(userRoutine, returnRecPtr, userDataPtr)		\		(*(userRoutine))((returnRecPtr), (userDataPtr))#endifextern pascal OSErr OpenResolver(char *fileName);extern pascal OSErr StrToAddr(char *hostName, struct hostInfo *hostInfoPtr, ResultUPP ResultProc, char *userDataPtr);extern pascal OSErr AddrToStr(unsigned long addr, char *addrStr);extern pascal OSErr EnumCache(EnumResultUPP enumResultProc, char *userDataPtr);extern pascal OSErr AddrToName(ip_addr addr, struct hostInfo *hostInfoPtr, ResultUPP ResultProc, char *userDataPtr);extern pascal OSErr HInfo(char *hostName, struct returnRec *returnRecPtr, Result2UPP resultProc, char *userDataPtr);extern pascal OSErr MXInfo(char *hostName, struct returnRec *returnRecPtr, Result2UPP resultProc, char *userDataPtr);extern pascal OSErr CloseResolver(void);/* csCode to get our IP address */enum {	ipctlGetAddr				= 15};struct GetAddrParamBlock {	struct QElem					*qLink;	short							qType;	short							ioTrap;	Ptr								ioCmdAddr;	UniversalProcPtr				ioCompletion;	OSErr							ioResult;	StringPtr						ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;						/* standard I/O header */	ip_addr							ourAddress;					/* our IP address */	long							ourNetMask;					/* our IP net mask */};typedef struct GetAddrParamBlock GetAddrParamBlock;/* control codes */enum {	ipctlEchoICMP				= 17,							/* send icmp echo */	ipctlLAPStats				= 19							/* get lap stats */};struct ICMPParamBlock {	struct QElem					*qLink;	short							qType;	short							ioTrap;	Ptr								ioCmdAddr;	UniversalProcPtr				ioCompletion;	OSErr							ioResult;	StringPtr						ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;						/* standard I/O header */	short							params[11];		struct {			unsigned long					echoRequestOut;		/* time in ticks of when the echo request went out */			unsigned long					echoReplyIn;		/* time in ticks of when the reply was received */			struct rdsEntry					echoedData;			/* data received in responce */			Ptr								options;			unsigned long					userDataPtr;		}							icmpEchoInfo;};enum {	NBP_TABLE_SIZE				= 20,							/* number of NBP table entries */	NBP_MAX_NAME_SIZE			= 16 + 10 + 2};struct nbp_entry {	ip_addr							ip_address;					/* IP address */	AddrBlock						at_address;					/* matching AppleTalk address */	Boolean							gateway;					/* TRUE if entry for a gateway */	Boolean							valid;						/* TRUE if LAP address is valid */	Boolean							probing;					/* TRUE if NBP lookup pending */	UInt8							afiller;					/* Filler for proper byte alignment	 */	long							age;						/* ticks since cache entry verified */	long							access;						/* ticks since last access */	char							filler[116];				/* for internal use only !!! */};/* number of ARP table entries */enum {	ARP_TABLE_SIZE				= 20};struct Enet_addr {	b_16							en_hi;	b_32							en_lo;};typedef struct Enet_addr Enet_addr;struct arp_entry {	short							age;						/* cache aging field */	b_16							protocol;					/* Protocol type */	ip_addr							ip_address;					/* IP address */	Enet_addr						en_address;					/* matching Ethernet address */};typedef struct arp_entry arp_entry;/* Command codes */enum {	TCPCreate					= 30,	TCPPassiveOpen				= 31,	TCPActiveOpen				= 32,	TCPSend						= 34,	TCPNoCopyRcv				= 35,	TCPRcvBfrReturn				= 36,	TCPRcv						= 37,	TCPClose					= 38,	TCPAbort					= 39,	TCPStatus					= 40,	TCPExtendedStat				= 41,	TCPRelease					= 42,	TCPGlobalInfo				= 43,	TCPCtlMax					= 49};typedef void (*ICMPEchoNotifyProcPtr)(struct ICMPParamBlock *iopb);#if GENERATINGCFMtypedef UniversalProcPtr ICMPEchoNotifyUPP;#elsetypedef ICMPEchoNotifyProcPtr ICMPEchoNotifyUPP;#endifenum {	uppICMPEchoNotifyProcInfo = kCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct ICMPParamBlock*)))};#if GENERATINGCFM#define NewICMPEchoNotifyProc(userRoutine)		\		(ICMPEchoNotifyUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppICMPEchoNotifyProcInfo, GetCurrentArchitecture())#else#define NewICMPEchoNotifyProc(userRoutine)		\		((ICMPEchoNotifyUPP) (userRoutine))#endif#if GENERATINGCFM#define CallICMPEchoNotifyProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppICMPEchoNotifyProcInfo, (iopb))#else#define CallICMPEchoNotifyProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#endifstruct IPParamBlock {	struct QElem					*qLink;	short							qType;	short							ioTrap;	Ptr								ioCmdAddr;	UniversalProcPtr				ioCompletion;	OSErr							ioResult;	StringPtr						ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;						/* standard I/O header */		union {				struct {					ip_addr							dest;		/* echo to IP address */					wdsEntry						data;					short							timeout;					Ptr								options;					unsigned short					optLength;					ICMPEchoNotifyUPP				icmpCompletion;					unsigned long					userDataPtr;				}							IPEchoPB;				struct {					struct LAPStats					*lapStatsPtr;				}							LAPStatsPB;		}							csParam;};struct LAPStats {	short							ifType;	char							*ifString;	short							ifMaxMTU;	long							ifSpeed;	short							ifPhyAddrLength;	char							*ifPhysicalAddress;		union {			struct arp_entry				*arp_table;			struct nbp_entry				*nbp_table;		}							AddrXlation;	short							slotNumber;};typedef struct LAPStats LAPStats;enum {	TCPClosing					= 1,	TCPULPTimeout				= 2,	TCPTerminate				= 3,	TCPDataArrival				= 4,	TCPUrgent					= 5,	TCPICMPReceived				= 6};typedef unsigned short TCPEventCode;enum {	TCPRemoteAbort				= 2,	TCPNetworkFailure			= 3,	TCPSecPrecMismatch			= 4,	TCPULPTimeoutTerminate		= 5,	TCPULPAbort					= 6,	TCPULPClose					= 7,	TCPServiceError				= 8};typedef unsigned short TCPTerminationReason;typedef pascal void (*TCPNotifyProcPtr)(StreamPtr tcpStream, unsigned short eventCode, Ptr userDataPtr, unsigned short terminReason, struct ICMPReport *icmpMsg);#if GENERATINGCFMtypedef UniversalProcPtr TCPNotifyUPP;#elsetypedef TCPNotifyProcPtr TCPNotifyUPP;#endifenum {	uppTCPNotifyProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(StreamPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(unsigned short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(unsigned short)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(struct ICMPReport*)))};#if GENERATINGCFM#define NewTCPNotifyProc(userRoutine)		\		(TCPNotifyUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTCPNotifyProcInfo, GetCurrentArchitecture())#else#define NewTCPNotifyProc(userRoutine)		\		((TCPNotifyUPP) (userRoutine))#endif#if GENERATINGCFM#define CallTCPNotifyProc(userRoutine, tcpStream, eventCode, userDataPtr, terminReason, icmpMsg)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppTCPNotifyProcInfo, (tcpStream), (eventCode), (userDataPtr), (terminReason), (icmpMsg))#else#define CallTCPNotifyProc(userRoutine, tcpStream, eventCode, userDataPtr, terminReason, icmpMsg)		\		(*(userRoutine))((tcpStream), (eventCode), (userDataPtr), (terminReason), (icmpMsg))#endiftypedef unsigned short tcp_port;/* ValidityFlags */enum {	timeoutValue				= 0x80,	timeoutAction				= 0x40,	typeOfService				= 0x20,	precedence					= 0x10};/* TOSFlags */enum {	lowDelay					= 0x01,	throughPut					= 0x02,	reliability					= 0x04};struct TCPCreatePB {	Ptr								rcvBuff;	unsigned long					rcvBuffLen;	TCPNotifyUPP					notifyProc;	Ptr								userDataPtr;};typedef struct TCPCreatePB TCPCreatePB;struct TCPOpenPB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	SInt8							validityFlags;	SInt8							commandTimeoutValue;	ip_addr							remoteHost;	tcp_port						remotePort;	ip_addr							localHost;	tcp_port						localPort;	SInt8							tosFlags;	SInt8							precedence;	Boolean							dontFrag;	SInt8							timeToLive;	SInt8							security;	SInt8							optionCnt;	SInt8							options[40];	Ptr								userDataPtr;};typedef struct TCPOpenPB TCPOpenPB;struct TCPSendPB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	SInt8							validityFlags;	UInt8							filler;						/* Filler for proper byte alignment	 */	Boolean							pushFlag;	Boolean							urgentFlag;	Ptr								wdsPtr;	unsigned long					sendFree;	unsigned short					sendLength;	Ptr								userDataPtr;};typedef struct TCPSendPB TCPSendPB;/* for receive and return rcv buff calls */struct TCPReceivePB {	SInt8							commandTimeoutValue;	SInt8							filler;	Boolean							markFlag;	Boolean							urgentFlag;	Ptr								rcvBuff;	unsigned short					rcvBuffLen;	Ptr								rdsPtr;	unsigned short					rdsLength;	unsigned short					secondTimeStamp;	Ptr								userDataPtr;};typedef struct TCPReceivePB TCPReceivePB;struct TCPClosePB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	SInt8							validityFlags;	UInt8							filler;						/* Filler for proper byte alignment	 */	Ptr								userDataPtr;};typedef struct TCPClosePB TCPClosePB;struct HistoBucket {	unsigned short					value;	unsigned long					counter;};typedef struct HistoBucket HistoBucket;enum {	NumOfHistoBuckets			= 7};struct TCPConnectionStats {	unsigned long					dataPktsRcvd;	unsigned long					dataPktsSent;	unsigned long					dataPktsResent;	unsigned long					bytesRcvd;	unsigned long					bytesRcvdDup;	unsigned long					bytesRcvdPastWindow;	unsigned long					bytesSent;	unsigned long					bytesResent;	unsigned short					numHistoBuckets;	struct HistoBucket				sentSizeHisto[NumOfHistoBuckets];	unsigned short					lastRTT;	unsigned short					tmrSRTT;	unsigned short					rttVariance;	unsigned short					tmrRTO;	SInt8							sendTries;	SInt8							sourchQuenchRcvd;};typedef struct TCPConnectionStats TCPConnectionStats;struct TCPStatusPB {	SInt8							ulpTimeoutValue;	SInt8							ulpTimeoutAction;	long							unused;	ip_addr							remoteHost;	tcp_port						remotePort;	ip_addr							localHost;	tcp_port						localPort;	SInt8							tosFlags;	SInt8							precedence;	SInt8							connectionState;	UInt8							filler;						/* Filler for proper byte alignment	 */	unsigned short					sendWindow;	unsigned short					rcvWindow;	unsigned short					amtUnackedData;	unsigned short					amtUnreadData;	Ptr								securityLevelPtr;	unsigned long					sendUnacked;	unsigned long					sendNext;	unsigned long					congestionWindow;	unsigned long					rcvNext;	unsigned long					srtt;	unsigned long					lastRTT;	unsigned long					sendMaxSegSize;	struct TCPConnectionStats		*connStatPtr;	Ptr								userDataPtr;};typedef struct TCPStatusPB TCPStatusPB;struct TCPAbortPB {	Ptr								userDataPtr;};typedef struct TCPAbortPB TCPAbortPB;struct TCPParam {	unsigned long					tcpRtoA;	unsigned long					tcpRtoMin;	unsigned long					tcpRtoMax;	unsigned long					tcpMaxSegSize;	unsigned long					tcpMaxConn;	unsigned long					tcpMaxWindow;};typedef struct TCPParam TCPParam;struct TCPStats {	unsigned long					tcpConnAttempts;	unsigned long					tcpConnOpened;	unsigned long					tcpConnAccepted;	unsigned long					tcpConnClosed;	unsigned long					tcpConnAborted;	unsigned long					tcpOctetsIn;	unsigned long					tcpOctetsOut;	unsigned long					tcpOctetsInDup;	unsigned long					tcpOctetsRetrans;	unsigned long					tcpInputPkts;	unsigned long					tcpOutputPkts;	unsigned long					tcpDupPkts;	unsigned long					tcpRetransPkts;};typedef struct TCPStats TCPStats;typedef StreamPtr *StreamPPtr;struct TCPGlobalInfoPB {	struct TCPParam					*tcpParamPtr;	struct TCPStats					*tcpStatsPtr;	StreamPPtr						tcpCDBTable[1];	Ptr								userDataPtr;	unsigned short					maxTCPConnections;};typedef struct TCPGlobalInfoPB TCPGlobalInfoPB;typedef void (*TCPIOCompletionProcPtr)(struct TCPiopb *iopb);#if GENERATINGCFMtypedef UniversalProcPtr TCPIOCompletionUPP;#elsetypedef TCPIOCompletionProcPtr TCPIOCompletionUPP;#endifstruct TCPiopb {	char							fill12[12];	TCPIOCompletionUPP				ioCompletion;	short							ioResult;	char							*ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;	StreamPtr						tcpStream;		union {			struct TCPCreatePB				create;			struct TCPOpenPB				open;			struct TCPSendPB				send;			struct TCPReceivePB				receive;			struct TCPClosePB				close;			struct TCPAbortPB				abort;			struct TCPStatusPB				status;			struct TCPGlobalInfoPB			globalInfo;		}							csParam;};typedef struct TCPiopb TCPiopb;#if GENERATINGCFM#else#endifenum {	uppTCPIOCompletionProcInfo = kCStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(struct TCPiopb*)))};#if GENERATINGCFM#define NewTCPIOCompletionProc(userRoutine)		\		(TCPIOCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTCPIOCompletionProcInfo, GetCurrentArchitecture())#else#define NewTCPIOCompletionProc(userRoutine)		\		((TCPIOCompletionUPP) (userRoutine))#endif#if GENERATINGCFM#define CallTCPIOCompletionProc(userRoutine, iopb)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppTCPIOCompletionProcInfo, (iopb))#else#define CallTCPIOCompletionProc(userRoutine, iopb)		\		(*(userRoutine))((iopb))#endifenum {	UDPCreate					= 20,	UDPRead						= 21,	UDPBfrReturn				= 22,	UDPWrite					= 23,	UDPRelease					= 24,	UDPMaxMTUSize				= 25,	UDPStatus					= 26,	UDPMultiCreate				= 27,	UDPMultiSend				= 28,	UDPMultiRead				= 29,	UDPCtlMax					= 29};enum {	UDPDataArrival				= 1,	UDPICMPReceived				= 2};typedef unsigned short UDPEventCode;typedef pascal void (*UDPNotifyProcPtr)(StreamPtr udpStream, unsigned short eventCode, Ptr userDataPtr, struct ICMPReport *icmpMsg);#if GENERATINGCFMtypedef UniversalProcPtr UDPNotifyUPP;#elsetypedef UDPNotifyProcPtr UDPNotifyUPP;#endifenum {	uppUDPNotifyProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(StreamPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(unsigned short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(struct ICMPReport*)))};#if GENERATINGCFM#define NewUDPNotifyProc(userRoutine)		\		(UDPNotifyUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppUDPNotifyProcInfo, GetCurrentArchitecture())#else#define NewUDPNotifyProc(userRoutine)		\		((UDPNotifyUPP) (userRoutine))#endif#if GENERATINGCFM#define CallUDPNotifyProc(userRoutine, udpStream, eventCode, userDataPtr, icmpMsg)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppUDPNotifyProcInfo, (udpStream), (eventCode), (userDataPtr), (icmpMsg))#else#define CallUDPNotifyProc(userRoutine, udpStream, eventCode, userDataPtr, icmpMsg)		\		(*(userRoutine))((udpStream), (eventCode), (userDataPtr), (icmpMsg))#endiftypedef unsigned short udp_port;/* for create and release calls */struct UDPCreatePB {	Ptr								rcvBuff;	unsigned long					rcvBuffLen;	UDPNotifyUPP					notifyProc;	unsigned short					localPort;	Ptr								userDataPtr;	udp_port						endingPort;};typedef struct UDPCreatePB UDPCreatePB;struct UDPSendPB {	unsigned short					reserved;	ip_addr							remoteHost;	udp_port						remotePort;	Ptr								wdsPtr;	Boolean							checkSum;	UInt8							filler;						/* Filler for proper byte alignment	 */	unsigned short					sendLength;	Ptr								userDataPtr;	udp_port						localPort;};typedef struct UDPSendPB UDPSendPB;/* for receive and buffer return calls */struct UDPReceivePB {	unsigned short					timeOut;	ip_addr							remoteHost;	udp_port						remotePort;	Ptr								rcvBuff;	unsigned short					rcvBuffLen;	unsigned short					secondTimeStamp;	Ptr								userDataPtr;	ip_addr							destHost;					/* only for use with multi rcv */	udp_port						destPort;					/* only for use with multi rcv */};typedef struct UDPReceivePB UDPReceivePB;struct UDPMTUPB {	unsigned short					mtuSize;	ip_addr							remoteHost;	Ptr								userDataPtr;};typedef void (*UDPIOCompletionProcPtr)(struct UDPiopb *iopb);#if GENERATINGCFMtypedef UniversalProcPtr UDPIOCompletionUPP;#elsetypedef UDPIOCompletionProcPtr UDPIOCompletionUPP;#endiftypedef struct UDPMTUPB UDPMTUPB;struct UDPiopb {	char							fill12[12];	UDPIOCompletionUPP				ioCompletion;	short							ioResult;	char							*ioNamePtr;	short							ioVRefNum;	short							ioCRefNum;	short							csCode;	StreamPtr						udpStream;		union {			struct UDPCreatePB				create;			struct UDPSendPB				send;			struct UDPReceivePB				receive;			struct UDPMTUPB					mtu;		}							csParam;};typedef struct UDPiopb UDPiopb;#ifdef __CFM68K__#pragma lib_export off#endif#if GENERATINGPOWERPC#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __MACTCP__ */