/* 	File:		QuickTimeComponents.h  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS */#ifndef __QUICKTIMECOMPONENTS__#define __QUICKTIMECOMPONENTS__#ifndef __COMPONENTS__#include <Components.h>#endif/*	#include <Types.h>											*//*		#include <ConditionalMacros.h>							*//*	#include <MixedMode.h>										*/#ifndef __IMAGECOMPRESSION__#include <ImageCompression.h>#endif/*	#include <Quickdraw.h>										*//*		#include <QuickdrawText.h>								*//*	#include <QDOffscreen.h>									*//*		#include <Errors.h>										*//*	#include <Windows.h>										*//*		#include <Memory.h>										*//*		#include <Events.h>										*//*			#include <OSUtils.h>								*//*		#include <Controls.h>									*//*			#include <Menus.h>									*//*	#include <StandardFile.h>									*//*		#include <Dialogs.h>									*//*			#include <TextEdit.h>								*//*		#include <Files.h>										*/#ifndef __MOVIES__#include <Movies.h>#endif/*	#include <Aliases.h>										*//*		#include <AppleTalk.h>									*/#ifndef __VIDEO__#include <Video.h>#endif#ifdef __cplusplusextern "C" {#endif#if GENERATINGPOWERPC#pragma options align=mac68k#endif#ifdef __CFM68K__#pragma lib_export on#endifenum {	clockComponentType			= 'clok',	systemTickClock				= 'tick',						/* subtype: 60ths since boot		*/	systemSecondClock			= 'seco',						/* subtype: seconds since 1904		*/	systemMillisecondClock		= 'mill',						/* subtype: 1000ths since boot		*/	systemMicrosecondClock		= 'micr'};enum {	kClockRateIsLinear			= 1,	kClockImplementsCallBacks	= 2};#if OLDROUTINENAMES#define ClockGetTime(aClock, out) GetClockTime(aClock, out)#endif/** These are Clock procedures **/extern pascal ComponentResult ClockGetTime(ComponentInstance aClock, TimeRecord *out) FIVEWORDINLINE(0x2F3C, 0x4, 0x1, 0x7000, 0xA82A);extern pascal QTCallBack ClockNewCallBack(ComponentInstance aClock, TimeBase tb, short callBackType) FIVEWORDINLINE(0x2F3C, 0x6, 0x2, 0x7000, 0xA82A);extern pascal ComponentResult ClockDisposeCallBack(ComponentInstance aClock, QTCallBack cb) FIVEWORDINLINE(0x2F3C, 0x4, 0x3, 0x7000, 0xA82A);extern pascal ComponentResult ClockCallMeWhen(ComponentInstance aClock, QTCallBack cb, long param1, long param2, long param3) FIVEWORDINLINE(0x2F3C, 0x10, 0x4, 0x7000, 0xA82A);extern pascal ComponentResult ClockCancelCallBack(ComponentInstance aClock, QTCallBack cb) FIVEWORDINLINE(0x2F3C, 0x4, 0x5, 0x7000, 0xA82A);extern pascal ComponentResult ClockRateChanged(ComponentInstance aClock, QTCallBack cb) FIVEWORDINLINE(0x2F3C, 0x4, 0x6, 0x7000, 0xA82A);extern pascal ComponentResult ClockTimeChanged(ComponentInstance aClock, QTCallBack cb) FIVEWORDINLINE(0x2F3C, 0x4, 0x7, 0x7000, 0xA82A);extern pascal ComponentResult ClockSetTimeBase(ComponentInstance aClock, TimeBase tb) FIVEWORDINLINE(0x2F3C, 0x4, 0x8, 0x7000, 0xA82A);extern pascal ComponentResult ClockStartStopChanged(ComponentInstance aClock, QTCallBack cb, Boolean startChanged, Boolean stopChanged) FIVEWORDINLINE(0x2F3C, 0x8, 0x9, 0x7000, 0xA82A);extern pascal ComponentResult ClockGetRate(ComponentInstance aClock, Fixed *rate) FIVEWORDINLINE(0x2F3C, 0x4, 0xA, 0x7000, 0xA82A);enum {	kClockGetTimeSelect			= 0x1,	kClockNewCallBackSelect		= 0x2,	kClockDisposeCallBackSelect	= 0x3,	kClockCallMeWhenSelect		= 0x4,	kClockCancelCallBackSelect	= 0x5,	kClockRateChangedSelect		= 0x6,	kClockTimeChangedSelect		= 0x7,	kClockSetTimeBaseSelect		= 0x8,	kClockStartStopChangedSelect = 0x9,	kClockGetRateSelect			= 0xA};/*	General Sequence Grab stuff*/typedef ComponentInstance SeqGrabComponent;typedef ComponentInstance SGChannel;enum {	SeqGrabComponentType		= 'barg',	SeqGrabChannelType			= 'sgch',	SeqGrabPanelType			= 'sgpn',	SeqGrabCompressionPanelType	= 'comp',	SeqGrabSourcePanelType		= 'sour'};enum {	seqGrabToDisk				= 1,	seqGrabToMemory				= 2,	seqGrabDontUseTempMemory	= 4,	seqGrabAppendToFile			= 8,	seqGrabDontAddMovieResource	= 16,	seqGrabDontMakeMovie		= 32,	seqGrabPreExtendFile		= 64,	seqGrabDataProcIsInterruptSafe = 128,	seqGrabDataProcDoesOverlappingReads = 256};typedef unsigned long SeqGrabDataOutputEnum;enum {	seqGrabRecord				= 1,	seqGrabPreview				= 2,	seqGrabPlayDuringRecord		= 4};typedef unsigned long SeqGrabUsageEnum;enum {	seqGrabHasBounds			= 1,	seqGrabHasVolume			= 2,	seqGrabHasDiscreteSamples	= 4};typedef unsigned long SeqGrabChannelInfoEnum;struct SeqGrabFrameInfo {	long							frameOffset;	long							frameTime;	long							frameSize;	SGChannel						frameChannel;	long							frameRefCon;};typedef struct SeqGrabFrameInfo SeqGrabFrameInfo, *SeqGrabFrameInfoPtr;enum {	grabPictOffScreen			= 1,	grabPictIgnoreClip			= 2,	grabPictCurrentImage		= 4};enum {	sgFlagControlledGrab		= (1 << 0)};typedef pascal OSErr (*SGDataProcPtr)(SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType, long refCon);#if GENERATINGCFMtypedef UniversalProcPtr SGDataUPP;#elsetypedef SGDataProcPtr SGDataUPP;#endifstruct SGDeviceName {	Str63							name;	Handle							icon;	long							flags;	long							refCon;	long							reserved;					/* zero*/};typedef struct SGDeviceName SGDeviceName;enum {	sgDeviceNameFlagDeviceUnavailable = (1 << 0)};struct SGDeviceListRecord {	short							count;	short							selectedIndex;	long							reserved;					/* zero*/	SGDeviceName					entry[1];};typedef struct SGDeviceListRecord SGDeviceListRecord, *SGDeviceListPtr, **SGDeviceList;enum {	sgDeviceListWithIcons		= (1 << 0),	sgDeviceListDontCheckAvailability = (1 << 1)};enum {	seqGrabWriteAppend,	seqGrabWriteReserve,	seqGrabWriteFill};enum {	seqGrabUnpause				= 0,	seqGrabPause				= 1,	seqGrabPauseForMenu			= 3};enum {	channelFlagDontOpenResFile	= 2,	channelFlagHasDependency	= 4};typedef pascal Boolean (*SGModalFilterProcPtr)(DialogPtr theDialog, EventRecord *theEvent, short *itemHit, long refCon);#if GENERATINGCFMtypedef UniversalProcPtr SGModalFilterUPP;#elsetypedef SGModalFilterProcPtr SGModalFilterUPP;#endifenum {	sgPanelFlagForPanel			= 1};struct SGOutputRecord {	long							data[1];};typedef struct SGOutputRecord SGOutputRecord, *SGOutput;enum {	channelPlayNormal			= 0,	channelPlayFast				= 1,	channelPlayHighQuality		= 2,	channelPlayAllData			= 4};extern pascal ComponentResult SGInitialize(SeqGrabComponent s) FIVEWORDINLINE(0x2F3C, 0, 0x1, 0x7000, 0xA82A);extern pascal ComponentResult SGSetDataOutput(SeqGrabComponent s, const FSSpec *movieFile, long whereFlags) FIVEWORDINLINE(0x2F3C, 0x8, 0x2, 0x7000, 0xA82A);extern pascal ComponentResult SGGetDataOutput(SeqGrabComponent s, FSSpec *movieFile, long *whereFlags) FIVEWORDINLINE(0x2F3C, 0x8, 0x3, 0x7000, 0xA82A);extern pascal ComponentResult SGSetGWorld(SeqGrabComponent s, CGrafPtr gp, GDHandle gd) FIVEWORDINLINE(0x2F3C, 0x8, 0x4, 0x7000, 0xA82A);extern pascal ComponentResult SGGetGWorld(SeqGrabComponent s, CGrafPtr *gp, GDHandle *gd) FIVEWORDINLINE(0x2F3C, 0x8, 0x5, 0x7000, 0xA82A);extern pascal ComponentResult SGNewChannel(SeqGrabComponent s, OSType channelType, SGChannel *ref) FIVEWORDINLINE(0x2F3C, 0x8, 0x6, 0x7000, 0xA82A);extern pascal ComponentResult SGDisposeChannel(SeqGrabComponent s, SGChannel c) FIVEWORDINLINE(0x2F3C, 0x4, 0x7, 0x7000, 0xA82A);extern pascal ComponentResult SGStartPreview(SeqGrabComponent s) FIVEWORDINLINE(0x2F3C, 0, 0x10, 0x7000, 0xA82A);extern pascal ComponentResult SGStartRecord(SeqGrabComponent s) FIVEWORDINLINE(0x2F3C, 0, 0x11, 0x7000, 0xA82A);extern pascal ComponentResult SGIdle(SeqGrabComponent s) FIVEWORDINLINE(0x2F3C, 0, 0x12, 0x7000, 0xA82A);extern pascal ComponentResult SGStop(SeqGrabComponent s) FIVEWORDINLINE(0x2F3C, 0, 0x13, 0x7000, 0xA82A);extern pascal ComponentResult SGPause(SeqGrabComponent s, Byte pause) FIVEWORDINLINE(0x2F3C, 0x2, 0x14, 0x7000, 0xA82A);extern pascal ComponentResult SGPrepare(SeqGrabComponent s, Boolean prepareForPreview, Boolean prepareForRecord) FIVEWORDINLINE(0x2F3C, 0x4, 0x15, 0x7000, 0xA82A);extern pascal ComponentResult SGRelease(SeqGrabComponent s) FIVEWORDINLINE(0x2F3C, 0, 0x16, 0x7000, 0xA82A);extern pascal Movie SGGetMovie(SeqGrabComponent s) FIVEWORDINLINE(0x2F3C, 0, 0x17, 0x7000, 0xA82A);extern pascal ComponentResult SGSetMaximumRecordTime(SeqGrabComponent s, unsigned long ticks) FIVEWORDINLINE(0x2F3C, 0x4, 0x18, 0x7000, 0xA82A);extern pascal ComponentResult SGGetMaximumRecordTime(SeqGrabComponent s, unsigned long *ticks) FIVEWORDINLINE(0x2F3C, 0x4, 0x19, 0x7000, 0xA82A);extern pascal ComponentResult SGGetStorageSpaceRemaining(SeqGrabComponent s, unsigned long *bytes) FIVEWORDINLINE(0x2F3C, 0x4, 0x1A, 0x7000, 0xA82A);extern pascal ComponentResult SGGetTimeRemaining(SeqGrabComponent s, long *ticksLeft) FIVEWORDINLINE(0x2F3C, 0x4, 0x1B, 0x7000, 0xA82A);extern pascal ComponentResult SGGrabPict(SeqGrabComponent s, PicHandle *p, const Rect *bounds, short offscreenDepth, long grabPictFlags) FIVEWORDINLINE(0x2F3C, 0xE, 0x1C, 0x7000, 0xA82A);extern pascal ComponentResult SGGetLastMovieResID(SeqGrabComponent s, short *resID) FIVEWORDINLINE(0x2F3C, 0x4, 0x1D, 0x7000, 0xA82A);extern pascal ComponentResult SGSetFlags(SeqGrabComponent s, long sgFlags) FIVEWORDINLINE(0x2F3C, 0x4, 0x1E, 0x7000, 0xA82A);extern pascal ComponentResult SGGetFlags(SeqGrabComponent s, long *sgFlags) FIVEWORDINLINE(0x2F3C, 0x4, 0x1F, 0x7000, 0xA82A);extern pascal ComponentResult SGSetDataProc(SeqGrabComponent s, SGDataUPP proc, long refCon) FIVEWORDINLINE(0x2F3C, 0x8, 0x20, 0x7000, 0xA82A);extern pascal ComponentResult SGNewChannelFromComponent(SeqGrabComponent s, SGChannel *newChannel, Component sgChannelComponent) FIVEWORDINLINE(0x2F3C, 0x8, 0x21, 0x7000, 0xA82A);extern pascal ComponentResult SGDisposeDeviceList(SeqGrabComponent s, SGDeviceList list) FIVEWORDINLINE(0x2F3C, 0x4, 0x22, 0x7000, 0xA82A);extern pascal ComponentResult SGAppendDeviceListToMenu(SeqGrabComponent s, SGDeviceList list, MenuHandle mh) FIVEWORDINLINE(0x2F3C, 0x8, 0x23, 0x7000, 0xA82A);extern pascal ComponentResult SGSetSettings(SeqGrabComponent s, UserData ud, long flags) FIVEWORDINLINE(0x2F3C, 0x8, 0x24, 0x7000, 0xA82A);extern pascal ComponentResult SGGetSettings(SeqGrabComponent s, UserData *ud, long flags) FIVEWORDINLINE(0x2F3C, 0x8, 0x25, 0x7000, 0xA82A);extern pascal ComponentResult SGGetIndChannel(SeqGrabComponent s, short index, SGChannel *ref, OSType *chanType) FIVEWORDINLINE(0x2F3C, 0xA, 0x26, 0x7000, 0xA82A);extern pascal ComponentResult SGUpdate(SeqGrabComponent s, RgnHandle updateRgn) FIVEWORDINLINE(0x2F3C, 0x4, 0x27, 0x7000, 0xA82A);extern pascal ComponentResult SGGetPause(SeqGrabComponent s, Byte *paused) FIVEWORDINLINE(0x2F3C, 0x4, 0x28, 0x7000, 0xA82A);extern pascal ComponentResult SGSettingsDialog(SeqGrabComponent s, SGChannel c, short numPanels, Component *panelList, long flags, SGModalFilterUPP proc, long procRefNum) FIVEWORDINLINE(0x2F3C, 0x16, 0x29, 0x7000, 0xA82A);extern pascal ComponentResult SGGetAlignmentProc(SeqGrabComponent s, ICMAlignmentProcRecordPtr alignmentProc) FIVEWORDINLINE(0x2F3C, 0x4, 0x2A, 0x7000, 0xA82A);extern pascal ComponentResult SGSetChannelSettings(SeqGrabComponent s, SGChannel c, UserData ud, long flags) FIVEWORDINLINE(0x2F3C, 0xC, 0x2B, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelSettings(SeqGrabComponent s, SGChannel c, UserData *ud, long flags) FIVEWORDINLINE(0x2F3C, 0xC, 0x2C, 0x7000, 0xA82A);extern pascal ComponentResult SGGetMode(SeqGrabComponent s, Boolean *previewMode, Boolean *recordMode) FIVEWORDINLINE(0x2F3C, 0x8, 0x2D, 0x7000, 0xA82A);extern pascal ComponentResult SGSetDataRef(SeqGrabComponent s, Handle dataRef, OSType dataRefType, long whereFlags) FIVEWORDINLINE(0x2F3C, 0xC, 0x2E, 0x7000, 0xA82A);extern pascal ComponentResult SGGetDataRef(SeqGrabComponent s, Handle *dataRef, OSType *dataRefType, long *whereFlags) FIVEWORDINLINE(0x2F3C, 0xC, 0x2F, 0x7000, 0xA82A);extern pascal ComponentResult SGNewOutput(SeqGrabComponent s, Handle dataRef, OSType dataRefType, long whereFlags, SGOutput *output) FIVEWORDINLINE(0x2F3C, 0x10, 0x30, 0x7000, 0xA82A);extern pascal ComponentResult SGDisposeOutput(SeqGrabComponent s, SGOutput output) FIVEWORDINLINE(0x2F3C, 0x4, 0x31, 0x7000, 0xA82A);extern pascal ComponentResult SGSetOutputFlags(SeqGrabComponent s, SGOutput output, long whereFlags) FIVEWORDINLINE(0x2F3C, 0x8, 0x32, 0x7000, 0xA82A);extern pascal ComponentResult SGSetChannelOutput(SeqGrabComponent s, SGChannel c, SGOutput output) FIVEWORDINLINE(0x2F3C, 0x8, 0x33, 0x7000, 0xA82A);extern pascal ComponentResult SGGetDataOutputStorageSpaceRemaining(SeqGrabComponent s, SGOutput output, unsigned long *space) FIVEWORDINLINE(0x2F3C, 0x8, 0x34, 0x7000, 0xA82A);/*	calls from Channel to seqGrab*/extern pascal ComponentResult SGWriteMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, long *offset) FIVEWORDINLINE(0x2F3C, 0x10, 0x100, 0x7000, 0xA82A);extern pascal ComponentResult SGAddFrameReference(SeqGrabComponent s, SeqGrabFrameInfoPtr frameInfo) FIVEWORDINLINE(0x2F3C, 0x4, 0x101, 0x7000, 0xA82A);extern pascal ComponentResult SGGetNextFrameReference(SeqGrabComponent s, SeqGrabFrameInfoPtr frameInfo, TimeValue *frameDuration, long *frameNumber) FIVEWORDINLINE(0x2F3C, 0xC, 0x102, 0x7000, 0xA82A);extern pascal ComponentResult SGGetTimeBase(SeqGrabComponent s, TimeBase *tb) FIVEWORDINLINE(0x2F3C, 0x4, 0x103, 0x7000, 0xA82A);extern pascal ComponentResult SGSortDeviceList(SeqGrabComponent s, SGDeviceList list) FIVEWORDINLINE(0x2F3C, 0x4, 0x104, 0x7000, 0xA82A);extern pascal ComponentResult SGAddMovieData(SeqGrabComponent s, SGChannel c, Ptr p, long len, long *offset, long chRefCon, TimeValue time, short writeType) FIVEWORDINLINE(0x2F3C, 0x1A, 0x105, 0x7000, 0xA82A);extern pascal ComponentResult SGChangedSource(SeqGrabComponent s, SGChannel c) FIVEWORDINLINE(0x2F3C, 0x4, 0x106, 0x7000, 0xA82A);/*** Sequence Grab CHANNEL Component Stuff ***/extern pascal ComponentResult SGSetChannelUsage(SGChannel c, long usage) FIVEWORDINLINE(0x2F3C, 0x4, 0x80, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelUsage(SGChannel c, long *usage) FIVEWORDINLINE(0x2F3C, 0x4, 0x81, 0x7000, 0xA82A);extern pascal ComponentResult SGSetChannelBounds(SGChannel c, const Rect *bounds) FIVEWORDINLINE(0x2F3C, 0x4, 0x82, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelBounds(SGChannel c, Rect *bounds) FIVEWORDINLINE(0x2F3C, 0x4, 0x83, 0x7000, 0xA82A);extern pascal ComponentResult SGSetChannelVolume(SGChannel c, short volume) FIVEWORDINLINE(0x2F3C, 0x2, 0x84, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelVolume(SGChannel c, short *volume) FIVEWORDINLINE(0x2F3C, 0x4, 0x85, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelInfo(SGChannel c, long *channelInfo) FIVEWORDINLINE(0x2F3C, 0x4, 0x86, 0x7000, 0xA82A);extern pascal ComponentResult SGSetChannelPlayFlags(SGChannel c, long playFlags) FIVEWORDINLINE(0x2F3C, 0x4, 0x87, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelPlayFlags(SGChannel c, long *playFlags) FIVEWORDINLINE(0x2F3C, 0x4, 0x88, 0x7000, 0xA82A);extern pascal ComponentResult SGSetChannelMaxFrames(SGChannel c, long frameCount) FIVEWORDINLINE(0x2F3C, 0x4, 0x89, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelMaxFrames(SGChannel c, long *frameCount) FIVEWORDINLINE(0x2F3C, 0x4, 0x8A, 0x7000, 0xA82A);extern pascal ComponentResult SGSetChannelRefCon(SGChannel c, long refCon) FIVEWORDINLINE(0x2F3C, 0x4, 0x8B, 0x7000, 0xA82A);extern pascal ComponentResult SGSetChannelClip(SGChannel c, RgnHandle theClip) FIVEWORDINLINE(0x2F3C, 0x4, 0x8C, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelClip(SGChannel c, RgnHandle *theClip) FIVEWORDINLINE(0x2F3C, 0x4, 0x8D, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelSampleDescription(SGChannel c, Handle sampleDesc) FIVEWORDINLINE(0x2F3C, 0x4, 0x8E, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelDeviceList(SGChannel c, long selectionFlags, SGDeviceList *list) FIVEWORDINLINE(0x2F3C, 0x8, 0x8F, 0x7000, 0xA82A);extern pascal ComponentResult SGSetChannelDevice(SGChannel c, StringPtr name) FIVEWORDINLINE(0x2F3C, 0x4, 0x90, 0x7000, 0xA82A);extern pascal ComponentResult SGSetChannelMatrix(SGChannel c, const MatrixRecord *m) FIVEWORDINLINE(0x2F3C, 0x4, 0x91, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelMatrix(SGChannel c, MatrixRecord *m) FIVEWORDINLINE(0x2F3C, 0x4, 0x92, 0x7000, 0xA82A);extern pascal ComponentResult SGGetChannelTimeScale(SGChannel c, TimeScale *scale) FIVEWORDINLINE(0x2F3C, 0x4, 0x93, 0x7000, 0xA82A);extern pascal ComponentResult SGChannelPutPicture(SGChannel c) FIVEWORDINLINE(0x2F3C, 0, 0x94, 0x7000, 0xA82A);extern pascal ComponentResult SGChannelSetRequestedDataRate(SGChannel c, long bytesPerSecond) FIVEWORDINLINE(0x2F3C, 0x4, 0x95, 0x7000, 0xA82A);extern pascal ComponentResult SGChannelGetRequestedDataRate(SGChannel c, long *bytesPerSecond) FIVEWORDINLINE(0x2F3C, 0x4, 0x96, 0x7000, 0xA82A);extern pascal ComponentResult SGChannelSetDataSourceName(SGChannel c, ConstStr255Param name, ScriptCode scriptTag) FIVEWORDINLINE(0x2F3C, 0x6, 0x97, 0x7000, 0xA82A);extern pascal ComponentResult SGChannelGetDataSourceName(SGChannel c, Str255 name, ScriptCode *scriptTag) FIVEWORDINLINE(0x2F3C, 0x8, 0x98, 0x7000, 0xA82A);/*	calls from seqGrab to Channel*/extern pascal ComponentResult SGInitChannel(SGChannel c, SeqGrabComponent owner) FIVEWORDINLINE(0x2F3C, 0x4, 0x180, 0x7000, 0xA82A);extern pascal ComponentResult SGWriteSamples(SGChannel c, Movie m, AliasHandle theFile) FIVEWORDINLINE(0x2F3C, 0x8, 0x181, 0x7000, 0xA82A);extern pascal ComponentResult SGGetDataRate(SGChannel c, long *bytesPerSecond) FIVEWORDINLINE(0x2F3C, 0x4, 0x182, 0x7000, 0xA82A);extern pascal ComponentResult SGAlignChannelRect(SGChannel c, Rect *r) FIVEWORDINLINE(0x2F3C, 0x4, 0x183, 0x7000, 0xA82A);/*	Dorky dialog panel calls*/extern pascal ComponentResult SGPanelGetDitl(SeqGrabComponent s, Handle *ditl) FIVEWORDINLINE(0x2F3C, 0x4, 0x200, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelGetTitle(SeqGrabComponent s, Str255 title) FIVEWORDINLINE(0x2F3C, 0x4, 0x201, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelCanRun(SeqGrabComponent s, SGChannel c) FIVEWORDINLINE(0x2F3C, 0x4, 0x202, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelInstall(SeqGrabComponent s, SGChannel c, DialogPtr d, short itemOffset) FIVEWORDINLINE(0x2F3C, 0xA, 0x203, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelEvent(SeqGrabComponent s, SGChannel c, DialogPtr d, short itemOffset, EventRecord *theEvent, short *itemHit, Boolean *handled) FIVEWORDINLINE(0x2F3C, 0x16, 0x204, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelItem(SeqGrabComponent s, SGChannel c, DialogPtr d, short itemOffset, short itemNum) FIVEWORDINLINE(0x2F3C, 0xC, 0x205, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelRemove(SeqGrabComponent s, SGChannel c, DialogPtr d, short itemOffset) FIVEWORDINLINE(0x2F3C, 0xA, 0x206, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelSetGrabber(SeqGrabComponent s, SeqGrabComponent sg) FIVEWORDINLINE(0x2F3C, 0x4, 0x207, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelSetResFile(SeqGrabComponent s, short resRef) FIVEWORDINLINE(0x2F3C, 0x2, 0x208, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelGetSettings(SeqGrabComponent s, SGChannel c, UserData *ud, long flags) FIVEWORDINLINE(0x2F3C, 0xC, 0x209, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelSetSettings(SeqGrabComponent s, SGChannel c, UserData ud, long flags) FIVEWORDINLINE(0x2F3C, 0xC, 0x20A, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelValidateInput(SeqGrabComponent s, Boolean *ok) FIVEWORDINLINE(0x2F3C, 0x4, 0x20B, 0x7000, 0xA82A);extern pascal ComponentResult SGPanelSetEventFilter(SeqGrabComponent s, SGModalFilterUPP proc, long refCon) FIVEWORDINLINE(0x2F3C, 0x8, 0x20C, 0x7000, 0xA82A);/*** Sequence Grab VIDEO CHANNEL Component Stuff ***//*	Video stuff*/struct SGCompressInfo {	Ptr								buffer;	unsigned long					bufferSize;	UInt8							similarity;	UInt8							reserved;};typedef struct SGCompressInfo SGCompressInfo;typedef pascal ComponentResult (*SGGrabProcPtr)(SGChannel c, short bufferNum, long refCon);typedef pascal ComponentResult (*SGGrabCompleteProcPtr)(SGChannel c, short bufferNum, Boolean *done, long refCon);typedef pascal ComponentResult (*SGDisplayProcPtr)(SGChannel c, short bufferNum, MatrixRecord *mp, RgnHandle clipRgn, long refCon);typedef pascal ComponentResult (*SGCompressProcPtr)(SGChannel c, short bufferNum, long refCon);typedef pascal ComponentResult (*SGCompressCompleteProcPtr)(SGChannel c, short bufferNum, Boolean *done, SGCompressInfo *ci, long refCon);typedef pascal ComponentResult (*SGAddFrameProcPtr)(SGChannel c, short bufferNum, TimeValue atTime, TimeScale scale, const SGCompressInfo *ci, long refCon);typedef pascal ComponentResult (*SGTransferFrameProcPtr)(SGChannel c, short bufferNum, MatrixRecord *mp, RgnHandle clipRgn, long refCon);typedef pascal ComponentResult (*SGGrabCompressCompleteProcPtr)(SGChannel c, Boolean *done, SGCompressInfo *ci, TimeRecord *t, long refCon);typedef pascal ComponentResult (*SGDisplayCompressProcPtr)(SGChannel c, Ptr dataPtr, ImageDescriptionHandle desc, MatrixRecord *mp, RgnHandle clipRgn, long refCon);#if GENERATINGCFMtypedef UniversalProcPtr SGGrabUPP;typedef UniversalProcPtr SGGrabCompleteUPP;typedef UniversalProcPtr SGDisplayUPP;typedef UniversalProcPtr SGCompressUPP;typedef UniversalProcPtr SGCompressCompleteUPP;typedef UniversalProcPtr SGAddFrameUPP;typedef UniversalProcPtr SGTransferFrameUPP;typedef UniversalProcPtr SGGrabCompressCompleteUPP;typedef UniversalProcPtr SGDisplayCompressUPP;#elsetypedef SGGrabProcPtr SGGrabUPP;typedef SGGrabCompleteProcPtr SGGrabCompleteUPP;typedef SGDisplayProcPtr SGDisplayUPP;typedef SGCompressProcPtr SGCompressUPP;typedef SGCompressCompleteProcPtr SGCompressCompleteUPP;typedef SGAddFrameProcPtr SGAddFrameUPP;typedef SGTransferFrameProcPtr SGTransferFrameUPP;typedef SGGrabCompressCompleteProcPtr SGGrabCompressCompleteUPP;typedef SGDisplayCompressProcPtr SGDisplayCompressUPP;#endifstruct VideoBottles {	short							procCount;	SGGrabUPP						grabProc;	SGGrabCompleteUPP				grabCompleteProc;	SGDisplayUPP					displayProc;	SGCompressUPP					compressProc;	SGCompressCompleteUPP			compressCompleteProc;	SGAddFrameUPP					addFrameProc;	SGTransferFrameUPP				transferFrameProc;	SGGrabCompressCompleteUPP		grabCompressCompleteProc;	SGDisplayCompressUPP			displayCompressProc;};typedef struct VideoBottles VideoBottles;extern pascal ComponentResult SGGetSrcVideoBounds(SGChannel c, Rect *r) FIVEWORDINLINE(0x2F3C, 0x4, 0x100, 0x7000, 0xA82A);extern pascal ComponentResult SGSetVideoRect(SGChannel c, const Rect *r) FIVEWORDINLINE(0x2F3C, 0x4, 0x101, 0x7000, 0xA82A);extern pascal ComponentResult SGGetVideoRect(SGChannel c, Rect *r) FIVEWORDINLINE(0x2F3C, 0x4, 0x102, 0x7000, 0xA82A);extern pascal ComponentResult SGGetVideoCompressorType(SGChannel c, OSType *compressorType) FIVEWORDINLINE(0x2F3C, 0x4, 0x103, 0x7000, 0xA82A);extern pascal ComponentResult SGSetVideoCompressorType(SGChannel c, OSType compressorType) FIVEWORDINLINE(0x2F3C, 0x4, 0x104, 0x7000, 0xA82A);extern pascal ComponentResult SGSetVideoCompressor(SGChannel c, short depth, CompressorComponent compressor, CodecQ spatialQuality, CodecQ temporalQuality, long keyFrameRate) FIVEWORDINLINE(0x2F3C, 0x12, 0x105, 0x7000, 0xA82A);extern pascal ComponentResult SGGetVideoCompressor(SGChannel c, short *depth, CompressorComponent *compressor, CodecQ *spatialQuality, CodecQ *temporalQuality, long *keyFrameRate) FIVEWORDINLINE(0x2F3C, 0x14, 0x106, 0x7000, 0xA82A);extern pascal ComponentInstance SGGetVideoDigitizerComponent(SGChannel c) FIVEWORDINLINE(0x2F3C, 0, 0x107, 0x7000, 0xA82A);extern pascal ComponentResult SGSetVideoDigitizerComponent(SGChannel c, ComponentInstance vdig) FIVEWORDINLINE(0x2F3C, 0x4, 0x108, 0x7000, 0xA82A);extern pascal ComponentResult SGVideoDigitizerChanged(SGChannel c) FIVEWORDINLINE(0x2F3C, 0, 0x109, 0x7000, 0xA82A);extern pascal ComponentResult SGSetVideoBottlenecks(SGChannel c, VideoBottles *vb) FIVEWORDINLINE(0x2F3C, 0x4, 0x10A, 0x7000, 0xA82A);extern pascal ComponentResult SGGetVideoBottlenecks(SGChannel c, VideoBottles *vb) FIVEWORDINLINE(0x2F3C, 0x4, 0x10B, 0x7000, 0xA82A);extern pascal ComponentResult SGGrabFrame(SGChannel c, short bufferNum) FIVEWORDINLINE(0x2F3C, 0x2, 0x10C, 0x7000, 0xA82A);extern pascal ComponentResult SGGrabFrameComplete(SGChannel c, short bufferNum, Boolean *done) FIVEWORDINLINE(0x2F3C, 0x6, 0x10D, 0x7000, 0xA82A);extern pascal ComponentResult SGDisplayFrame(SGChannel c, short bufferNum, const MatrixRecord *mp, RgnHandle clipRgn) FIVEWORDINLINE(0x2F3C, 0xA, 0x10E, 0x7000, 0xA82A);extern pascal ComponentResult SGCompressFrame(SGChannel c, short bufferNum) FIVEWORDINLINE(0x2F3C, 0x2, 0x10F, 0x7000, 0xA82A);extern pascal ComponentResult SGCompressFrameComplete(SGChannel c, short bufferNum, Boolean *done, SGCompressInfo *ci) FIVEWORDINLINE(0x2F3C, 0xA, 0x110, 0x7000, 0xA82A);extern pascal ComponentResult SGAddFrame(SGChannel c, short bufferNum, TimeValue atTime, TimeScale scale, const SGCompressInfo *ci) FIVEWORDINLINE(0x2F3C, 0xE, 0x111, 0x7000, 0xA82A);extern pascal ComponentResult SGTransferFrameForCompress(SGChannel c, short bufferNum, const MatrixRecord *mp, RgnHandle clipRgn) FIVEWORDINLINE(0x2F3C, 0xA, 0x112, 0x7000, 0xA82A);extern pascal ComponentResult SGSetCompressBuffer(SGChannel c, short depth, const Rect *compressSize) FIVEWORDINLINE(0x2F3C, 0x6, 0x113, 0x7000, 0xA82A);extern pascal ComponentResult SGGetCompressBuffer(SGChannel c, short *depth, Rect *compressSize) FIVEWORDINLINE(0x2F3C, 0x8, 0x114, 0x7000, 0xA82A);extern pascal ComponentResult SGGetBufferInfo(SGChannel c, short bufferNum, PixMapHandle *bufferPM, Rect *bufferRect, GWorldPtr *compressBuffer, Rect *compressBufferRect) FIVEWORDINLINE(0x2F3C, 0x12, 0x115, 0x7000, 0xA82A);extern pascal ComponentResult SGSetUseScreenBuffer(SGChannel c, Boolean useScreenBuffer) FIVEWORDINLINE(0x2F3C, 0x2, 0x116, 0x7000, 0xA82A);extern pascal ComponentResult SGGetUseScreenBuffer(SGChannel c, Boolean *useScreenBuffer) FIVEWORDINLINE(0x2F3C, 0x4, 0x117, 0x7000, 0xA82A);extern pascal ComponentResult SGGrabCompressComplete(SGChannel c, Boolean *done, SGCompressInfo *ci, TimeRecord *tr) FIVEWORDINLINE(0x2F3C, 0xC, 0x118, 0x7000, 0xA82A);extern pascal ComponentResult SGDisplayCompress(SGChannel c, Ptr dataPtr, ImageDescriptionHandle desc, MatrixRecord *mp, RgnHandle clipRgn) FIVEWORDINLINE(0x2F3C, 0x10, 0x119, 0x7000, 0xA82A);extern pascal ComponentResult SGSetFrameRate(SGChannel c, Fixed frameRate) FIVEWORDINLINE(0x2F3C, 0x4, 0x11A, 0x7000, 0xA82A);extern pascal ComponentResult SGGetFrameRate(SGChannel c, Fixed *frameRate) FIVEWORDINLINE(0x2F3C, 0x4, 0x11B, 0x7000, 0xA82A);/*** Sequence Grab SOUND CHANNEL Component Stuff ***//*	Sound stuff*/extern pascal ComponentResult SGSetSoundInputDriver(SGChannel c, ConstStr255Param driverName) FIVEWORDINLINE(0x2F3C, 0x4, 0x100, 0x7000, 0xA82A);extern pascal long SGGetSoundInputDriver(SGChannel c) FIVEWORDINLINE(0x2F3C, 0, 0x101, 0x7000, 0xA82A);extern pascal ComponentResult SGSoundInputDriverChanged(SGChannel c) FIVEWORDINLINE(0x2F3C, 0, 0x102, 0x7000, 0xA82A);extern pascal ComponentResult SGSetSoundRecordChunkSize(SGChannel c, long seconds) FIVEWORDINLINE(0x2F3C, 0x4, 0x103, 0x7000, 0xA82A);extern pascal long SGGetSoundRecordChunkSize(SGChannel c) FIVEWORDINLINE(0x2F3C, 0, 0x104, 0x7000, 0xA82A);extern pascal ComponentResult SGSetSoundInputRate(SGChannel c, Fixed rate) FIVEWORDINLINE(0x2F3C, 0x4, 0x105, 0x7000, 0xA82A);extern pascal Fixed SGGetSoundInputRate(SGChannel c) FIVEWORDINLINE(0x2F3C, 0, 0x106, 0x7000, 0xA82A);extern pascal ComponentResult SGSetSoundInputParameters(SGChannel c, short sampleSize, short numChannels, OSType compressionType) FIVEWORDINLINE(0x2F3C, 0x8, 0x107, 0x7000, 0xA82A);extern pascal ComponentResult SGGetSoundInputParameters(SGChannel c, short *sampleSize, short *numChannels, OSType *compressionType) FIVEWORDINLINE(0x2F3C, 0xC, 0x108, 0x7000, 0xA82A);enum {	sgChannelAtom				= 'chan',	sgChannelSettingsAtom		= 'ctom',	sgChannelDescription		= 'cdsc',	sgChannelSettings			= 'cset'};enum {	sgDeviceNameType			= 'name',	sgUsageType					= 'use ',	sgPlayFlagsType				= 'plyf',	sgClipType					= 'clip',	sgMatrixType				= 'mtrx',	sgVolumeType				= 'volu'};enum {	sgPanelSettingsAtom			= 'ptom',	sgPanelDescription			= 'pdsc',	sgPanelSettings				= 'pset'};enum {	sgcSoundCompressionType		= 'scmp',	sgcSoundSampleRateType		= 'srat',	sgcSoundChannelCountType	= 'schn',	sgcSoundSampleSizeType		= 'ssiz',	sgcSoundInputType			= 'sinp',	sgcSoundGainType			= 'gain'};enum {	sgcVideoHueType				= 'hue ',	sgcVideoSaturationType		= 'satr',	sgcVideoContrastType		= 'trst',	sgcVideoSharpnessType		= 'shrp',	sgcVideoBrigtnessType		= 'brit',	sgcVideoBlackLevelType		= 'blkl',	sgcVideoWhiteLevelType		= 'whtl',	sgcVideoInputType			= 'vinp',	sgcVideoFormatType			= 'vstd',	sgcVideoFilterType			= 'vflt',	sgcVideoRectType			= 'vrct',	sgVideoDigitizerType		= 'vdig'};enum {	kSGInitializeSelect			= 0x1,	kSGSetDataOutputSelect		= 0x2,	kSGGetDataOutputSelect		= 0x3,	kSGSetGWorldSelect			= 0x4,	kSGGetGWorldSelect			= 0x5,	kSGNewChannelSelect			= 0x6,	kSGDisposeChannelSelect		= 0x7,	kSGStartPreviewSelect		= 0x10,	kSGStartRecordSelect		= 0x11,	kSGIdleSelect				= 0x12,	kSGStopSelect				= 0x13,	kSGPauseSelect				= 0x14,	kSGPrepareSelect			= 0x15,	kSGReleaseSelect			= 0x16,	kSGGetMovieSelect			= 0x17,	kSGSetMaximumRecordTimeSelect = 0x18,	kSGGetMaximumRecordTimeSelect = 0x19,	kSGGetStorageSpaceRemainingSelect = 0x1A,	kSGGetTimeRemainingSelect	= 0x1B,	kSGGrabPictSelect			= 0x1C,	kSGGetLastMovieResIDSelect	= 0x1D,	kSGSetFlagsSelect			= 0x1E,	kSGGetFlagsSelect			= 0x1F,	kSGSetDataProcSelect		= 0x20,	kSGNewChannelFromComponentSelect = 0x21,	kSGDisposeDeviceListSelect	= 0x22,	kSGAppendDeviceListToMenuSelect = 0x23,	kSGSetSettingsSelect		= 0x24,	kSGGetSettingsSelect		= 0x25,	kSGGetIndChannelSelect		= 0x26,	kSGUpdateSelect				= 0x27,	kSGGetPauseSelect			= 0x28,	kSGSettingsDialogSelect		= 0x29,	kSGGetAlignmentProcSelect	= 0x2A,	kSGSetChannelSettingsSelect	= 0x2B,	kSGGetChannelSettingsSelect	= 0x2C,	kSGGetModeSelect			= 0x2D,	kSGSetDataRefSelect			= 0x2E,	kSGGetDataRefSelect			= 0x2F,	kSGNewOutputSelect			= 0x30,	kSGDisposeOutputSelect		= 0x31,	kSGSetOutputFlagsSelect		= 0x32,	kSGSetChannelOutputSelect	= 0x33,	kSGGetDataOutputStorageSpaceRemainingSelect = 0x34,	kSGWriteMovieDataSelect		= 0x100,	kSGAddFrameReferenceSelect	= 0x101,	kSGGetNextFrameReferenceSelect = 0x102,	kSGGetTimeBaseSelect		= 0x103,	kSGSortDeviceListSelect		= 0x104,	kSGAddMovieDataSelect		= 0x105,	kSGChangedSourceSelect		= 0x106,	kSGCSetChannelUsageSelect	= 0x80,	kSGCGetChannelUsageSelect	= 0x81,	kSGCSetChannelBoundsSelect	= 0x82,	kSGCGetChannelBoundsSelect	= 0x83,	kSGCSetChannelVolumeSelect	= 0x84,	kSGCGetChannelVolumeSelect	= 0x85,	kSGCGetChannelInfoSelect	= 0x86,	kSGCSetChannelPlayFlagsSelect = 0x87,	kSGCGetChannelPlayFlagsSelect = 0x88,	kSGCSetChannelMaxFramesSelect = 0x89,	kSGCGetChannelMaxFramesSelect = 0x8A,	kSGCSetChannelRefConSelect	= 0x8B,	kSGCSetChannelClipSelect	= 0x8C,	kSGCGetChannelClipSelect	= 0x8D,	kSGCGetChannelSampleDescriptionSelect = 0x8E,	kSGCGetChannelDeviceListSelect = 0x8F,	kSGCSetChannelDeviceSelect	= 0x90,	kSGCSetChannelMatrixSelect	= 0x91,	kSGCGetChannelMatrixSelect	= 0x92,	kSGCGetChannelTimeScaleSelect = 0x93,	kSGCChannelPutPictureSelect	= 0x94,	kSGCChannelSetRequestedDataRateSelect = 0x95,	kSGCChannelGetRequestedDataRateSelect = 0x96,	kSGCChannelSetDataSourceNameSelect = 0x97,	kSGCChannelGetDataSourceNameSelect = 0x98,	kSGCInitChannelSelect		= 0x180,	kSGCWriteSamplesSelect		= 0x181,	kSGCGetDataRateSelect		= 0x182,	kSGCAlignChannelRectSelect	= 0x183,	kSGCPanelGetDitlSelect		= 0x200,	kSGCPanelGetTitleSelect		= 0x201,	kSGCPanelCanRunSelect		= 0x202,	kSGCPanelInstallSelect		= 0x203,	kSGCPanelEventSelect		= 0x204,	kSGCPanelItemSelect			= 0x205,	kSGCPanelRemoveSelect		= 0x206,	kSGCPanelSetGrabberSelect	= 0x207,	kSGCPanelSetResFileSelect	= 0x208,	kSGCPanelGetSettingsSelect	= 0x209,	kSGCPanelSetSettingsSelect	= 0x20A,	kSGCPanelValidateInputSelect = 0x20B,	kSGCPanelSetEventFilterSelect = 0x20C,	kSGCGetSrcVideoBoundsSelect	= 0x100,	kSGCSetVideoRectSelect		= 0x101,	kSGCGetVideoRectSelect		= 0x102,	kSGCGetVideoCompressorTypeSelect = 0x103,	kSGCSetVideoCompressorTypeSelect = 0x104,	kSGCSetVideoCompressorSelect = 0x105,	kSGCGetVideoCompressorSelect = 0x106,	kSGCGetVideoDigitizerComponentSelect = 0x107,	kSGCSetVideoDigitizerComponentSelect = 0x108,	kSGCVideoDigitizerChangedSelect = 0x109,	kSGCSetVideoBottlenecksSelect = 0x10A,	kSGCGetVideoBottlenecksSelect = 0x10B,	kSGCGrabFrameSelect			= 0x10C,	kSGCGrabFrameCompleteSelect	= 0x10D,	kSGCDisplayFrameSelect		= 0x10E,	kSGCCompressFrameSelect		= 0x10F,	kSGCCompressFrameCompleteSelect = 0x110,	kSGCAddFrameSelect			= 0x111,	kSGCTransferFrameForCompressSelect = 0x112,	kSGCSetCompressBufferSelect	= 0x113,	kSGCGetCompressBufferSelect	= 0x114,	kSGCGetBufferInfoSelect		= 0x115,	kSGCSetUseScreenBufferSelect = 0x116,	kSGCGetUseScreenBufferSelect = 0x117,	kSGCGrabCompressCompleteSelect = 0x118,	kSGCDisplayCompressSelect	= 0x119,	kSGCSetFrameRateSelect		= 0x11A,	kSGCGetFrameRateSelect		= 0x11B,	kSGCSetSoundInputDriverSelect = 0x100,	kSGCGetSoundInputDriverSelect = 0x101,	kSGCSoundInputDriverChangedSelect = 0x102,	kSGCSetSoundRecordChunkSizeSelect = 0x103,	kSGCGetSoundRecordChunkSizeSelect = 0x104,	kSGCSetSoundInputRateSelect	= 0x105,	kSGCGetSoundInputRateSelect	= 0x106,	kSGCSetSoundInputParametersSelect = 0x107,	kSGCGetSoundInputParametersSelect = 0x108};/* Standard type for video digitizers */enum {	videoDigitizerComponentType	= 'vdig',	vdigInterfaceRev			= 2};/* Input Format Standards */enum {	ntscIn						= 0,							/* current input format */	currentIn					= 0,							/* ntsc input format */	palIn						= 1,							/* pal input format */	secamIn						= 2,							/* secam input format */	ntscReallyIn				= 3								/* ntsc input format */};/* Input Formats */enum {	compositeIn					= 0,							/* input is composite format */	sVideoIn					= 1,							/* input is sVideo format */	rgbComponentIn				= 2,							/* input is rgb component format */	rgbComponentSyncIn			= 3,							/* input is rgb component format (sync on green?)*/	yuvComponentIn				= 4,							/* input is yuv component format */	yuvComponentSyncIn			= 5								/* input is yuv component format (sync on green?) */};/* Video Digitizer PlayThru States */enum {	vdPlayThruOff				= 0,	vdPlayThruOn				= 1};/* Input Color Space Modes */enum {	vdDigitizerBW				= 0,							/* black and white */	vdDigitizerRGB				= 1								/* rgb color */};/* Phase Lock Loop Modes */enum {	vdBroadcastMode				= 0,							/* Broadcast / Laser Disk video mode */	vdVTRMode					= 1								/* VCR / Magnetic media mode */};/* Field Select Options */enum {	vdUseAnyField				= 0,							/* Digitizers choice on field use */	vdUseOddField				= 1,							/* Use odd field for half size vert and smaller */	vdUseEvenField				= 2								/* Use even field for half size vert and smaller */};/* vdig types */enum {	vdTypeBasic					= 0,							/* basic, no clipping */	vdTypeAlpha					= 1,							/* supports clipping with alpha channel */	vdTypeMask					= 2,							/* supports clipping with mask plane */	vdTypeKey					= 3								/* supports clipping with key color(s) */};/* Digitizer Input Capability/Current Flags	*/enum {	digiInDoesNTSC				= 1L << 0,						/* digitizer supports NTSC input format */	digiInDoesPAL				= 1L << 1,						/* digitizer supports PAL input format */	digiInDoesSECAM				= 1L << 2,						/* digitizer supports SECAM input format */	digiInDoesGenLock			= 1L << 7,						/* digitizer does genlock */	digiInDoesComposite			= 1L << 8,						/* digitizer supports composite input type */	digiInDoesSVideo			= 1L << 9,						/* digitizer supports S-Video input type */	digiInDoesComponent			= 1L << 10,						/* digitizer supports component = rgb, input type */	digiInVTR_Broadcast			= 1L << 11,						/* digitizer can differentiate between the two */	digiInDoesColor				= 1L << 12,						/* digitizer supports color */	digiInDoesBW				= 1L << 13,						/* digitizer supports black & white *//* Digitizer Input Current Flags = these are valid only during active operating conditions,	*/	digiInSignalLock			= 1L << 31						/* digitizer detects input signal is locked, this bit = horiz lock || vertical lock */};/* Digitizer Output Capability/Current Flags */enum {	digiOutDoes1				= 1L << 0,						/* digitizer supports 1 bit pixels */	digiOutDoes2				= 1L << 1,						/* digitizer supports 2 bit pixels */	digiOutDoes4				= 1L << 2,						/* digitizer supports 4 bit pixels */	digiOutDoes8				= 1L << 3,						/* digitizer supports 8 bit pixels */	digiOutDoes16				= 1L << 4,						/* digitizer supports 16 bit pixels */	digiOutDoes32				= 1L << 5,						/* digitizer supports 32 bit pixels */	digiOutDoesDither			= 1L << 6,						/* digitizer dithers in indexed modes */	digiOutDoesStretch			= 1L << 7,						/* digitizer can arbitrarily stretch */	digiOutDoesShrink			= 1L << 8,						/* digitizer can arbitrarily shrink */	digiOutDoesMask				= 1L << 9,						/* digitizer can mask to clipping regions */	digiOutDoesDouble			= 1L << 11,						/* digitizer can stretch to exactly double size */	digiOutDoesQuad				= 1L << 12,						/* digitizer can stretch exactly quadruple size */	digiOutDoesQuarter			= 1L << 13,						/* digitizer can shrink to exactly quarter size */	digiOutDoesSixteenth		= 1L << 14,						/* digitizer can shrink to exactly sixteenth size */	digiOutDoesRotate			= 1L << 15,						/* digitizer supports rotate transformations */	digiOutDoesHorizFlip		= 1L << 16,						/* digitizer supports horizontal flips Sx < 0 */	digiOutDoesVertFlip			= 1L << 17,						/* digitizer supports vertical flips Sy < 0 */	digiOutDoesSkew				= 1L << 18,						/* digitizer supports skew = shear,twist, */	digiOutDoesBlend			= 1L << 19,	digiOutDoesWarp				= 1L << 20,	digiOutDoesHW_DMA			= 1L << 21,						/* digitizer not constrained to local device */	digiOutDoesHWPlayThru		= 1L << 22,						/* digitizer doesn't need time to play thru */	digiOutDoesILUT				= 1L << 23,						/* digitizer does inverse LUT for index modes */	digiOutDoesKeyColor			= 1L << 24,						/* digitizer does key color functions too */	digiOutDoesAsyncGrabs		= 1L << 25,						/* digitizer supports async grabs */	digiOutDoesUnreadableScreenBits = 1L << 26,					/* playthru doesn't generate readable bits on screen*/	digiOutDoesCompress			= 1L << 27,						/* supports alternate output data types */	digiOutDoesCompressOnly		= 1L << 28,						/* can't provide raw frames anywhere */	digiOutDoesPlayThruDuringCompress = 1L << 29				/* digi can do playthru while providing compressed data */};/* Types */typedef ComponentInstance VideoDigitizerComponent;typedef ComponentResult VideoDigitizerError;struct DigitizerInfo {	short							vdigType;	long							inputCapabilityFlags;	long							outputCapabilityFlags;	long							inputCurrentFlags;	long							outputCurrentFlags;	short							slot;						/* temporary for connection purposes */	GDHandle						gdh;						/* temporary for digitizers that have preferred screen */	GDHandle						maskgdh;					/* temporary for digitizers that have mask planes */	short							minDestHeight;				/* Smallest resizable height */	short							minDestWidth;				/* Smallest resizable width */	short							maxDestHeight;				/* Largest resizable height */	short							maxDestWidth;				/* Largest resizable height */	short							blendLevels;				/* Number of blend levels supported (2 if 1 bit mask) */	long							reserved;					/* reserved */};typedef struct DigitizerInfo DigitizerInfo;struct VdigType {	long							digType;	long							reserved;};typedef struct VdigType VdigType;struct VdigTypeList {	short							count;	VdigType						list[1];};typedef struct VdigTypeList VdigTypeList;struct VdigBufferRec {	PixMapHandle					dest;	Point							location;	long							reserved;};typedef struct VdigBufferRec VdigBufferRec;struct VdigBufferRecList {	short							count;	MatrixRecordPtr					matrix;	RgnHandle						mask;	VdigBufferRec					list[1];};typedef struct VdigBufferRecList VdigBufferRecList, *VdigBufferRecListPtr, **VdigBufferRecListHandle;typedef pascal void (*VdigIntProcPtr)(long flags, long refcon);#if GENERATINGCFMtypedef UniversalProcPtr VdigIntUPP;#elsetypedef VdigIntProcPtr VdigIntUPP;#endifstruct VDCompressionList {	CodecComponent					codec;	CodecType						cType;	Str63							typeName;	Str63							name;	long							formatFlags;	long							compressFlags;	long							reserved;};typedef struct VDCompressionList VDCompressionList, *VDCompressionListPtr, **VDCompressionListHandle;enum {	dmaDepth1					= 1,	dmaDepth2					= 2,	dmaDepth4					= 4,	dmaDepth8					= 8,	dmaDepth16					= 16,	dmaDepth32					= 32,	dmaDepth2Gray				= 64,	dmaDepth4Gray				= 128,	dmaDepth8Gray				= 256};enum {	kVDIGControlledFrameRate	= -1};/* number of vdig calls*/enum {	kvdigSelectors				= 86};extern pascal VideoDigitizerError VDGetMaxSrcRect(VideoDigitizerComponent ci, short inputStd, Rect *maxSrcRect) FIVEWORDINLINE(0x2F3C, 0x6, 0x1, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetActiveSrcRect(VideoDigitizerComponent ci, short inputStd, Rect *activeSrcRect) FIVEWORDINLINE(0x2F3C, 0x6, 0x2, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetDigitizerRect(VideoDigitizerComponent ci, Rect *digitizerRect) FIVEWORDINLINE(0x2F3C, 0x4, 0x3, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetDigitizerRect(VideoDigitizerComponent ci, Rect *digitizerRect) FIVEWORDINLINE(0x2F3C, 0x4, 0x4, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetVBlankRect(VideoDigitizerComponent ci, short inputStd, Rect *vBlankRect) FIVEWORDINLINE(0x2F3C, 0x6, 0x5, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetMaskPixMap(VideoDigitizerComponent ci, PixMapHandle maskPixMap) FIVEWORDINLINE(0x2F3C, 0x4, 0x6, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetPlayThruDestination(VideoDigitizerComponent ci, PixMapHandle *dest, Rect *destRect, MatrixRecord *m, RgnHandle *mask) FIVEWORDINLINE(0x2F3C, 0x10, 0x8, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDUseThisCLUT(VideoDigitizerComponent ci, CTabHandle colorTableHandle) FIVEWORDINLINE(0x2F3C, 0x4, 0x9, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetInputGammaValue(VideoDigitizerComponent ci, Fixed channel1, Fixed channel2, Fixed channel3) FIVEWORDINLINE(0x2F3C, 0xC, 0xA, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetInputGammaValue(VideoDigitizerComponent ci, Fixed *channel1, Fixed *channel2, Fixed *channel3) FIVEWORDINLINE(0x2F3C, 0xC, 0xB, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetBrightness(VideoDigitizerComponent ci, unsigned short *brightness) FIVEWORDINLINE(0x2F3C, 0x4, 0xC, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetBrightness(VideoDigitizerComponent ci, unsigned short *brightness) FIVEWORDINLINE(0x2F3C, 0x4, 0xD, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetContrast(VideoDigitizerComponent ci, unsigned short *contrast) FIVEWORDINLINE(0x2F3C, 0x4, 0xE, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetHue(VideoDigitizerComponent ci, unsigned short *hue) FIVEWORDINLINE(0x2F3C, 0x4, 0xF, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetSharpness(VideoDigitizerComponent ci, unsigned short *sharpness) FIVEWORDINLINE(0x2F3C, 0x4, 0x10, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetSaturation(VideoDigitizerComponent ci, unsigned short *saturation) FIVEWORDINLINE(0x2F3C, 0x4, 0x11, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetContrast(VideoDigitizerComponent ci, unsigned short *contrast) FIVEWORDINLINE(0x2F3C, 0x4, 0x12, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetHue(VideoDigitizerComponent ci, unsigned short *hue) FIVEWORDINLINE(0x2F3C, 0x4, 0x13, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetSharpness(VideoDigitizerComponent ci, unsigned short *sharpness) FIVEWORDINLINE(0x2F3C, 0x4, 0x14, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetSaturation(VideoDigitizerComponent ci, unsigned short *saturation) FIVEWORDINLINE(0x2F3C, 0x4, 0x15, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGrabOneFrame(VideoDigitizerComponent ci) FIVEWORDINLINE(0x2F3C, 0, 0x16, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetMaxAuxBuffer(VideoDigitizerComponent ci, PixMapHandle *pm, Rect *r) FIVEWORDINLINE(0x2F3C, 0x8, 0x17, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetDigitizerInfo(VideoDigitizerComponent ci, DigitizerInfo *info) FIVEWORDINLINE(0x2F3C, 0x4, 0x19, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetCurrentFlags(VideoDigitizerComponent ci, long *inputCurrentFlag, long *outputCurrentFlag) FIVEWORDINLINE(0x2F3C, 0x8, 0x1A, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetKeyColor(VideoDigitizerComponent ci, long index) FIVEWORDINLINE(0x2F3C, 0x4, 0x1B, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetKeyColor(VideoDigitizerComponent ci, long *index) FIVEWORDINLINE(0x2F3C, 0x4, 0x1C, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDAddKeyColor(VideoDigitizerComponent ci, long *index) FIVEWORDINLINE(0x2F3C, 0x4, 0x1D, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetNextKeyColor(VideoDigitizerComponent ci, long index) FIVEWORDINLINE(0x2F3C, 0x4, 0x1E, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetKeyColorRange(VideoDigitizerComponent ci, RGBColor *minRGB, RGBColor *maxRGB) FIVEWORDINLINE(0x2F3C, 0x8, 0x1F, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetKeyColorRange(VideoDigitizerComponent ci, RGBColor *minRGB, RGBColor *maxRGB) FIVEWORDINLINE(0x2F3C, 0x8, 0x20, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetDigitizerUserInterrupt(VideoDigitizerComponent ci, long flags, VdigIntUPP userInterruptProc, long refcon) FIVEWORDINLINE(0x2F3C, 0xC, 0x21, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetInputColorSpaceMode(VideoDigitizerComponent ci, short colorSpaceMode) FIVEWORDINLINE(0x2F3C, 0x2, 0x22, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetInputColorSpaceMode(VideoDigitizerComponent ci, short *colorSpaceMode) FIVEWORDINLINE(0x2F3C, 0x4, 0x23, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetClipState(VideoDigitizerComponent ci, short clipEnable) FIVEWORDINLINE(0x2F3C, 0x2, 0x24, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetClipState(VideoDigitizerComponent ci, short *clipEnable) FIVEWORDINLINE(0x2F3C, 0x4, 0x25, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetClipRgn(VideoDigitizerComponent ci, RgnHandle clipRegion) FIVEWORDINLINE(0x2F3C, 0x4, 0x26, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDClearClipRgn(VideoDigitizerComponent ci, RgnHandle clipRegion) FIVEWORDINLINE(0x2F3C, 0x4, 0x27, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetCLUTInUse(VideoDigitizerComponent ci, CTabHandle *colorTableHandle) FIVEWORDINLINE(0x2F3C, 0x4, 0x28, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetPLLFilterType(VideoDigitizerComponent ci, short pllType) FIVEWORDINLINE(0x2F3C, 0x2, 0x29, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetPLLFilterType(VideoDigitizerComponent ci, short *pllType) FIVEWORDINLINE(0x2F3C, 0x4, 0x2A, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetMaskandValue(VideoDigitizerComponent ci, unsigned short blendLevel, long *mask, long *value) FIVEWORDINLINE(0x2F3C, 0xA, 0x2B, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetMasterBlendLevel(VideoDigitizerComponent ci, unsigned short *blendLevel) FIVEWORDINLINE(0x2F3C, 0x4, 0x2C, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetPlayThruDestination(VideoDigitizerComponent ci, PixMapHandle dest, Rect *destRect, MatrixRecord *m, RgnHandle mask) FIVEWORDINLINE(0x2F3C, 0x10, 0x2D, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetPlayThruOnOff(VideoDigitizerComponent ci, short state) FIVEWORDINLINE(0x2F3C, 0x2, 0x2E, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetFieldPreference(VideoDigitizerComponent ci, short fieldFlag) FIVEWORDINLINE(0x2F3C, 0x2, 0x2F, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetFieldPreference(VideoDigitizerComponent ci, short *fieldFlag) FIVEWORDINLINE(0x2F3C, 0x4, 0x30, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDPreflightDestination(VideoDigitizerComponent ci, Rect *digitizerRect, PixMap **dest, Rect *destRect, MatrixRecord *m) FIVEWORDINLINE(0x2F3C, 0x10, 0x32, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDPreflightGlobalRect(VideoDigitizerComponent ci, GrafPtr theWindow, Rect *globalRect) FIVEWORDINLINE(0x2F3C, 0x8, 0x33, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetPlayThruGlobalRect(VideoDigitizerComponent ci, GrafPtr theWindow, Rect *globalRect) FIVEWORDINLINE(0x2F3C, 0x8, 0x34, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetInputGammaRecord(VideoDigitizerComponent ci, VDGamRecPtr inputGammaPtr) FIVEWORDINLINE(0x2F3C, 0x4, 0x35, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetInputGammaRecord(VideoDigitizerComponent ci, VDGamRecPtr *inputGammaPtr) FIVEWORDINLINE(0x2F3C, 0x4, 0x36, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetBlackLevelValue(VideoDigitizerComponent ci, unsigned short *blackLevel) FIVEWORDINLINE(0x2F3C, 0x4, 0x37, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetBlackLevelValue(VideoDigitizerComponent ci, unsigned short *blackLevel) FIVEWORDINLINE(0x2F3C, 0x4, 0x38, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetWhiteLevelValue(VideoDigitizerComponent ci, unsigned short *whiteLevel) FIVEWORDINLINE(0x2F3C, 0x4, 0x39, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetWhiteLevelValue(VideoDigitizerComponent ci, unsigned short *whiteLevel) FIVEWORDINLINE(0x2F3C, 0x4, 0x3A, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetVideoDefaults(VideoDigitizerComponent ci, unsigned short *blackLevel, unsigned short *whiteLevel, unsigned short *brightness, unsigned short *hue, unsigned short *saturation, unsigned short *contrast, unsigned short *sharpness) FIVEWORDINLINE(0x2F3C, 0x1C, 0x3B, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetNumberOfInputs(VideoDigitizerComponent ci, short *inputs) FIVEWORDINLINE(0x2F3C, 0x4, 0x3C, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetInputFormat(VideoDigitizerComponent ci, short input, short *format) FIVEWORDINLINE(0x2F3C, 0x6, 0x3D, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetInput(VideoDigitizerComponent ci, short input) FIVEWORDINLINE(0x2F3C, 0x2, 0x3E, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetInput(VideoDigitizerComponent ci, short *input) FIVEWORDINLINE(0x2F3C, 0x4, 0x3F, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetInputStandard(VideoDigitizerComponent ci, short inputStandard) FIVEWORDINLINE(0x2F3C, 0x2, 0x40, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetupBuffers(VideoDigitizerComponent ci, VdigBufferRecListHandle bufferList) FIVEWORDINLINE(0x2F3C, 0x4, 0x41, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGrabOneFrameAsync(VideoDigitizerComponent ci, short buffer) FIVEWORDINLINE(0x2F3C, 0x2, 0x42, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDDone(VideoDigitizerComponent ci, short buffer) FIVEWORDINLINE(0x2F3C, 0x2, 0x43, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetCompression(VideoDigitizerComponent ci, OSType compressType, short depth, Rect *bounds, CodecQ spatialQuality, CodecQ temporalQuality, long keyFrameRate) FIVEWORDINLINE(0x2F3C, 0x16, 0x44, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDCompressOneFrameAsync(VideoDigitizerComponent ci) FIVEWORDINLINE(0x2F3C, 0, 0x45, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDCompressDone(VideoDigitizerComponent ci, Boolean *done, Ptr *theData, long *dataSize, UInt8 *similarity, TimeRecord *t) FIVEWORDINLINE(0x2F3C, 0x14, 0x46, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDReleaseCompressBuffer(VideoDigitizerComponent ci, Ptr bufferAddr) FIVEWORDINLINE(0x2F3C, 0x4, 0x47, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetImageDescription(VideoDigitizerComponent ci, ImageDescriptionHandle desc) FIVEWORDINLINE(0x2F3C, 0x4, 0x48, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDResetCompressSequence(VideoDigitizerComponent ci) FIVEWORDINLINE(0x2F3C, 0, 0x49, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetCompressionOnOff(VideoDigitizerComponent ci, Boolean state) FIVEWORDINLINE(0x2F3C, 0x2, 0x4A, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetCompressionTypes(VideoDigitizerComponent ci, VDCompressionListHandle h) FIVEWORDINLINE(0x2F3C, 0x4, 0x4B, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetTimeBase(VideoDigitizerComponent ci, TimeBase t) FIVEWORDINLINE(0x2F3C, 0x4, 0x4C, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDSetFrameRate(VideoDigitizerComponent ci, Fixed framesPerSecond) FIVEWORDINLINE(0x2F3C, 0x4, 0x4D, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetDataRate(VideoDigitizerComponent ci, long *milliSecPerFrame, Fixed *framesPerSecond, long *bytesPerSecond) FIVEWORDINLINE(0x2F3C, 0xC, 0x4E, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetSoundInputDriver(VideoDigitizerComponent ci, Str255 soundDriverName) FIVEWORDINLINE(0x2F3C, 0x4, 0x4F, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetDMADepths(VideoDigitizerComponent ci, long *depthArray, long *preferredDepth) FIVEWORDINLINE(0x2F3C, 0x8, 0x50, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetPreferredTimeScale(VideoDigitizerComponent ci, TimeScale *preferred) FIVEWORDINLINE(0x2F3C, 0x4, 0x51, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDReleaseAsyncBuffers(VideoDigitizerComponent ci) FIVEWORDINLINE(0x2F3C, 0, 0x52, 0x7000, 0xA82A);/* 83 is reserved for compatibility reasons */extern pascal VideoDigitizerError VDSetDataRate(VideoDigitizerComponent ci, long bytesPerSecond) FIVEWORDINLINE(0x2F3C, 0x4, 0x54, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDGetTimeCode(VideoDigitizerComponent ci, TimeRecord *atTime, void *timeCodeFormat, void *timeCodeTime) FIVEWORDINLINE(0x2F3C, 0xC, 0x55, 0x7000, 0xA82A);extern pascal VideoDigitizerError VDUseSafeBuffers(VideoDigitizerComponent ci, Boolean useSafeBuffers) FIVEWORDINLINE(0x2F3C, 0x2, 0x56, 0x7000, 0xA82A);enum {	kSelectVDGetMaxSrcRect		= 0x1,	kSelectVDGetActiveSrcRect	= 0x2,	kSelectVDSetDigitizerRect	= 0x3,	kSelectVDGetDigitizerRect	= 0x4,	kSelectVDGetVBlankRect		= 0x5,	kSelectVDGetMaskPixMap		= 0x6,	kSelectVDGetPlayThruDestination = 0x8,	kSelectVDUseThisCLUT		= 0x9,	kSelectVDSetInputGammaValue	= 0xA,	kSelectVDGetInputGammaValue	= 0xB,	kSelectVDSetBrightness		= 0xC,	kSelectVDGetBrightness		= 0xD,	kSelectVDSetContrast		= 0xE,	kSelectVDSetHue				= 0xF,	kSelectVDSetSharpness		= 0x10,	kSelectVDSetSaturation		= 0x11,	kSelectVDGetContrast		= 0x12,	kSelectVDGetHue				= 0x13,	kSelectVDGetSharpness		= 0x14,	kSelectVDGetSaturation		= 0x15,	kSelectVDGrabOneFrame		= 0x16,	kSelectVDGetMaxAuxBuffer	= 0x17,	kSelectVDGetDigitizerInfo	= 0x19,	kSelectVDGetCurrentFlags	= 0x1A,	kSelectVDSetKeyColor		= 0x1B,	kSelectVDGetKeyColor		= 0x1C,	kSelectVDAddKeyColor		= 0x1D,	kSelectVDGetNextKeyColor	= 0x1E,	kSelectVDSetKeyColorRange	= 0x1F,	kSelectVDGetKeyColorRange	= 0x20,	kSelectVDSetDigitizerUserInterrupt = 0x21,	kSelectVDSetInputColorSpaceMode = 0x22,	kSelectVDGetInputColorSpaceMode = 0x23,	kSelectVDSetClipState		= 0x24,	kSelectVDGetClipState		= 0x25,	kSelectVDSetClipRgn			= 0x26,	kSelectVDClearClipRgn		= 0x27,	kSelectVDGetCLUTInUse		= 0x28,	kSelectVDSetPLLFilterType	= 0x29,	kSelectVDGetPLLFilterType	= 0x2A,	kSelectVDGetMaskandValue	= 0x2B,	kSelectVDSetMasterBlendLevel = 0x2C,	kSelectVDSetPlayThruDestination = 0x2D,	kSelectVDSetPlayThruOnOff	= 0x2E,	kSelectVDSetFieldPreference	= 0x2F,	kSelectVDGetFieldPreference	= 0x30,	kSelectVDPreflightDestination = 0x32,	kSelectVDPreflightGlobalRect = 0x33,	kSelectVDSetPlayThruGlobalRect = 0x34,	kSelectVDSetInputGammaRecord = 0x35,	kSelectVDGetInputGammaRecord = 0x36,	kSelectVDSetBlackLevelValue	= 0x37,	kSelectVDGetBlackLevelValue	= 0x38,	kSelectVDSetWhiteLevelValue	= 0x39,	kSelectVDGetWhiteLevelValue	= 0x3A,	kSelectVDGetVideoDefaults	= 0x3B,	kSelectVDGetNumberOfInputs	= 0x3C,	kSelectVDGetInputFormat		= 0x3D,	kSelectVDSetInput			= 0x3E,	kSelectVDGetInput			= 0x3F,	kSelectVDSetInputStandard	= 0x40,	kSelectVDSetupBuffers		= 0x41,	kSelectVDGrabOneFrameAsync	= 0x42,	kSelectVDDone				= 0x43,	kSelectVDSetCompression		= 0x44,	kSelectVDCompressOneFrameAsync = 0x45,	kSelectVDCompressDone		= 0x46,	kSelectVDReleaseCompressBuffer = 0x47,	kSelectVDGetImageDescription = 0x48,	kSelectVDResetCompressSequence = 0x49,	kSelectVDSetCompressionOnOff = 0x4A,	kSelectVDGetCompressionTypes = 0x4B,	kSelectVDSetTimeBase		= 0x4C,	kSelectVDSetFrameRate		= 0x4D,	kSelectVDGetDataRate		= 0x4E,	kSelectVDGetSoundInputDriver = 0x4F,	kSelectVDGetDMADepths		= 0x50,	kSelectVDGetPreferredTimeScale = 0x51,	kSelectVDReleaseAsyncBuffers = 0x52,	kSelectVDSetDataRate		= 0x54,	kSelectVDGetTimeCode		= 0x55,	kSelectVDUseSafeBuffers		= 0x56};enum {	StandardCompressionType		= 'scdi',	StandardCompressionSubType	= 'imag'};typedef pascal Boolean (*SCModalFilterProcPtr)(DialogPtr theDialog, EventRecord *theEvent, short *itemHit, long refcon);typedef pascal short (*SCModalHookProcPtr)(DialogPtr theDialog, short itemHit, void *params, long refcon);#if GENERATINGCFMtypedef UniversalProcPtr SCModalFilterUPP;typedef UniversalProcPtr SCModalHookUPP;#elsetypedef SCModalFilterProcPtr SCModalFilterUPP;typedef SCModalHookProcPtr SCModalHookUPP;#endifenum {	scListEveryCodec			= 1L << 1,	scAllowZeroFrameRate		= 1L << 2,	scAllowZeroKeyFrameRate		= 1L << 3,	scShowBestDepth				= 1L << 4,	scUseMovableModal			= 1L << 5};/*	Possible test flags for setting test image.*/enum {	scPreferCropping			= 1 << 0,	scPreferScaling				= 1 << 1,	scPreferScalingAndCropping	= scPreferScaling | scPreferCropping};/*	Dimensions of the image preview box.*/enum {	scTestImageWidth			= 80,	scTestImageHeight			= 80};/*	Possible items returned by hookProc.*/enum {	scOKItem					= 1,	scCancelItem				= 2,	scCustomItem				= 3};/*	Result returned when user cancelled.*/enum {	scUserCancelled				= 1};enum {	scPositionRect				= 2,	scPositionDialog			= 3,	scSetTestImagePictHandle	= 4,	scSetTestImagePictFile		= 5,	scSetTestImagePixMap		= 6,	scGetBestDeviceRect			= 7,	scRequestImageSettings		= 10,	scCompressImage				= 11,	scCompressPicture			= 12,	scCompressPictureFile		= 13,	scRequestSequenceSettings	= 14,	scCompressSequenceBegin		= 15,	scCompressSequenceFrame		= 16,	scCompressSequenceEnd		= 17,	scDefaultPictHandleSettings	= 18,	scDefaultPictFileSettings	= 19,	scDefaultPixMapSettings		= 20,	scGetInfo					= 21,	scSetInfo					= 22,	scNewGWorld					= 23};struct SCSpatialSettings {	CodecType						codecType;	CodecComponent					codec;	short							depth;	CodecQ							spatialQuality;};typedef struct SCSpatialSettings SCSpatialSettings;struct SCTemporalSettings {	CodecQ							temporalQuality;	Fixed							frameRate;	long							keyFrameRate;};typedef struct SCTemporalSettings SCTemporalSettings;struct SCDataRateSettings {	long							dataRate;	long							frameDuration;	CodecQ							minSpatialQuality;	CodecQ							minTemporalQuality;};typedef struct SCDataRateSettings SCDataRateSettings;struct SCExtendedProcs {	SCModalFilterUPP				filterProc;	SCModalHookUPP					hookProc;	long							refcon;	Str31							customName;};typedef struct SCExtendedProcs SCExtendedProcs;/*	Get/SetInfo selectors*/enum {	scSpatialSettingsType		= 'sptl',						/* pointer to SCSpatialSettings struct*/	scTemporalSettingsType		= 'tprl',						/* pointer to SCTemporalSettings struct*/	scDataRateSettingsType		= 'drat',						/* pointer to SCDataRateSettings struct*/	scColorTableType			= 'clut',						/* pointer to CTabHandle*/	scProgressProcType			= 'prog',						/* pointer to ProgressRecord struct*/	scExtendedProcsType			= 'xprc',						/* pointer to SCExtendedProcs struct*/	scPreferenceFlagsType		= 'pref',						/* pointer to long*/	scSettingsStateType			= 'ssta',						/* pointer to Handle*/	scSequenceIDType			= 'sequ',						/* pointer to ImageSequence*/	scWindowPositionType		= 'wndw',						/* pointer to Point*/	scCodecFlagsType			= 'cflg',						/* pointer to CodecFlags*/	scCodecSettingsType			= 'cdec',						/* pointer to Handle*/	scForceKeyValueType			= 'ksim'};/*	scTypeNotFoundErr returned by Get/SetInfo when type cannot be found.*//** These are Progress procedures **/extern pascal ComponentResult SCPositionRect(ComponentInstance ci, Rect *rp, Point *where) FIVEWORDINLINE(0x2F3C, 0x8, 0x2, 0x7000, 0xA82A);extern pascal ComponentResult SCPositionDialog(ComponentInstance ci, short id, Point *where) FIVEWORDINLINE(0x2F3C, 0x6, 0x3, 0x7000, 0xA82A);extern pascal ComponentResult SCSetTestImagePictHandle(ComponentInstance ci, PicHandle testPict, Rect *testRect, short testFlags) FIVEWORDINLINE(0x2F3C, 0xA, 0x4, 0x7000, 0xA82A);extern pascal ComponentResult SCSetTestImagePictFile(ComponentInstance ci, short testFileRef, Rect *testRect, short testFlags) FIVEWORDINLINE(0x2F3C, 0x8, 0x5, 0x7000, 0xA82A);extern pascal ComponentResult SCSetTestImagePixMap(ComponentInstance ci, PixMapHandle testPixMap, Rect *testRect, short testFlags) FIVEWORDINLINE(0x2F3C, 0xA, 0x6, 0x7000, 0xA82A);extern pascal ComponentResult SCGetBestDeviceRect(ComponentInstance ci, Rect *r) FIVEWORDINLINE(0x2F3C, 0x4, 0x7, 0x7000, 0xA82A);extern pascal ComponentResult SCRequestImageSettings(ComponentInstance ci) FIVEWORDINLINE(0x2F3C, 0, 0xA, 0x7000, 0xA82A);extern pascal ComponentResult SCCompressImage(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, ImageDescriptionHandle *desc, Handle *data) FIVEWORDINLINE(0x2F3C, 0x10, 0xB, 0x7000, 0xA82A);extern pascal ComponentResult SCCompressPicture(ComponentInstance ci, PicHandle srcPicture, PicHandle dstPicture) FIVEWORDINLINE(0x2F3C, 0x8, 0xC, 0x7000, 0xA82A);extern pascal ComponentResult SCCompressPictureFile(ComponentInstance ci, short srcRefNum, short dstRefNum) FIVEWORDINLINE(0x2F3C, 0x4, 0xD, 0x7000, 0xA82A);extern pascal ComponentResult SCRequestSequenceSettings(ComponentInstance ci) FIVEWORDINLINE(0x2F3C, 0, 0xE, 0x7000, 0xA82A);extern pascal ComponentResult SCCompressSequenceBegin(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, ImageDescriptionHandle *desc) FIVEWORDINLINE(0x2F3C, 0xC, 0xF, 0x7000, 0xA82A);extern pascal ComponentResult SCCompressSequenceFrame(ComponentInstance ci, PixMapHandle src, const Rect *srcRect, Handle *data, long *dataSize, short *notSyncFlag) FIVEWORDINLINE(0x2F3C, 0x14, 0x10, 0x7000, 0xA82A);extern pascal ComponentResult SCCompressSequenceEnd(ComponentInstance ci) FIVEWORDINLINE(0x2F3C, 0, 0x11, 0x7000, 0xA82A);extern pascal ComponentResult SCDefaultPictHandleSettings(ComponentInstance ci, PicHandle srcPicture, short motion) FIVEWORDINLINE(0x2F3C, 0x6, 0x12, 0x7000, 0xA82A);extern pascal ComponentResult SCDefaultPictFileSettings(ComponentInstance ci, short srcRef, short motion) FIVEWORDINLINE(0x2F3C, 0x4, 0x13, 0x7000, 0xA82A);extern pascal ComponentResult SCDefaultPixMapSettings(ComponentInstance ci, PixMapHandle src, short motion) FIVEWORDINLINE(0x2F3C, 0x6, 0x14, 0x7000, 0xA82A);extern pascal ComponentResult SCGetInfo(ComponentInstance ci, OSType infoType, void *info) FIVEWORDINLINE(0x2F3C, 0x8, 0x15, 0x7000, 0xA82A);extern pascal ComponentResult SCSetInfo(ComponentInstance ci, OSType infoType, void *info) FIVEWORDINLINE(0x2F3C, 0x8, 0x16, 0x7000, 0xA82A);extern pascal ComponentResult SCNewGWorld(ComponentInstance ci, GWorldPtr *gwp, Rect *rp, GWorldFlags flags) FIVEWORDINLINE(0x2F3C, 0xC, 0x17, 0x7000, 0xA82A);extern pascal ComponentResult SCSetCompressFlags(ComponentInstance ci, long flags) FIVEWORDINLINE(0x2F3C, 0x4, 0x18, 0x7000, 0xA82A);extern pascal ComponentResult SCGetCompressFlags(ComponentInstance ci, long *flags) FIVEWORDINLINE(0x2F3C, 0x4, 0x19, 0x7000, 0xA82A);struct SCParams {	long							flags;	CodecType						theCodecType;	CodecComponent					theCodec;	CodecQ							spatialQuality;	CodecQ							temporalQuality;	short							depth;	Fixed							frameRate;	long							keyFrameRate;	long							reserved1;	long							reserved2;};typedef struct SCParams SCParams;enum {	scGetCompression			= 1,	scShowMotionSettings		= 1L << 0,	scSettingsChangedItem		= -1};enum {	scCompressFlagIgnoreIdenticalFrames = 1};extern pascal ComponentResult SCGetCompressionExtended(ComponentInstance ci, SCParams *params, Point where, SCModalFilterUPP filterProc, SCModalHookUPP hookProc, long refcon, StringPtr customName) FIVEWORDINLINE(0x2F3C, 0x18, 0x1, 0x7000, 0xA82A);#define SCGetCompression(ci, params, where) SCGetCompressionExtended(ci,params,where,0,0,0,0)enum {	kSCPositionRectSelect		= 0x2,	kSCPositionDialogSelect		= 0x3,	kSCSetTestImagePictHandleSelect = 0x4,	kSCSetTestImagePictFileSelect = 0x5,	kSCSetTestImagePixMapSelect	= 0x6,	kSCGetBestDeviceRectSelect	= 0x7,	kSCRequestImageSettingsSelect = 0xA,	kSCCompressImageSelect		= 0xB,	kSCCompressPictureSelect	= 0xC,	kSCCompressPictureFileSelect = 0xD,	kSCRequestSequenceSettingsSelect = 0xE,	kSCCompressSequenceBeginSelect = 0xF,	kSCCompressSequenceFrameSelect = 0x10,	kSCCompressSequenceEndSelect = 0x11,	kSCDefaultPictHandleSettingsSelect = 0x12,	kSCDefaultPictFileSettingsSelect = 0x13,	kSCDefaultPixMapSettingsSelect = 0x14,	kSCGetInfoSelect			= 0x15,	kSCSetInfoSelect			= 0x16,	kSCNewGWorldSelect			= 0x17,	kSCSetCompressFlagsSelect	= 0x18,	kSCGetCompressFlagsSelect	= 0x19,	kSCGetCompressionExtendedSelect = 0x1};typedef ComponentInstance MovieImportComponent, MovieExportComponent;enum {	MovieImportType				= 'eat ',	MovieExportType				= 'spit'};enum {	canMovieImportHandles		= 1 << 0,	canMovieImportFiles			= 1 << 1,	hasMovieImportUserInterface	= 1 << 2,	canMovieExportHandles		= 1 << 3,	canMovieExportFiles			= 1 << 4,	hasMovieExportUserInterface	= 1 << 5,	dontAutoFileMovieImport		= 1 << 6,	canMovieExportAuxDataHandle	= 1 << 7,	canMovieImportValidateHandles = 1 << 8,	canMovieImportValidateFile	= 1 << 9,	dontRegisterWithEasyOpen	= 1 << 10,	canMovieImportInPlace		= 1 << 11,	movieImportSubTypeIsFileExtension = 1 << 12};enum {	kMovieImportExportOpenSelect = kComponentOpenSelect,	kMovieImportExportCloseSelect = kComponentCloseSelect,	kMovieImportExportCanDoSelect = kComponentCanDoSelect,	kMovieImportExportVersionSelect = kComponentVersionSelect,	kMovieImportHandleSelect	= 1,	kMovieImportFileSelect		= 2,	kMovieImportSetSampleDurationSelect = 3,	kMovieImportSetSampleDescriptionSelect = 4,	kMovieImportSetMediaFileSelect = 5,	kMovieImportSetDimensionsSelect = 6,	kMovieImportSetChunkSizeSelect = 7,	kMovieImportSetProgressProcSelect = 8,	kMovieImportSetAuxiliaryDataSelect = 9,	kMovieImportSetFromScrapSelect = 10,	kMovieImportDoUserDialogSelect = 11,	kMovieImportSetDurationSelect = 12,	kMovieImportGetAuxiliaryDataTypeSelect = 13,	kMovieImportValidateSelect	= 14,	kMovieImportGetFileTypeSelect = 15,	kMovieExportToHandleSelect	= 128,	kMovieExportToFileSelect	= 129,	kMovieExportDoUserDialogSelectOBSOLETE = 130,	kMovieExportGetAuxiliaryDataSelect = 131,	kMovieExportSetProgressProcSelect = 132,	kMovieExportSetSampleDescriptionSelect = 133,	kMovieExportDoUserDialogSelect = 134,	kMovieExportGetCreatorTypeSelect = 135};enum {	movieImportCreateTrack		= 1,	movieImportInParallel		= 2,	movieImportMustUseTrack		= 4};enum {	movieImportResultUsedMultipleTracks = 8};extern pascal ComponentResult MovieImportHandle(MovieImportComponent ci, Handle dataH, Movie theMovie, Track targetTrack, Track *usedTrack, TimeValue atTime, TimeValue *addedDuration, long inFlags, long *outFlags) FIVEWORDINLINE(0x2F3C, 0x20, 0x1, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportFile(MovieImportComponent ci, const FSSpec *theFile, Movie theMovie, Track targetTrack, Track *usedTrack, TimeValue atTime, TimeValue *addedDuration, long inFlags, long *outFlags) FIVEWORDINLINE(0x2F3C, 0x20, 0x2, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportSetSampleDuration(MovieImportComponent ci, TimeValue duration, TimeScale scale) FIVEWORDINLINE(0x2F3C, 0x8, 0x3, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportSetSampleDescription(MovieImportComponent ci, SampleDescriptionHandle desc, OSType mediaType) FIVEWORDINLINE(0x2F3C, 0x8, 0x4, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportSetMediaFile(MovieImportComponent ci, AliasHandle alias) FIVEWORDINLINE(0x2F3C, 0x4, 0x5, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportSetDimensions(MovieImportComponent ci, Fixed width, Fixed height) FIVEWORDINLINE(0x2F3C, 0x8, 0x6, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportSetChunkSize(MovieImportComponent ci, long chunkSize) FIVEWORDINLINE(0x2F3C, 0x4, 0x7, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportSetProgressProc(MovieImportComponent ci, MovieProgressUPP proc, long refcon) FIVEWORDINLINE(0x2F3C, 0x8, 0x8, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportSetAuxiliaryData(MovieImportComponent ci, Handle data, OSType handleType) FIVEWORDINLINE(0x2F3C, 0x8, 0x9, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportSetFromScrap(MovieImportComponent ci, Boolean fromScrap) FIVEWORDINLINE(0x2F3C, 0x2, 0xA, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportDoUserDialog(MovieImportComponent ci, const FSSpec *theFile, Handle theData, Boolean *canceled) FIVEWORDINLINE(0x2F3C, 0xC, 0xB, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportSetDuration(MovieImportComponent ci, TimeValue duration) FIVEWORDINLINE(0x2F3C, 0x4, 0xC, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportGetAuxiliaryDataType(MovieImportComponent ci, OSType *auxType) FIVEWORDINLINE(0x2F3C, 0x4, 0xD, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportValidate(MovieImportComponent ci, const FSSpec *theFile, Handle theData, Boolean *valid) FIVEWORDINLINE(0x2F3C, 0xC, 0xE, 0x7000, 0xA82A);extern pascal ComponentResult MovieImportGetFileType(MovieImportComponent ci, OSType *fileType) FIVEWORDINLINE(0x2F3C, 0x4, 0xF, 0x7000, 0xA82A);extern pascal ComponentResult MovieExportToHandle(MovieExportComponent ci, Handle dataH, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration) FIVEWORDINLINE(0x2F3C, 0x14, 0x80, 0x7000, 0xA82A);extern pascal ComponentResult MovieExportToFile(MovieExportComponent ci, const FSSpec *theFile, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration) FIVEWORDINLINE(0x2F3C, 0x14, 0x81, 0x7000, 0xA82A);extern pascal ComponentResult MovieExportGetAuxiliaryData(MovieExportComponent ci, Handle dataH, OSType *handleType) FIVEWORDINLINE(0x2F3C, 0x8, 0x83, 0x7000, 0xA82A);extern pascal ComponentResult MovieExportSetProgressProc(MovieExportComponent ci, MovieProgressUPP proc, long refcon) FIVEWORDINLINE(0x2F3C, 0x8, 0x84, 0x7000, 0xA82A);extern pascal ComponentResult MovieExportSetSampleDescription(MovieExportComponent ci, SampleDescriptionHandle desc, OSType mediaType) FIVEWORDINLINE(0x2F3C, 0x8, 0x85, 0x7000, 0xA82A);extern pascal ComponentResult MovieExportDoUserDialog(MovieExportComponent ci, Movie theMovie, Track onlyThisTrack, TimeValue startTime, TimeValue duration, Boolean *canceled) FIVEWORDINLINE(0x2F3C, 0x14, 0x86, 0x7000, 0xA82A);extern pascal ComponentResult MovieExportGetCreatorType(MovieExportComponent ci, OSType *creator) FIVEWORDINLINE(0x2F3C, 0x4, 0x87, 0x7000, 0xA82A);/* Text Export Display Info data structure*/struct TextDisplayData {	long							displayFlags;	long							textJustification;	RGBColor						bgColor;	Rect							textBox;	short							beginHilite;	short							endHilite;	RGBColor						hiliteColor;	Boolean							doHiliteColor;	SInt8							filler;	TimeValue						scrollDelayDur;	Point							dropShadowOffset;	short							dropShadowTransparency;};typedef struct TextDisplayData TextDisplayData;typedef ComponentInstance TextExportComponent;extern pascal ComponentResult TextExportGetDisplayData(TextExportComponent ci, TextDisplayData *textDisplay) FIVEWORDINLINE(0x2F3C, 0x4, 0x100, 0x7000, 0xA82A);/***************	File Preview Components***************/typedef ComponentInstance pnotComponent;enum {	pnotComponentWantsEvents	= 1,	pnotComponentNeedsNoCache	= 2};enum {	kPreviewOpenSelector		= 0,	kPreviewCloseSelector		= -1,	kPreviewCanDoSelector		= -2,	kPreviewVersionSelector		= -3,	kPreviewShowDataSelector	= 1,	kPreviewMakePreviewSelector	= 2,	kPreviewMakePreviewReferenceSelector = 3,	kPreviewEventSelector		= 4};enum {	ShowFilePreviewComponentType = 'pnot',	CreateFilePreviewComponentType = 'pmak'};extern pascal ComponentResult PreviewShowData(pnotComponent p, OSType dataType, Handle data, const Rect *inHere) FIVEWORDINLINE(0x2F3C, 0xC, 0x1, 0x7000, 0xA82A);extern pascal ComponentResult PreviewMakePreview(pnotComponent p, OSType *previewType, Handle *previewResult, const FSSpec *sourceFile, ICMProgressProcRecordPtr progress) FIVEWORDINLINE(0x2F3C, 0x10, 0x2, 0x7000, 0xA82A);extern pascal ComponentResult PreviewMakePreviewReference(pnotComponent p, OSType *previewType, short *resID, const FSSpec *sourceFile) FIVEWORDINLINE(0x2F3C, 0xC, 0x3, 0x7000, 0xA82A);extern pascal ComponentResult PreviewEvent(pnotComponent p, EventRecord *e, Boolean *handledEvent) FIVEWORDINLINE(0x2F3C, 0x8, 0x4, 0x7000, 0xA82A);typedef pascal void (*DataHCompletionProcPtr)(Ptr request, long refcon, OSErr err);#if GENERATINGCFMtypedef UniversalProcPtr DataHCompletionUPP;#elsetypedef DataHCompletionProcPtr DataHCompletionUPP;#endifenum {	kDataHCanRead				= 1L << 0,	kDataHSpecialRead			= 1L << 1,	kDataHSpecialReadFile		= 1L << 2,	kDataHCanWrite				= 1L << 3,	kDataHSpecialWrite			= 1 << 4,	kDataHSpecialWriteFile		= 1 << 5,	kDataHCanStreamingWrite		= 1 << 6,	kDataHMustCheckDataRef		= 1 << 7};struct DataHVolumeListRecord {	short							vRefNum;	long							flags;};typedef struct DataHVolumeListRecord DataHVolumeListRecord;typedef DataHVolumeListRecord *DataHVolumeListPtr;typedef DataHVolumeListPtr *DataHVolumeList;enum {	kDataHExtendedSchedule		= 'xtnd'};struct DataHScheduleRecord {	TimeRecord						timeNeededBy;	long							extendedID;					/* always is kDataHExtendedSchedule*/	long							extendedVers;				/* always set to 0*/	Fixed							priority;					/* 100.0 or more means must have. lower numbersÉ*/};typedef struct DataHScheduleRecord DataHScheduleRecord;typedef DataHScheduleRecord *DataHSchedulePtr;extern pascal ComponentResult DataHGetData(DataHandler dh, Handle h, long hOffset, long offset, long size) FIVEWORDINLINE(0x2F3C, 0x10, 0x2, 0x7000, 0xA82A);extern pascal ComponentResult DataHPutData(DataHandler dh, Handle h, long hOffset, long *offset, long size) FIVEWORDINLINE(0x2F3C, 0x10, 0x3, 0x7000, 0xA82A);extern pascal ComponentResult DataHFlushData(DataHandler dh) FIVEWORDINLINE(0x2F3C, 0, 0x4, 0x7000, 0xA82A);extern pascal ComponentResult DataHOpenForWrite(DataHandler dh) FIVEWORDINLINE(0x2F3C, 0, 0x5, 0x7000, 0xA82A);extern pascal ComponentResult DataHCloseForWrite(DataHandler dh) FIVEWORDINLINE(0x2F3C, 0, 0x6, 0x7000, 0xA82A);extern pascal ComponentResult DataHOpenForRead(DataHandler dh) FIVEWORDINLINE(0x2F3C, 0, 0x8, 0x7000, 0xA82A);extern pascal ComponentResult DataHCloseForRead(DataHandler dh) FIVEWORDINLINE(0x2F3C, 0, 0x9, 0x7000, 0xA82A);extern pascal ComponentResult DataHSetDataRef(DataHandler dh, Handle dataRef) FIVEWORDINLINE(0x2F3C, 0x4, 0xA, 0x7000, 0xA82A);extern pascal ComponentResult DataHGetDataRef(DataHandler dh, Handle *dataRef) FIVEWORDINLINE(0x2F3C, 0x4, 0xB, 0x7000, 0xA82A);extern pascal ComponentResult DataHCompareDataRef(DataHandler dh, Handle dataRef, Boolean *equal) FIVEWORDINLINE(0x2F3C, 0x8, 0xC, 0x7000, 0xA82A);extern pascal ComponentResult DataHTask(DataHandler dh) FIVEWORDINLINE(0x2F3C, 0, 0xD, 0x7000, 0xA82A);extern pascal ComponentResult DataHScheduleData(DataHandler dh, Ptr PlaceToPutDataPtr, long FileOffset, long DataSize, long RefCon, DataHSchedulePtr scheduleRec, DataHCompletionUPP CompletionRtn) FIVEWORDINLINE(0x2F3C, 0x18, 0xE, 0x7000, 0xA82A);extern pascal ComponentResult DataHFinishData(DataHandler dh, Ptr PlaceToPutDataPtr, Boolean Cancel) FIVEWORDINLINE(0x2F3C, 0x6, 0xF, 0x7000, 0xA82A);extern pascal ComponentResult DataHFlushCache(DataHandler dh) FIVEWORDINLINE(0x2F3C, 0, 0x10, 0x7000, 0xA82A);extern pascal ComponentResult DataHResolveDataRef(DataHandler dh, Handle theDataRef, Boolean *wasChanged, Boolean userInterfaceAllowed) FIVEWORDINLINE(0x2F3C, 0xA, 0x11, 0x7000, 0xA82A);extern pascal ComponentResult DataHGetFileSize(DataHandler dh, long *fileSize) FIVEWORDINLINE(0x2F3C, 0x4, 0x12, 0x7000, 0xA82A);extern pascal ComponentResult DataHCanUseDataRef(DataHandler dh, Handle dataRef, long *useFlags) FIVEWORDINLINE(0x2F3C, 0x8, 0x13, 0x7000, 0xA82A);extern pascal ComponentResult DataHGetVolumeList(DataHandler dh, DataHVolumeList *volumeList) FIVEWORDINLINE(0x2F3C, 0x4, 0x14, 0x7000, 0xA82A);extern pascal ComponentResult DataHWrite(DataHandler dh, Ptr data, long offset, long size, DataHCompletionUPP completion, long refCon) FIVEWORDINLINE(0x2F3C, 0x14, 0x15, 0x7000, 0xA82A);extern pascal ComponentResult DataHPreextend(DataHandler dh, long maxToAdd, long *spaceAdded) FIVEWORDINLINE(0x2F3C, 0x8, 0x16, 0x7000, 0xA82A);extern pascal ComponentResult DataHSetFileSize(DataHandler dh, long fileSize) FIVEWORDINLINE(0x2F3C, 0x4, 0x17, 0x7000, 0xA82A);extern pascal ComponentResult DataHGetFreeSpace(DataHandler dh, unsigned long *freeSize) FIVEWORDINLINE(0x2F3C, 0x4, 0x18, 0x7000, 0xA82A);extern pascal ComponentResult DataHCreateFile(DataHandler dh, OSType creator, Boolean deleteExisting) FIVEWORDINLINE(0x2F3C, 0x6, 0x19, 0x7000, 0xA82A);extern pascal ComponentResult DataHGetPreferredBlockSize(DataHandler dh, long *blockSize) FIVEWORDINLINE(0x2F3C, 0x4, 0x1A, 0x7000, 0xA82A);extern pascal ComponentResult DataHGetDeviceIndex(DataHandler dh, long *deviceIndex) FIVEWORDINLINE(0x2F3C, 0x4, 0x1B, 0x7000, 0xA82A);extern pascal ComponentResult DataHIsStreamingDataHandler(DataHandler dh, Boolean *yes) FIVEWORDINLINE(0x2F3C, 0x4, 0x1C, 0x7000, 0xA82A);extern pascal ComponentResult DataHGetDataInBuffer(DataHandler dh, long startOffset, long *size) FIVEWORDINLINE(0x2F3C, 0x8, 0x1D, 0x7000, 0xA82A);extern pascal ComponentResult DataHGetScheduleAheadTime(DataHandler dh, long *millisecs) FIVEWORDINLINE(0x2F3C, 0x4, 0x1E, 0x7000, 0xA82A);extern pascal ComponentResult DataHSetCacheSizeLimit(DataHandler dh, Size cacheSizeLimit) FIVEWORDINLINE(0x2F3C, 0x4, 0x1F, 0x7000, 0xA82A);extern pascal ComponentResult DataHGetCacheSizeLimit(DataHandler dh, Size *cacheSizeLimit) FIVEWORDINLINE(0x2F3C, 0x4, 0x20, 0x7000, 0xA82A);extern pascal ComponentResult DataHPlaybackHints(DataHandler dh, long flags, unsigned long minFileOffset, unsigned long maxFileOffset, long bytesPerSecond) FIVEWORDINLINE(0x2F3C, 0x10, 0x103, 0x7000, 0xA82A);enum {	kDataHGetDataSelect			= 0x2,	kDataHPutDataSelect			= 0x3,	kDataHFlushDataSelect		= 0x4,	kDataHOpenForWriteSelect	= 0x5,	kDataHCloseForWriteSelect	= 0x6,	kDataHOpenForReadSelect		= 0x8,	kDataHCloseForReadSelect	= 0x9,	kDataHSetDataRefSelect		= 0xA,	kDataHGetDataRefSelect		= 0xB,	kDataHCompareDataRefSelect	= 0xC,	kDataHTaskSelect			= 0xD,	kDataHScheduleDataSelect	= 0xE,	kDataHFinishDataSelect		= 0xF,	kDataHFlushCacheSelect		= 0x10,	kDataHResolveDataRefSelect	= 0x11,	kDataHGetFileSizeSelect		= 0x12,	kDataHCanUseDataRefSelect	= 0x13,	kDataHGetVolumeListSelect	= 0x14,	kDataHWriteSelect			= 0x15,	kDataHPreextendSelect		= 0x16,	kDataHSetFileSizeSelect		= 0x17,	kDataHGetFreeSpaceSelect	= 0x18,	kDataHCreateFileSelect		= 0x19,	kDataHGetPreferredBlockSizeSelect = 0x1A,	kDataHGetDeviceIndexSelect	= 0x1B,	kDataHIsStreamingDataHandlerSelect = 0x1C,	kDataHGetDataInBufferSelect	= 0x1D,	kDataHGetScheduleAheadTimeSelect = 0x1E,	kDataHSetCacheSizeLimitSelect = 0x1F,	kDataHGetCacheSizeLimitSelect = 0x20,	kDataHPlaybackHintsSelect	= 0x103};enum {	kMusicComponentType			= 'musi'};typedef ComponentInstance MusicComponent;/* MusicSynthesizerFlags*/enum {	kSynthesizerDynamicVoice	= 1,							/* can reassign voices/channels (else, hogs all channels in mask */	kSynthesizerUsesMIDIPort	= 2,							/* must be patched through MIDI Manager */	kSynthesizerMicrotone		= 4,							/* can play microtonal scales */	kSynthesizerLimitedMicrotone = 8,							/* can play microtones, but only on 1-voice parts */	kSynthesizerMixedDrums		= 16,							/* any part can play drum parts, total = instrument parts */	kSynthesizerSoftware		= 32,							/* implemented in main CPU software == uses cpu cycles */	kSynthesizerGMSuperset		= 8192,	kSynthesizerGM				= 16384							/* synth is a GM device */};/* * Note that these controller numbers * are _not_ identical to the MIDI controller numbers. * These are _signed_ 8.8 values, and the LSB's are * always sent to a MIDI device. Controllers 32-63 are * reserved (for MIDI, they are LSB's for 0-31, but we * always send both). * * The full range, therefore, is -128.00 to 127.7f. * * _Excepting_ _volume_, all controls default to zero. * * Pitch bend is specified in fractional semitones! No * more "pitch bend range" nonsense. You can bend as far * as you want, any time you want. */enum MusicControllers {	kControllerModulationWheel	= 1,	kControllerBreath			= 2,	kControllerFoot				= 4,	kControllerPortamentoTime	= 5,	kControllerVolume			= 7,	kControllerBalance			= 8,	kControllerPan				= 10,							/* 0 - "default", 1 - n: positioned in output 1-n (incl fractions) */	kControllerExpression		= 11,	kControllerPitchBend		= 32,							/* positive & negative semitones, with 7 bits fraction */	kControllerAfterTouch		= 33,	kControllerSustain			= 64,							/* boolean - positive for on, 0 or negative off */	kControllerPortamento		= 65,							/* boolean */	kControllerSostenuto		= 66,							/* boolean */	kControllerSoftPedal		= 67,							/* boolean */	kControllerReverb			= 91,	kControllerTremolo			= 92,	kControllerChorus			= 93,	kControllerCeleste			= 94,	kControllerPhaser			= 95};enum {	kControllerMaximum			= 0x7FFF,						/* +01111111.11111111 */	kControllerMinimum			= 0x8000						/* -10000000.00000000 */};struct SynthesizerDescription {	OSType							synthesizerType;			/* synthesizer type (must be same as component subtype) */	Str31							name;						/* text name of synthesizer type */	unsigned long					flags;						/* from the above enum */	unsigned long					voiceCount;					/* maximum polyphony */	unsigned long					partCount;					/* maximum multi-timbrality (and midi channels) */	unsigned long					instrumentCount;			/* non gm, built in (rom) instruments only */	unsigned long					modifiableInstrumentCount;	/* plus n-more are user modifiable */	unsigned long					channelMask;				/* (midi device only) which channels device always uses */	unsigned long					drumPartCount;				/* maximum multi-timbrality of drum parts */	unsigned long					drumCount;					/* non gm, built in (rom) drumkits only */	unsigned long					modifiableDrumCount;		/* plus n-more are user modifiable */	unsigned long					drumChannelMask;			/* (midi device only) which channels device always uses */	unsigned long					outputCount;				/* number of audio outputs (usually two) */	unsigned long					latency;					/* response time in µSec */	unsigned long					controllers[4];				/* array of 128 bits */	unsigned long					gmInstruments[4];			/* array of 128 bits */	unsigned long					gmDrums[4];					/* array of 128 bits */};typedef struct SynthesizerDescription SynthesizerDescription;enum {	kVoiceCountDynamic			= -1							/* constant to use to specify dynamic voicing */};struct ToneDescription {	OSType							synthesizerType;			/* synthesizer type */	Str31							synthesizerName;			/* name of instantiation of synth */	Str31							instrumentName;				/* preferred name for human use */	long							instrumentNumber;			/* inst-number used if synth-name matches */	long							gmNumber;					/* Best matching general MIDI number */};typedef struct ToneDescription ToneDescription;enum {	kFirstDrumkit				= 16384,						/* (first value is "no drum". instrument numbers from 16384->16384+128 are drumkits, and for GM they are _defined_ drumkits! */	kLastDrumkit				= (kFirstDrumkit + 128)};/* InstrumentMatch*/enum {	kInstrumentMatchSynthesizerType = 1,	kInstrumentMatchSynthesizerName = 2,	kInstrumentMatchName		= 4,	kInstrumentMatchNumber		= 8,	kInstrumentMatchGMNumber	= 16};/* KnobFlags*/enum {	kKnobRealtime				= 1,							/* Knob can be changed interactively as part of a sequence (ie knob can be changed at interrupt time) */	kKnobNextNote				= 2,							/* Knob only takes effect on the next note played */	kKnobAction					= 4,							/* setting the knob does something immediate */	kKnobNotInstrument			= 8,							/* indicates that the knob isn't in the instrument handle */	kKnobAffectsOthers			= 16,							/* other knobs will change value from this one */	kKnobMinorGroupStart		= 64,							/* knob is first in some logical subgroup of knobs */	kKnobGroupStart				= 128,							/* knob is first in some logical group of knobs *//* One of these may be used at a time. */	kKnobTypeNumber				= 0 << 12,	kKnobTypeBoolean			= 1 << 12,	kKnobTypeNote				= 2 << 12,	kKnobTypePan				= 3 << 12,	kKnobTypeInstrument			= 4 << 12,						/* knob value = reference to another instrument number */	kKnobTypeSetting			= 5 << 12						/* knob value is 1 of n different things (eg, fm algorithms) */};enum {	kUnknownKnobValue			= 0x7FFFFFFF					/* a knob with this value means, we don't know it. */};struct KnobDescription {	Str31							name;	long							lowValue;	long							highValue;	long							defaultValue;				/* a default instrument is made of all default values */	long							flags;};typedef struct KnobDescription KnobDescription;struct InstrumentData {	ToneDescription					tone;	long							knobCount;	long							knob[1];};typedef struct InstrumentData InstrumentData, **InstrumentDataHandle;struct FlatInstrument {	ToneDescription					tone;	long							size;						/* size in bytes of the following data, including size field (excluding tonedescription) */	UInt8							data[4];};typedef struct FlatInstrument FlatInstrument;struct InstrumentAboutInfo {	PicHandle						p;	Str255							author;	Str255							copyright;	Str255							other;};typedef struct InstrumentAboutInfo InstrumentAboutInfo;struct MusicMIDIPacket {	unsigned short					length;	unsigned long					reserved;	UInt8							data[249];};typedef struct MusicMIDIPacket MusicMIDIPacket;typedef pascal ComponentResult (*MusicMIDISendProcPtr)(MusicComponent self, long refCon, MusicMIDIPacket *mmp);#if GENERATINGCFMtypedef UniversalProcPtr MusicMIDISendUPP;#elsetypedef MusicMIDISendProcPtr MusicMIDISendUPP;#endifenum {	kMusicFirstSelect			= 0,	kMusicGetDescriptionSelect,	kMusicGetPartSelect,	kMusicSetPartSelect,	kMusicSetInstrumentNumberSelect,	kMusicGetInstrumentNumberSelect,	kMusicStoreInstrumentSelect,	kMusicGetInstrumentSelect,	kMusicSetInstrumentSelect,	kMusicDummyOne,	kMusicDummyTwo,	kMusicDummyThree,	kMusicDummyFour,	kMusicGetInstrumentKnobDescriptionSelect,	kMusicGetDrumKnobDescriptionSelect,	kMusicGetKnobDescriptionSelect,	kMusicGetPartKnobSelect,	kMusicSetPartKnobSelect,	kMusicGetKnobSelect,	kMusicSetKnobSelect,	kMusicGetPartNameSelect,	kMusicSetPartNameSelect,	kMusicFindToneSelect,	kMusicPlayNoteSelect,	kMusicResetPartSelect,	kMusicSetControllerSelect,	kMusicGetControllerSelect,	kMusicGetMIDIProcSelect,	kMusicSetMIDIProcSelect,	kMusicGetInstrumentNamesSelect,	kMusicGetDrumNamesSelect,	kMusicGetMasterTuneSelect,	kMusicSetMasterTuneSelect,	kMusicSetFlatInstrumentSelect,	kMusicGetInstrumentAboutInfoSelect};enum {	notImplementedMusicErr		= (0x80000000 | ((unsigned)(-2100 - 1))),	cantSendToSynthesizerErr	= (0x80000000 | ((unsigned)(-2100 - 2))),	cantReceiveFromSynthesizerErr = (0x80000000 | ((unsigned)(-2100 - 3))),	illegalVoiceAllocationErr	= (0x80000000 | ((unsigned)(-2100 - 4))),	illegalPartErr				= (0x80000000 | ((unsigned)(-2100 - 5))),	illegalChannelErr			= (0x80000000 | ((unsigned)(-2100 - 6))),	illegalKnobErr				= (0x80000000 | ((unsigned)(-2100 - 7))),	illegalKnobValueErr			= (0x80000000 | ((unsigned)(-2100 - 8))),	illegalInstrumentErr		= (0x80000000 | ((unsigned)(-2100 - 9))),	illegalControllerErr		= (0x80000000 | ((unsigned)(-2100 - 10))),	midiManagerAbsentErr		= (0x80000000 | ((unsigned)(-2100 - 11))),	synthesizerNotRespondingErr	= (0x80000000 | ((unsigned)(-2100 - 12))),	synthesizerErr				= (0x80000000 | ((unsigned)(-2100 - 13))),	illegalNoteChannelErr		= (0x80000000 | ((unsigned)(-2100 - 14))),	noteChannelNotAllocatedErr	= (0x80000000 | ((unsigned)(-2100 - 15))),	tunePlayerFullErr			= (0x80000000 | ((unsigned)(-2100 - 16))),	tuneParseErr				= (0x80000000 | ((unsigned)(-2100 - 17)))};enum {	kGMType						= 'gm  '};/*-----------------------------------------	Capabilities and Voice Allocation-----------------------------------------*/extern pascal ComponentResult MusicGetPart(MusicComponent mc, long part, long *midiChannel, long *polyphony) FIVEWORDINLINE(0x2F3C, 0xC, 0x2, 0x7000, 0xA82A);extern pascal ComponentResult MusicSetPart(MusicComponent mc, long part, long midiChannel, long polyphony) FIVEWORDINLINE(0x2F3C, 0xC, 0x3, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetDescription(MusicComponent mc, SynthesizerDescription *sd) FIVEWORDINLINE(0x2F3C, 0x4, 0x1, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetInstrumentAboutInfo(MusicComponent mc, long part, InstrumentAboutInfo *iai) FIVEWORDINLINE(0x2F3C, 0x8, 0x22, 0x7000, 0xA82A);/*-----------------------------------------	Instrument Loading and Storing-----------------------------------------*/extern pascal ComponentResult MusicSetInstrumentNumber(MusicComponent mc, long part, long instrumentNumber) FIVEWORDINLINE(0x2F3C, 0x8, 0x4, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetInstrumentNumber(MusicComponent mc, long part) FIVEWORDINLINE(0x2F3C, 0x4, 0x5, 0x7000, 0xA82A);extern pascal ComponentResult MusicStoreInstrument(MusicComponent mc, long part, long instrumentNumber) FIVEWORDINLINE(0x2F3C, 0x8, 0x6, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetInstrument(MusicComponent mc, long part, InstrumentDataHandle *iH) FIVEWORDINLINE(0x2F3C, 0x8, 0x7, 0x7000, 0xA82A);extern pascal ComponentResult MusicSetInstrument(MusicComponent mc, long part, InstrumentDataHandle iH) FIVEWORDINLINE(0x2F3C, 0x8, 0x8, 0x7000, 0xA82A);extern pascal ComponentResult MusicSetFlatInstrument(MusicComponent mc, long part, FlatInstrument *flatInstrument) FIVEWORDINLINE(0x2F3C, 0x8, 0x21, 0x7000, 0xA82A);/*-----------------------------------------	Instrument Knobs-----------------------------------------*/extern pascal ComponentResult MusicGetInstrumentKnobDescription(MusicComponent mc, long knobNumber, KnobDescription *mkd) FIVEWORDINLINE(0x2F3C, 0x8, 0xD, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetDrumKnobDescription(MusicComponent mc, long knobNumber, KnobDescription *mkd) FIVEWORDINLINE(0x2F3C, 0x8, 0xE, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetPartKnob(MusicComponent mc, long part, long knobNumber) FIVEWORDINLINE(0x2F3C, 0x8, 0x10, 0x7000, 0xA82A);extern pascal ComponentResult MusicSetPartKnob(MusicComponent mc, long part, long knobNumber, long knobValue) FIVEWORDINLINE(0x2F3C, 0xC, 0x11, 0x7000, 0xA82A);/*-----------------------------------------	Synthesizer Knobs-----------------------------------------*/extern pascal ComponentResult MusicGetKnobDescription(MusicComponent mc, long knobNumber, KnobDescription *mkd) FIVEWORDINLINE(0x2F3C, 0x8, 0xF, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetKnob(MusicComponent mc, long knobNumber) FIVEWORDINLINE(0x2F3C, 0x4, 0x12, 0x7000, 0xA82A);extern pascal ComponentResult MusicSetKnob(MusicComponent mc, long knobNumber, long knobValue) FIVEWORDINLINE(0x2F3C, 0x8, 0x13, 0x7000, 0xA82A);extern pascal ComponentResult MusicSetMasterTune(MusicComponent mc, Fixed masterTune) FIVEWORDINLINE(0x2F3C, 0x4, 0x20, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetMasterTune(MusicComponent mc) FIVEWORDINLINE(0x2F3C, 0, 0x1F, 0x7000, 0xA82A);/*-----------------------------------------	Names of Instruments-----------------------------------------*/extern pascal ComponentResult MusicGetPartName(MusicComponent mc, long part, Str31 name) FIVEWORDINLINE(0x2F3C, 0x8, 0x14, 0x7000, 0xA82A);extern pascal ComponentResult MusicSetPartName(MusicComponent mc, long part, Str31 name) FIVEWORDINLINE(0x2F3C, 0x8, 0x15, 0x7000, 0xA82A);extern pascal ComponentResult MusicFindTone(MusicComponent mc, ToneDescription *td, long *instrumentNumber, unsigned long *fit) FIVEWORDINLINE(0x2F3C, 0xC, 0x16, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetInstrumentNames(MusicComponent mc, long modifiableInstruments, Handle *instrumentNames, Handle *instrumentCategoryLasts, Handle *instrumentCategoryNames) FIVEWORDINLINE(0x2F3C, 0x10, 0x1D, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetDrumNames(MusicComponent mc, long modifiableInstruments, Handle *instrumentNumbers, Handle *instrumentNames) FIVEWORDINLINE(0x2F3C, 0xC, 0x1E, 0x7000, 0xA82A);/*-----------------------------------------	Realtime Actions-----------------------------------------*/extern pascal ComponentResult MusicPlayNote(MusicComponent mc, long part, long pitch, long velocity) FIVEWORDINLINE(0x2F3C, 0xC, 0x17, 0x7000, 0xA82A);extern pascal ComponentResult MusicResetPart(MusicComponent mc, long part) FIVEWORDINLINE(0x2F3C, 0x4, 0x18, 0x7000, 0xA82A);extern pascal ComponentResult MusicSetController(MusicComponent mc, long part, long controllerNumber, long controllerValue) FIVEWORDINLINE(0x2F3C, 0xC, 0x19, 0x7000, 0xA82A);extern pascal ComponentResult MusicGetController(MusicComponent mc, long part, long controllerNumber) FIVEWORDINLINE(0x2F3C, 0x8, 0x1A, 0x7000, 0xA82A);/*-----------------------------------------	Finding the Hardware-----------------------------------------*/extern pascal ComponentResult MusicGetMIDIProc(MusicComponent mc, MusicMIDISendUPP *midiSendProc, long *refCon) FIVEWORDINLINE(0x2F3C, 0x8, 0x1B, 0x7000, 0xA82A);extern pascal ComponentResult MusicSetMIDIProc(MusicComponent mc, MusicMIDISendUPP midiSendProc, long refCon) FIVEWORDINLINE(0x2F3C, 0x8, 0x1C, 0x7000, 0xA82A);/*--------------------------	Types--------------------------*/typedef struct privateNoteChannel *NoteChannel;struct SynthesizerConnections {	OSType							clientID;	OSType							inputPortID;	OSType							outputPortID;	long							midiChannel;				/* The system channel; others are configurable (or the nubus slot number) */	long							flags;	long							reserved[3];				/* should be zero */};typedef struct SynthesizerConnections SynthesizerConnections;struct NoteRequest {	long							polyphony;					/* Maximum number of voices */	Fixed							typicalPolyphony;			/* Hint for level mixing */	ToneDescription					tone;};typedef struct NoteRequest NoteRequest;enum {	kNAFirstSelector			= -7,	kNATargetSelect,	kNARegisterSelect,	kNAVersionSelect,	kNACanDoSelect,	kNACloseSelect,	kNAOpenSelect,	kNARegisterMusicDeviceSelect,	kNAUnregisterMusicDeviceSelect,	kNAGetRegisteredMusicDeviceSelect,	kNASaveMusicConfigurationSelect,	kNANewNoteChannelSelect,	kNADisposeNoteChannelSelect,	kNAGetNoteChannelInfoSelect,	kNAPrerollNoteChannelSelect,	kNAUnrollNoteChannelSelect,	kNAEngageNoteChannelSelect,	kNADisengageNoteChannelSelect,	kNASetNoteChannelVolumeSelect,	kNAResetNoteChannelSelect,	kNAPlayNoteSelect,	kNASetControllerSelect,	kNASetKnobSelect,	kNAFindNoteChannelToneSelect,	kNASetNoteChannelInstrumentSelect,	kNAPickInstrumentSelect,	kNAPickArrangementSelect,	kNAGetStatusBlockSelect,	kNASetDefaultMIDIInputSelect,	kNAGetDefaultMIDIInputSelect,	kNAGetNoteChannelStateSelect,	kNASetNoteChannelStateSelect,	kNAUseDefaultMIDIInputSelect,	kNALoseDefaultMIDIInputSelect,	kNAStuffToneDescriptionSelect,	kNACopyrightDialogSelect,	kNASetFlatInstrumentSelect,	kNASetInstrumentSelect,	kNALastSelector};typedef ComponentInstance NoteAllocator;enum {	kPickDontMix				= 1,							/* dont mix instruments with drum sounds */	kPickSameSynth				= 2								/* only allow the same device that went in, to come out */};typedef pascal ComponentResult (*MusicMIDIReadHookProcPtr)(MusicMIDIPacket *mp, long myRefCon);#if GENERATINGCFMtypedef UniversalProcPtr MusicMIDIReadHookUPP;#elsetypedef MusicMIDIReadHookProcPtr MusicMIDIReadHookUPP;#endifenum {	kNoteAllocatorType			= 'nota'};/*--------------------------------	Note Allocator Prototypes--------------------------------*//* * System Configuration */extern pascal ComponentResult NARegisterMusicDevice(NoteAllocator na, OSType synthType, Str31 name, SynthesizerConnections *connections) FIVEWORDINLINE(0x2F3C, 0xC, 0, 0x7000, 0xA82A);extern pascal ComponentResult NAUnregisterMusicDevice(NoteAllocator na, long index) FIVEWORDINLINE(0x2F3C, 0x4, 0x1, 0x7000, 0xA82A);extern pascal ComponentResult NAGetRegisteredMusicDevice(NoteAllocator na, long index, OSType *synthType, Str31 name, SynthesizerConnections *connections, MusicComponent *mc) FIVEWORDINLINE(0x2F3C, 0x14, 0x2, 0x7000, 0xA82A);extern pascal ComponentResult NASetDefaultMIDIInput(NoteAllocator na, SynthesizerConnections *sc) FIVEWORDINLINE(0x2F3C, 0x4, 0x15, 0x7000, 0xA82A);extern pascal ComponentResult NAGetDefaultMIDIInput(NoteAllocator na, SynthesizerConnections *sc) FIVEWORDINLINE(0x2F3C, 0x4, 0x16, 0x7000, 0xA82A);extern pascal ComponentResult NASaveMusicConfiguration(NoteAllocator na) FIVEWORDINLINE(0x2F3C, 0, 0x3, 0x7000, 0xA82A);/* * Allocation */extern pascal ComponentResult NANewNoteChannel(NoteAllocator na, NoteRequest *noteRequest, NoteChannel *outChannel) FIVEWORDINLINE(0x2F3C, 0x8, 0x4, 0x7000, 0xA82A);extern pascal ComponentResult NADisposeNoteChannel(NoteAllocator na, NoteChannel noteChannel) FIVEWORDINLINE(0x2F3C, 0x4, 0x5, 0x7000, 0xA82A);extern pascal ComponentResult NAGetNoteChannelInfo(NoteAllocator na, NoteChannel noteChannel, long *index, long *part) FIVEWORDINLINE(0x2F3C, 0xC, 0x6, 0x7000, 0xA82A);extern pascal ComponentResult NAUseDefaultMIDIInput(NoteAllocator na, MusicMIDIReadHookUPP readHook, long refCon, unsigned long flags) FIVEWORDINLINE(0x2F3C, 0xC, 0x19, 0x7000, 0xA82A);extern pascal ComponentResult NALoseDefaultMIDIInput(NoteAllocator na) FIVEWORDINLINE(0x2F3C, 0, 0x1A, 0x7000, 0xA82A);/* * Setup */extern pascal ComponentResult NAPrerollNoteChannel(NoteAllocator na, NoteChannel noteChannel) FIVEWORDINLINE(0x2F3C, 0x4, 0x7, 0x7000, 0xA82A);extern pascal ComponentResult NAUnrollNoteChannel(NoteAllocator na, NoteChannel noteChannel) FIVEWORDINLINE(0x2F3C, 0x4, 0x8, 0x7000, 0xA82A);extern pascal ComponentResult NAEngageNoteChannel(NoteAllocator na, NoteChannel noteChannel) FIVEWORDINLINE(0x2F3C, 0x4, 0x9, 0x7000, 0xA82A);extern pascal ComponentResult NADisengageNoteChannel(NoteAllocator na, NoteChannel noteChannel, long silenceNotes) FIVEWORDINLINE(0x2F3C, 0x8, 0xA, 0x7000, 0xA82A);extern pascal ComponentResult NAGetNoteChannelState(NoteAllocator na, NoteChannel noteChannel, long instrumentNumber, Handle *state) FIVEWORDINLINE(0x2F3C, 0xC, 0x17, 0x7000, 0xA82A);extern pascal ComponentResult NASetNoteChannelState(NoteAllocator na, NoteChannel noteChannel, long instrumentNumber, Handle state) FIVEWORDINLINE(0x2F3C, 0xC, 0x18, 0x7000, 0xA82A);extern pascal ComponentResult NAResetNoteChannel(NoteAllocator na, NoteChannel noteChannel) FIVEWORDINLINE(0x2F3C, 0x4, 0xC, 0x7000, 0xA82A);extern pascal ComponentResult NASetNoteChannelVolume(NoteAllocator na, NoteChannel noteChannel, Fixed volume) FIVEWORDINLINE(0x2F3C, 0x8, 0xB, 0x7000, 0xA82A);extern pascal ComponentResult NASetInstrument(NoteAllocator na, NoteChannel noteChannel, InstrumentData *instrumentData) FIVEWORDINLINE(0x2F3C, 0x8, 0x1E, 0x7000, 0xA82A);extern pascal ComponentResult NASetFlatInstrument(NoteAllocator na, NoteChannel noteChannel, FlatInstrument *flatInstrument) FIVEWORDINLINE(0x2F3C, 0x8, 0x1D, 0x7000, 0xA82A);/* * Control */extern pascal ComponentResult NAPlayNote(NoteAllocator na, NoteChannel noteChannel, long pitch, long velocity) FIVEWORDINLINE(0x2F3C, 0xC, 0xD, 0x7000, 0xA82A);extern pascal ComponentResult NASetController(NoteAllocator na, NoteChannel noteChannel, long controllerNumber, long controllerValue) FIVEWORDINLINE(0x2F3C, 0xC, 0xE, 0x7000, 0xA82A);extern pascal ComponentResult NASetKnob(NoteAllocator na, NoteChannel noteChannel, long knobNumber, long knobValue) FIVEWORDINLINE(0x2F3C, 0xC, 0xF, 0x7000, 0xA82A);extern pascal ComponentResult NAFindNoteChannelTone(NoteAllocator na, NoteChannel noteChannel, ToneDescription *td, long *instrumentNumber) FIVEWORDINLINE(0x2F3C, 0xC, 0x10, 0x7000, 0xA82A);extern pascal ComponentResult NASetNoteChannelInstrument(NoteAllocator na, NoteChannel noteChannel, long instrumentNumber) FIVEWORDINLINE(0x2F3C, 0x8, 0x11, 0x7000, 0xA82A);/* * User Interface */extern pascal ComponentResult NAPickInstrument(NoteAllocator na, ModalFilterUPP filterProc, StringPtr prompt, ToneDescription *sd, unsigned long flags, long refCon, Ptr *flatList, long *flatChoiceIndex) FIVEWORDINLINE(0x2F3C, 0x1C, 0x12, 0x7000, 0xA82A);extern pascal ComponentResult NAStuffToneDescription(NoteAllocator na, long gmNumber, ToneDescription *td) FIVEWORDINLINE(0x2F3C, 0x8, 0x1B, 0x7000, 0xA82A);extern pascal ComponentResult NAPickArrangement(NoteAllocator na, ModalFilterUPP filterProc, StringPtr prompt, long partCount, NoteRequest *noteRequestList, Track t, StringPtr songName) FIVEWORDINLINE(0x2F3C, 0x18, 0x13, 0x7000, 0xA82A);extern pascal ComponentResult NACopyrightDialog(NoteAllocator na, PicHandle p, StringPtr author, StringPtr copyright, StringPtr other, StringPtr title, ModalFilterUPP filterProc, long refCon) FIVEWORDINLINE(0x2F3C, 0x1C, 0x1C, 0x7000, 0xA82A);/* * Note Allocator interior views */struct NAStatPiece {	Str31							clientName;	Str31							synthesizerName;	long							part;	long							midiChannel;	long							polyphony;	long							valid;};typedef struct NAStatPiece NAStatPiece;struct NAStat {	long							pieceCount;	NAStatPiece						piece[64];};typedef struct NAStat NAStat;extern pascal ComponentResult NAGetStatusBlock(NoteAllocator na, NAStat *stat) FIVEWORDINLINE(0x2F3C, 0x4, 0x14, 0x7000, 0xA82A);/*--------------------------	Types--------------------------*/enum {	kTuneQueueDepth				= 8								/* Deepest you can queue tune segments */};struct TuneStatus {	unsigned long					*tune;						/* currently playing tune */	unsigned long					*tunePtr;					/* position within currently playing piece */	TimeValue						time;						/* current tune time */	short							queueCount;					/* how many pieces queued up? */	short							queueSpots;					/* How many more tunepieces can be queued */	TimeValue						queueTime;					/* How much time is queued up? (can be very inaccurate) */	long							reserved[3];};typedef struct TuneStatus TuneStatus;enum {	kStopTuneFade				= 1,							/* do a quick, synchronous fadeout */	kStopTuneSustain			= 2,							/* don't silece notes */	kStopTuneInstant			= 4,							/* silence notes fast (else, decay them) */	kStopTuneReleaseChannels	= 8								/* afterwards, let the channels go */};enum {	kTuneSelect					= 3,	kTuneSetHeaderSelect,	kTuneGetTimeBaseSelect,	kTuneSetTimeScaleSelect,	kTuneGetTimeScaleSelect,	kTuneGetIndexedNoteChannelSelect,	kTuneDummy,	kTuneQueueSelect,	kTuneInstantSelect,	kTuneGetStatusSelect,	kTuneStopSelect,	kTuneResumeSelect,	kTuneFlushSelect,	kTuneSetVolumeSelect,	kTuneGetVolumeSelect,	kTunePrerollSelect,	kTuneUnrollSelect,	kTuneLastSelector};typedef pascal void (*TuneCallBackProcPtr)(const TuneStatus *status, long refCon);typedef pascal void (*TunePlayCallBackProcPtr)(unsigned long *event, long seed, long refCon);#if GENERATINGCFMtypedef UniversalProcPtr TuneCallBackUPP;typedef UniversalProcPtr TunePlayCallBackUPP;#elsetypedef TuneCallBackProcPtr TuneCallBackUPP;typedef TunePlayCallBackProcPtr TunePlayCallBackUPP;#endiftypedef ComponentInstance TunePlayer;enum {	kMaxTunePlayerParts			= 32,	kTunePlayerType				= 'tune'};/*--------------------------	Prototypes--------------------------*/extern pascal ComponentResult TuneSetHeader(TunePlayer tp, unsigned long *header) FIVEWORDINLINE(0x2F3C, 0x4, 0x4, 0x7000, 0xA82A);extern pascal ComponentResult TuneGetTimeBase(TunePlayer tp, TimeBase *tb) FIVEWORDINLINE(0x2F3C, 0x4, 0x5, 0x7000, 0xA82A);extern pascal ComponentResult TuneSetTimeScale(TunePlayer tp, TimeScale scale) FIVEWORDINLINE(0x2F3C, 0x4, 0x6, 0x7000, 0xA82A);extern pascal ComponentResult TuneGetTimeScale(TunePlayer tp, TimeScale *scale) FIVEWORDINLINE(0x2F3C, 0x4, 0x7, 0x7000, 0xA82A);extern pascal ComponentResult TuneGetIndexedNoteChannel(TunePlayer tp, long i, NoteChannel *nc) FIVEWORDINLINE(0x2F3C, 0x8, 0x8, 0x7000, 0xA82A);/* Values for when to start. */enum {	kTuneStartNow				= 1,							/* start after buffer is implied */	kTuneDontClipNotes			= 2,							/* allow notes to finish their durations outside sample */	kTuneExcludeEdgeNotes		= 4,							/* dont play notes that start at end of tune */	kTuneStartNewMaster			= 16384};extern pascal ComponentResult TuneQueue(TunePlayer tp, unsigned long *tune, Fixed tuneRate, unsigned long tuneStartPosition, unsigned long tuneStopPosition, unsigned long queueFlags, TuneCallBackUPP callBackProc, long refCon) FIVEWORDINLINE(0x2F3C, 0x1C, 0xA, 0x7000, 0xA82A);extern pascal ComponentResult TuneInstant(TunePlayer tp, unsigned long *tune, long tunePosition) FIVEWORDINLINE(0x2F3C, 0x8, 0xB, 0x7000, 0xA82A);extern pascal ComponentResult TuneGetStatus(TunePlayer tp, TuneStatus *status) FIVEWORDINLINE(0x2F3C, 0x4, 0xC, 0x7000, 0xA82A);/* Values for when to start. */enum {	kStopSustain				= 1,							/* Leaves notes playing, not silent */	kStopFadeout				= 2								/* Does a synchronous fade-out */};extern pascal ComponentResult TuneStop(TunePlayer tp, long stopFlags) FIVEWORDINLINE(0x2F3C, 0x4, 0xD, 0x7000, 0xA82A);extern pascal ComponentResult TuneResume(TunePlayer tp) FIVEWORDINLINE(0x2F3C, 0, 0xE, 0x7000, 0xA82A);extern pascal ComponentResult TuneFlush(TunePlayer tp) FIVEWORDINLINE(0x2F3C, 0, 0xF, 0x7000, 0xA82A);extern pascal ComponentResult TuneSetVolume(TunePlayer tp, Fixed volume) FIVEWORDINLINE(0x2F3C, 0x4, 0x10, 0x7000, 0xA82A);extern pascal ComponentResult TuneGetVolume(TunePlayer tp) FIVEWORDINLINE(0x2F3C, 0, 0x11, 0x7000, 0xA82A);extern pascal ComponentResult TunePreroll(TunePlayer tp) FIVEWORDINLINE(0x2F3C, 0, 0x12, 0x7000, 0xA82A);extern pascal ComponentResult TuneUnroll(TunePlayer tp) FIVEWORDINLINE(0x2F3C, 0, 0x13, 0x7000, 0xA82A);typedef unsigned long MusicOpWord, *MusicOpWordPtr;/* 	QuickTime Music Track Event Formats:	At this time, QuickTime music tracks support 5 different event types -- REST events,	short NOTE events, short CONTROL events, short GENERAL events, Long NOTE events, 	long CONTROL events, and variable GENERAL events. 		¥ REST Event (4 bytes/event):				(0 0 0) (5-bit UNUSED) (24-bit Rest Duration)				¥ÊShort NOTE Events (4 bytes/event):				(0 0 1) (5-bit Instrument) (6-bit Pitch) (7-bit Volume) (11-bit Duration)					where:	Pitch is offset by 32 (Actual pitch = pitch field + 32)		¥ÊShort CONTROL Events (4 bytes/event):				(0 1 0) (5-bit Instrument) (8-bit Controller) (1-bit UNUSED) (1-bit Sign) (7-bit MSB) (7-bit LSB)																		 ( or 15-bit Signed Value)		¥ Short GENERAL Event (4 bytes/event):				(0 1 1) (1-bit UNUSED) (12-bit Sub-Type) (16-bit Value)			¥ Long NOTE Events (8 bytes/event):				(1 0 0 1) (12-bit Instrument) (1-bit UNUSED) (7-bit Pitch) (1-bit UNUSED) (7-bit Volume)			(1 0) (8-bit UNUSED) (22-bit Duration)				¥ÊLong CONTROL Event (8 bytes/event):					(1 0 1 0) (12-bit Instrument) (16-bit Value MSB) 			(1 0) (14-bit Controller) (16-bit Value LSB)			¥ÊLong KNOB Event (8 bytes/event):				(1 0 1 1) (12-bit Sub-Type) (16-bit Value MSB)			(1 0) (14-bit KNOB) (16-bit Value LSB)			¥ÊVariable GENERAL Length Events (N bytes/event):				(1 1 1 1) (12-bit Sub-Type) (16-bit Length)				:			(32-bit Data values)				:			(1 1) (14-bit UNUSED) (16-bit Length)				where:	Length field is the number of LONG words in the record.					Lengths include the first and last long words (Minimum length = 2)					The following event type values have not been used yet and are reserved for 	future expansion:				¥ (1 0 0 0)		(8 bytes/event)		¥ (1 1 0 0)		(N bytes/event)		¥ (1 1 0 1)		(N bytes/event)		¥ (1 1 1 0)		(N bytes/event)			For all events, the following generalizations apply:			-	All duration values are specified in Millisecond units.		- 	Pitch values are intended to map directly to the MIDI key numbers.		-	Controllers from 0 to 127 correspond to the standard MIDI controllers.			Controllers greater than 127 correspond to other controls (i.e., Pitch Bend, 			Key Pressure, and Channel Pressure).	*//* Defines for the implemented music event data fields*/enum {	kRestEventType				= 0x0L,							/* lower 3-bits */	kNoteEventType				= 0x1L,							/* lower 3-bits */	kControlEventType			= 0x2L,							/* lower 3-bits */	kMarkerEventType			= 0x3L,							/* lower 3-bits */	kUndefined1EventType		= 0x8L,							/* 4-bits */	kXNoteEventType				= 0x9L,							/* 4-bits */	kXControlEventType			= 0xAL,							/* 4-bits */	kKnobEventType				= 0xBL,							/* 4-bits */	kUndefined2EventType		= 0xCL,							/* 4-bits */	kUndefined3EventType		= 0xDL,							/* 4-bits */	kUndefined4EventType		= 0xEL,							/* 4-bits */	kGeneralEventType			= 0xFL,							/* 4-bits */	kXEventLengthBits			= 0x2L,							/* 2 bits: indicates 8-byte event record */	kGeneralEventLengthBits		= 0x3L,							/* 2 bits: indicates variable length event record */	kEventLen					= 1L,							/* length of events in long words */	kXEventLen					= 2L,	kRestEventLen				= kEventLen,					/* length of events in long words */	kNoteEventLen				= kEventLen,	kControlEventLen			= kEventLen,	kMarkerEventLen				= kEventLen,	kXNoteEventLen				= kXEventLen,	kXControlEventLen			= kXEventLen,	kGeneralEventLen			= kXEventLen,					/* 2 or more, however *//* Universal Event Defines*/	kEventLengthFieldPos		= 30,							/* by looking at these two bits of the 1st or last word 			 */	kEventLengthFieldWidth		= 2,							/* of an event you can determine the event length 					 *//* length field: 0 & 1 => 1 long; 2 => 2 longs; 3 => variable length */	kEventTypeFieldPos			= 29,							/* event type field for short events */	kEventTypeFieldWidth		= 3,							/* short type is 3 bits */	kXEventTypeFieldPos			= 28,							/* event type field for extended events */	kXEventTypeFieldWidth		= 4,							/* extended type is 4 bits */	kEventInstrumentFieldPos	= 24,	kEventInstrumentFieldWidth	= 5,	kXEventInstrumentFieldPos	= 16,							/* in the 1st long word */	kXEventInstrumentFieldWidth	= 12,/* Rest Events*/	kRestEventDurationFieldPos	= 0,	kRestEventDurationFieldWidth = 24,	kRestEventDurationMax		= ((1 << kRestEventDurationFieldWidth) - 1),/* Note Events*/	kNoteEventPitchFieldPos		= 18,	kNoteEventPitchFieldWidth	= 6,	kNoteEventPitchOffset		= 32,							/* add to value in pitch field to get actual pitch */	kNoteEventVolumeFieldPos	= 11,	kNoteEventVolumeFieldWidth	= 7,	kNoteEventVolumeOffset		= 0,							/* add to value in volume field to get actual volume */	kNoteEventDurationFieldPos	= 0,	kNoteEventDurationFieldWidth = 11,	kNoteEventDurationMax		= ((1 << kNoteEventDurationFieldWidth) - 1),	kXNoteEventPitchFieldPos	= 0,							/* in the 1st long word */	kXNoteEventPitchFieldWidth	= 16,	kXNoteEventDurationFieldPos	= 0,							/* in the 2nd long word */	kXNoteEventDurationFieldWidth = 22,	kXNoteEventDurationMax		= ((1 << kXNoteEventDurationFieldWidth) - 1),	kXNoteEventVolumeFieldPos	= 22,							/* in the 2nd long word */	kXNoteEventVolumeFieldWidth	= 7,/* Control Events*/	kControlEventControllerFieldPos = 16,	kControlEventControllerFieldWidth = 8,	kControlEventValueFieldPos	= 0,	kControlEventValueFieldWidth = 16,	kXControlEventControllerFieldPos = 0,						/* in the 2nd long word */	kXControlEventControllerFieldWidth = 16,	kXControlEventValueFieldPos	= 0,							/* in the 1st long word */	kXControlEventValueFieldWidth = 16,/* Knob Events*/	kKnobEventValueHighFieldPos	= 0,							/* 1st long word */	kKnobEventValueHighFieldWidth = 16,	kKnobEventKnobFieldPos		= 16,							/* 2nd long word */	kKnobEventKnobFieldWidth	= 14,	kKnobEventValueLowFieldPos	= 0,							/* 2nd long word */	kKnobEventValueLowFieldWidth = 16,/* Marker Events*/	kMarkerEventSubtypeFieldPos	= 16,	kMarkerEventSubtypeFieldWidth = 8,	kMarkerEventValueFieldPos	= 0,	kMarkerEventValueFieldWidth	= 16,/* General Events*/	kGeneralEventSubtypeFieldPos = 16,							/* in the last long word */	kGeneralEventSubtypeFieldWidth = 14,	kGeneralEventLengthFieldPos	= 0,							/* in the 1st & last long words */	kGeneralEventLengthFieldWidth = 16};#define MASK(bitWidth) ((1 << (bitWidth)) - 1)#define EXT(val, pos, width) (((val) >> (pos)) & MASK(width))#define _EventLength(x) ((EXT(x, kEventLengthFieldPos,  \	kEventLengthFieldWidth) < 2) ? 1 :  \	((EXT(x, kEventLengthFieldPos, kEventLengthFieldWidth) == 2) ? 2 :  \	EXT(x, kGeneralEventLengthFieldPos, kGeneralEventLengthFieldWidth)))#define _EventType(x) ((EXT(x, kEventTypeFieldPos, kEventTypeFieldWidth) > 3) ? EXT(x, kXEventTypeFieldPos, kXEventTypeFieldWidth) : EXT(x, kEventTypeFieldPos, kEventTypeFieldWidth))#define _RestDuration(x) (EXT(x, kRestEventDurationFieldPos, kRestEventDurationFieldWidth))#define _Instrument(x) (EXT(x, kEventInstrumentFieldPos, kEventInstrumentFieldWidth))#define _XInstrument(m, l) (EXT(m, kXEventInstrumentFieldPos, kXEventInstrumentFieldWidth))#define _NotePitch(x) (EXT(x, kNoteEventPitchFieldPos, kNoteEventPitchFieldWidth) + kNoteEventPitchOffset)#define _NoteVolume(x) (EXT(x, kNoteEventVolumeFieldPos, kNoteEventVolumeFieldWidth) + kNoteEventVolumeOffset)#define _NoteDuration(x) (EXT(x, kNoteEventDurationFieldPos, kNoteEventDurationFieldWidth))#define _NoteVelocity _NoteVolume#define _XNotePitch(m, l) (EXT(m, kXNoteEventPitchFieldPos, kXNoteEventPitchFieldWidth))#define _XNoteVolume(m, l) (EXT(l, kXNoteEventVolumeFieldPos, kXNoteEventVolumeFieldWidth))#define _XNoteDuration(m, l) (EXT(l, kXNoteEventDurationFieldPos, kXNoteEventDurationFieldWidth))#define _XNoteVelocity _XNoteVolume#define _ControlController(x) (EXT(x, kControlEventControllerFieldPos, kControlEventControllerFieldWidth))#define _ControlValue(x) (EXT(x, kControlEventValueFieldPos, kControlEventValueFieldWidth))#define _XControlController(m, l) (EXT(m, kXControlEventControllerFieldPos, kXControlEventControllerFieldWidth))#define _XControlValue(m, l) (EXT(m, kXControlEventValueFieldPos, kXControlEventValueFieldWidth))#define _MarkerSubtype(x) (EXT(x,kMarkerEventSubtypeFieldPos,kMarkerEventSubtypeFieldWidth))#define _MarkerValue(x) (EXT(x, kMarkerEventValueFieldPos, kMarkerEventValueFieldWidth))#define _KnobValue(m, l) ((EXT(m,kKnobEventValueHighFieldPos,kKnobEventValueHighFieldWidth) << 16)	 \	| (EXT(l,kKnobEventValueLowFieldPos,kKnobEventValueLowFieldWidth)))#define _KnobKnob(m, l) (EXT(l,kKnobEventKnobFieldPos,kKnobEventKnobFieldWidth))#define _GeneralSubtype(m, l) (EXT(l,kGeneralEventSubtypeFieldPos,kGeneralEventSubtypeFieldWidth))#define _GeneralLength(m, l) (EXT(m,kGeneralEventLengthFieldPos,kGeneralEventLengthFieldWidth))#define _StuffRestEvent(x, duration)  \	x = (kRestEventType << kEventTypeFieldPos)	 \	|	((long)(duration) << kRestEventDurationFieldPos)#define _StuffNoteEvent(x, instrument, pitch, volume, duration)  \	x = (kNoteEventType << kEventTypeFieldPos)	 \	| ((long)(instrument) << kEventInstrumentFieldPos)	 \	|	(((long)(pitch) - kNoteEventPitchOffset) << kNoteEventPitchFieldPos)	 \	|	(((long)(volume) - kNoteEventVolumeOffset) << kNoteEventVolumeFieldPos)	 \	|	((long)(duration) << kNoteEventDurationFieldPos)#define _StuffControlEvent(x, instrument, control, value)  \	x = (kControlEventType << kEventTypeFieldPos)	 \	| ((long)(instrument) << kEventInstrumentFieldPos)	 \	|	((long)(control) << kControlEventControllerFieldPos)	 \	|	((long)((value) & MASK(kControlEventValueFieldWidth)) << kControlEventValueFieldPos)#define _StuffXNoteEvent(w1, w2, instrument, pitch, volume, duration)  \	w1 = (kXNoteEventType << kXEventTypeFieldPos)	 \	|	((long)(instrument) << kXEventInstrumentFieldPos)	 \	|	((long)(pitch) << kXNoteEventPitchFieldPos),	 \	w2 =	(kXEventLengthBits << kEventLengthFieldPos)	 \	|	((long)(duration) << kXNoteEventDurationFieldPos)	 \	|	((long)(volume) << kXNoteEventVolumeFieldPos)	#define _StuffXControlEvent(w1, w2, instrument, control, value)  \	w1 = (kXControlEventType << kXEventTypeFieldPos)	 \	|	((long)(instrument) << kXEventInstrumentFieldPos)	 \	|	((long)((value) & MASK(kXControlEventValueFieldWidth)) << kXControlEventValueFieldPos),  \	w2 =	(kXEventLengthBits << kEventLengthFieldPos)	 \	|	((long)(control) << kXControlEventControllerFieldPos)#define _StuffKnobEvent(w1, w2, instrument, knob, value)  \	w1 =	(kKnobEventType << kXEventTypeFieldPos)	 \	|	((long)(instrument) << kXEventInstrumentFieldPos)	 \	|	((long)(value >> 16) << kKnobEventValueLowFieldPos),	 \	w2 =	(kXEventLengthBits << kEventLengthFieldPos)	 \	|	((long)(knob) << kKnobEventKnobFieldPos)	 \	|	((long)(value & 0xFFFF) << kKnobEventValueLowFieldPos)#define _StuffGeneralEvent(w1, w2, instrument, subType, length)  \	w1 =	(kGeneralEventType << kXEventTypeFieldPos)	 \	|	((long)(instrument) << kXEventInstrumentFieldPos)	 \	|	((long)(length) << kGeneralEventLengthFieldPos),	 \	w2 =	(kGeneralEventLengthBits << kEventLengthFieldPos)	 \	|	((long)(subType) << kGeneralEventSubtypeFieldPos)	 \	|	((long)(length) << kGeneralEventLengthFieldPos)enum {	kGeneralEventNoteRequest	= 1,							/* Encapsulates NoteRequest data structure */	kGeneralEventInstrument		= 2,							/* Encapsulates poly, typical poly, followed by InstrumentData record */	kGeneralEventFlatInstrument	= 3,							/* Encapsulates poly, typical poly, followed by FlatInstrument record */	kGeneralEventPartName		= 4,							/* Brackets 2 longs follwed by a pascal string (padded to long alignment) */	kGeneralEventPartKey		= 5								/* Brackets 2 longs */};enum {	TCSourceRefNameType			= 'name'};enum {	tcDropFrame					= 1 << 0,	tc24HourMax					= 1 << 1,	tcNegTimesOK				= 1 << 2,	tcCounter					= 1 << 3};struct TimeCodeDef {	long							flags;						/* drop-frame, etc.*/	TimeScale						fTimeScale;					/* time scale of frameDuration (eg. 2997)*/	TimeValue						frameDuration;				/* duration of each frame (eg. 100)*/	UInt8							numFrames;					/* number of frames per second for timecode (eg. 30)*//* number of frames per tick for counter mode*/	UInt8							padding;					/* unused padding byte */};typedef struct TimeCodeDef TimeCodeDef;enum {	tctNegFlag					= 0x80							/* negative bit is in minutes*/};struct TimeCodeTime {	UInt8							hours;	UInt8							minutes;	UInt8							seconds;	UInt8							frames;};typedef struct TimeCodeTime TimeCodeTime;struct TimeCodeCounter {	long							counter;};typedef struct TimeCodeCounter TimeCodeCounter;union TimeCodeRecord {	TimeCodeTime					t;	TimeCodeCounter					c;};typedef union TimeCodeRecord TimeCodeRecord;struct TimeCodeDescription {/* standard sample description header*/	long							descSize;	long							dataFormat;	long							resvd1;	short							resvd2;	short							dataRefIndex;/* timecode specific stuff*/	long							flags;	TimeCodeDef						timeCodeDef;	long							srcRef[1];};typedef struct TimeCodeDescription TimeCodeDescription;typedef TimeCodeDescription *TimeCodeDescriptionPtr;typedef TimeCodeDescriptionPtr *TimeCodeDescriptionHandle;enum {	tcdfShowTimeCode			= 1 << 0};enum {	kTCGetCurrentTimeCodeSelect	= 257,	kTCGetTimeCodeAtTimeSelect,	kTCTimeCodeToStringSelect,	kTCTimeCodeToFrameNumberSelect,	kTCFrameNumberToTimeCodeSelect,	kTCGetSourceRefSelect,	kTCSetSourceRefSelect,	kTCSetTimeCodeFlagsSelect,	kTCGetTimeCodeFlagsSelect,	kTCSetDisplayOptionsSelect,	kTCGetDisplayOptionsSelect};struct TCTextOptions {	short							txFont;	short							txFace;	short							txSize;	RGBColor						foreColor;	RGBColor						backColor;};typedef struct TCTextOptions TCTextOptions;typedef TCTextOptions *TCTextOptionsPtr;extern pascal HandlerError TCGetCurrentTimeCode(MediaHandler mh, long *frameNum, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, UserData *srcRefH) FIVEWORDINLINE(0x2F3C, 0x10, 0x101, 0x7000, 0xA82A);extern pascal HandlerError TCGetTimeCodeAtTime(MediaHandler mh, TimeValue mediaTime, long *frameNum, TimeCodeDef *tcdef, TimeCodeRecord *tcdata, UserData *srcRefH) FIVEWORDINLINE(0x2F3C, 0x14, 0x102, 0x7000, 0xA82A);extern pascal HandlerError TCTimeCodeToFrameNumber(MediaHandler mh, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, long *frameNumber) FIVEWORDINLINE(0x2F3C, 0xC, 0x104, 0x7000, 0xA82A);extern pascal HandlerError TCFrameNumberToTimeCode(MediaHandler mh, long frameNumber, TimeCodeDef *tcdef, TimeCodeRecord *tcrec) FIVEWORDINLINE(0x2F3C, 0xC, 0x105, 0x7000, 0xA82A);extern pascal HandlerError TCTimeCodeToString(MediaHandler mh, TimeCodeDef *tcdef, TimeCodeRecord *tcrec, StringPtr tcStr) FIVEWORDINLINE(0x2F3C, 0xC, 0x103, 0x7000, 0xA82A);extern pascal HandlerError TCGetSourceRef(MediaHandler mh, TimeCodeDescriptionHandle tcdH, UserData *srefH) FIVEWORDINLINE(0x2F3C, 0x8, 0x106, 0x7000, 0xA82A);extern pascal HandlerError TCSetSourceRef(MediaHandler mh, TimeCodeDescriptionHandle tcdH, UserData srefH) FIVEWORDINLINE(0x2F3C, 0x8, 0x107, 0x7000, 0xA82A);extern pascal HandlerError TCSetTimeCodeFlags(MediaHandler mh, long flags, long flagsMask) FIVEWORDINLINE(0x2F3C, 0x8, 0x108, 0x7000, 0xA82A);extern pascal HandlerError TCGetTimeCodeFlags(MediaHandler mh, long *flags) FIVEWORDINLINE(0x2F3C, 0x4, 0x109, 0x7000, 0xA82A);extern pascal HandlerError TCSetDisplayOptions(MediaHandler mh, TCTextOptionsPtr textOptions) FIVEWORDINLINE(0x2F3C, 0x4, 0x10A, 0x7000, 0xA82A);extern pascal HandlerError TCGetDisplayOptions(MediaHandler mh, TCTextOptionsPtr textOptions) FIVEWORDINLINE(0x2F3C, 0x4, 0x10B, 0x7000, 0xA82A);/* UPP call backs */#if GENERATINGCFM#else#endifenum {	uppSGDataProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SGChannel)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long*)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(TimeValue)))		 | STACK_ROUTINE_PARAMETER(7, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(8, SIZE_CODE(sizeof(long))),	uppSGModalFilterProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(DialogPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(EventRecord*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(short*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long))),	uppSGGrabProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SGChannel)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),	uppSGGrabCompleteProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SGChannel)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Boolean*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long))),	uppSGDisplayProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SGChannel)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(MatrixRecord*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(RgnHandle)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(long))),	uppSGCompressProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SGChannel)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long))),	uppSGCompressCompleteProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SGChannel)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Boolean*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(SGCompressInfo*)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(long))),	uppSGAddFrameProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SGChannel)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(TimeValue)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(TimeScale)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(SGCompressInfo*)))		 | STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(long))),	uppSGTransferFrameProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SGChannel)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(MatrixRecord*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(RgnHandle)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(long))),	uppSGGrabCompressCompleteProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SGChannel)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Boolean*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(SGCompressInfo*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(TimeRecord*)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(long))),	uppSGDisplayCompressProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SGChannel)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(ImageDescriptionHandle)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(MatrixRecord*)))		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(RgnHandle)))		 | STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(long))),	uppVdigIntProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long))),	uppSCModalFilterProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(DialogPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(EventRecord*)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(short*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long))),	uppSCModalHookProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(DialogPtr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(void*)))		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long))),	uppDataHCompletionProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Ptr)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(OSErr))),	uppMusicMIDISendProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(MusicComponent)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(MusicMIDIPacket*))),	uppMusicMIDIReadHookProcInfo = kPascalStackBased		 | RESULT_SIZE(SIZE_CODE(sizeof(ComponentResult)))		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(MusicMIDIPacket*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long))),	uppTuneCallBackProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(TuneStatus*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long))),	uppTunePlayCallBackProcInfo = kPascalStackBased		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(unsigned long*)))		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long)))		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long)))};#if GENERATINGCFM#define NewSGDataProc(userRoutine)		\		(SGDataUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGDataProcInfo, GetCurrentArchitecture())#define NewSGModalFilterProc(userRoutine)		\		(SGModalFilterUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGModalFilterProcInfo, GetCurrentArchitecture())#define NewSGGrabProc(userRoutine)		\		(SGGrabUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGGrabProcInfo, GetCurrentArchitecture())#define NewSGGrabCompleteProc(userRoutine)		\		(SGGrabCompleteUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGGrabCompleteProcInfo, GetCurrentArchitecture())#define NewSGDisplayProc(userRoutine)		\		(SGDisplayUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGDisplayProcInfo, GetCurrentArchitecture())#define NewSGCompressProc(userRoutine)		\		(SGCompressUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGCompressProcInfo, GetCurrentArchitecture())#define NewSGCompressCompleteProc(userRoutine)		\		(SGCompressCompleteUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGCompressCompleteProcInfo, GetCurrentArchitecture())#define NewSGAddFrameProc(userRoutine)		\		(SGAddFrameUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGAddFrameProcInfo, GetCurrentArchitecture())#define NewSGTransferFrameProc(userRoutine)		\		(SGTransferFrameUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGTransferFrameProcInfo, GetCurrentArchitecture())#define NewSGGrabCompressCompleteProc(userRoutine)		\		(SGGrabCompressCompleteUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGGrabCompressCompleteProcInfo, GetCurrentArchitecture())#define NewSGDisplayCompressProc(userRoutine)		\		(SGDisplayCompressUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSGDisplayCompressProcInfo, GetCurrentArchitecture())#define NewVdigIntProc(userRoutine)		\		(VdigIntUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppVdigIntProcInfo, GetCurrentArchitecture())#define NewSCModalFilterProc(userRoutine)		\		(SCModalFilterUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSCModalFilterProcInfo, GetCurrentArchitecture())#define NewSCModalHookProc(userRoutine)		\		(SCModalHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSCModalHookProcInfo, GetCurrentArchitecture())#define NewDataHCompletionProc(userRoutine)		\		(DataHCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppDataHCompletionProcInfo, GetCurrentArchitecture())#define NewMusicMIDISendProc(userRoutine)		\		(MusicMIDISendUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppMusicMIDISendProcInfo, GetCurrentArchitecture())#define NewMusicMIDIReadHookProc(userRoutine)		\		(MusicMIDIReadHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppMusicMIDIReadHookProcInfo, GetCurrentArchitecture())#define NewTuneCallBackProc(userRoutine)		\		(TuneCallBackUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTuneCallBackProcInfo, GetCurrentArchitecture())#define NewTunePlayCallBackProc(userRoutine)		\		(TunePlayCallBackUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTunePlayCallBackProcInfo, GetCurrentArchitecture())#else#define NewSGDataProc(userRoutine)		\		((SGDataUPP) (userRoutine))#define NewSGModalFilterProc(userRoutine)		\		((SGModalFilterUPP) (userRoutine))#define NewSGGrabProc(userRoutine)		\		((SGGrabUPP) (userRoutine))#define NewSGGrabCompleteProc(userRoutine)		\		((SGGrabCompleteUPP) (userRoutine))#define NewSGDisplayProc(userRoutine)		\		((SGDisplayUPP) (userRoutine))#define NewSGCompressProc(userRoutine)		\		((SGCompressUPP) (userRoutine))#define NewSGCompressCompleteProc(userRoutine)		\		((SGCompressCompleteUPP) (userRoutine))#define NewSGAddFrameProc(userRoutine)		\		((SGAddFrameUPP) (userRoutine))#define NewSGTransferFrameProc(userRoutine)		\		((SGTransferFrameUPP) (userRoutine))#define NewSGGrabCompressCompleteProc(userRoutine)		\		((SGGrabCompressCompleteUPP) (userRoutine))#define NewSGDisplayCompressProc(userRoutine)		\		((SGDisplayCompressUPP) (userRoutine))#define NewVdigIntProc(userRoutine)		\		((VdigIntUPP) (userRoutine))#define NewSCModalFilterProc(userRoutine)		\		((SCModalFilterUPP) (userRoutine))#define NewSCModalHookProc(userRoutine)		\		((SCModalHookUPP) (userRoutine))#define NewDataHCompletionProc(userRoutine)		\		((DataHCompletionUPP) (userRoutine))#define NewMusicMIDISendProc(userRoutine)		\		((MusicMIDISendUPP) (userRoutine))#define NewMusicMIDIReadHookProc(userRoutine)		\		((MusicMIDIReadHookUPP) (userRoutine))#define NewTuneCallBackProc(userRoutine)		\		((TuneCallBackUPP) (userRoutine))#define NewTunePlayCallBackProc(userRoutine)		\		((TunePlayCallBackUPP) (userRoutine))#endif#if GENERATINGCFM#define CallSGDataProc(userRoutine, c, p, len, offset, chRefCon, time, writeType, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGDataProcInfo, (c), (p), (len), (offset), (chRefCon), (time), (writeType), (refCon))#define CallSGModalFilterProc(userRoutine, theDialog, theEvent, itemHit, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGModalFilterProcInfo, (theDialog), (theEvent), (itemHit), (refCon))#define CallSGGrabProc(userRoutine, c, bufferNum, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGGrabProcInfo, (c), (bufferNum), (refCon))#define CallSGGrabCompleteProc(userRoutine, c, bufferNum, done, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGGrabCompleteProcInfo, (c), (bufferNum), (done), (refCon))#define CallSGDisplayProc(userRoutine, c, bufferNum, mp, clipRgn, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGDisplayProcInfo, (c), (bufferNum), (mp), (clipRgn), (refCon))#define CallSGCompressProc(userRoutine, c, bufferNum, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGCompressProcInfo, (c), (bufferNum), (refCon))#define CallSGCompressCompleteProc(userRoutine, c, bufferNum, done, ci, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGCompressCompleteProcInfo, (c), (bufferNum), (done), (ci), (refCon))#define CallSGAddFrameProc(userRoutine, c, bufferNum, atTime, scale, ci, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGAddFrameProcInfo, (c), (bufferNum), (atTime), (scale), (ci), (refCon))#define CallSGTransferFrameProc(userRoutine, c, bufferNum, mp, clipRgn, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGTransferFrameProcInfo, (c), (bufferNum), (mp), (clipRgn), (refCon))#define CallSGGrabCompressCompleteProc(userRoutine, c, done, ci, t, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGGrabCompressCompleteProcInfo, (c), (done), (ci), (t), (refCon))#define CallSGDisplayCompressProc(userRoutine, c, dataPtr, desc, mp, clipRgn, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSGDisplayCompressProcInfo, (c), (dataPtr), (desc), (mp), (clipRgn), (refCon))#define CallVdigIntProc(userRoutine, flags, refcon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppVdigIntProcInfo, (flags), (refcon))#define CallSCModalFilterProc(userRoutine, theDialog, theEvent, itemHit, refcon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSCModalFilterProcInfo, (theDialog), (theEvent), (itemHit), (refcon))#define CallSCModalHookProc(userRoutine, theDialog, itemHit, params, refcon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSCModalHookProcInfo, (theDialog), (itemHit), (params), (refcon))#define CallDataHCompletionProc(userRoutine, request, refcon, err)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppDataHCompletionProcInfo, (request), (refcon), (err))#define CallMusicMIDISendProc(userRoutine, self, refCon, mmp)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppMusicMIDISendProcInfo, (self), (refCon), (mmp))#define CallMusicMIDIReadHookProc(userRoutine, mp, myRefCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppMusicMIDIReadHookProcInfo, (mp), (myRefCon))#define CallTuneCallBackProc(userRoutine, status, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppTuneCallBackProcInfo, (status), (refCon))#define CallTunePlayCallBackProc(userRoutine, event, seed, refCon)		\		CallUniversalProc((UniversalProcPtr)(userRoutine), uppTunePlayCallBackProcInfo, (event), (seed), (refCon))#else#define CallSGDataProc(userRoutine, c, p, len, offset, chRefCon, time, writeType, refCon)		\		(*(userRoutine))((c), (p), (len), (offset), (chRefCon), (time), (writeType), (refCon))#define CallSGModalFilterProc(userRoutine, theDialog, theEvent, itemHit, refCon)		\		(*(userRoutine))((theDialog), (theEvent), (itemHit), (refCon))#define CallSGGrabProc(userRoutine, c, bufferNum, refCon)		\		(*(userRoutine))((c), (bufferNum), (refCon))#define CallSGGrabCompleteProc(userRoutine, c, bufferNum, done, refCon)		\		(*(userRoutine))((c), (bufferNum), (done), (refCon))#define CallSGDisplayProc(userRoutine, c, bufferNum, mp, clipRgn, refCon)		\		(*(userRoutine))((c), (bufferNum), (mp), (clipRgn), (refCon))#define CallSGCompressProc(userRoutine, c, bufferNum, refCon)		\		(*(userRoutine))((c), (bufferNum), (refCon))#define CallSGCompressCompleteProc(userRoutine, c, bufferNum, done, ci, refCon)		\		(*(userRoutine))((c), (bufferNum), (done), (ci), (refCon))#define CallSGAddFrameProc(userRoutine, c, bufferNum, atTime, scale, ci, refCon)		\		(*(userRoutine))((c), (bufferNum), (atTime), (scale), (ci), (refCon))#define CallSGTransferFrameProc(userRoutine, c, bufferNum, mp, clipRgn, refCon)		\		(*(userRoutine))((c), (bufferNum), (mp), (clipRgn), (refCon))#define CallSGGrabCompressCompleteProc(userRoutine, c, done, ci, t, refCon)		\		(*(userRoutine))((c), (done), (ci), (t), (refCon))#define CallSGDisplayCompressProc(userRoutine, c, dataPtr, desc, mp, clipRgn, refCon)		\		(*(userRoutine))((c), (dataPtr), (desc), (mp), (clipRgn), (refCon))#define CallVdigIntProc(userRoutine, flags, refcon)		\		(*(userRoutine))((flags), (refcon))#define CallSCModalFilterProc(userRoutine, theDialog, theEvent, itemHit, refcon)		\		(*(userRoutine))((theDialog), (theEvent), (itemHit), (refcon))#define CallSCModalHookProc(userRoutine, theDialog, itemHit, params, refcon)		\		(*(userRoutine))((theDialog), (itemHit), (params), (refcon))#define CallDataHCompletionProc(userRoutine, request, refcon, err)		\		(*(userRoutine))((request), (refcon), (err))#define CallMusicMIDISendProc(userRoutine, self, refCon, mmp)		\		(*(userRoutine))((self), (refCon), (mmp))#define CallMusicMIDIReadHookProc(userRoutine, mp, myRefCon)		\		(*(userRoutine))((mp), (myRefCon))#define CallTuneCallBackProc(userRoutine, status, refCon)		\		(*(userRoutine))((status), (refCon))#define CallTunePlayCallBackProc(userRoutine, event, seed, refCon)		\		(*(userRoutine))((event), (seed), (refCon))#endif#ifdef __CFM68K__#pragma lib_export off#endif#if GENERATINGPOWERPC#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __QUICKTIMECOMPONENTS__ */