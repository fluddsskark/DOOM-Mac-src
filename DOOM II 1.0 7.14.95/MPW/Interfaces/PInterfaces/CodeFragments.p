{ 	File:		CodeFragments.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.1  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT CodeFragments; INTERFACE{$ENDC}{$IFC UNDEFINED __CODEFRAGMENTS__}{$SETC __CODEFRAGMENTS__ := 1}{$I+}{$SETC CodeFragmentsIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __TYPES__}{$I Types.p}{$ENDC}{	ConditionalMacros.p											}{$IFC UNDEFINED __FILES__}{$I Files.p}{$ENDC}{	MixedMode.p													}{	OSUtils.p													}{$IFC UNDEFINED __TRAPS__}{$I Traps.p}{$ENDC}{$PUSH}{$ALIGN MAC68K}{$LibExport+}	TYPEConnectionID = LONGINT;	LoadFlags = LONGINT;	SymClass = CHAR;CONST	kPowerPCArch				= 'pwpc';						{ use as the architecture type }	kMotorola68KArch			= 'm68k';						{ use as the architecture type }	kAnyArchType				= $3f3f3f3f;{ Confusing names, soon to be removed! }	kPowerPC					= 'pwpc';						{ use as the architecture type }	kMotorola68K				= 'm68k';						{ use as the architecture type }	kNoLibName					= 0;	kNoConnectionID				= 0;	kUnresolvedSymbolAddress	= 0;{ Constants used for findFlags mask }	kLoadLib					= 1;							{ use existing connection if possible }	kFindLib					= 2;							{ just see if library is already loaded }	kLoadNewCopy				= 5;							{ load a new instance no matter what }	kUseInPlace					= $80;							{ use container’s sections in place }	kCodeSym					= 0;	kDataSym					= 1;	kTVectSym					= 2;	kTOCSym						= 3;	kGlueSym					= 4;{	Constants for the FragmentLocator field .where (other values for this enum exist) }	kInMem						= 0;	kOnDiskFlat					= 1;	kOnDiskSegmented			= 2;	kIsLib						= 0;	kIsApp						= 1;	kIsDropIn					= 2;{	Constants for the 'cfrg' field .updateLevel }	kFullLib					= 0;	kUpdateLib					= 1;{ For fragment initialization routines }TYPE	MemFragment = RECORD		address:				Ptr;		length:					LONGINT;		inPlace:				BOOLEAN;		spare3a:				ARRAY [0..2] OF CHAR;	END;	DiskFragment = RECORD		fileSpec:				FSSpecPtr;								{ Must correspond to FSSpecPtr in segmented case }		offset:					LONGINT;		length:					LONGINT;	END;	SegmentedFragment = RECORD		fileSpec:				FSSpecPtr;								{ Must correspond to FSSpecPtr in data fork case }		rsrcType:				OSType;		rsrcID:					INTEGER;	END;{ Note that the onDisk and inSegs members are required to have an FSSpecPtr field at the same location.  CFM code uses just one member to access the information for either case }	FragmentLocator = RECORD		where:					LONGINT;		CASE INTEGER OF		0: (			inMem:						MemFragment;		   );		1: (			onDisk:						DiskFragment;		   );		2: (			inSegs:						SegmentedFragment;		   );	END;	FragmentLocatorPtr = ^FragmentLocator;{ NOTE: when fragLocator. where == kOnDisk, then       fragLocator. u. onDisk. fileSpec is a pointer       to the file that the library belonged to.       the pointer is valid only for the duration       of the init routine's invocation, so make       a copy of the filespec if it is important }	InitBlock = RECORD		contextID:				LONGINT;		closureID:				LONGINT;		connectionID:			LONGINT;		fragLocator:			FragmentLocator;		libName:				Ptr;		reserved4a:				LONGINT;		reserved4b:				LONGINT;		reserved4c:				LONGINT;		reserved4d:				LONGINT;	END;	InitBlockPtr = ^InitBlock;{ Prototype for initialization routines.  Note that these are C, not Pascal conventions! This differs from customary “Apple-callback” useage, but is felt to be less error prone in practice since the vast bulk of 68K CFM aware code will be in C. NOTE: Initialization routines may comfortably ignore their parameters, however, they must return an error status (ie: noErr) in order to succeed with the load of the library. Termination routines get no parameters and have no return value. }	ConnectionInitializationRoutine = ProcPtr;  { FUNCTION (initBlkPtr: InitBlockPtr): OSErr; }	ConnectionTerminationRoutine = ProcPtr;  { PROCEDURE ; }{ Constants used in building shared libraries }CONST	kCFMRsrcType				= 'cfrg';	kCFMRsrcID					= 0;	kSHLBFileType				= 'shlb';{$IFC UNDEFINED TurnOff68KCFMTraps }{$SETC TurnOff68KCFMTraps := 0}{$ENDC}{$IFC TurnOff68KCFMTraps }FUNCTION GetSharedLibrary(VAR libName: Str63; archType: OSType; findFlags: LoadFlags; VAR connID: ConnectionID; VAR mainAddr: Ptr; VAR errName: Str255): OSErr;FUNCTION GetDiskFragment(fileSpec: FSSpec; offset: LONGINT; length: LONGINT; VAR fragName: Str63; findFlags: LoadFlags; VAR connID: ConnectionID; VAR mainAddr: Ptr; VAR errName: Str255): OSErr;FUNCTION GetMemFragment(memAddr: UNIV Ptr; length: LONGINT; VAR fragName: Str63; findFlags: LoadFlags; VAR connID: ConnectionID; VAR mainAddr: Ptr; VAR errName: Str255): OSErr;FUNCTION CloseConnection(VAR connID: ConnectionID): OSErr;FUNCTION FindSymbol(connID: ConnectionID; VAR symName: Str255; VAR symAddr: Ptr; VAR symClass: SymClass): OSErr;FUNCTION CountSymbols(connID: ConnectionID; VAR symCount: LONGINT): OSErr;FUNCTION GetIndSymbol(connID: ConnectionID; symIndex: LONGINT; VAR symName: Str255; VAR symAddr: Ptr; VAR symClass: SymClass): OSErr;{$ELSEC}FUNCTION GetSharedLibrary(VAR libName: Str63; archType: OSType; findFlags: LoadFlags; VAR connID: ConnectionID; VAR mainAddr: Ptr; VAR errName: Str255): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $3F3C, 1, $AA5A;	{$ENDC}FUNCTION GetDiskFragment(fileSpec: FSSpec; offset: LONGINT; length: LONGINT; VAR fragName: Str63; findFlags: LoadFlags; VAR connID: ConnectionID; VAR mainAddr: Ptr; VAR errName: Str255): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $3F3C, 2, $AA5A;	{$ENDC}FUNCTION GetMemFragment(memAddr: UNIV Ptr; length: LONGINT; VAR fragName: Str63; findFlags: LoadFlags; VAR connID: ConnectionID; VAR mainAddr: Ptr; VAR errName: Str255): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $3F3C, 3, $AA5A;	{$ENDC}FUNCTION CloseConnection(VAR connID: ConnectionID): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $3F3C, 4, $AA5A;	{$ENDC}FUNCTION FindSymbol(connID: ConnectionID; VAR symName: Str255; VAR symAddr: Ptr; VAR symClass: SymClass): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $3F3C, 5, $AA5A;	{$ENDC}FUNCTION CountSymbols(connID: ConnectionID; VAR symCount: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $3F3C, 6, $AA5A;	{$ENDC}FUNCTION GetIndSymbol(connID: ConnectionID; symIndex: LONGINT; VAR symName: Str255; VAR symAddr: Ptr; VAR symClass: SymClass): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $3F3C, 7, $AA5A;	{$ENDC}{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := CodeFragmentsIncludes}{$ENDC} {__CODEFRAGMENTS__}{$IFC NOT UsingIncludes} END.{$ENDC}