{ 	File:		Controls.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT Controls; INTERFACE{$ENDC}{$IFC UNDEFINED __CONTROLS__}{$SETC __CONTROLS__ := 1}{$I+}{$SETC ControlsIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __TYPES__}{$I Types.p}{$ENDC}{	ConditionalMacros.p											}{$IFC UNDEFINED __QUICKDRAW__}{$I Quickdraw.p}{$ENDC}{	MixedMode.p													}{	QuickdrawText.p												}{$IFC UNDEFINED __MENUS__}{$I Menus.p}{$ENDC}{	Memory.p													}{$PUSH}{$ALIGN MAC68K}{$LibExport+}CONST	pushButProc					= 0;	checkBoxProc				= 1;	radioButProc				= 2;	useWFont					= 8;	scrollBarProc				= 16;	popupMenuProc				= 1008;							{ 63 * 16 }	inLabel						= 1;	inMenu						= 2;	inTriangle					= 4;	TYPEControlPartCode = UInt8;CONST	kNoHiliteControlPart		= 0;	kInButtonControlPart		= 10;	kInCheckBoxControlPart		= 11;	kInUpButtonControlPart		= 20;	kInDownButtonControlPart	= 21;	kInPageUpControlPart		= 22;	kInPageDownControlPart		= 23;	kInIndicatorControlPart		= 129;	kReservedControlPart		= 254;	kControlInactiveControlPart	= 255;	inButton					= 10;	inCheckBox					= 11;	inUpButton					= 20;	inDownButton				= 21;	inPageUp					= 22;	inPageDown					= 23;	inThumb						= 129;	popupFixedWidth				= 1 * (2**(0));	popupVariableWidth			= 1 * (2**(1));	popupUseAddResMenu			= 1 * (2**(2));	popupUseWFont				= 1 * (2**(3));	popupTitleBold				= 1 * (2**(8));	popupTitleItalic			= 1 * (2**(9));	popupTitleUnderline			= 1 * (2**(10));	popupTitleOutline			= 1 * (2**(11));	popupTitleShadow			= 1 * (2**(12));	popupTitleCondense			= 1 * (2**(13));	popupTitleExtend			= 1 * (2**(14));	popupTitleNoStyle			= 1 * (2**(15));	popupTitleLeftJust			= $00000000;	popupTitleCenterJust		= $00000001;	popupTitleRightJust			= $000000FF;{axis constraints for DragGrayRgn call}	noConstraint				= kNoConstraint;	hAxisOnly					= 1;	vAxisOnly					= 2;	TYPEControlDefProcMessage = SInt16;CONST	drawCntl					= 0;	testCntl					= 1;	calcCRgns					= 2;	initCntl					= 3;	dispCntl					= 4;	posCntl						= 5;	thumbCntl					= 6;	dragCntl					= 7;	autoTrack					= 8;	calcCntlRgn					= 10;	calcThumbRgn				= 11;	drawThumbOutline			= 12;	cFrameColor					= 0;	cBodyColor					= 1;	cTextColor					= 2;	cThumbColor					= 3;{	Set STRICT_CONTROLS to 1 to make sure your code 	doesn't access the control records directly}{$IFC UNDEFINED STRICT_CONTROLS }{$SETC STRICT_CONTROLS := 0}{$ENDC}{$IFC STRICT_CONTROLS }	TYPEControlRef = Ptr;	ControlHandle = ControlRef;{$ELSEC}	TYPEControlPtr = ^ControlRecord;	ControlHandle = ^ControlPtr;	ControlRef = ControlHandle;{$ENDC}	ControlDefProcPtr = ProcPtr;  { FUNCTION ControlDef(varCode: INTEGER; theControl: ControlRef; message: INTEGER; param: LONGINT): LONGINT; }	ControlActionProcPtr = ProcPtr;  { PROCEDURE ControlAction(theControl: ControlRef; partCode: INTEGER); }	ControlDefUPP = UniversalProcPtr;	ControlActionUPP = UniversalProcPtr;{$IFC NOT STRICT_CONTROLS }	ControlRecord = PACKED RECORD		nextControl:			ControlRef;		contrlOwner:			WindowRef;		contrlRect:				Rect;		contrlVis:				UInt8;		contrlHilite:			UInt8;		contrlValue:			INTEGER;		contrlMin:				INTEGER;		contrlMax:				INTEGER;		contrlDefProc:			Handle;		contrlData:				Handle;		contrlAction:			ControlActionUPP;		contrlRfCon:			LONGINT;		contrlTitle:			Str255;	END;{$ENDC}	PopupPrivateData = RECORD		mHandle:				MenuHandle;								{popup menu handle}		mID:					INTEGER;								{popup menu ID}	END;	PopupPrivateDataPtr = ^PopupPrivateData;	PopupPrivateDataHandle = ^PopupPrivateDataPtr;	CtlCTab = RECORD		ccSeed:					LONGINT;								{reserved}		ccRider:				INTEGER;								{see what you have done - reserved}		ctSize:					INTEGER;								{usually 3 for controls}		ctTable:				ARRAY [0..3] OF ColorSpec;	END;	CCTabPtr = ^CtlCTab;	CCTabHandle = ^CCTabPtr;{$IFC NOT STRICT_CONTROLS }	AuxCtlRec = RECORD		acNext:					Handle;		acOwner:				ControlRef;		acCTable:				CCTabHandle;		acFlags:				INTEGER;		acReserved:				LONGINT;		acRefCon:				LONGINT;	END;	AuxCtlPtr = ^AuxCtlRec;	AuxCtlHandle = ^AuxCtlPtr;{$ENDC}CONST	uppControlDefProcInfo = $00003BB0; { FUNCTION (2 byte param, 4 byte param, 2 byte param, 4 byte param): 4 byte result; }	uppControlActionProcInfo = $000002C0; { PROCEDURE (4 byte param, 2 byte param); }FUNCTION NewControlDefProc(userRoutine: ControlDefProcPtr): ControlDefUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewControlActionProc(userRoutine: ControlActionProcPtr): ControlActionUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION CallControlDefProc(varCode: INTEGER; theControl: ControlRef; message: INTEGER; param: LONGINT; userRoutine: ControlDefUPP): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}PROCEDURE CallControlActionProc(theControl: ControlRef; partCode: INTEGER; userRoutine: ControlActionUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION NewControl(theWindow: WindowRef; boundsRect: Rect; title: ConstStr255Param; visible: BOOLEAN; value: INTEGER; min: INTEGER; max: INTEGER; procID: INTEGER; refCon: LONGINT): ControlRef;	{$IFC NOT GENERATINGCFM}	INLINE $A954;	{$ENDC}PROCEDURE SetControlTitle(theControl: ControlRef; title: ConstStr255Param);	{$IFC NOT GENERATINGCFM}	INLINE $A95F;	{$ENDC}PROCEDURE GetControlTitle(theControl: ControlRef; VAR title: Str255);	{$IFC NOT GENERATINGCFM}	INLINE $A95E;	{$ENDC}FUNCTION GetNewControl(controlID: INTEGER; owner: WindowRef): ControlRef;	{$IFC NOT GENERATINGCFM}	INLINE $A9BE;	{$ENDC}PROCEDURE DisposeControl(theControl: ControlRef);	{$IFC NOT GENERATINGCFM}	INLINE $A955;	{$ENDC}PROCEDURE KillControls(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A956;	{$ENDC}PROCEDURE HideControl(theControl: ControlRef);	{$IFC NOT GENERATINGCFM}	INLINE $A958;	{$ENDC}PROCEDURE ShowControl(theControl: ControlRef);	{$IFC NOT GENERATINGCFM}	INLINE $A957;	{$ENDC}PROCEDURE DrawControls(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A969;	{$ENDC}PROCEDURE Draw1Control(theControl: ControlRef);	{$IFC NOT GENERATINGCFM}	INLINE $A96D;	{$ENDC}PROCEDURE HiliteControl(theControl: ControlRef; hiliteState: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $A95D;	{$ENDC}PROCEDURE UpdateControls(theWindow: WindowRef; updateRgn: RgnHandle);	{$IFC NOT GENERATINGCFM}	INLINE $A953;	{$ENDC}PROCEDURE MoveControl(theControl: ControlRef; h: INTEGER; v: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $A959;	{$ENDC}PROCEDURE SizeControl(theControl: ControlRef; w: INTEGER; h: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $A95C;	{$ENDC}PROCEDURE SetControlValue(theControl: ControlRef; theValue: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $A963;	{$ENDC}FUNCTION GetControlValue(theControl: ControlRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A960;	{$ENDC}PROCEDURE SetControlMinimum(theControl: ControlRef; minValue: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $A964;	{$ENDC}FUNCTION GetControlMinimum(theControl: ControlRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A961;	{$ENDC}PROCEDURE SetControlMaximum(theControl: ControlRef; maxValue: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $A965;	{$ENDC}FUNCTION GetControlMaximum(theControl: ControlRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A962;	{$ENDC}{$IFC NOT STRICT_CONTROLS }FUNCTION GetAuxiliaryControlRecord(theControl: ControlRef; VAR acHndl: AuxCtlHandle): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $AA44;	{$ENDC}{$ENDC}PROCEDURE SetControlReference(theControl: ControlRef; data: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $A95B;	{$ENDC}FUNCTION GetControlReference(theControl: ControlRef): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $A95A;	{$ENDC}PROCEDURE SetControlAction(theControl: ControlRef; actionProc: ControlActionUPP);	{$IFC NOT GENERATINGCFM}	INLINE $A96B;	{$ENDC}FUNCTION GetControlAction(theControl: ControlRef): ControlActionUPP;	{$IFC NOT GENERATINGCFM}	INLINE $A96A;	{$ENDC}PROCEDURE DragControl(theControl: ControlRef; startPt: Point; limitRect: Rect; slopRect: Rect; axis: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $A967;	{$ENDC}FUNCTION TestControl(theControl: ControlRef; thePt: Point): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A966;	{$ENDC}FUNCTION FindControl(thePoint: Point; theWindow: WindowRef; VAR theControl: ControlRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A96C;	{$ENDC}PROCEDURE SetControlColor(theControl: ControlRef; newColorTable: CCTabHandle);	{$IFC NOT GENERATINGCFM}	INLINE $AA43;	{$ENDC}FUNCTION GetControlVariant(theControl: ControlRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A809;	{$ENDC}{	When using the TrackControl() call when tracking an indicator, the	actionProc parameter (type ControlActionUPP) should be replaced by	a parameter of type DragGrayRgnUPP (defined in Quickdraw.<header>).}FUNCTION TrackControl(theControl: ControlRef; thePoint: Point; actionProc: ControlActionUPP): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A968;	{$ENDC}{$IFC OLDROUTINENAMES }PROCEDURE SetCTitle(theControl: ControlRef; title: ConstStr255Param);	{$IFC NOT GENERATINGCFM}	INLINE $A95F;	{$ENDC}PROCEDURE GetCTitle(theControl: ControlRef; VAR title: Str255);	{$IFC NOT GENERATINGCFM}	INLINE $A95E;	{$ENDC}PROCEDURE UpdtControl(theWindow: WindowRef; updateRgn: RgnHandle);	{$IFC NOT GENERATINGCFM}	INLINE $A953;	{$ENDC}{$IFC NOT STRICT_CONTROLS }PROCEDURE SetCtlValue(theControl: ControlRef; theValue: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $A963;	{$ENDC}FUNCTION GetCtlValue(theControl: ControlRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A960;	{$ENDC}PROCEDURE SetCtlMin(theControl: ControlRef; minValue: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $A964;	{$ENDC}FUNCTION GetCtlMin(theControl: ControlRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A961;	{$ENDC}PROCEDURE SetCtlMax(theControl: ControlRef; maxValue: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $A965;	{$ENDC}FUNCTION GetCtlMax(theControl: ControlRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A962;	{$ENDC}{$ENDC}PROCEDURE SetCRefCon(theControl: ControlRef; data: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $A95B;	{$ENDC}FUNCTION GetCRefCon(theControl: ControlRef): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $A95A;	{$ENDC}PROCEDURE SetCtlAction(theControl: ControlRef; actionProc: ControlActionUPP);	{$IFC NOT GENERATINGCFM}	INLINE $A96B;	{$ENDC}FUNCTION GetCtlAction(theControl: ControlRef): ControlActionUPP;	{$IFC NOT GENERATINGCFM}	INLINE $A96A;	{$ENDC}PROCEDURE SetCtlColor(theControl: ControlRef; newColorTable: CCTabHandle);	{$IFC NOT GENERATINGCFM}	INLINE $AA43;	{$ENDC}FUNCTION GetCVariant(theControl: ControlRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A809;	{$ENDC}{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := ControlsIncludes}{$ENDC} {__CONTROLS__}{$IFC NOT UsingIncludes} END.{$ENDC}