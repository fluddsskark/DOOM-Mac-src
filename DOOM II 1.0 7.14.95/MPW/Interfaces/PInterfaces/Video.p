{ 	File:		Video.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT Video; INTERFACE{$ENDC}{$IFC UNDEFINED __VIDEO__}{$SETC __VIDEO__ := 1}{$I+}{$SETC VideoIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __QUICKDRAW__}{$I Quickdraw.p}{$ENDC}{	Types.p														}{		ConditionalMacros.p										}{	MixedMode.p													}{	QuickdrawText.p												}{$PUSH}{$ALIGN MAC68K}{$LibExport+}CONST	mBaseOffset					= 1;							{Id of mBaseOffset.}	mRowBytes					= 2;							{Video sResource parameter Id's }	mBounds						= 3;							{Video sResource parameter Id's }	mVersion					= 4;							{Video sResource parameter Id's }	mHRes						= 5;							{Video sResource parameter Id's }	mVRes						= 6;							{Video sResource parameter Id's }	mPixelType					= 7;							{Video sResource parameter Id's }	mPixelSize					= 8;							{Video sResource parameter Id's }	mCmpCount					= 9;							{Video sResource parameter Id's }	mCmpSize					= 10;							{Video sResource parameter Id's }	mPlaneBytes					= 11;							{Video sResource parameter Id's }	mVertRefRate				= 14;							{Video sResource parameter Id's }	mVidParams					= 1;							{Video parameter block id.}	mTable						= 2;							{Offset to the table.}	mPageCnt					= 3;							{Number of pages}	mDevType					= 4;							{Device Type}	oneBitMode					= 128;							{Id of OneBitMode Parameter list.}	twoBitMode					= 129;							{Id of TwoBitMode Parameter list.}	fourBitMode					= 130;							{Id of FourBitMode Parameter list.}	eightBitMode				= 131;							{Id of EightBitMode Parameter list.}	sixteenBitMode				= 132;							{Id of SixteenBitMode Parameter list.}	thirtyTwoBitMode			= 133;							{Id of ThirtyTwoBitMode Parameter list.}	firstVidMode				= 128;							{The new, better way to do the above. }	secondVidMode				= 129;							{ QuickDraw only supports six video }	thirdVidMode				= 130;							{ at this time.      }	fourthVidMode				= 131;	fifthVidMode				= 132;	sixthVidMode				= 133;	spGammaDir					= 64;	spVidNamesDir				= 65;{ csTimingFormat values in VDTimingInfo }{ look in the declaration rom for timing info }	kDeclROMtables				= 'decl';{ csConnectFlags values in VDDisplayConnectInfo }	kAllModesValid				= 0;							{ All modes not trimmed by primary init are good close enough to try }	kAllModesSafe				= 1;							{ All modes not trimmed by primary init are know to be safe }	kReportsTagging				= 2;							{ Can detect tagged displays (to identify smart monitors) }	kHasDirectConnect			= 3;							{ True implies that driver can talk directly to device (e.g. serial data link via sense lines) }	kIsMonoDev					= 4;							{ Says whether there’s an RGB (0) or Monochrome (1) connection. }	kUncertainConnection		= 5;							{ There may not be a display (no sense lines?). }{ csDisplayType values in VDDisplayConnectInfo }	kUnknownConnect				= 1;							{ Not sure how we’ll use this, but seems like a good idea. }	kPanelConnect				= 2;							{ For use with fixed-in-place LCD panels. }	kPanelTFTConnect			= 2;							{ Alias for kPanelConnect }	kFixedModeCRTConnect		= 3;							{  For use with fixed-mode (i.e., very limited range) displays. }	kMultiModeCRT1Connect		= 4;							{ 320x200 maybe, 12" maybe, 13" (default), 16" certain, 19" maybe, 21" maybe }	kMultiModeCRT2Connect		= 5;							{ 320x200 maybe, 12" maybe, 13" certain, 16" (default), 19" certain, 21" maybe }	kMultiModeCRT3Connect		= 6;							{ 320x200 maybe, 12" maybe, 13" certain, 16" certain, 19" default, 21" certain }	kMultiModeCRT4Connect		= 7;							{ Expansion to large multi mode (not yet used) }	kModelessConnect			= 8;							{ Expansion to modeless model (not yet used) }	kFullPageConnect			= 9;							{ 640x818 (to get 8bpp in 512K case) and 640x870 (these two only) }	kVGAConnect					= 10;							{ 640x480 VGA default -- question everything else }	kNTSCConnect				= 11;							{ NTSC ST (default), FF, STconv, FFconv }	kPALConnect					= 12;							{ PAL ST (default), FF, STconv, FFconv }	kHRConnect					= 13;							{ 640x400 (to get 8bpp in 256K case) and 640x480 (these two only) }	kPanelFSTNConnect			= 14;							{ For use with fixed-in-place LCD FSTN (aka “Supertwist”) panels }{ csTimingFlags values in VDTimingInfoRec }	kModeValid					= 0;							{ Says that this mode should NOT be trimmed. }	kModeSafe					= 1;							{ This mode does not need confirmation }	kModeDefault				= 2;							{ This is the default mode for this type of connection }	kModeShowNow				= 3;							{ This mode should always be shown (even though it may require a confirm) }	kModeNotResize				= 4;							{ This mode should not be used to resize the display (eg. mode selects a different connector on card) }{ Control Codes }	cscReset					= 0;	cscKillIO					= 1;	cscSetMode					= 2;	cscSetEntries				= 3;	cscSetGamma					= 4;	cscGrayPage					= 5;	cscGrayScreen				= 5;	cscSetGray					= 6;	cscSetInterrupt				= 7;	cscDirectSetEntries			= 8;	cscSetDefaultMode			= 9;	cscSwitchMode				= 10;	cscSetSync					= 11;	cscSetVideoConfiguration	= 22;{ Status Codes }	cscGetMode					= 2;	cscGetEntries				= 3;	cscGetPageCnt				= 4;	cscGetPages					= 4;							{ This is what C&D 2 calls it. }	cscGetPageBase				= 5;	cscGetBaseAddr				= 5;							{ This is what C&D 2 calls it. }	cscGetGray					= 6;	cscGetInterrupt				= 7;	cscGetGamma					= 8;	cscGetDefaultMode			= 9;	cscGetCurMode				= 10;	cscGetSync					= 11;	cscGetConnection			= 12;							{ Return information about the connection to the display }	cscGetModeTiming			= 13;							{ Return timing info for a mode }	cscGetModeBaseAddress		= 14;							{ Return base address information about a particular mode }	cscGetScanProc				= 15;							{ QuickTime scan chasing routine }	cscGetNextResolution		= 20;	cscGetVideoParameters		= 21;	cscGetGammaList				= 22;TYPE	VPBlock = RECORD		vpBaseOffset:			LONGINT;								{Offset to page zero of video RAM (From minorBaseOS).}		vpRowBytes:				INTEGER;								{Width of each row of video memory.}		vpBounds:				Rect;									{BoundsRect for the video display (gives dimensions).}		vpVersion:				INTEGER;								{PixelMap version number.}		vpPackType:				INTEGER;		vpPackSize:				LONGINT;		vpHRes:					LONGINT;								{Horizontal resolution of the device (pixels per inch).}		vpVRes:					LONGINT;								{Vertical resolution of the device (pixels per inch).}		vpPixelType:			INTEGER;								{Defines the pixel type.}		vpPixelSize:			INTEGER;								{Number of bits in pixel.}		vpCmpCount:				INTEGER;								{Number of components in pixel.}		vpCmpSize:				INTEGER;								{Number of bits per component}		vpPlaneBytes:			LONGINT;								{Offset from one plane to the next.}	END;	VPBlockPtr = ^VPBlock;	VDEntryRecord = RECORD		csTable:				Ptr;									{(long) pointer to color table entry=value, r,g,b:INTEGER}	END;	VDEntRecPtr = ^VDEntryRecord;{ Parm block for SetGray control call }	VDGrayRecord = RECORD		csMode:					BOOLEAN;								{Same as GDDevType value (0=mono, 1=color)}	END;	VDGrayPtr = ^VDGrayRecord;{ Parm block for SetEntries control call }	VDSetEntryRecord = RECORD		csTable:				^ColorSpec;								{Pointer to an array of color specs}		csStart:				INTEGER;								{Which spec in array to start with, or -1}		csCount:				INTEGER;								{Number of color spec entries to set}	END;	VDSetEntryPtr = ^VDSetEntryRecord;{ Parm block for SetGamma control call }	VDGammaRecord = RECORD		csGTable:				Ptr;									{pointer to gamma table}	END;	VDGamRecPtr = ^VDGammaRecord;	VDSwitchInfoRec = RECORD		csMode:					INTEGER;								{(word) mode depth}		csData:					LONGINT;								{(long) functional sResource of mode}		csPage:					INTEGER;								{(word) page to switch in}		csBaseAddr:				Ptr;									{(long) base address of page (return value)}		csReserved:				LONGINT;								{(long) Reserved (set to 0) }	END;	VDSwitchInfoPtr = ^VDSwitchInfoRec;	VDTimingInfoRec = RECORD		csTimingMode:			LONGINT;								{ LONGINT - (long) timing mode (a la InitGDevice) }		csTimingReserved:		LONGINT;								{ LONGINT - (long) reserved }		csTimingFormat:			LONGINT;								{ LONGINT - (long) what format is the timing info }		csTimingData:			LONGINT;								{ LONGINT - (long) data supplied by driver }		csTimingFlags:			LONGINT;								{ LONGINT - (long) mode within device }	END;	VDTimingInfoPtr = ^VDTimingInfoRec;	VDDisplayConnectInfoRec = RECORD		csDisplayType:			INTEGER;								{ INTEGER - (word) Type of display connected }		csConnectTagged:		INTEGER;								{ INTEGER - (word) Display is currently "it" (tagged to identify component) }		csConnectFlags:			LONGINT;								{ LONGINT - (long) tell us about the connection }		csDisplayComponent:		LONGINT;								{ LONGINT - (long) if the card has a direct connection to the display, it returns the display component here (FUTURE) }		csConnectReserved:		LONGINT;								{ LONGINT - (long) reserved }	END;	VDDisplayConnectInfoPtr = ^VDDisplayConnectInfoRec;	VDPageInfo = RECORD		csMode:					INTEGER;								{(word) mode within device}		csData:					LONGINT;								{(long) data supplied by driver}		csPage:					INTEGER;								{(word) page to switch in}		csBaseAddr:				Ptr;									{(long) base address of page}	END;	VDPgInfoPtr = ^VDPageInfo;	VDSizeInfo = RECORD		csHSize:				INTEGER;								{(word) desired/returned h size}		csHPos:					INTEGER;								{(word) desired/returned h position}		csVSize:				INTEGER;								{(word) desired/returned v size}		csVPos:					INTEGER;								{(word) desired/returned v position}	END;	VDSzInfoPtr = ^VDSizeInfo;	VDSettings = RECORD		csParamCnt:				INTEGER;								{(word) number of params}		csBrightMax:			INTEGER;								{(word) max brightness}		csBrightDef:			INTEGER;								{(word) default brightness}		csBrightVal:			INTEGER;								{(word) current brightness}		csCntrstMax:			INTEGER;								{(word) max contrast}		csCntrstDef:			INTEGER;								{(word) default contrast}		csCntrstVal:			INTEGER;								{(word) current contrast}		csTintMax:				INTEGER;								{(word) max tint}		csTintDef:				INTEGER;								{(word) default tint}		csTintVal:				INTEGER;								{(word) current tint}		csHueMax:				INTEGER;								{(word) max hue}		csHueDef:				INTEGER;								{(word) default hue}		csHueVal:				INTEGER;								{(word) current hue}		csHorizDef:				INTEGER;								{(word) default horizontal}		csHorizVal:				INTEGER;								{(word) current horizontal}		csHorizMax:				INTEGER;								{(word) max horizontal}		csVertDef:				INTEGER;								{(word) default vertical}		csVertVal:				INTEGER;								{(word) current vertical}		csVertMax:				INTEGER;								{(word) max vertical}	END;	VDSettingsPtr = ^VDSettings;	DisplayModeID = LONGINT;	VideoDeviceType = LONGINT;	VideoMode = LONGINT;	GammaTableID = LONGINT;CONST	kFirstDepthMode				= 128;	kSecondDepthMode			= 129;	kThirdDepthMode				= 130;	kFourthDepthMode			= 131;	kFifthDepthMode				= 132;	kSixthDepthMode				= 133;TYPE	VDResolutionInfoRec = RECORD		csPreviousDisplayModeID: DisplayModeID;							{ ID of the previous resolution in a chain }		csDisplayModeID:		DisplayModeID;							{ ID of the next resolution }		csHorizontalPixels:		LONGINT;								{ # of pixels in a horizontal line }		csVerticalLines:		LONGINT;								{ # of lines in a screen }		csRefreshRate:			Fixed;									{ Vertical Refresh Rate in Hz }		csMaxDepthMode:			VideoMode;								{ 0x80-based number representing max bit depth }	END;	VDResolutionInfoPtr = ^VDResolutionInfoRec;	VDVideoParametersInfoRec = RECORD		csDisplayModeID:		DisplayModeID;							{ the ID of the resolution we want info on }		csDepthMode:			VideoMode;								{ The bit depth we want the info on (0x80 based) }		csVPBlockPtr:			VPBlockPtr;								{ Pointer to a vdeo parameter block }		csPageCount:			LONGINT;								{ Number of pages supported by the resolution }		csDeviceType:			VideoDeviceType;						{ Device Type:  Direct, Fixed or CLUT; }	END;	VDVideoParametersInfoPtr = ^VDVideoParametersInfoRec;	VDGammaInfoRec = RECORD		csLastGammaID:			GammaTableID;							{ the ID of the previous gamma table }		csNextGammaID:			GammaTableID;							{ the ID of the next gamma table }		csGammaPtr:				Ptr;									{ Ptr to a DeclROM style gamma table }	END;	VDGammaInfoPtr = ^VDGammaInfoRec;{$ALIGN RESET}{$POP}{$SETC UsingIncludes := VideoIncludes}{$ENDC} {__VIDEO__}{$IFC NOT UsingIncludes} END.{$ENDC}