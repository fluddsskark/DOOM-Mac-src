{ 	File:		MixedMode.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT MixedMode; INTERFACE{$ENDC}{$IFC UNDEFINED __MIXEDMODE__}{$SETC __MIXEDMODE__ := 1}{$I+}{$SETC MixedModeIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __TYPES__}{$I Types.p}{$ENDC}{	ConditionalMacros.p											}{$PUSH}{$ALIGN MAC68K}{$LibExport+}CONST	kRoutineDescriptorVersion	= 7;{ MixedModeMagic Magic Cookie/Trap number }	_MixedModeMagic				= $AAFE;{ Calling Conventions }	TYPECallingConventionType = INTEGER;CONST	kPascalStackBased			= 0;	kCStackBased				= 1;	kRegisterBased				= 2;	kD0DispatchedPascalStackBased = 8;	kD1DispatchedPascalStackBased = 12;	kD0DispatchedCStackBased	= 9;	kStackDispatchedPascalStackBased = 14;	kThinkCStackBased			= 5;{ ISA Types }	TYPEISAType = SInt8;CONST	kM68kISA					= 0;	kPowerPCISA					= 1;{ RTA Types }	TYPERTAType = SInt8;CONST	kOld68kRTA					= 0+(0 * (2**(4)));	kPowerPCRTA					= 0+(0 * (2**(4)));	kCFM68kRTA					= 0+(1 * (2**(4)));{$IFC GENERATINGPOWERPC }	GetCurrentISA				= kPowerPCISA;	GetCurrentRTA				= kPowerPCRTA;{$ELSEC}{$IFC GENERATINGCFM }	GetCurrentISA				= kM68kISA;	GetCurrentRTA				= kCFM68kRTA;{$ELSEC}	GetCurrentISA				= kM68kISA;	GetCurrentRTA				= kOld68kRTA;{$ENDC}{$ENDC}	GetCurrentArchitecture		= 0+(GetCurrentISA + GetCurrentRTA);	kRegisterD0					= 0;	kRegisterD1					= 1;	kRegisterD2					= 2;	kRegisterD3					= 3;	kRegisterD4					= 8;	kRegisterD5					= 9;	kRegisterD6					= 10;	kRegisterD7					= 11;	kRegisterA0					= 4;	kRegisterA1					= 5;	kRegisterA2					= 6;	kRegisterA3					= 7;	kRegisterA4					= 12;	kRegisterA5					= 13;	kRegisterA6					= 14;{ A7 is the same as the PowerPC SP }	kCCRegisterCBit				= 16;	kCCRegisterVBit				= 17;	kCCRegisterZBit				= 18;	kCCRegisterNBit				= 19;	kCCRegisterXBit				= 20;	TYPEregisterSelectorType = INTEGER;{ SizeCodes we use everywhere }CONST	kNoByteCode					= 0;	kOneByteCode				= 1;	kTwoByteCode				= 2;	kFourByteCode				= 3;{ Mixed Mode Routine Records }	TYPEProcInfoType = LONGINT;{ Routine Flag Bits }	RoutineFlagsType = INTEGER;CONST	kProcDescriptorIsAbsolute	= $00;	kProcDescriptorIsRelative	= $01;	kFragmentIsPrepared			= $00;	kFragmentNeedsPreparing		= $02;	kUseCurrentISA				= $00;	kUseNativeISA				= $04;	kPassSelector				= $0;	kDontPassSelector			= $08;	kRoutineIsNotDispatchedDefaultRoutine = $0;	kRoutineIsDispatchedDefaultRoutine = $10;TYPE	RoutineRecord = RECORD		procInfo:				ProcInfoType;							{ calling conventions }		reserved1:				SInt8;									{ Must be 0 }		ISA:					ISAType;								{ Instruction Set Architecture }		routineFlags:			RoutineFlagsType;						{ Flags for each routine }		procDescriptor:			ProcPtr;								{ Where is the thing we’re calling? }		reserved2:				LONGINT;								{ Must be 0 }		selector:				LONGINT;								{ For dispatched routines, the selector }	END;	RoutineRecordPtr = ^RoutineRecord;	RoutineRecordHandle = ^RoutineRecordPtr;{ Mixed Mode Routine Descriptors }{ Definitions of the Routine Descriptor Flag Bits }	RDFlagsType = UInt8;CONST	kSelectorsAreNotIndexable	= $00;	kSelectorsAreIndexable		= $01;{ Routine Descriptor Structure }TYPE	RoutineDescriptor = PACKED RECORD		goMixedModeTrap:		INTEGER;								{ Our A-Trap }		version:				SInt8;									{ Current Routine Descriptor version }		routineDescriptorFlags:	RDFlagsType;							{ Routine Descriptor Flags }		reserved1:				LONGINT;								{ Unused, must be zero }		reserved2:				UInt8;									{ Unused, must be zero }		selectorInfo:			UInt8;									{ If a dispatched routine, calling convention, else 0 }		routineCount:			INTEGER;								{ Number of routines in this RD }		routineRecords:			ARRAY [0..0] OF RoutineRecord;			{ The individual routines }	END;	RoutineDescriptorPtr = ^RoutineDescriptor;	RoutineDescriptorHandle = ^RoutineDescriptorPtr;CONST{ Calling Convention Offsets }	kCallingConventionWidth		= 4;	kCallingConventionPhase		= 0;{ Result Offsets }	kResultSizeWidth			= 2;	kResultSizePhase			= kCallingConventionWidth;	kResultSizeMask				= $30;{ Parameter offsets & widths }	kStackParameterWidth		= 2;	kStackParameterPhase		= 0+(kCallingConventionWidth + kResultSizeWidth);{ Register Result Location offsets & widths }	kRegisterResultLocationWidth = 5;	kRegisterResultLocationPhase = 0+(kCallingConventionWidth + kResultSizeWidth);{ Register Parameter offsets & widths }	kRegisterParameterWidth		= 5;	kRegisterParameterPhase		= 0+(kCallingConventionWidth + kResultSizeWidth + kRegisterResultLocationWidth);	kRegisterParameterSizePhase	= 0;	kRegisterParameterWhichPhase = 2;{ Dispatched Stack Routine Selector offsets & widths }	kDispatchedSelectorSizeWidth = 2;	kDispatchedSelectorSizePhase = 0+(kCallingConventionWidth + kResultSizeWidth);{ Dispatched Stack Routine Parameter offsets }	kDispatchedParameterPhase	= 0+(kCallingConventionWidth + kResultSizeWidth + kDispatchedSelectorSizeWidth);{ Special Case offsets & widths }	kSpecialCaseSelectorWidth	= 6;{ Component Manager Special Case offsets & widths }	kComponentMgrResultSizeWidth = 2;	kComponentMgrResultSizePhase = kCallingConventionWidth + kSpecialCaseSelectorWidth; { 4 + 6 = 10 }	kComponentMgrParameterWidth	= 2;	kComponentMgrParameterPhase	= kComponentMgrResultSizePhase + kComponentMgrResultSizeWidth; { 10 + 2 = 12 }	kSpecialCase				= $0000000F;{ all of the special cases enumerated.  The selector field is 6 bits wide }	kSpecialCaseHighHook		= 0;	kSpecialCaseCaretHook		= 0;							{ same as kSpecialCaseHighHook }	kSpecialCaseEOLHook			= 1;	kSpecialCaseWidthHook		= 2;	kSpecialCaseTextWidthHook	= 2;							{ same as kSpecialCaseWidthHook }	kSpecialCaseNWidthHook		= 3;	kSpecialCaseDrawHook		= 4;	kSpecialCaseHitTestHook		= 5;	kSpecialCaseTEFindWord		= 6;	kSpecialCaseProtocolHandler	= 7;	kSpecialCaseSocketListener	= 8;	kSpecialCaseTERecalc		= 9;	kSpecialCaseTEDoText		= 10;	kSpecialCaseGNEFilterProc	= 11;	kSpecialCaseMBarHook		= 12;	kSpecialCaseComponentMgr	= 13;{$IFC GENERATINGCFM }FUNCTION NewRoutineDescriptor(theProc: ProcPtr; theProcInfo: ProcInfoType; theISA: ByteParameter): UniversalProcPtr;	{$IFC NOT GENERATINGCFM}	INLINE $7000, $AA59;	{$ENDC}PROCEDURE DisposeRoutineDescriptor(theProcPtr: UniversalProcPtr);	{$IFC NOT GENERATINGCFM}	INLINE $7001, $AA59;	{$ENDC}FUNCTION NewFatRoutineDescriptor(theM68kProc: ProcPtr; thePowerPCProc: ProcPtr; theProcInfo: ProcInfoType): UniversalProcPtr;	{$IFC NOT GENERATINGCFM}	INLINE $7002, $AA59;	{$ENDC}{$ELSEC}FUNCTION NewRoutineDescriptor(theProc: ProcPtr; theProcInfo: ProcInfoType; theISA: ByteParameter): UniversalProcPtr;	{$IFC NOT GENERATINGCFM}	INLINE $5C4F, $2E9F;	{$ENDC}PROCEDURE DisposeRoutineDescriptor(theProcPtr: UniversalProcPtr);	{$IFC NOT GENERATINGCFM}	INLINE $584F;	{$ENDC}{$ENDC}{$IFC GENERATINGPOWERPC }FUNCTION CallUniversalProc(theProcPtr: UniversalProcPtr; procInfo: ProcInfoType; ...): LONGINT; C;FUNCTION CallOSTrapUniversalProc(theProcPtr: UniversalProcPtr; procInfo: ProcInfoType; ...): LONGINT; C;{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := MixedModeIncludes}{$ENDC} {__MIXEDMODE__}{$IFC NOT UsingIncludes} END.{$ENDC}