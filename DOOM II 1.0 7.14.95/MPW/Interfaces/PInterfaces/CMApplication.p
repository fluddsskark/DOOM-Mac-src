{ 	File:		CMApplication.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.1  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT CMApplication; INTERFACE{$ENDC}{$IFC UNDEFINED __CMAPPLICATION__}{$SETC __CMAPPLICATION__ := 1}{$I+}{$SETC CMApplicationIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __TYPES__}{$I Types.p}{$ENDC}{	ConditionalMacros.p											}{$IFC UNDEFINED __QUICKDRAW__}{$I Quickdraw.p}{$ENDC}{	MixedMode.p													}{	QuickdrawText.p												}{$IFC UNDEFINED __WINDOWS__}{$I Windows.p}{$ENDC}{	Memory.p													}{	Events.p													}{		OSUtils.p												}{	Controls.p													}{		Menus.p													}{$IFC UNDEFINED __PRINTING__}{$I Printing.p}{$ENDC}{	Errors.p													}{	Dialogs.p													}{		TextEdit.p												}{$PUSH}{$ALIGN MAC68K}{$LibExport+}CONST	gestaltColorMatchingVersion	= 'cmtc';	gestaltColorSync10			= $0100;						{ 0x0100 & 0x0110 _Gestalt versions for 1.0-1.0.3 product }	gestaltColorSync11			= $0110;						{   0x0100 == low-level matching only }	gestaltColorSync104			= $0104;						{ Real version, by popular demand }	gestaltColorSync105			= $0105;	gestaltColorMatchingAttr	= 'cmta';{ Attribute bit numbers for gestaltColorMatchingAttr }	gestaltHighLevelMatching	= 0;	gestaltColorMatchingLibLoaded = 1;{ 68K A-trap }	CMTrap						= $ABEE;{ PicComments }	CMBeginProfile				= 220;	CMEndProfile				= 221;	CMEnableMatching			= 222;	CMDisableMatching			= 223;{ Defines for fieldMask in profile search record }	kMatchCMMType				= $00000001;	kMatchApplProfileVersion	= $00000002;	kMatchDataType				= $00000004;	kMatchDeviceType			= $00000008;	kMatchDeviceManufacturer	= $00000010;	kMatchDeviceModel			= $00000020;	kMatchDeviceAttributes		= $00000040;	kMatchFlags					= $00000080;	kMatchOptions				= $00000100;	kMatchWhite					= $00000200;	kMatchBlack					= $00000400;{ Profile Header version }	kCMApplProfileVersion		= $0100;{ Data types }	rgbData						= 'RGB ';	cmykData					= 'CMYK';	grayData					= 'GRAY';	xyzData						= 'XYZ ';{ Device types }	monitorDevice				= 'mntr';	scannerDevice				= 'scnr';	printerDevice				= 'prtr';	qdSystemDevice				= 'sys ';	qdGDevice					= 'gdev';{ Profile flags }	CMNativeMatchingPreferred	= $00000001;					{ Default to native not preferred }	CMTurnOffCache				= $00000002;					{ Default to turn on CMM cache }	TYPECMMatchFlag = LONGINT;{ Profile options }CONST	CMPerceptualMatch			= $0000;						{ Default. For photographic images }	CMColorimetricMatch			= $0001;						{ Exact matching when possible }	CMSaturationMatch			= $0002;						{ For solid colors }	TYPECMMatchOption = LONGINT;	CMMatchRef = LONGINT;	CWorld = LONGINT;{ ColorSync result codes }CONST	CMNoError					= 0;	CMProfileError				= -170;	CMMethodError				= -171;	CMMemFullError				= -172;	CMUnimplementedError		= -173;	CMParamError				= -174;	CMMethodNotFound			= -175;							{ CMM not present }	CMProfileNotFound			= -176;							{ Responder error }	CMProfilesIdentical			= -177;							{ Profiles the same }	CMCantConcatenateError		= -178;							{ Profile can't be concatenated }	CMCantXYZ					= -179;							{ CMM cant handle XYZ space }	CMCantDeleteProfile			= -180;							{ Responder error }	CMUnsupportedDataType		= -181;							{ Responder error }	CMNoCurrentProfile			= -182;							{ Responder error }	TYPECMError = LONGINT;{** Types}	XYZColor = RECORD		X:						INTEGER;								{ 1.15 bit unsigned fixed numbers }		Y:						INTEGER;		Z:						INTEGER;	END;	CMYKColor = RECORD		cyan:					INTEGER;		magenta:				INTEGER;		yellow:					INTEGER;		black:					INTEGER;	END;	CMColor = RECORD		CASE INTEGER OF		0: (			rgb:						RGBColor;		   );		1: (			xyz:						XYZColor;		   );		2: (			cmyk:						CMYKColor;		   );	END;	CMColorList = ^CMColor;	CMGamutResult = ^LONGINT;	CMHeader = RECORD		size:					LONGINT;								{ This is the total size of the Profile including custom data }		CMMType:				OSType;									{ Corresponding CMM }		applProfileVersion:		LONGINT;								{ Version of CMProfile format }		dataType:				OSType;									{ rgbData, etc. }		deviceType:				OSType;									{ monitorDevice, etc. }		deviceManufacturer:		OSType;									{ Registered with DTS }		deviceModel:			LONGINT;								{ Specific to Manufacturer }		deviceAttributes:		ARRAY [0..1] OF LONGINT;				{ Attributes like paper, ink, etc. }		profileNameOffset:		LONGINT;								{ Offset to profile name from top of data }		customDataOffset:		LONGINT;								{ Offset to custom data from top of data }		flags:					CMMatchFlag;		options:				CMMatchOption;		white:					XYZColor;		black:					XYZColor;	END;	CMProfileSearchRecord = RECORD		header:					CMHeader;		fieldMask:				LONGINT;		reserved:				ARRAY [0..1] OF LONGINT;	END;	CMProfileSearchRecordPtr = ^CMProfileSearchRecord;	CMProfileSearchRecordHandle = ^CMProfileSearchRecordPtr;	CMProfileChromaticities = RECORD		red:					XYZColor;		green:					XYZColor;		blue:					XYZColor;		cyan:					XYZColor;		magenta:				XYZColor;		yellow:					XYZColor;	END;	CMResponseData = INTEGER;	IString = RECORD		theScript:				ScriptCode;		theString:				Str63;	END;	IStringPtr = ^IString;	IStringHandle = ^IStringPtr;CONST	grayResponse				= 0;	redResponse					= 1;	greenResponse				= 2;	blueResponse				= 3;	cyanResponse				= 4;	magentaResponse				= 5;	yellowResponse				= 6;	ucrResponse					= 7;	bgResponse					= 8;	onePlusLastResponse			= 9;	TYPEresponseColor = LONGINT;	CMProfileResponse = RECORD		counts:					ARRAY [0..onePlusLastResponse-1] OF INTEGER;		data:					ARRAY [0..0] OF CMResponseData;			{ Variable size }	END;	CMProfile = RECORD		header:					CMHeader;		profile:				CMProfileChromaticities;		response:				CMProfileResponse;						{ Variable size }		profileName:			IString;								{ Variable size }		customData:				ARRAY [0..0] OF CHAR;					{ Optional variable length custom CMM data }	END;	CMProfilePtr = ^CMProfile;	CMProfileHandle = ^CMProfilePtr;	PixMapCallBackProcPtr = ProcPtr;  { FUNCTION PixMapCallBack(progress: LONGINT; refCon: LONGINT): BOOLEAN; }	PixMapCallBackUPP = UniversalProcPtr;CONST	uppPixMapCallBackProcInfo = $000003D0; { FUNCTION (4 byte param, 4 byte param): 1 byte result; }FUNCTION NewPixMapCallBackProc(userRoutine: PixMapCallBackProcPtr): PixMapCallBackUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION CallPixMapCallBackProc(progress: LONGINT; refCon: LONGINT; userRoutine: PixMapCallBackUPP): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}{** Printing Stuff that will be moved later}CONST	enableColorMatchingOp		= 12;	registerProfileOp			= 13;{ PrGeneral parameter blocks }TYPE	TEnableColorMatchingBlk = RECORD		iOpCode:				INTEGER;		iError:					INTEGER;		lReserved:				LONGINT;		hPrint:					THPrint;		fEnableIt:				BOOLEAN;	END;	TRegisterProfileBlk = RECORD		iOpCode:				INTEGER;		iError:					INTEGER;		lReserved:				LONGINT;		hPrint:					THPrint;		fRegisterIt:			BOOLEAN;	END;{** High Level Calls}FUNCTION BeginMatching(src: CMProfileHandle; dst: CMProfileHandle; VAR myRef: CMMatchRef): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $000C, 10, $ABEE;	{$ENDC}PROCEDURE EndMatching(myRef: CMMatchRef);	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0004, 11, $ABEE;	{$ENDC}FUNCTION GetProfile(deviceType: LONGINT; refNum: LONGINT; aProfile: CMProfileHandle; VAR returnedProfile: CMProfileHandle): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0010, 5, $ABEE;	{$ENDC}FUNCTION SetProfile(deviceType: LONGINT; refNum: LONGINT; newProfile: CMProfileHandle): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $000c, 6, $ABEE;	{$ENDC}FUNCTION SetProfileDescription(deviceType: LONGINT; refNum: LONGINT; deviceData: LONGINT; hProfile: CMProfileHandle): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0010, 16, $ABEE;	{$ENDC}FUNCTION GetColorSyncFolderSpec(vRefNum: INTEGER; createFolder: BOOLEAN; VAR foundVRefNum: INTEGER; VAR foundDirID: LONGINT): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $000c, 17, $ABEE;	{$ENDC}FUNCTION GetIndexedProfile(deviceType: LONGINT; refNum: LONGINT; search: CMProfileSearchRecordHandle; VAR returnProfile: CMProfileHandle; VAR index: LONGINT): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0014, 18, $ABEE;	{$ENDC}FUNCTION DeleteDeviceProfile(deviceType: LONGINT; refNum: LONGINT; deleteMe: CMProfileHandle): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $000C, 19, $ABEE;	{$ENDC}{** Data interchange routines}FUNCTION UseProfile(profile: CMProfileHandle): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0004, 8, $ABEE;	{$ENDC}PROCEDURE DrawMatchedPicture(myPicture: PicHandle; dst: CMProfileHandle; VAR myRect: Rect);	{$IFC NOT GENERATINGCFM}	INLINE $203c, $000C, 9, $ABEE;	{$ENDC}PROCEDURE EnableMatching(enableIt: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0002, 13, $ABEE;	{$ENDC}{** Profile concatenation}FUNCTION ConcatenateProfiles(thru: CMProfileHandle; dst: CMProfileHandle; VAR newDst: CMProfileHandle): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $000C, 12, $ABEE;	{$ENDC}{** Profile manipulation routines}PROCEDURE GetProfileName(myProfile: CMProfileHandle; VAR IStringResult: IString);	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0008, 14, $ABEE;	{$ENDC}FUNCTION GetProfileAdditionalDataOffset(myProfile: CMProfileHandle): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0004, 15, $ABEE;	{$ENDC}{** Low level color calculation routines}FUNCTION CWNewColorWorld(VAR myCWorld: CWorld; src: CMProfileHandle; dst: CMProfileHandle): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $000C, 0, $ABEE;	{$ENDC}PROCEDURE CWDisposeColorWorld(myCWorld: CWorld);	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0004, 1, $ABEE;	{$ENDC}FUNCTION CWMatchColors(myCWorld: CWorld; myColors: CMColorList; count: LONGINT): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $000c, 2, $ABEE;	{$ENDC}FUNCTION CWCheckColors(myCWorld: CWorld; myColors: CMColorList; count: LONGINT; result: CMGamutResult): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0010, 3, $ABEE;	{$ENDC}FUNCTION CWMatchPixMap(myCWorld: CWorld; VAR myPixMap: PixMap; progressProc: PixMapCallBackUPP; refCon: LONGINT): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0010, 4, $ABEE;	{$ENDC}FUNCTION CWCheckPixMap(myCWorld: CWorld; VAR myPixMap: PixMap; progressProc: PixMapCallBackUPP; refCon: LONGINT; VAR resultBitMap: BitMap): CMError;	{$IFC NOT GENERATINGCFM}	INLINE $203c, $0014, 7, $ABEE;	{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := CMApplicationIncludes}{$ENDC} {__CMAPPLICATION__}{$IFC NOT UsingIncludes} END.{$ENDC}