{ 	File:		Components.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT Components; INTERFACE{$ENDC}{$IFC UNDEFINED __COMPONENTS__}{$SETC __COMPONENTS__ := 1}{$I+}{$SETC ComponentsIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __TYPES__}{$I Types.p}{$ENDC}{	ConditionalMacros.p											}{$IFC UNDEFINED __MIXEDMODE__}{$I MixedMode.p}{$ENDC}{$PUSH}{$ALIGN MAC68K}{$LibExport+}CONST	kAppleManufacturer			= 'appl';						{ Apple supplied components }	kComponentResourceType		= 'thng';	kAnyComponentType			= 0;	kAnyComponentSubType		= 0;	kAnyComponentManufacturer	= 0;	kAnyComponentFlagsMask		= 0;	cmpWantsRegisterMessage		= 1 * (2**(31));	kComponentOpenSelect		= -1;							{ ComponentInstance for this open }	kComponentCloseSelect		= -2;							{ ComponentInstance for this close }	kComponentCanDoSelect		= -3;							{ selector # being queried }	kComponentVersionSelect		= -4;							{ no params }	kComponentRegisterSelect	= -5;							{ no params }	kComponentTargetSelect		= -6;							{ ComponentInstance for top of call chain }	kComponentUnregisterSelect	= -7;							{ no params }{ Component Resource Extension flags }	componentDoAutoVersion		= 0+(1 * (2**(0)));	componentWantsUnregister	= 0+(1 * (2**(1)));	componentAutoVersionIncludeFlags = 0+(1 * (2**(2)));	componentHasMultiplePlatforms = 0+(1 * (2**(3)));{ Set Default Component flags }	defaultComponentIdentical	= 0;	defaultComponentAnyFlags	= 1;	defaultComponentAnyManufacturer = 2;	defaultComponentAnySubType	= 4;	defaultComponentAnyFlagsAnyManufacturer = 0+(defaultComponentAnyFlags + defaultComponentAnyManufacturer);	defaultComponentAnyFlagsAnyManufacturerAnySubType = 0+(defaultComponentAnyFlags + defaultComponentAnyManufacturer + defaultComponentAnySubType);TYPE	ComponentDescription = RECORD		componentType:			OSType;									{ A unique 4-byte code indentifying the command set }		componentSubType:		OSType;									{ Particular flavor of this instance }		componentManufacturer:	OSType;									{ Vendor indentification }		componentFlags:			LONGINT;								{ 8 each for Component,Type,SubType,Manuf/revision }		componentFlagsMask:		LONGINT;								{ Mask for specifying which flags to consider in search, zero during registration }	END;	ResourceSpec = RECORD		resType:				OSType;									{ 4-byte code  }		resID:					INTEGER;	END;	ComponentResource = RECORD		cd:						ComponentDescription;					{ Registration parameters }		component:				ResourceSpec;							{ resource where Component code is found }		componentName:			ResourceSpec;							{ name string resource }		componentInfo:			ResourceSpec;							{ info string resource }		componentIcon:			ResourceSpec;							{ icon resource }	END;	ComponentResourcePtr = ^ComponentResource;	ComponentResourceHandle = ^ComponentResourcePtr;	ComponentPlatformInfo = RECORD		componentFlags:			LONGINT;								{ flags of Component }		component:				ResourceSpec;							{ resource where Component code is found }		platformType:			INTEGER;								{ gestaltSysArchitecture result }	END;	ComponentResourceExtension = RECORD		componentVersion:		LONGINT;								{ version of Component }		componentRegisterFlags:	LONGINT;								{ flags for registration }		componentIconFamily:	INTEGER;								{ resource id of Icon Family }	END;	ComponentPlatformInfoArray = RECORD		count:					LONGINT;		platformArray:			ARRAY [0..0] OF ComponentPlatformInfo;	END;	ExtComponentResource = RECORD		cd:						ComponentDescription;					{ registration parameters }		component:				ResourceSpec;							{ resource where Component code is found }		componentName:			ResourceSpec;							{ name string resource }		componentInfo:			ResourceSpec;							{ info string resource }		componentIcon:			ResourceSpec;							{ icon resource }		componentVersion:		LONGINT;								{ version of Component }		componentRegisterFlags:	LONGINT;								{ flags for registration }		componentIconFamily:	INTEGER;								{ resource id of Icon Family }		count:					LONGINT;								{ elements in platformArray }		platformArray:			ARRAY [0..0] OF ComponentPlatformInfo;	END;	ComponentParameters = PACKED RECORD		flags:					CHAR;									{ call modifiers: sync/async, deferred, immed, etc }		paramSize:				CHAR;									{ size in bytes of actual parameters passed to this call }		what:					INTEGER;								{ routine selector, negative for Component management calls }		params:					ARRAY [0..0] OF LONGINT;				{ actual parameters for the indicated routine }	END;	ComponentRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	Component = ^ComponentRecord;	ComponentInstanceRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	ComponentInstance = ^ComponentInstanceRecord;	ComponentResult = LONGINT;	ComponentRoutineProcPtr = ProcPtr;  { FUNCTION ComponentRoutine(VAR cp: ComponentParameters; componentStorage: Handle): ComponentResult; }	ComponentRoutineUPP = UniversalProcPtr;CONST	uppComponentRoutineProcInfo = $000003F0; { FUNCTION (4 byte param, 4 byte param): 4 byte result; }FUNCTION NewComponentRoutineProc(userRoutine: ComponentRoutineProcPtr): ComponentRoutineUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION CallComponentRoutineProc(VAR cp: ComponentParameters; componentStorage: Handle; userRoutine: ComponentRoutineUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}	TYPEComponentRoutine = ComponentRoutineUPP;{	The parameter list for each ComponentFunction is unique. It is 	therefore up to users to create the appropriate procInfo for their 	own ComponentFunctions where necessary.}	ComponentFunctionUPP = UniversalProcPtr;FUNCTION RegisterComponent(VAR cd: ComponentDescription; componentEntryPoint: ComponentRoutineUPP; global: INTEGER; componentName: Handle; componentInfo: Handle; componentIcon: Handle): Component;	{$IFC NOT GENERATINGCFM}	INLINE $7001, $A82A;	{$ENDC}FUNCTION RegisterComponentResource(tr: ComponentResourceHandle; global: INTEGER): Component;	{$IFC NOT GENERATINGCFM}	INLINE $7012, $A82A;	{$ENDC}FUNCTION UnregisterComponent(aComponent: Component): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7002, $A82A;	{$ENDC}FUNCTION FindNextComponent(aComponent: Component; VAR looking: ComponentDescription): Component;	{$IFC NOT GENERATINGCFM}	INLINE $7004, $A82A;	{$ENDC}FUNCTION CountComponents(VAR looking: ComponentDescription): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7003, $A82A;	{$ENDC}FUNCTION GetComponentInfo(aComponent: Component; VAR cd: ComponentDescription; componentName: Handle; componentInfo: Handle; componentIcon: Handle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7005, $A82A;	{$ENDC}FUNCTION GetComponentListModSeed: LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7006, $A82A;	{$ENDC}{ Component Instance Allocation and dispatch routines }FUNCTION OpenComponent(aComponent: Component): ComponentInstance;	{$IFC NOT GENERATINGCFM}	INLINE $7007, $A82A;	{$ENDC}FUNCTION CloseComponent(aComponentInstance: ComponentInstance): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7008, $A82A;	{$ENDC}FUNCTION GetComponentInstanceError(aComponentInstance: ComponentInstance): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $700A, $A82A;	{$ENDC}{ Direct calls to the Components }FUNCTION ComponentFunctionImplemented(ci: ComponentInstance; ftnNumber: INTEGER): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $FFFD, $7000, $A82A;	{$ENDC}FUNCTION GetComponentVersion(ci: ComponentInstance): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $0, $FFFC, $7000, $A82A;	{$ENDC}FUNCTION ComponentSetTarget(ci: ComponentInstance; target: ComponentInstance): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $FFFA, $7000, $A82A;	{$ENDC}{ Component Management routines }PROCEDURE SetComponentInstanceError(aComponentInstance: ComponentInstance; theError: OSErr);	{$IFC NOT GENERATINGCFM}	INLINE $700B, $A82A;	{$ENDC}FUNCTION GetComponentRefcon(aComponent: Component): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7010, $A82A;	{$ENDC}PROCEDURE SetComponentRefcon(aComponent: Component; theRefcon: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $7011, $A82A;	{$ENDC}FUNCTION OpenComponentResFile(aComponent: Component): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $7015, $A82A;	{$ENDC}FUNCTION CloseComponentResFile(refnum: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7018, $A82A;	{$ENDC}{ Component Instance Management routines }FUNCTION GetComponentInstanceStorage(aComponentInstance: ComponentInstance): Handle;	{$IFC NOT GENERATINGCFM}	INLINE $700C, $A82A;	{$ENDC}PROCEDURE SetComponentInstanceStorage(aComponentInstance: ComponentInstance; theStorage: Handle);	{$IFC NOT GENERATINGCFM}	INLINE $700D, $A82A;	{$ENDC}FUNCTION GetComponentInstanceA5(aComponentInstance: ComponentInstance): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $700E, $A82A;	{$ENDC}PROCEDURE SetComponentInstanceA5(aComponentInstance: ComponentInstance; theA5: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $700F, $A82A;	{$ENDC}FUNCTION CountComponentInstances(aComponent: Component): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7013, $A82A;	{$ENDC}{ Useful helper routines for convenient method dispatching }FUNCTION CallComponentFunction(VAR params: ComponentParameters; func: ComponentFunctionUPP): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $70FF, $A82A;	{$ENDC}FUNCTION CallComponentFunctionWithStorage(storage: Handle; VAR params: ComponentParameters; func: ComponentFunctionUPP): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $70FF, $A82A;	{$ENDC}FUNCTION DelegateComponentCall(VAR originalParams: ComponentParameters; ci: ComponentInstance): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7024, $A82A;	{$ENDC}FUNCTION SetDefaultComponent(aComponent: Component; flags: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $701E, $A82A;	{$ENDC}FUNCTION OpenDefaultComponent(componentType: OSType; componentSubType: OSType): ComponentInstance;	{$IFC NOT GENERATINGCFM}	INLINE $7021, $A82A;	{$ENDC}FUNCTION CaptureComponent(capturedComponent: Component; capturingComponent: Component): Component;	{$IFC NOT GENERATINGCFM}	INLINE $701C, $A82A;	{$ENDC}FUNCTION UncaptureComponent(aComponent: Component): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $701D, $A82A;	{$ENDC}FUNCTION RegisterComponentResourceFile(resRefNum: INTEGER; global: INTEGER): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7014, $A82A;	{$ENDC}FUNCTION GetComponentIconSuite(aComponent: Component; VAR iconSuite: Handle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7029, $A82A;	{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := ComponentsIncludes}{$ENDC} {__COMPONENTS__}{$IFC NOT UsingIncludes} END.{$ENDC}