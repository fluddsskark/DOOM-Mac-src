{ 	File:		MacTCP.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.1  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT MacTCP; INTERFACE{$ENDC}{$IFC UNDEFINED __MACTCP__}{$SETC __MACTCP__ := 1}{$I+}{$SETC MacTCPIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __TYPES__}{$I Types.p}{$ENDC}{	ConditionalMacros.p											}{$IFC UNDEFINED __APPLETALK__}{$I AppleTalk.p}{$ENDC}{	OSUtils.p													}{		MixedMode.p												}{$PUSH}{$ALIGN MAC68K}{$LibExport+}CONST	inProgress					= 1;							{ I/O in progress }	ipBadLapErr					= -23000;						{ bad network configuration }	ipBadCnfgErr				= -23001;						{ bad IP configuration error }	ipNoCnfgErr					= -23002;						{ missing IP or LAP configuration error }	ipLoadErr					= -23003;						{ error in MacTCP load }	ipBadAddr					= -23004;						{ error in getting address }	connectionClosing			= -23005;						{ connection is closing }	invalidLength				= -23006;	connectionExists			= -23007;						{ request conflicts with existing connection }	connectionDoesntExist		= -23008;						{ connection does not exist }	insufficientResources		= -23009;						{ insufficient resources to perform request }	invalidStreamPtr			= -23010;	streamAlreadyOpen			= -23011;	connectionTerminated		= -23012;	invalidBufPtr				= -23013;	invalidRDS					= -23014;	invalidWDS					= -23014;	openFailed					= -23015;	commandTimeout				= -23016;	duplicateSocket				= -23017;{ Error codes from internal IP functions }	ipDontFragErr				= -23032;						{ Packet too large to send w/o fragmenting }	ipDestDeadErr				= -23033;						{ destination not responding }	icmpEchoTimeoutErr			= -23035;						{ ICMP echo timed-out }	ipNoFragMemErr				= -23036;						{ no memory to send fragmented pkt }	ipRouteErr					= -23037;						{ can't route packet off-net }	nameSyntaxErr				= -23041;	cacheFault					= -23042;	noResultProc				= -23043;	noNameServer				= -23044;	authNameErr					= -23045;	noAnsErr					= -23046;	dnrErr						= -23047;	outOfMemory					= -23048;	BYTES_16WORD				= 2;							{ bytes per = 16, bit ip word }	BYTES_32WORD				= 4;							{ bytes per = 32, bit ip word }	BYTES_64WORD				= 8;							{ bytes per = 64, bit ip word }	TYPEb_8 = CHAR;	b_16 = INTEGER;	b_32 = LONGINT;	ip_addr = b_32;	ip_addrbytes = RECORD		CASE INTEGER OF		0: (			addr:						b_32;		   );		1: (			bytes:						ARRAY [0..3] OF CHAR;		   );	END;	wdsEntry = RECORD		length:					INTEGER;								{ length of buffer }		ptr:					^CHAR;									{ pointer to buffer }	END;	rdsEntry = RECORD		length:					INTEGER;								{ length of buffer }		ptr:					^CHAR;									{ pointer to buffer }	END;	BufferPtr = LONGINT;	StreamPtr = LONGINT;CONST	netUnreach					= 0;	hostUnreach					= 1;	protocolUnreach				= 2;	portUnreach					= 3;	fragReqd					= 4;	sourceRouteFailed			= 5;	timeExceeded				= 6;	parmProblem					= 7;	missingOption				= 8;	TYPEICMPMsgType = INTEGER;	ip_port = b_16;	ICMPReport = RECORD		streamPtr:				StreamPtr;		localHost:				ip_addr;		localPort:				ip_port;		remoteHost:				ip_addr;		remotePort:				ip_port;		reportType:				INTEGER;		optionalAddlInfo:		INTEGER;		optionalAddlInfoPtr:	LONGINT;	END;	OSErrProcPtr = ProcPtr;  { FUNCTION OSErr: OSErr; }	OSErrUPP = UniversalProcPtr;CONST	uppOSErrProcInfo = $00000021; { FUNCTION (): 2 byte result; }FUNCTION NewOSErrProc(userRoutine: OSErrProcPtr): OSErrUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION CallOSErrProc(userRoutine: OSErrUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}TYPE	PtrProcPtr = ProcPtr;  { FUNCTION Ptr: Ptr; }	PtrUPP = UniversalProcPtr;CONST	uppPtrProcInfo = $00000031; { FUNCTION (): 4 byte result; }FUNCTION NewPtrProc(userRoutine: PtrProcPtr): PtrUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION CallPtrProc(userRoutine: PtrUPP): Ptr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}TYPE	BooleanProcPtr = ProcPtr;  { FUNCTION Boolean: BOOLEAN; }	BooleanUPP = UniversalProcPtr;CONST	uppBooleanProcInfo = $00000011; { FUNCTION (): 1 byte result; }FUNCTION NewBooleanProc(userRoutine: BooleanProcPtr): BooleanUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION CallBooleanProc(userRoutine: BooleanUPP): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}CONST	NUM_ALT_ADDRS				= 4;TYPE	hostInfo = RECORD		rtnCode:				LONGINT;		cname:					ARRAY [0..254] OF CHAR;		filler:					SInt8;									{ Filler for proper byte alignment	 }		addr:					ARRAY [0..NUM_ALT_ADDRS-1] OF LONGINT;	END;CONST	kA							= 1;	kNS							= 2;	kCNAME						= 5;	kHINFO						= 13;	kMX							= 15;	TYPEAddrClasses = INTEGER;	HInfoRec = RECORD		cpuType:				ARRAY [0..29] OF CHAR;		osType:					ARRAY [0..29] OF CHAR;	END;	MXRec = RECORD		preference:				INTEGER;		exchange:				ARRAY [0..254] OF CHAR;	END;	returnRec = RECORD		rtnCode:				LONGINT;		cname:					ARRAY [0..254] OF CHAR;		filler:					SInt8;									{ Filler for proper byte alignment	 }		CASE INTEGER OF		0: (			addr:						ARRAY [0..NUM_ALT_ADDRS-1] OF LONGINT;		   );		1: (			hinfo:						HInfoRec;		   );		2: (			mx:							MXRec;		   );	END;	cacheEntryRecord = RECORD		cname:					^CHAR;		ctype:					INTEGER;		cacheClass:				INTEGER;		ttl:					LONGINT;		CASE INTEGER OF		0: (			name:						^CHAR;		   );		1: (			addr:						ip_addr;		   );	END;	EnumResultProcPtr = ProcPtr;  { PROCEDURE EnumResult(VAR cacheEntryRecordPtr: cacheEntryRecord; VAR userDataPtr: CHAR); }	EnumResultUPP = UniversalProcPtr;CONST	uppEnumResultProcInfo = $000003C0; { PROCEDURE (4 byte param, 4 byte param); }FUNCTION NewEnumResultProc(userRoutine: EnumResultProcPtr): EnumResultUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}PROCEDURE CallEnumResultProc(VAR cacheEntryRecordPtr: cacheEntryRecord; VAR userDataPtr: CHAR; userRoutine: EnumResultUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}TYPE	ResultProcPtr = ProcPtr;  { PROCEDURE Result(VAR hostInfoPtr: hostInfo; VAR userDataPtr: CHAR); }	ResultUPP = UniversalProcPtr;CONST	uppResultProcInfo = $000003C0; { PROCEDURE (4 byte param, 4 byte param); }FUNCTION NewResultProc(userRoutine: ResultProcPtr): ResultUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}PROCEDURE CallResultProc(VAR hostInfoPtr: hostInfo; VAR userDataPtr: CHAR; userRoutine: ResultUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}TYPE	Result2ProcPtr = ProcPtr;  { PROCEDURE Result2(VAR returnRecPtr: returnRec; VAR userDataPtr: CHAR); }	Result2UPP = UniversalProcPtr;CONST	uppResult2ProcInfo = $000003C0; { PROCEDURE (4 byte param, 4 byte param); }FUNCTION NewResult2Proc(userRoutine: Result2ProcPtr): Result2UPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}PROCEDURE CallResult2Proc(VAR returnRecPtr: returnRec; VAR userDataPtr: CHAR; userRoutine: Result2UPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION OpenResolver(VAR fileName: CHAR): OSErr;FUNCTION StrToAddr(VAR hostName: CHAR; VAR hostInfoPtr: hostInfo; ResultProc: ResultUPP; VAR userDataPtr: CHAR): OSErr;FUNCTION AddrToStr(addr: LONGINT; VAR addrStr: CHAR): OSErr;FUNCTION EnumCache(enumResultProc: EnumResultUPP; VAR userDataPtr: CHAR): OSErr;FUNCTION AddrToName(addr: ip_addr; VAR hostInfoPtr: hostInfo; ResultProc: ResultUPP; VAR userDataPtr: CHAR): OSErr;FUNCTION HInfo(VAR hostName: CHAR; VAR returnRecPtr: returnRec; resultProc: Result2UPP; VAR userDataPtr: CHAR): OSErr;FUNCTION MXInfo(VAR hostName: CHAR; VAR returnRecPtr: returnRec; resultProc: Result2UPP; VAR userDataPtr: CHAR): OSErr;FUNCTION CloseResolver: OSErr;{ csCode to get our IP address }CONST	ipctlGetAddr				= 15;TYPE	GetAddrParamBlock = RECORD		qLink:					^QElem;		qType:					INTEGER;		ioTrap:					INTEGER;		ioCmdAddr:				Ptr;		ioCompletion:			UniversalProcPtr;		ioResult:				OSErr;		ioNamePtr:				StringPtr;		ioVRefNum:				INTEGER;		ioCRefNum:				INTEGER;		csCode:					INTEGER;								{ standard I/O header }		ourAddress:				ip_addr;								{ our IP address }		ourNetMask:				LONGINT;								{ our IP net mask }	END;{ control codes }CONST	ipctlEchoICMP				= 17;							{ send icmp echo }	ipctlLAPStats				= 19;							{ get lap stats }TYPE	ICMPParamBlock = RECORD		qLink:					^QElem;		qType:					INTEGER;		ioTrap:					INTEGER;		ioCmdAddr:				Ptr;		ioCompletion:			UniversalProcPtr;		ioResult:				OSErr;		ioNamePtr:				StringPtr;		ioVRefNum:				INTEGER;		ioCRefNum:				INTEGER;		csCode:					INTEGER;								{ standard I/O header }		params:					ARRAY [0..10] OF INTEGER;		icmpEchoInfo:			RECORD				echoRequestOut:					LONGINT;						{ time in ticks of when the echo request went out }				echoReplyIn:					LONGINT;						{ time in ticks of when the reply was received }				echoedData:						rdsEntry;						{ data received in responce }				options:						Ptr;				userDataPtr:					LONGINT;			END;	END;CONST	NBP_TABLE_SIZE				= 20;							{ number of NBP table entries }	NBP_MAX_NAME_SIZE			= 16 + 10 + 2;TYPE	nbp_entry = RECORD		ip_address:				ip_addr;								{ IP address }		at_address:				AddrBlock;								{ matching AppleTalk address }		gateway:				BOOLEAN;								{ TRUE if entry for a gateway }		valid:					BOOLEAN;								{ TRUE if LAP address is valid }		probing:				BOOLEAN;								{ TRUE if NBP lookup pending }		afiller:				SInt8;									{ Filler for proper byte alignment	 }		age:					LONGINT;								{ ticks since cache entry verified }		access:					LONGINT;								{ ticks since last access }		filler:					ARRAY [0..115] OF CHAR;					{ for internal use only !!! }	END;{ number of ARP table entries }CONST	ARP_TABLE_SIZE				= 20;TYPE	Enet_addr = RECORD		en_hi:					b_16;		en_lo:					b_32;	END;	arp_entry = RECORD		age:					INTEGER;								{ cache aging field }		protocol:				b_16;									{ Protocol type }		ip_address:				ip_addr;								{ IP address }		en_address:				Enet_addr;								{ matching Ethernet address }	END;{ Command codes }CONST	TCPCreate					= 30;	TCPPassiveOpen				= 31;	TCPActiveOpen				= 32;	TCPSend						= 34;	TCPNoCopyRcv				= 35;	TCPRcvBfrReturn				= 36;	TCPRcv						= 37;	TCPClose					= 38;	TCPAbort					= 39;	TCPStatus					= 40;	TCPExtendedStat				= 41;	TCPRelease					= 42;	TCPGlobalInfo				= 43;	TCPCtlMax					= 49;TYPE	ICMPEchoNotifyProcPtr = ProcPtr;  { PROCEDURE ICMPEchoNotify(VAR iopb: ICMPParamBlock); }	ICMPEchoNotifyUPP = UniversalProcPtr;CONST	uppICMPEchoNotifyProcInfo = $000000C1; { PROCEDURE (4 byte param); }FUNCTION NewICMPEchoNotifyProc(userRoutine: ICMPEchoNotifyProcPtr): ICMPEchoNotifyUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}PROCEDURE CallICMPEchoNotifyProc(VAR iopb: ICMPParamBlock; userRoutine: ICMPEchoNotifyUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}TYPE	IPParamBlock = RECORD		qLink:					^QElem;		qType:					INTEGER;		ioTrap:					INTEGER;		ioCmdAddr:				Ptr;		ioCompletion:			UniversalProcPtr;		ioResult:				OSErr;		ioNamePtr:				StringPtr;		ioVRefNum:				INTEGER;		ioCRefNum:				INTEGER;		csCode:					INTEGER;								{ standard I/O header }		CASE INTEGER OF		0: (			dest:						ip_addr;							{ echo to IP address }			data:						wdsEntry;			timeout:					INTEGER;			options:					Ptr;			optLength:					INTEGER;			icmpCompletion:				ICMPEchoNotifyUPP;			userDataPtr:				LONGINT;		   );		1: (			lapStatsPtr:				^LAPStats;		   );	END;	AddressXlation = RECORD		CASE INTEGER OF		0: (			arp_table:					^arp_entry;		   );		1: (			nbp_table:					^nbp_entry;		   );	END;	LAPStats = RECORD		ifType:					INTEGER;		ifString:				^CHAR;		ifMaxMTU:				INTEGER;		ifSpeed:				LONGINT;		ifPhyAddrLength:		INTEGER;		ifPhysicalAddress:		^CHAR;		AddrXlation:			AddressXlation;		slotNumber:				INTEGER;	END;CONST	TCPClosing					= 1;	TCPULPTimeout				= 2;	TCPTerminate				= 3;	TCPDataArrival				= 4;	TCPUrgent					= 5;	TCPICMPReceived				= 6;	TYPETCPEventCode = INTEGER;CONST	TCPRemoteAbort				= 2;	TCPNetworkFailure			= 3;	TCPSecPrecMismatch			= 4;	TCPULPTimeoutTerminate		= 5;	TCPULPAbort					= 6;	TCPULPClose					= 7;	TCPServiceError				= 8;	TYPETCPTerminationReason = INTEGER;	TCPNotifyProcPtr = ProcPtr;  { PROCEDURE TCPNotify(tcpStream: StreamPtr; eventCode: INTEGER; userDataPtr: Ptr; terminReason: INTEGER; VAR icmpMsg: ICMPReport); }	TCPNotifyUPP = UniversalProcPtr;CONST	uppTCPNotifyProcInfo = $0000EEC0; { PROCEDURE (4 byte param, 2 byte param, 4 byte param, 2 byte param, 4 byte param); }FUNCTION NewTCPNotifyProc(userRoutine: TCPNotifyProcPtr): TCPNotifyUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}PROCEDURE CallTCPNotifyProc(tcpStream: StreamPtr; eventCode: INTEGER; userDataPtr: Ptr; terminReason: INTEGER; VAR icmpMsg: ICMPReport; userRoutine: TCPNotifyUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}	TYPEtcp_port = INTEGER;{ ValidityFlags }CONST	timeoutValue				= $80;	timeoutAction				= $40;	typeOfService				= $20;	precedence					= $10;{ TOSFlags }	lowDelay					= $01;	throughPut					= $02;	reliability					= $04;TYPE	TCPCreatePB = RECORD		rcvBuff:				Ptr;		rcvBuffLen:				LONGINT;		notifyProc:				TCPNotifyUPP;		userDataPtr:			Ptr;	END;	TCPOpenPB = RECORD		ulpTimeoutValue:		SInt8;		ulpTimeoutAction:		SInt8;		validityFlags:			SInt8;		commandTimeoutValue:	SInt8;		remoteHost:				ip_addr;		remotePort:				tcp_port;		localHost:				ip_addr;		localPort:				tcp_port;		tosFlags:				SInt8;		precedence:				SInt8;		dontFrag:				BOOLEAN;		timeToLive:				SInt8;		security:				SInt8;		optionCnt:				SInt8;		options:				ARRAY [0..39] OF SInt8;		userDataPtr:			Ptr;	END;	TCPSendPB = RECORD		ulpTimeoutValue:		SInt8;		ulpTimeoutAction:		SInt8;		validityFlags:			SInt8;		filler:					SInt8;									{ Filler for proper byte alignment	 }		pushFlag:				BOOLEAN;		urgentFlag:				BOOLEAN;		wdsPtr:					Ptr;		sendFree:				LONGINT;		sendLength:				INTEGER;		userDataPtr:			Ptr;	END;{ for receive and return rcv buff calls }	TCPReceivePB = RECORD		commandTimeoutValue:	SInt8;		filler:					SInt8;		markFlag:				BOOLEAN;		urgentFlag:				BOOLEAN;		rcvBuff:				Ptr;		rcvBuffLen:				INTEGER;		rdsPtr:					Ptr;		rdsLength:				INTEGER;		secondTimeStamp:		INTEGER;		userDataPtr:			Ptr;	END;	TCPClosePB = RECORD		ulpTimeoutValue:		SInt8;		ulpTimeoutAction:		SInt8;		validityFlags:			SInt8;		filler:					SInt8;									{ Filler for proper byte alignment	 }		userDataPtr:			Ptr;	END;	HistoBucket = RECORD		value:					INTEGER;		counter:				LONGINT;	END;CONST	NumOfHistoBuckets			= 7;TYPE	TCPConnectionStats = RECORD		dataPktsRcvd:			LONGINT;		dataPktsSent:			LONGINT;		dataPktsResent:			LONGINT;		bytesRcvd:				LONGINT;		bytesRcvdDup:			LONGINT;		bytesRcvdPastWindow:	LONGINT;		bytesSent:				LONGINT;		bytesResent:			LONGINT;		numHistoBuckets:		INTEGER;		sentSizeHisto:			ARRAY [0..NumOfHistoBuckets-1] OF HistoBucket;		lastRTT:				INTEGER;		tmrSRTT:				INTEGER;		rttVariance:			INTEGER;		tmrRTO:					INTEGER;		sendTries:				SInt8;		sourchQuenchRcvd:		SInt8;	END;	TCPStatusPB = RECORD		ulpTimeoutValue:		SInt8;		ulpTimeoutAction:		SInt8;		unused:					LONGINT;		remoteHost:				ip_addr;		remotePort:				tcp_port;		localHost:				ip_addr;		localPort:				tcp_port;		tosFlags:				SInt8;		precedence:				SInt8;		connectionState:		SInt8;		filler:					SInt8;									{ Filler for proper byte alignment	 }		sendWindow:				INTEGER;		rcvWindow:				INTEGER;		amtUnackedData:			INTEGER;		amtUnreadData:			INTEGER;		securityLevelPtr:		Ptr;		sendUnacked:			LONGINT;		sendNext:				LONGINT;		congestionWindow:		LONGINT;		rcvNext:				LONGINT;		srtt:					LONGINT;		lastRTT:				LONGINT;		sendMaxSegSize:			LONGINT;		connStatPtr:			^TCPConnectionStats;		userDataPtr:			Ptr;	END;	TCPAbortPB = RECORD		userDataPtr:			Ptr;	END;	TCPParam = RECORD		tcpRtoA:				LONGINT;		tcpRtoMin:				LONGINT;		tcpRtoMax:				LONGINT;		tcpMaxSegSize:			LONGINT;		tcpMaxConn:				LONGINT;		tcpMaxWindow:			LONGINT;	END;	TCPStats = RECORD		tcpConnAttempts:		LONGINT;		tcpConnOpened:			LONGINT;		tcpConnAccepted:		LONGINT;		tcpConnClosed:			LONGINT;		tcpConnAborted:			LONGINT;		tcpOctetsIn:			LONGINT;		tcpOctetsOut:			LONGINT;		tcpOctetsInDup:			LONGINT;		tcpOctetsRetrans:		LONGINT;		tcpInputPkts:			LONGINT;		tcpOutputPkts:			LONGINT;		tcpDupPkts:				LONGINT;		tcpRetransPkts:			LONGINT;	END;	StreamPPtr = ^StreamPtr;	TCPGlobalInfoPB = RECORD		tcpParamPtr:			^TCPParam;		tcpStatsPtr:			^TCPStats;		tcpCDBTable:			ARRAY [0..0] OF StreamPPtr;		userDataPtr:			Ptr;		maxTCPConnections:		INTEGER;	END;	TCPIOCompletionProcPtr = ProcPtr;  { PROCEDURE TCPIOCompletion(VAR iopb: TCPiopb); }	TCPIOCompletionUPP = UniversalProcPtr;	TCPiopb = RECORD		fill12:					ARRAY [0..11] OF CHAR;		ioCompletion:			TCPIOCompletionUPP;		ioResult:				INTEGER;		ioNamePtr:				^CHAR;		ioVRefNum:				INTEGER;		ioCRefNum:				INTEGER;		csCode:					INTEGER;		tcpStream:				StreamPtr;		CASE INTEGER OF		0: (			create:						TCPCreatePB;		   );		1: (			open:						TCPOpenPB;		   );		2: (			send:						TCPSendPB;		   );		3: (			receive:					TCPReceivePB;		   );		4: (			close:						TCPClosePB;		   );		5: (			abort:						TCPAbortPB;		   );		6: (			status:						TCPStatusPB;		   );		7: (			globalInfo:					TCPGlobalInfoPB;		   );	END;CONST	uppTCPIOCompletionProcInfo = $000000C1; { PROCEDURE (4 byte param); }FUNCTION NewTCPIOCompletionProc(userRoutine: TCPIOCompletionProcPtr): TCPIOCompletionUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}PROCEDURE CallTCPIOCompletionProc(VAR iopb: TCPiopb; userRoutine: TCPIOCompletionUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}CONST	UDPCreate					= 20;	UDPRead						= 21;	UDPBfrReturn				= 22;	UDPWrite					= 23;	UDPRelease					= 24;	UDPMaxMTUSize				= 25;	UDPStatus					= 26;	UDPMultiCreate				= 27;	UDPMultiSend				= 28;	UDPMultiRead				= 29;	UDPCtlMax					= 29;	UDPDataArrival				= 1;	UDPICMPReceived				= 2;	TYPEUDPEventCode = INTEGER;	UDPNotifyProcPtr = ProcPtr;  { PROCEDURE UDPNotify(udpStream: StreamPtr; eventCode: INTEGER; userDataPtr: Ptr; VAR icmpMsg: ICMPReport); }	UDPNotifyUPP = UniversalProcPtr;CONST	uppUDPNotifyProcInfo = $00003EC0; { PROCEDURE (4 byte param, 2 byte param, 4 byte param, 4 byte param); }FUNCTION NewUDPNotifyProc(userRoutine: UDPNotifyProcPtr): UDPNotifyUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}PROCEDURE CallUDPNotifyProc(udpStream: StreamPtr; eventCode: INTEGER; userDataPtr: Ptr; VAR icmpMsg: ICMPReport; userRoutine: UDPNotifyUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}	TYPEudp_port = INTEGER;{ for create and release calls }	UDPCreatePB = RECORD		rcvBuff:				Ptr;		rcvBuffLen:				LONGINT;		notifyProc:				UDPNotifyUPP;		localPort:				INTEGER;		userDataPtr:			Ptr;		endingPort:				udp_port;	END;	UDPSendPB = RECORD		reserved:				INTEGER;		remoteHost:				ip_addr;		remotePort:				udp_port;		wdsPtr:					Ptr;		checkSum:				BOOLEAN;		filler:					SInt8;									{ Filler for proper byte alignment	 }		sendLength:				INTEGER;		userDataPtr:			Ptr;		localPort:				udp_port;	END;{ for receive and buffer return calls }	UDPReceivePB = RECORD		timeOut:				INTEGER;		remoteHost:				ip_addr;		remotePort:				udp_port;		rcvBuff:				Ptr;		rcvBuffLen:				INTEGER;		secondTimeStamp:		INTEGER;		userDataPtr:			Ptr;		destHost:				ip_addr;								{ only for use with multi rcv }		destPort:				udp_port;								{ only for use with multi rcv }	END;	UDPMTUPB = RECORD		mtuSize:				INTEGER;		remoteHost:				ip_addr;		userDataPtr:			Ptr;	END;	UDPIOCompletionProcPtr = ProcPtr;  { PROCEDURE UDPIOCompletion(VAR iopb: UDPiopb); }	UDPIOCompletionUPP = UniversalProcPtr;	UDPiopb = RECORD		fill12:					ARRAY [0..11] OF CHAR;		ioCompletion:			UDPIOCompletionUPP;		ioResult:				INTEGER;		ioNamePtr:				^CHAR;		ioVRefNum:				INTEGER;		ioCRefNum:				INTEGER;		csCode:					INTEGER;		udpStream:				StreamPtr;		CASE INTEGER OF		0: (			create:						UDPCreatePB;		   );		1: (			send:						UDPSendPB;		   );		2: (			receive:					UDPReceivePB;		   );		3: (			mtu:						UDPMTUPB;		   );	END;CONST	uppUDPIOCompletionProcInfo = $000000C1; { PROCEDURE (4 byte param); }FUNCTION NewUDPIOCompletionProc(userRoutine: UDPIOCompletionProcPtr): UDPIOCompletionUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}PROCEDURE CallUDPIOCompletionProc(VAR iopb: UDPiopb; userRoutine: UDPIOCompletionUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := MacTCPIncludes}{$ENDC} {__MACTCP__}{$IFC NOT UsingIncludes} END.{$ENDC}