{ 	File:		Events.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT Events; INTERFACE{$ENDC}{$IFC UNDEFINED __EVENTS__}{$SETC __EVENTS__ := 1}{$I+}{$SETC EventsIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __TYPES__}{$I Types.p}{$ENDC}{	ConditionalMacros.p											}{$IFC UNDEFINED __QUICKDRAW__}{$I Quickdraw.p}{$ENDC}{	MixedMode.p													}{	QuickdrawText.p												}{$IFC UNDEFINED __OSUTILS__}{$I OSUtils.p}{$ENDC}{$PUSH}{$ALIGN MAC68K}{$LibExport+}CONST	nullEvent					= 0;	mouseDown					= 1;	mouseUp						= 2;	keyDown						= 3;	keyUp						= 4;	autoKey						= 5;	updateEvt					= 6;	diskEvt						= 7;	activateEvt					= 8;	osEvt						= 15;{ event mask equates }	mDownMask					= $0002;						{ mouse button pressed }	mUpMask						= $0004;						{ mouse button released }	keyDownMask					= $0008;						{ key pressed }	keyUpMask					= $0010;						{ key released }	autoKeyMask					= $0020;						{ key repeatedly held down }	updateMask					= $0040;						{ window needs updating }	diskMask					= $0080;						{ disk inserted }	activMask					= $0100;						{ activate/deactivate window }	highLevelEventMask			= $0400;						{ high-level events (includes AppleEvents) }	osMask						= $8000;						{ operating system events (suspend, resume) }	everyEvent					= $FFFFFFFF;{ event message equates }	charCodeMask				= $000000FF;	keyCodeMask					= $0000FF00;	adbAddrMask					= $00FF0000;	osEvtMessageMask			= $FF000000;{ OS event messages.  Event (sub)code is in the high byte of the message field. }	mouseMovedMessage			= $00FA;	suspendResumeMessage		= $0001;	resumeFlag					= 1;							{ Bit 0 of message indicates resume vs suspend }	convertClipboardFlag		= 2;							{ Bit 1 in resume message indicates clipboard change }{ modifiers }	activeFlag					= $0001;						{ Bit 0 of modifiers for activateEvt and mouseDown events }	btnState					= $0080;						{ Bit 7 of low byte is mouse button state }	cmdKey						= $0100;						{ Bit 0 of high byte }	shiftKey					= $0200;						{ Bit 1 of high byte }	alphaLock					= $0400;						{ Bit 2 of high byte }	optionKey					= $0800;						{ Bit 3 of high byte }	controlKey					= $1000;						{ Bit 4 of high byte }{ obsolete equates }	networkEvt					= 10;	driverEvt					= 11;	app1Evt						= 12;	app2Evt						= 13;	app3Evt						= 14;	app4Evt						= 15;	networkMask					= $0400;	driverMask					= $0800;	app1Mask					= $1000;	app2Mask					= $2000;	app3Mask					= $4000;	app4Mask					= $8000;TYPE	EventRecord = RECORD		what:					INTEGER;		message:				LONGINT;		when:					LONGINT;		where:					Point;		modifiers:				INTEGER;	END;	KeyMap = PACKED ARRAY [0..127] OF BOOLEAN;	EvQEl = RECORD		qLink:					QElemPtr;		qType:					INTEGER;		evtQWhat:				INTEGER;								{ this part is identical to the EventRecord as... }		evtQMessage:			LONGINT;								{ defined in ToolIntf }		evtQWhen:				LONGINT;		evtQWhere:				Point;		evtQModifiers:			INTEGER;	END;	EvQElPtr = ^EvQEl;	GetNextEventFilterProcPtr = ProcPtr;  { PROCEDURE GetNextEventFilter(VAR theEvent: EventRecord; VAR result: BOOLEAN); }	GetNextEventFilterUPP = UniversalProcPtr;CONST	uppGetNextEventFilterProcInfo = $000000BF; { SPECIAL_CASE_PROCINFO( kSpecialCaseGNEFilterProc ) }FUNCTION NewGetNextEventFilterProc(userRoutine: GetNextEventFilterProcPtr): GetNextEventFilterUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}PROCEDURE CallGetNextEventFilterProc(VAR theEvent: EventRecord; VAR result: BOOLEAN; userRoutine: GetNextEventFilterUPP);	{$IFC NOT GENERATINGCFM}	{To be implemented:  Glue to move parameters according to special case conventions.}	{$ENDC}	TYPEGNEFilterUPP = GetNextEventFilterUPP;FUNCTION GetDblTime : LONGINT;	{$IFC NOT CFMSYSTEMCALLS}	INLINE $2EB8, $02F0;			{ MOVE.L $02F0,(SP) }	{$ENDC}FUNCTION GetCaretTime : LONGINT;	{$IFC NOT CFMSYSTEMCALLS}	INLINE $2EB8, $02F4;			{ MOVE.L $02F4,(SP) }	{$ENDC}PROCEDURE SetEventMask( value: INTEGER );	{$IFC NOT CFMSYSTEMCALLS}	INLINE $31DF, $0144;			{ MOVE.W (SP)+,$0144 }	{$ENDC}FUNCTION GetEventQueue: QHdrPtr;	{$IFC NOT GENERATINGCFM}	INLINE $2EBC, $0000, $014A;	{$ENDC}FUNCTION GetNextEvent(eventMask: INTEGER; VAR theEvent: EventRecord): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $A970;	{$ENDC}FUNCTION WaitNextEvent(eventMask: INTEGER; VAR theEvent: EventRecord; sleep: LONGINT; mouseRgn: RgnHandle): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $A860;	{$ENDC}FUNCTION EventAvail(eventMask: INTEGER; VAR theEvent: EventRecord): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $A971;	{$ENDC}PROCEDURE GetMouse(VAR mouseLoc: Point);	{$IFC NOT GENERATINGCFM}	INLINE $A972;	{$ENDC}FUNCTION Button: BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $A974;	{$ENDC}FUNCTION StillDown: BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $A973;	{$ENDC}FUNCTION WaitMouseUp: BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $A977;	{$ENDC}PROCEDURE GetKeys(VAR theKeys: KeyMap);	{$IFC NOT GENERATINGCFM}	INLINE $A976;	{$ENDC}FUNCTION KeyTranslate(transData: UNIV Ptr; keycode: INTEGER; VAR state: LONGINT): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $A9C3;	{$ENDC}FUNCTION TickCount: LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $A975;	{$ENDC}FUNCTION PostEvent(eventNum: INTEGER; eventMsg: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $201F, $305F, $A02F, $3E80;	{$ENDC}FUNCTION PPostEvent(eventCode: INTEGER; eventMsg: LONGINT; VAR qEl: EvQElPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $225F, $201F, $305F, $A12F, $2288, $3E80;	{$ENDC}FUNCTION OSEventAvail(mask: INTEGER; VAR theEvent: EventRecord): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $301F, $A030, $5240, $1E80;	{$ENDC}FUNCTION GetOSEvent(mask: INTEGER; VAR theEvent: EventRecord): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $301F, $A031, $5240, $1E80;	{$ENDC}PROCEDURE FlushEvents(whichMask: INTEGER; stopMask: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $201F, $A032;	{$ENDC}PROCEDURE SystemClick(theEvent: EventRecord; theWindow: WindowPtr);	{$IFC NOT GENERATINGCFM}	INLINE $A9B3;	{$ENDC}PROCEDURE SystemTask;	{$IFC NOT GENERATINGCFM}	INLINE $A9B4;	{$ENDC}FUNCTION SystemEvent(theEvent: EventRecord): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $A9B2;	{$ENDC}{$IFC OLDROUTINENAMES }FUNCTION KeyTrans(transData: UNIV Ptr; keycode: INTEGER; VAR state: LONGINT): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $A9C3;	{$ENDC}FUNCTION GetEvQHdr: QHdrPtr;	{$IFC NOT GENERATINGCFM}	INLINE $2EBC, $0000, $014A;	{$ENDC}{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := EventsIncludes}{$ENDC} {__EVENTS__}{$IFC NOT UsingIncludes} END.{$ENDC}