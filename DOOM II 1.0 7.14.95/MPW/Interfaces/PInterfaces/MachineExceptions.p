{ 	File:		MachineExceptions.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.1  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT MachineExceptions; INTERFACE{$ENDC}{$IFC UNDEFINED __MACHINEEXCEPTIONS__}{$SETC __MACHINEEXCEPTIONS__ := 1}{$I+}{$SETC MachineExceptionsIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __TYPES__}{$I Types.p}{$ENDC}{	ConditionalMacros.p											}{$PUSH}{$ALIGN MAC68K}{$LibExport+}	TYPERef = Ptr;	OSStatus = LONGINT;	AreaID = Ref;	LogicalAddress = Ref;{ Machine Dependent types for PowerPC }	MachineInformation = RECORD		CTR:					UnsignedWide;		LR:						UnsignedWide;		PC:						UnsignedWide;		CR:						LONGINT;		XER:					LONGINT;		MSR:					LONGINT;	END;	RegisterInformation = RECORD		R0:						UnsignedWide;		R1:						UnsignedWide;		R2:						UnsignedWide;		R3:						UnsignedWide;		R4:						UnsignedWide;		R5:						UnsignedWide;		R6:						UnsignedWide;		R7:						UnsignedWide;		R8:						UnsignedWide;		R9:						UnsignedWide;		R10:					UnsignedWide;		R11:					UnsignedWide;		R12:					UnsignedWide;		R13:					UnsignedWide;		R14:					UnsignedWide;		R15:					UnsignedWide;		R16:					UnsignedWide;		R17:					UnsignedWide;		R18:					UnsignedWide;		R19:					UnsignedWide;		R20:					UnsignedWide;		R21:					UnsignedWide;		R22:					UnsignedWide;		R23:					UnsignedWide;		R24:					UnsignedWide;		R25:					UnsignedWide;		R26:					UnsignedWide;		R27:					UnsignedWide;		R28:					UnsignedWide;		R29:					UnsignedWide;		R30:					UnsignedWide;		R31:					UnsignedWide;	END;	FPUInformation = RECORD		Registers:				ARRAY [0..31] OF UnsignedWide;		FPSCR:					LONGINT;	END;{ Exception related declarations }CONST	writeReference				= 0;	readReference				= 1;	fetchReference				= 2;	TYPEMemoryReferenceKind = LONGINT;	MemoryExceptionInformation = RECORD		theArea:				AreaID;		theAddress:				LogicalAddress;		theError:				OSStatus;		theReference:			MemoryReferenceKind;	END;CONST	unknownException			= 0;	illegalInstructionException	= 1;	trapException				= 2;	accessException				= 3;	unmappedMemoryException		= 4;	excludedMemoryException		= 5;	readOnlyMemoryException		= 6;	unresolvablePageFaultException = 7;	privilegeViolationException	= 8;	traceException				= 9;	instructionBreakpointException = 10;	dataBreakpointException		= 11;	integerException			= 12;	floatingPointException		= 13;	stackOverflowException		= 14;	terminationException		= 15;	TYPEExceptionKind = LONGINT;	ExceptionInfo = RECORD		CASE INTEGER OF		0: (			memoryInfo:					^MemoryExceptionInformation;		   );	END;	ExceptionInformation = RECORD		theKind:				ExceptionKind;		machineState:			^MachineInformation;		registerImage:			^RegisterInformation;		FPUImage:				^FPUInformation;		info:					ExceptionInfo;	END;{ Note: An ExceptionHandler is NOT a UniversalProcPtr. It must be   a native PowerPC transition vector with NO routine descriptor. }	ExceptionHandler = ProcPtr;  { FUNCTION (VAR theException: ExceptionInformation): OSStatus; }FUNCTION InstallExceptionHandler(theHandler: ExceptionHandler): ExceptionHandler;{$ALIGN RESET}{$POP}{$SETC UsingIncludes := MachineExceptionsIncludes}{$ENDC} {__MACHINEEXCEPTIONS__}{$IFC NOT UsingIncludes} END.{$ENDC}