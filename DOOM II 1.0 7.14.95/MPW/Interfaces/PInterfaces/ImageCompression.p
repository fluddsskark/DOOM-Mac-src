{ 	File:		ImageCompression.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT ImageCompression; INTERFACE{$ENDC}{$IFC UNDEFINED __IMAGECOMPRESSION__}{$SETC __IMAGECOMPRESSION__ := 1}{$I+}{$SETC ImageCompressionIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __TYPES__}{$I Types.p}{$ENDC}{	ConditionalMacros.p											}{$IFC UNDEFINED __QUICKDRAW__}{$I Quickdraw.p}{$ENDC}{	MixedMode.p													}{	QuickdrawText.p												}{$IFC UNDEFINED __QDOFFSCREEN__}{$I QDOffscreen.p}{$ENDC}{	Errors.p													}{$IFC UNDEFINED __COMPONENTS__}{$I Components.p}{$ENDC}{$IFC UNDEFINED __WINDOWS__}{$I Windows.p}{$ENDC}{	Memory.p													}{	Events.p													}{		OSUtils.p												}{	Controls.p													}{		Menus.p													}{$IFC UNDEFINED __STANDARDFILE__}{$I StandardFile.p}{$ENDC}{	Dialogs.p													}{		TextEdit.p												}{	Files.p														}{$PUSH}{$ALIGN MAC68K}{$LibExport+}TYPE	MatrixRecord = RECORD		matrix:					ARRAY [0..2,0..2] OF Fixed;	END;	MatrixRecordPtr = ^MatrixRecord;	FixedPoint = RECORD		x:						Fixed;		y:						Fixed;	END;	FixedRect = RECORD		left:					Fixed;		top:					Fixed;		right:					Fixed;		bottom:					Fixed;	END;{ These are the bits that are set in the Component flags, and also in the codecInfo struct. }CONST	codecInfoDoes1				= 0+(1 * (2**(0)));	codecInfoDoes2				= 0+(1 * (2**(1)));	codecInfoDoes4				= 0+(1 * (2**(2)));	codecInfoDoes8				= 0+(1 * (2**(3)));	codecInfoDoes16				= 0+(1 * (2**(4)));	codecInfoDoes32				= 0+(1 * (2**(5)));	codecInfoDoesDither			= 0+(1 * (2**(6)));	codecInfoDoesStretch		= 0+(1 * (2**(7)));	codecInfoDoesShrink			= 0+(1 * (2**(8)));	codecInfoDoesMask			= 0+(1 * (2**(9)));	codecInfoDoesTemporal		= 0+(1 * (2**(10)));	codecInfoDoesDouble			= 0+(1 * (2**(11)));	codecInfoDoesQuad			= 0+(1 * (2**(12)));	codecInfoDoesHalf			= 0+(1 * (2**(13)));	codecInfoDoesQuarter		= 0+(1 * (2**(14)));	codecInfoDoesRotate			= 0+(1 * (2**(15)));	codecInfoDoesHorizFlip		= 0+(1 * (2**(16)));	codecInfoDoesVertFlip		= 0+(1 * (2**(17)));	codecInfoDoesSkew			= 0+(1 * (2**(18)));	codecInfoDoesBlend			= 0+(1 * (2**(19)));	codecInfoDoesWarp			= 0+(1 * (2**(20)));	codecInfoDoesRecompress		= 0+(1 * (2**(21)));	codecInfoDoesSpool			= 0+(1 * (2**(22)));	codecInfoDoesRateConstrain	= 0+(1 * (2**(23)));	codecInfoDepth1				= 0+(1 * (2**(0)));	codecInfoDepth2				= 0+(1 * (2**(1)));	codecInfoDepth4				= 0+(1 * (2**(2)));	codecInfoDepth8				= 0+(1 * (2**(3)));	codecInfoDepth16			= 0+(1 * (2**(4)));	codecInfoDepth32			= 0+(1 * (2**(5)));	codecInfoDepth24			= 0+(1 * (2**(6)));	codecInfoDepth33			= 0+(1 * (2**(7)));	codecInfoDepth34			= 0+(1 * (2**(8)));	codecInfoDepth36			= 0+(1 * (2**(9)));	codecInfoDepth40			= 0+(1 * (2**(10)));	codecInfoStoresClut			= 0+(1 * (2**(11)));	codecInfoDoesLossless		= 0+(1 * (2**(12)));	codecInfoSequenceSensitive	= 0+(1 * (2**(13)));	codecFlagUseImageBuffer		= 0+(1 * (2**(0)));	codecFlagUseScreenBuffer	= 0+(1 * (2**(1)));	codecFlagUpdatePrevious		= 0+(1 * (2**(2)));	codecFlagNoScreenUpdate		= 0+(1 * (2**(3)));	codecFlagWasCompressed		= 0+(1 * (2**(4)));	codecFlagDontOffscreen		= 0+(1 * (2**(5)));	codecFlagUpdatePreviousComp	= 0+(1 * (2**(6)));	codecFlagForceKeyFrame		= 0+(1 * (2**(7)));	codecFlagOnlyScreenUpdate	= 0+(1 * (2**(8)));	codecFlagLiveGrab			= 0+(1 * (2**(9)));	codecFlagDontUseNewImageBuffer = 0+(1 * (2**(10)));	codecFlagInterlaceUpdate	= 0+(1 * (2**(11)));	codeFlagCatchUpDiff			= 0+(1 * (2**(12)));	codecFlagUsedNewImageBuffer	= 0+(1 * (2**(14)));	codecFlagUsedImageBuffer	= 0+(1 * (2**(15)));{ The minimum data size for spooling in or out data }	codecMinimumDataSize		= 32768;	compressorComponentType		= 'imco';						{ the type for "Components" which compress images }	decompressorComponentType	= 'imdc';	TYPECompressorComponent = Component;	DecompressorComponent = Component;	CodecComponent = Component;CONST	anyCodec					= 0;							{ take first working codec of given type }	bestSpeedCodec				= -1;							{ take fastest codec of given type }	bestFidelityCodec			= -2;							{ take codec which is most accurate }	bestCompressionCodec		= -3;							{ take codec of given type that is most accurate }	TYPECodecType = LONGINT;	CodecFlags = INTEGER;	CodecQ = LONGINT;CONST	codecLosslessQuality		= $400;	codecMaxQuality				= $3ff;	codecMinQuality				= $000;	codecLowQuality				= $100;	codecNormalQuality			= $200;	codecHighQuality			= $300;	codecCompletionSource		= 0+(1 * (2**(0)));				{ asynchronous codec is done with source data }	codecCompletionDest			= 0+(1 * (2**(1)));				{ asynchronous codec is done with destination data }	codecProgressOpen			= 0;	codecProgressUpdatePercent	= 1;	codecProgressClose			= 2;TYPE	ICMDataProcPtr = ProcPtr;  { FUNCTION ICMData(VAR dataP: Ptr; bytesNeeded: LONGINT; refcon: LONGINT): OSErr; }	ICMFlushProcPtr = ProcPtr;  { FUNCTION ICMFlush(data: Ptr; bytesAdded: LONGINT; refcon: LONGINT): OSErr; }	ICMCompletionProcPtr = ProcPtr;  { PROCEDURE ICMCompletion(result: OSErr; flags: INTEGER; refcon: LONGINT); }	ICMProgressProcPtr = ProcPtr;  { FUNCTION ICMProgress(message: INTEGER; completeness: Fixed; refcon: LONGINT): OSErr; }	StdPixProcPtr = ProcPtr;  { PROCEDURE StdPix(VAR src: PixMap; VAR srcRect: Rect; VAR matrix: MatrixRecord; mode: INTEGER; mask: RgnHandle; VAR matte: PixMap; VAR matteRect: Rect; flags: INTEGER); }	ICMAlignmentProcPtr = ProcPtr;  { PROCEDURE ICMAlignment(VAR rp: Rect; refcon: LONGINT); }	ICMDataUPP = UniversalProcPtr;	ICMFlushUPP = UniversalProcPtr;	ICMCompletionUPP = UniversalProcPtr;	ICMProgressUPP = UniversalProcPtr;	StdPixUPP = UniversalProcPtr;	ICMAlignmentUPP = UniversalProcPtr;	ImageSequence = LONGINT;	ICMProgressProcRecord = RECORD		progressProc:			ICMProgressUPP;		progressRefCon:			LONGINT;	END;	ICMProgressProcRecordPtr = ^ICMProgressProcRecord;	ICMCompletionProcRecord = RECORD		completionProc:			ICMCompletionUPP;		completionRefCon:		LONGINT;	END;	ICMCompletionProcRecordPtr = ^ICMCompletionProcRecord;	ICMDataProcRecord = RECORD		dataProc:				ICMDataUPP;		dataRefCon:				LONGINT;	END;	ICMDataProcRecordPtr = ^ICMDataProcRecord;	ICMFlushProcRecord = RECORD		flushProc:				ICMFlushUPP;		flushRefCon:			LONGINT;	END;	ICMFlushProcRecordPtr = ^ICMFlushProcRecord;	ICMAlignmentProcRecord = RECORD		alignmentProc:			ICMAlignmentUPP;		alignmentRefCon:		LONGINT;	END;	ICMAlignmentProcRecordPtr = ^ICMAlignmentProcRecord;	DataRateParams = RECORD		dataRate:				LONGINT;		dataOverrun:			LONGINT;		frameDuration:			LONGINT;		keyFrameRate:			LONGINT;		minSpatialQuality:		CodecQ;		minTemporalQuality:		CodecQ;	END;	DataRateParamsPtr = ^DataRateParams;	ImageDescription = PACKED RECORD		idSize:					LONGINT;								{ total size of ImageDescription including extra data ( CLUTs and other per sequence data }		cType:					CodecType;								{ what kind of codec compressed this data }		resvd1:					LONGINT;								{ reserved for Apple use }		resvd2:					INTEGER;								{ reserved for Apple use }		dataRefIndex:			INTEGER;								{ set to zero  }		version:				INTEGER;								{ which version is this data }		revisionLevel:			INTEGER;								{ what version of that codec did this }		vendor:					LONGINT;								{ whose  codec compressed this data }		temporalQuality:		CodecQ;									{ what was the temporal quality factor  }		spatialQuality:			CodecQ;									{ what was the spatial quality factor }		width:					INTEGER;								{ how many pixels wide is this data }		height:					INTEGER;								{ how many pixels high is this data }		hRes:					Fixed;									{ horizontal resolution }		vRes:					Fixed;									{ vertical resolution }		dataSize:				LONGINT;								{ if known, the size of data for this image descriptor }		frameCount:				INTEGER;								{ number of frames this description applies to }		name:					Str31;									{ name of codec ( in case not installed )  }		depth:					INTEGER;								{ what depth is this data (1-32) or ( 33-40 grayscale ) }		clutID:					INTEGER;								{ clut id or if 0 clut follows  or -1 if no clut }	END;	ImageDescriptionPtr = ^ImageDescription;	ImageDescriptionHandle = ^ImageDescriptionPtr;	CodecInfo = PACKED RECORD		typeName:				Str31;									{ name of the codec type i.e.: 'Apple Image Compression' }		version:				INTEGER;								{ version of the codec data that this codec knows about }		revisionLevel:			INTEGER;								{ revision level of this codec i.e: 0x00010001 (1.0.1) }		vendor:					LONGINT;								{ Maker of this codec i.e: 'appl' }		decompressFlags:		LONGINT;								{ codecInfo flags for decompression capabilities }		compressFlags:			LONGINT;								{ codecInfo flags for compression capabilities }		formatFlags:			LONGINT;								{ codecInfo flags for compression format details }		compressionAccuracy:	UInt8;									{ measure (1-255) of accuracy of this codec for compress (0 if unknown) }		decompressionAccuracy:	UInt8;									{ measure (1-255) of accuracy of this codec for decompress (0 if unknown) }		compressionSpeed:		INTEGER;								{ ( millisecs for compressing 320x240 on base mac II) (0 if unknown)  }		decompressionSpeed:		INTEGER;								{ ( millisecs for decompressing 320x240 on mac II)(0 if unknown)  }		compressionLevel:		UInt8;									{ measure (1-255) of compression level of this codec (0 if unknown)  }		resvd:					UInt8;									{ pad }		minimumHeight:			INTEGER;								{ minimum height of image (block size) }		minimumWidth:			INTEGER;								{ minimum width of image (block size) }		decompressPipelineLatency: INTEGER;								{ in milliseconds ( for asynchronous codecs ) }		compressPipelineLatency: INTEGER;								{ in milliseconds ( for asynchronous codecs ) }		privateData:			LONGINT;	END;	CodecNameSpec = RECORD		codec:					CodecComponent;		cType:					CodecType;		typeName:				Str31;		name:					Handle;	END;	CodecNameSpecList = RECORD		count:					INTEGER;		list:					ARRAY [0..0] OF CodecNameSpec;	END;	CodecNameSpecListPtr = ^CodecNameSpecList;CONST	defaultDither				= 0;	forceDither					= 1;	suppressDither				= 2;	useColorMatching			= 4;TYPE	ICMFrameTimeRecord = RECORD		value:					wide;									{ frame time }		scale:					LONGINT;								{ timescale of value/duration fields }		base:					Ptr;									{ timebase }		duration:				LONGINT;								{ duration frame is to be displayed (0 if unknown) }		rate:					Fixed;									{ rate of timebase relative to wall-time }	END;	ICMFrameTimePtr = ^ICMFrameTimeRecord;CONST	uppICMDataProcInfo = $00000FE0; { FUNCTION (4 byte param, 4 byte param, 4 byte param): 2 byte result; }	uppICMFlushProcInfo = $00000FE0; { FUNCTION (4 byte param, 4 byte param, 4 byte param): 2 byte result; }	uppICMCompletionProcInfo = $00000E80; { PROCEDURE (2 byte param, 2 byte param, 4 byte param); }	uppICMProgressProcInfo = $00000FA0; { FUNCTION (2 byte param, 4 byte param, 4 byte param): 2 byte result; }	uppStdPixProcInfo = $002FEFC0; { PROCEDURE (4 byte param, 4 byte param, 4 byte param, 2 byte param, 4 byte param, 4 byte param, 4 byte param, 2 byte param); }	uppICMAlignmentProcInfo = $000003C0; { PROCEDURE (4 byte param, 4 byte param); }FUNCTION NewICMDataProc(userRoutine: ICMDataProcPtr): ICMDataUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewICMFlushProc(userRoutine: ICMFlushProcPtr): ICMFlushUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewICMCompletionProc(userRoutine: ICMCompletionProcPtr): ICMCompletionUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewICMProgressProc(userRoutine: ICMProgressProcPtr): ICMProgressUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewStdPixProc(userRoutine: StdPixProcPtr): StdPixUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewICMAlignmentProc(userRoutine: ICMAlignmentProcPtr): ICMAlignmentUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION CallICMDataProc(VAR dataP: Ptr; bytesNeeded: LONGINT; refcon: LONGINT; userRoutine: ICMDataUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallICMFlushProc(data: Ptr; bytesAdded: LONGINT; refcon: LONGINT; userRoutine: ICMFlushUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}PROCEDURE CallICMCompletionProc(result: OSErr; flags: INTEGER; refcon: LONGINT; userRoutine: ICMCompletionUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallICMProgressProc(message: INTEGER; completeness: Fixed; refcon: LONGINT; userRoutine: ICMProgressUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}PROCEDURE CallStdPixProc(VAR src: PixMap; VAR srcRect: Rect; VAR matrix: MatrixRecord; mode: INTEGER; mask: RgnHandle; VAR matte: PixMap; VAR matteRect: Rect; flags: INTEGER; userRoutine: StdPixUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}PROCEDURE CallICMAlignmentProc(VAR rp: Rect; refcon: LONGINT; userRoutine: ICMAlignmentUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CodecManagerVersion(VAR version: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7000, $AAA3;	{$ENDC}FUNCTION GetCodecNameList(VAR list: CodecNameSpecListPtr; showAll: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7001, $AAA3;	{$ENDC}FUNCTION DisposeCodecNameList(list: CodecNameSpecListPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $700F, $AAA3;	{$ENDC}FUNCTION GetCodecInfo(VAR info: CodecInfo; cType: CodecType; codec: CodecComponent): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7003, $AAA3;	{$ENDC}FUNCTION GetMaxCompressionSize(src: PixMapHandle; srcRect: Rect; colorDepth: INTEGER; quality: CodecQ; cType: CodecType; codec: CompressorComponent; VAR size: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7004, $AAA3;	{$ENDC}FUNCTION GetCompressionTime(src: PixMapHandle; srcRect: Rect; colorDepth: INTEGER; cType: CodecType; codec: CompressorComponent; VAR spatialQuality: CodecQ; VAR temporalQuality: CodecQ; VAR compressTime: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7005, $AAA3;	{$ENDC}FUNCTION CompressImage(src: PixMapHandle; srcRect: Rect; quality: CodecQ; cType: CodecType; desc: ImageDescriptionHandle; data: Ptr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7006, $AAA3;	{$ENDC}FUNCTION FCompressImage(src: PixMapHandle; srcRect: Rect; colorDepth: INTEGER; quality: CodecQ; cType: CodecType; codec: CompressorComponent; clut: CTabHandle; flags: CodecFlags; bufferSize: LONGINT; flushProc: ICMFlushProcRecordPtr; progressProc: ICMProgressProcRecordPtr; desc: ImageDescriptionHandle; data: Ptr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7007, $AAA3;	{$ENDC}FUNCTION DecompressImage(data: Ptr; desc: ImageDescriptionHandle; dst: PixMapHandle; srcRect: Rect; dstRect: Rect; mode: INTEGER; mask: RgnHandle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7008, $AAA3;	{$ENDC}FUNCTION FDecompressImage(data: Ptr; desc: ImageDescriptionHandle; dst: PixMapHandle; srcRect: Rect; matrix: MatrixRecordPtr; mode: INTEGER; mask: RgnHandle; matte: PixMapHandle; matteRect: Rect; accuracy: CodecQ; codec: DecompressorComponent; bufferSize: LONGINT; dataProc: ICMDataProcRecordPtr; progressProc: ICMProgressProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7009, $AAA3;	{$ENDC}FUNCTION CompressSequenceBegin(VAR seqID: ImageSequence; src: PixMapHandle; prev: PixMapHandle; srcRect: Rect; prevRect: Rect; colorDepth: INTEGER; cType: CodecType; codec: CompressorComponent; spatialQuality: CodecQ; temporalQuality: CodecQ; keyFrameRate: LONGINT; clut: CTabHandle; flags: CodecFlags; desc: ImageDescriptionHandle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $700A, $AAA3;	{$ENDC}FUNCTION CompressSequenceFrame(seqID: ImageSequence; src: PixMapHandle; srcRect: Rect; flags: CodecFlags; data: Ptr; VAR dataSize: LONGINT; VAR similarity: UInt8; asyncCompletionProc: ICMCompletionProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $700B, $AAA3;	{$ENDC}FUNCTION DecompressSequenceBegin(VAR seqID: ImageSequence; desc: ImageDescriptionHandle; port: CGrafPtr; gdh: GDHandle; srcRect: Rect; matrix: MatrixRecordPtr; mode: INTEGER; mask: RgnHandle; flags: CodecFlags; accuracy: CodecQ; codec: DecompressorComponent): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $700D, $AAA3;	{$ENDC}FUNCTION DecompressSequenceBeginS(VAR seqID: ImageSequence; desc: ImageDescriptionHandle; data: Ptr; dataSize: LONGINT; port: CGrafPtr; gdh: GDHandle; srcRect: Rect; matrix: MatrixRecordPtr; mode: INTEGER; mask: RgnHandle; flags: CodecFlags; accuracy: CodecQ; codec: DecompressorComponent): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $30, $5D, $AAA3;	{$ENDC}FUNCTION DecompressSequenceFrame(seqID: ImageSequence; data: Ptr; inFlags: CodecFlags; VAR outFlags: CodecFlags; asyncCompletionProc: ICMCompletionProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $700E, $AAA3;	{$ENDC}FUNCTION DecompressSequenceFrameS(seqID: ImageSequence; data: Ptr; dataSize: LONGINT; inFlags: CodecFlags; VAR outFlags: CodecFlags; asyncCompletionProc: ICMCompletionProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $16, $47, $AAA3;	{$ENDC}FUNCTION DecompressSequenceFrameWhen(seqID: ImageSequence; data: Ptr; dataSize: LONGINT; inFlags: CodecFlags; VAR outFlags: CodecFlags; asyncCompletionProc: ICMCompletionProcRecordPtr; frameTime: ICMFrameTimePtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $1A, $5E, $AAA3;	{$ENDC}FUNCTION CDSequenceFlush(seqID: ImageSequence): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $4, $5F, $AAA3;	{$ENDC}FUNCTION SetDSequenceMatrix(seqID: ImageSequence; matrix: MatrixRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7010, $AAA3;	{$ENDC}FUNCTION SetDSequenceMatte(seqID: ImageSequence; matte: PixMapHandle; matteRect: Rect): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7011, $AAA3;	{$ENDC}FUNCTION SetDSequenceMask(seqID: ImageSequence; mask: RgnHandle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7012, $AAA3;	{$ENDC}FUNCTION SetDSequenceTransferMode(seqID: ImageSequence; mode: INTEGER; opColor: RGBColor): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7013, $AAA3;	{$ENDC}FUNCTION SetDSequenceDataProc(seqID: ImageSequence; dataProc: ICMDataProcRecordPtr; bufferSize: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7014, $AAA3;	{$ENDC}FUNCTION SetDSequenceAccuracy(seqID: ImageSequence; accuracy: CodecQ): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7034, $AAA3;	{$ENDC}FUNCTION SetDSequenceSrcRect(seqID: ImageSequence; srcRect: Rect): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7035, $AAA3;	{$ENDC}FUNCTION GetDSequenceImageBuffer(seqID: ImageSequence; VAR gworld: GWorldPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7015, $AAA3;	{$ENDC}FUNCTION GetDSequenceScreenBuffer(seqID: ImageSequence; VAR gworld: GWorldPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7016, $AAA3;	{$ENDC}FUNCTION SetCSequenceQuality(seqID: ImageSequence; spatialQuality: CodecQ; temporalQuality: CodecQ): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7017, $AAA3;	{$ENDC}FUNCTION SetCSequencePrev(seqID: ImageSequence; prev: PixMapHandle; prevRect: Rect): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7018, $AAA3;	{$ENDC}FUNCTION SetCSequenceFlushProc(seqID: ImageSequence; flushProc: ICMFlushProcRecordPtr; bufferSize: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7033, $AAA3;	{$ENDC}FUNCTION SetCSequenceKeyFrameRate(seqID: ImageSequence; keyframerate: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7036, $AAA3;	{$ENDC}FUNCTION GetCSequenceKeyFrameRate(seqID: ImageSequence; VAR keyframerate: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $8, $4B, $AAA3;	{$ENDC}FUNCTION GetCSequencePrevBuffer(seqID: ImageSequence; VAR gworld: GWorldPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7019, $AAA3;	{$ENDC}FUNCTION CDSequenceBusy(seqID: ImageSequence): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $701A, $AAA3;	{$ENDC}FUNCTION CDSequenceEnd(seqID: ImageSequence): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $701B, $AAA3;	{$ENDC}FUNCTION GetCompressedImageSize(desc: ImageDescriptionHandle; data: Ptr; bufferSize: LONGINT; dataProc: ICMDataProcRecordPtr; VAR dataSize: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $701C, $AAA3;	{$ENDC}FUNCTION GetSimilarity(src: PixMapHandle; srcRect: Rect; desc: ImageDescriptionHandle; data: Ptr; VAR similarity: Fixed): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $701D, $AAA3;	{$ENDC}FUNCTION GetImageDescriptionCTable(desc: ImageDescriptionHandle; VAR ctable: CTabHandle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $701E, $AAA3;	{$ENDC}FUNCTION SetImageDescriptionCTable(desc: ImageDescriptionHandle; ctable: CTabHandle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $701F, $AAA3;	{$ENDC}FUNCTION GetImageDescriptionExtension(desc: ImageDescriptionHandle; VAR extension: Handle; idType: LONGINT; index: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7020, $AAA3;	{$ENDC}FUNCTION SetImageDescriptionExtension(desc: ImageDescriptionHandle; extension: Handle; idType: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7021, $AAA3;	{$ENDC}FUNCTION RemoveImageDescriptionExtension(VAR desc: ImageDescription; idType: LONGINT; index: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $C, $3A, $AAA3;	{$ENDC}FUNCTION CountImageDescriptionExtensionType(VAR desc: ImageDescription; idType: LONGINT; VAR count: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $C, $3B, $AAA3;	{$ENDC}FUNCTION GetNextImageDescriptionExtensionType(VAR desc: ImageDescription; VAR idType: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $8, $3C, $AAA3;	{$ENDC}FUNCTION FindCodec(cType: CodecType; specCodec: CodecComponent; VAR compressor: CompressorComponent; VAR decompressor: DecompressorComponent): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7023, $AAA3;	{$ENDC}FUNCTION CompressPicture(srcPicture: PicHandle; dstPicture: PicHandle; quality: CodecQ; cType: CodecType): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7024, $AAA3;	{$ENDC}FUNCTION FCompressPicture(srcPicture: PicHandle; dstPicture: PicHandle; colorDepth: INTEGER; clut: CTabHandle; quality: CodecQ; doDither: INTEGER; compressAgain: INTEGER; progressProc: ICMProgressProcRecordPtr; cType: CodecType; codec: CompressorComponent): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7025, $AAA3;	{$ENDC}FUNCTION CompressPictureFile(srcRefNum: INTEGER; dstRefNum: INTEGER; quality: CodecQ; cType: CodecType): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7026, $AAA3;	{$ENDC}FUNCTION FCompressPictureFile(srcRefNum: INTEGER; dstRefNum: INTEGER; colorDepth: INTEGER; clut: CTabHandle; quality: CodecQ; doDither: INTEGER; compressAgain: INTEGER; progressProc: ICMProgressProcRecordPtr; cType: CodecType; codec: CompressorComponent): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7027, $AAA3;	{$ENDC}FUNCTION GetPictureFileHeader(refNum: INTEGER; VAR frame: Rect; VAR header: OpenCPicParams): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7028, $AAA3;	{$ENDC}FUNCTION DrawPictureFile(refNum: INTEGER; frame: Rect; progressProc: ICMProgressProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7029, $AAA3;	{$ENDC}FUNCTION DrawTrimmedPicture(srcPicture: PicHandle; frame: Rect; trimMask: RgnHandle; doDither: INTEGER; progressProc: ICMProgressProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $702E, $AAA3;	{$ENDC}FUNCTION DrawTrimmedPictureFile(srcRefnum: INTEGER; frame: Rect; trimMask: RgnHandle; doDither: INTEGER; progressProc: ICMProgressProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $702F, $AAA3;	{$ENDC}FUNCTION MakeThumbnailFromPicture(picture: PicHandle; colorDepth: INTEGER; thumbnail: PicHandle; progressProc: ICMProgressProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $702A, $AAA3;	{$ENDC}FUNCTION MakeThumbnailFromPictureFile(refNum: INTEGER; colorDepth: INTEGER; thumbnail: PicHandle; progressProc: ICMProgressProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $702B, $AAA3;	{$ENDC}FUNCTION MakeThumbnailFromPixMap(src: PixMapHandle; srcRect: Rect; colorDepth: INTEGER; thumbnail: PicHandle; progressProc: ICMProgressProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $702C, $AAA3;	{$ENDC}FUNCTION TrimImage(desc: ImageDescriptionHandle; inData: Ptr; inBufferSize: LONGINT; dataProc: ICMDataProcRecordPtr; outData: Ptr; outBufferSize: LONGINT; flushProc: ICMFlushProcRecordPtr; VAR trimRect: Rect; progressProc: ICMProgressProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $702D, $AAA3;	{$ENDC}FUNCTION ConvertImage(srcDD: ImageDescriptionHandle; srcData: Ptr; colorDepth: INTEGER; clut: CTabHandle; accuracy: CodecQ; quality: CodecQ; cType: CodecType; codec: CodecComponent; dstDD: ImageDescriptionHandle; dstData: Ptr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7030, $AAA3;	{$ENDC}FUNCTION GetCompressedPixMapInfo(pix: PixMapPtr; VAR desc: ImageDescriptionHandle; VAR data: Ptr; VAR bufferSize: LONGINT; VAR dataProc: ICMDataProcRecord; VAR progressProc: ICMProgressProcRecord): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7037, $AAA3;	{$ENDC}FUNCTION SetCompressedPixMapInfo(pix: PixMapPtr; desc: ImageDescriptionHandle; data: Ptr; bufferSize: LONGINT; dataProc: ICMDataProcRecordPtr; progressProc: ICMProgressProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7038, $AAA3;	{$ENDC}PROCEDURE StdPix(src: PixMapPtr; srcRect: Rect; matrix: MatrixRecordPtr; mode: INTEGER; mask: RgnHandle; matte: PixMapPtr; matteRect: Rect; flags: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $700C, $AAA3;	{$ENDC}FUNCTION TransformRgn(matrix: MatrixRecordPtr; rgn: RgnHandle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7039, $AAA3;	{$ENDC}{**********	preview stuff**********}PROCEDURE SFGetFilePreview(where: Point; prompt: ConstStr255Param; fileFilter: FileFilterUPP; numTypes: INTEGER; VAR typeList: SFTypeList; dlgHook: DlgHookUPP; VAR reply: SFReply);	{$IFC NOT GENERATINGCFM}	INLINE $7041, $AAA3;	{$ENDC}PROCEDURE SFPGetFilePreview(where: Point; prompt: ConstStr255Param; fileFilter: FileFilterUPP; numTypes: INTEGER; VAR typeList: SFTypeList; dlgHook: DlgHookUPP; VAR reply: SFReply; dlgID: INTEGER; filterProc: ModalFilterUPP);	{$IFC NOT GENERATINGCFM}	INLINE $7042, $AAA3;	{$ENDC}PROCEDURE StandardGetFilePreview(fileFilter: FileFilterUPP; numTypes: INTEGER; VAR typeList: SFTypeList; VAR reply: StandardFileReply);	{$IFC NOT GENERATINGCFM}	INLINE $7043, $AAA3;	{$ENDC}PROCEDURE CustomGetFilePreview(fileFilter: FileFilterYDUPP; numTypes: INTEGER; VAR typeList: SFTypeList; VAR reply: StandardFileReply; dlgID: INTEGER; where: Point; dlgHook: DlgHookYDUPP; filterProc: ModalFilterYDUPP; activeList: INTEGER; activateProc: ActivateYDUPP; yourDataPtr: UNIV Ptr);	{$IFC NOT GENERATINGCFM}	INLINE $7044, $AAA3;	{$ENDC}FUNCTION MakeFilePreview(resRefNum: INTEGER; progress: ICMProgressProcRecordPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7045, $AAA3;	{$ENDC}FUNCTION AddFilePreview(resRefNum: INTEGER; previewType: OSType; previewData: Handle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7046, $AAA3;	{$ENDC}CONST	sfpItemPreviewAreaUser		= 11;	sfpItemPreviewStaticText	= 12;	sfpItemPreviewDividerUser	= 13;	sfpItemCreatePreviewButton	= 14;	sfpItemShowPreviewButton	= 15;TYPE	PreviewResourceRecord = RECORD		modDate:				LONGINT;		version:				INTEGER;		resType:				OSType;		resID:					INTEGER;	END;	PreviewResourcePtr = ^PreviewResourceRecord;	PreviewResource = ^PreviewResourcePtr;PROCEDURE AlignScreenRect(VAR rp: Rect; alignmentProc: ICMAlignmentProcRecordPtr);	{$IFC NOT GENERATINGCFM}	INLINE $203C, $8, $4C, $AAA3;	{$ENDC}PROCEDURE AlignWindow(wp: WindowPtr; front: BOOLEAN; alignmentRect: Rect; alignmentProc: ICMAlignmentProcRecordPtr);	{$IFC NOT GENERATINGCFM}	INLINE $203C, $E, $4D, $AAA3;	{$ENDC}PROCEDURE DragAlignedWindow(wp: WindowPtr; startPt: Point; VAR boundsRect: Rect; VAR alignmentRect: Rect; alignmentProc: ICMAlignmentProcRecordPtr);	{$IFC NOT GENERATINGCFM}	INLINE $203C, $14, $4E, $AAA3;	{$ENDC}FUNCTION DragAlignedGrayRgn(theRgn: RgnHandle; startPt: Point; VAR boundsRect: Rect; VAR slopRect: Rect; axis: INTEGER; actionProc: UniversalProcPtr; VAR alignmentRect: Rect; alignmentProc: ICMAlignmentProcRecordPtr): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $1E, $4F, $AAA3;	{$ENDC}FUNCTION SetCSequenceDataRateParams(seqID: ImageSequence; params: DataRateParamsPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $8, $50, $AAA3;	{$ENDC}FUNCTION SetCSequenceFrameNumber(seqID: ImageSequence; frameNumber: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $8, $51, $AAA3;	{$ENDC}FUNCTION NewImageGWorld(VAR gworld: GWorldPtr; idh: ImageDescriptionHandle; flags: GWorldFlags): QDErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $C, $52, $AAA3;	{$ENDC}FUNCTION GetCSequenceDataRateParams(seqID: ImageSequence; params: DataRateParamsPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $8, $53, $AAA3;	{$ENDC}FUNCTION GetCSequenceFrameNumber(seqID: ImageSequence; VAR frameNumber: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $8, $54, $AAA3;	{$ENDC}FUNCTION GetBestDeviceRect(VAR gdh: GDHandle; VAR rp: Rect): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $8, $55, $AAA3;	{$ENDC}FUNCTION SetSequenceProgressProc(seqID: ImageSequence; VAR progressProc: ICMProgressProcRecord): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $8, $56, $AAA3;	{$ENDC}FUNCTION GDHasScale(gdh: GDHandle; depth: INTEGER; VAR scale: Fixed): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $A, $5A, $AAA3;	{$ENDC}FUNCTION GDGetScale(gdh: GDHandle; VAR scale: Fixed; VAR flags: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $C, $5B, $AAA3;	{$ENDC}FUNCTION GDSetScale(gdh: GDHandle; scale: Fixed; flags: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $A, $5C, $AAA3;	{$ENDC}FUNCTION ICMShieldSequenceCursor(seqID: ImageSequence): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $4, $62, $AAA3;	{$ENDC}PROCEDURE ICMDecompressComplete(seqID: ImageSequence; err: OSErr; flag: INTEGER; completionRtn: ICMCompletionProcRecordPtr);	{$IFC NOT GENERATINGCFM}	INLINE $203C, $C, $63, $AAA3;	{$ENDC}FUNCTION SetDSequenceTimeCode(seqID: ImageSequence; timeCodeFormat: UNIV Ptr; timeCodeTime: UNIV Ptr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $203C, $C, $64, $AAA3;	{$ENDC}CONST	identityMatrixType			= $00;							{ result if matrix is identity }	translateMatrixType			= $01;							{ result if matrix translates }	scaleMatrixType				= $02;							{ result if matrix scales }	scaleTranslateMatrixType	= $03;							{ result if matrix scales and translates }	linearMatrixType			= $04;							{ result if matrix is general 2 x 2 }	linearTranslateMatrixType	= $05;							{ result if matrix is general 2 x 2 and translates }	perspectiveMatrixType		= $06;							{ result if matrix is general 3 x 3 }	TYPEMatrixFlags = INTEGER;FUNCTION GetMatrixType(m: MatrixRecord): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $7014, $ABC2;	{$ENDC}PROCEDURE CopyMatrix(m1: MatrixRecord; VAR m2: MatrixRecord);	{$IFC NOT GENERATINGCFM}	INLINE $7020, $ABC2;	{$ENDC}FUNCTION EqualMatrix(m1: MatrixRecord; m2: MatrixRecord): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $7021, $ABC2;	{$ENDC}PROCEDURE SetIdentityMatrix(VAR matrix: MatrixRecord);	{$IFC NOT GENERATINGCFM}	INLINE $7015, $ABC2;	{$ENDC}PROCEDURE TranslateMatrix(VAR m: MatrixRecord; deltaH: Fixed; deltaV: Fixed);	{$IFC NOT GENERATINGCFM}	INLINE $7019, $ABC2;	{$ENDC}PROCEDURE RotateMatrix(VAR m: MatrixRecord; degrees: Fixed; aboutX: Fixed; aboutY: Fixed);	{$IFC NOT GENERATINGCFM}	INLINE $7016, $ABC2;	{$ENDC}PROCEDURE ScaleMatrix(VAR m: MatrixRecord; scaleX: Fixed; scaleY: Fixed; aboutX: Fixed; aboutY: Fixed);	{$IFC NOT GENERATINGCFM}	INLINE $7017, $ABC2;	{$ENDC}PROCEDURE SkewMatrix(VAR m: MatrixRecord; skewX: Fixed; skewY: Fixed; aboutX: Fixed; aboutY: Fixed);	{$IFC NOT GENERATINGCFM}	INLINE $7018, $ABC2;	{$ENDC}FUNCTION TransformFixedPoints(m: MatrixRecord; VAR fpt: FixedPoint; count: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7022, $ABC2;	{$ENDC}FUNCTION TransformPoints(mp: MatrixRecord; VAR pt1: Point; count: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7023, $ABC2;	{$ENDC}FUNCTION TransformFixedRect(m: MatrixRecord; VAR fr: FixedRect; VAR fpp: FixedPoint): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $7024, $ABC2;	{$ENDC}FUNCTION TransformRect(m: MatrixRecord; VAR r: Rect; VAR fpp: FixedPoint): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $7025, $ABC2;	{$ENDC}FUNCTION InverseMatrix(m: MatrixRecord; VAR im: MatrixRecord): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $701C, $ABC2;	{$ENDC}PROCEDURE ConcatMatrix(a: MatrixRecord; VAR b: MatrixRecord);	{$IFC NOT GENERATINGCFM}	INLINE $701B, $ABC2;	{$ENDC}PROCEDURE RectMatrix(VAR matrix: MatrixRecord; srcRect: Rect; dstRect: Rect);	{$IFC NOT GENERATINGCFM}	INLINE $701E, $ABC2;	{$ENDC}PROCEDURE MapMatrix(VAR matrix: MatrixRecord; fromRect: Rect; toRect: Rect);	{$IFC NOT GENERATINGCFM}	INLINE $701D, $ABC2;	{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := ImageCompressionIncludes}{$ENDC} {__IMAGECOMPRESSION__}{$IFC NOT UsingIncludes} END.{$ENDC}