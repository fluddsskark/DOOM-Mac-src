{ 	File:		QuickTimeComponents.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.1  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT QuickTimeComponents; INTERFACE{$ENDC}{$IFC UNDEFINED __QUICKTIMECOMPONENTS__}{$SETC __QUICKTIMECOMPONENTS__ := 1}{$I+}{$SETC QuickTimeComponentsIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __COMPONENTS__}{$I Components.p}{$ENDC}{	Types.p														}{		ConditionalMacros.p										}{	MixedMode.p													}{$IFC UNDEFINED __IMAGECOMPRESSION__}{$I ImageCompression.p}{$ENDC}{	Quickdraw.p													}{		QuickdrawText.p											}{	QDOffscreen.p												}{		Errors.p												}{	Windows.p													}{		Memory.p												}{		Events.p												}{			OSUtils.p											}{		Controls.p												}{			Menus.p												}{	StandardFile.p												}{		Dialogs.p												}{			TextEdit.p											}{		Files.p													}{$IFC UNDEFINED __MOVIES__}{$I Movies.p}{$ENDC}{	Aliases.p													}{		AppleTalk.p												}{$IFC UNDEFINED __VIDEO__}{$I Video.p}{$ENDC}{$PUSH}{$ALIGN MAC68K}{$LibExport+}CONST	clockComponentType			= 'clok';	systemTickClock				= 'tick';						{ subtype: 60ths since boot		}	systemSecondClock			= 'seco';						{ subtype: seconds since 1904		}	systemMillisecondClock		= 'mill';						{ subtype: 1000ths since boot		}	systemMicrosecondClock		= 'micr';	kClockRateIsLinear			= 1;	kClockImplementsCallBacks	= 2;{* These are Clock procedures *}FUNCTION ClockGetTime(aClock: ComponentInstance; VAR out: TimeRecord): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1, $7000, $A82A;	{$ENDC}FUNCTION ClockNewCallBack(aClock: ComponentInstance; tb: TimeBase; callBackType: INTEGER): QTCallBack;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $2, $7000, $A82A;	{$ENDC}FUNCTION ClockDisposeCallBack(aClock: ComponentInstance; cb: QTCallBack): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $3, $7000, $A82A;	{$ENDC}FUNCTION ClockCallMeWhen(aClock: ComponentInstance; cb: QTCallBack; param1: LONGINT; param2: LONGINT; param3: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $4, $7000, $A82A;	{$ENDC}FUNCTION ClockCancelCallBack(aClock: ComponentInstance; cb: QTCallBack): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $5, $7000, $A82A;	{$ENDC}FUNCTION ClockRateChanged(aClock: ComponentInstance; cb: QTCallBack): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $6, $7000, $A82A;	{$ENDC}FUNCTION ClockTimeChanged(aClock: ComponentInstance; cb: QTCallBack): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $7, $7000, $A82A;	{$ENDC}FUNCTION ClockSetTimeBase(aClock: ComponentInstance; tb: TimeBase): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $8, $7000, $A82A;	{$ENDC}FUNCTION ClockStartStopChanged(aClock: ComponentInstance; cb: QTCallBack; startChanged: BOOLEAN; stopChanged: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $9, $7000, $A82A;	{$ENDC}FUNCTION ClockGetRate(aClock: ComponentInstance; VAR rate: Fixed): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $A, $7000, $A82A;	{$ENDC}CONST	kClockGetTimeSelect			= $1;	kClockNewCallBackSelect		= $2;	kClockDisposeCallBackSelect	= $3;	kClockCallMeWhenSelect		= $4;	kClockCancelCallBackSelect	= $5;	kClockRateChangedSelect		= $6;	kClockTimeChangedSelect		= $7;	kClockSetTimeBaseSelect		= $8;	kClockStartStopChangedSelect = $9;	kClockGetRateSelect			= $A;{	General Sequence Grab stuff}	TYPESeqGrabComponent = ComponentInstance;	SGChannel = ComponentInstance;CONST	SeqGrabComponentType		= 'barg';	SeqGrabChannelType			= 'sgch';	SeqGrabPanelType			= 'sgpn';	SeqGrabCompressionPanelType	= 'comp';	SeqGrabSourcePanelType		= 'sour';	seqGrabToDisk				= 1;	seqGrabToMemory				= 2;	seqGrabDontUseTempMemory	= 4;	seqGrabAppendToFile			= 8;	seqGrabDontAddMovieResource	= 16;	seqGrabDontMakeMovie		= 32;	seqGrabPreExtendFile		= 64;	seqGrabDataProcIsInterruptSafe = 128;	seqGrabDataProcDoesOverlappingReads = 256;	TYPESeqGrabDataOutputEnum = LONGINT;CONST	seqGrabRecord				= 1;	seqGrabPreview				= 2;	seqGrabPlayDuringRecord		= 4;	TYPESeqGrabUsageEnum = LONGINT;CONST	seqGrabHasBounds			= 1;	seqGrabHasVolume			= 2;	seqGrabHasDiscreteSamples	= 4;	TYPESeqGrabChannelInfoEnum = LONGINT;	SeqGrabFrameInfo = RECORD		frameOffset:			LONGINT;		frameTime:				LONGINT;		frameSize:				LONGINT;		frameChannel:			SGChannel;		frameRefCon:			LONGINT;	END;	SeqGrabFrameInfoPtr = ^SeqGrabFrameInfo;CONST	grabPictOffScreen			= 1;	grabPictIgnoreClip			= 2;	grabPictCurrentImage		= 4;	sgFlagControlledGrab		= 0+(1 * (2**(0)));TYPE	SGDataProcPtr = ProcPtr;  { FUNCTION SGData(c: SGChannel; p: Ptr; len: LONGINT; VAR offset: LONGINT; chRefCon: LONGINT; time: TimeValue; writeType: INTEGER; refCon: LONGINT): OSErr; }	SGDataUPP = UniversalProcPtr;	SGDeviceName = RECORD		name:					Str63;		icon:					Handle;		flags:					LONGINT;		refCon:					LONGINT;		reserved:				LONGINT;								{ zero}	END;CONST	sgDeviceNameFlagDeviceUnavailable = 0+(1 * (2**(0)));TYPE	SGDeviceListRecord = RECORD		count:					INTEGER;		selectedIndex:			INTEGER;		reserved:				LONGINT;								{ zero}		entry:					ARRAY [0..0] OF SGDeviceName;	END;	SGDeviceListPtr = ^SGDeviceListRecord;	SGDeviceList = ^SGDeviceListPtr;CONST	sgDeviceListWithIcons		= 0+(1 * (2**(0)));	sgDeviceListDontCheckAvailability = 0+(1 * (2**(1)));	seqGrabWriteAppend			= 0;	seqGrabWriteReserve			= 1;	seqGrabWriteFill			= 2;	seqGrabUnpause				= 0;	seqGrabPause				= 1;	seqGrabPauseForMenu			= 3;	channelFlagDontOpenResFile	= 2;	channelFlagHasDependency	= 4;TYPE	SGModalFilterProcPtr = ProcPtr;  { FUNCTION SGModalFilter(theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: INTEGER; refCon: LONGINT): BOOLEAN; }	SGModalFilterUPP = UniversalProcPtr;CONST	sgPanelFlagForPanel			= 1;TYPE	SGOutputRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	SGOutput = ^SGOutputRecord;CONST	channelPlayNormal			= 0;	channelPlayFast				= 1;	channelPlayHighQuality		= 2;	channelPlayAllData			= 4;FUNCTION SGInitialize(s: SeqGrabComponent): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $1, $7000, $A82A;	{$ENDC}FUNCTION SGSetDataOutput(s: SeqGrabComponent; movieFile: FSSpec; whereFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $2, $7000, $A82A;	{$ENDC}FUNCTION SGGetDataOutput(s: SeqGrabComponent; VAR movieFile: FSSpec; VAR whereFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $3, $7000, $A82A;	{$ENDC}FUNCTION SGSetGWorld(s: SeqGrabComponent; gp: CGrafPtr; gd: GDHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $4, $7000, $A82A;	{$ENDC}FUNCTION SGGetGWorld(s: SeqGrabComponent; VAR gp: CGrafPtr; VAR gd: GDHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $5, $7000, $A82A;	{$ENDC}FUNCTION SGNewChannel(s: SeqGrabComponent; channelType: OSType; VAR ref: SGChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $6, $7000, $A82A;	{$ENDC}FUNCTION SGDisposeChannel(s: SeqGrabComponent; c: SGChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $7, $7000, $A82A;	{$ENDC}FUNCTION SGStartPreview(s: SeqGrabComponent): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $10, $7000, $A82A;	{$ENDC}FUNCTION SGStartRecord(s: SeqGrabComponent): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $11, $7000, $A82A;	{$ENDC}FUNCTION SGIdle(s: SeqGrabComponent): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $12, $7000, $A82A;	{$ENDC}FUNCTION SGStop(s: SeqGrabComponent): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $13, $7000, $A82A;	{$ENDC}FUNCTION SGPause(s: SeqGrabComponent; pause: ByteParameter): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $14, $7000, $A82A;	{$ENDC}FUNCTION SGPrepare(s: SeqGrabComponent; prepareForPreview: BOOLEAN; prepareForRecord: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $15, $7000, $A82A;	{$ENDC}FUNCTION SGRelease(s: SeqGrabComponent): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $16, $7000, $A82A;	{$ENDC}FUNCTION SGGetMovie(s: SeqGrabComponent): Movie;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $17, $7000, $A82A;	{$ENDC}FUNCTION SGSetMaximumRecordTime(s: SeqGrabComponent; ticks: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $18, $7000, $A82A;	{$ENDC}FUNCTION SGGetMaximumRecordTime(s: SeqGrabComponent; VAR ticks: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $19, $7000, $A82A;	{$ENDC}FUNCTION SGGetStorageSpaceRemaining(s: SeqGrabComponent; VAR bytes: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1A, $7000, $A82A;	{$ENDC}FUNCTION SGGetTimeRemaining(s: SeqGrabComponent; VAR ticksLeft: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1B, $7000, $A82A;	{$ENDC}FUNCTION SGGrabPict(s: SeqGrabComponent; VAR p: PicHandle; bounds: Rect; offscreenDepth: INTEGER; grabPictFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $E, $1C, $7000, $A82A;	{$ENDC}FUNCTION SGGetLastMovieResID(s: SeqGrabComponent; VAR resID: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1D, $7000, $A82A;	{$ENDC}FUNCTION SGSetFlags(s: SeqGrabComponent; sgFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1E, $7000, $A82A;	{$ENDC}FUNCTION SGGetFlags(s: SeqGrabComponent; VAR sgFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1F, $7000, $A82A;	{$ENDC}FUNCTION SGSetDataProc(s: SeqGrabComponent; proc: SGDataUPP; refCon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $20, $7000, $A82A;	{$ENDC}FUNCTION SGNewChannelFromComponent(s: SeqGrabComponent; VAR newChannel: SGChannel; sgChannelComponent: Component): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $21, $7000, $A82A;	{$ENDC}FUNCTION SGDisposeDeviceList(s: SeqGrabComponent; list: SGDeviceList): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $22, $7000, $A82A;	{$ENDC}FUNCTION SGAppendDeviceListToMenu(s: SeqGrabComponent; list: SGDeviceList; mh: MenuHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $23, $7000, $A82A;	{$ENDC}FUNCTION SGSetSettings(s: SeqGrabComponent; ud: UserData; flags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $24, $7000, $A82A;	{$ENDC}FUNCTION SGGetSettings(s: SeqGrabComponent; VAR ud: UserData; flags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $25, $7000, $A82A;	{$ENDC}FUNCTION SGGetIndChannel(s: SeqGrabComponent; index: INTEGER; VAR ref: SGChannel; VAR chanType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $26, $7000, $A82A;	{$ENDC}FUNCTION SGUpdate(s: SeqGrabComponent; updateRgn: RgnHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $27, $7000, $A82A;	{$ENDC}FUNCTION SGGetPause(s: SeqGrabComponent; VAR paused: Byte): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $28, $7000, $A82A;	{$ENDC}FUNCTION SGSettingsDialog(s: SeqGrabComponent; c: SGChannel; numPanels: INTEGER; VAR panelList: Component; flags: LONGINT; proc: SGModalFilterUPP; procRefNum: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $16, $29, $7000, $A82A;	{$ENDC}FUNCTION SGGetAlignmentProc(s: SeqGrabComponent; alignmentProc: ICMAlignmentProcRecordPtr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $2A, $7000, $A82A;	{$ENDC}FUNCTION SGSetChannelSettings(s: SeqGrabComponent; c: SGChannel; ud: UserData; flags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $2B, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelSettings(s: SeqGrabComponent; c: SGChannel; VAR ud: UserData; flags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $2C, $7000, $A82A;	{$ENDC}FUNCTION SGGetMode(s: SeqGrabComponent; VAR previewMode: BOOLEAN; VAR recordMode: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $2D, $7000, $A82A;	{$ENDC}FUNCTION SGSetDataRef(s: SeqGrabComponent; dataRef: Handle; dataRefType: OSType; whereFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $2E, $7000, $A82A;	{$ENDC}FUNCTION SGGetDataRef(s: SeqGrabComponent; VAR dataRef: Handle; VAR dataRefType: OSType; VAR whereFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $2F, $7000, $A82A;	{$ENDC}FUNCTION SGNewOutput(s: SeqGrabComponent; dataRef: Handle; dataRefType: OSType; whereFlags: LONGINT; VAR output: SGOutput): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $30, $7000, $A82A;	{$ENDC}FUNCTION SGDisposeOutput(s: SeqGrabComponent; output: SGOutput): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $31, $7000, $A82A;	{$ENDC}FUNCTION SGSetOutputFlags(s: SeqGrabComponent; output: SGOutput; whereFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $32, $7000, $A82A;	{$ENDC}FUNCTION SGSetChannelOutput(s: SeqGrabComponent; c: SGChannel; output: SGOutput): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $33, $7000, $A82A;	{$ENDC}FUNCTION SGGetDataOutputStorageSpaceRemaining(s: SeqGrabComponent; output: SGOutput; VAR space: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $34, $7000, $A82A;	{$ENDC}{	calls from Channel to seqGrab}FUNCTION SGWriteMovieData(s: SeqGrabComponent; c: SGChannel; p: Ptr; len: LONGINT; VAR offset: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $100, $7000, $A82A;	{$ENDC}FUNCTION SGAddFrameReference(s: SeqGrabComponent; frameInfo: SeqGrabFrameInfoPtr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $101, $7000, $A82A;	{$ENDC}FUNCTION SGGetNextFrameReference(s: SeqGrabComponent; frameInfo: SeqGrabFrameInfoPtr; VAR frameDuration: TimeValue; VAR frameNumber: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $102, $7000, $A82A;	{$ENDC}FUNCTION SGGetTimeBase(s: SeqGrabComponent; VAR tb: TimeBase): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $103, $7000, $A82A;	{$ENDC}FUNCTION SGSortDeviceList(s: SeqGrabComponent; list: SGDeviceList): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $104, $7000, $A82A;	{$ENDC}FUNCTION SGAddMovieData(s: SeqGrabComponent; c: SGChannel; p: Ptr; len: LONGINT; VAR offset: LONGINT; chRefCon: LONGINT; time: TimeValue; writeType: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $1A, $105, $7000, $A82A;	{$ENDC}FUNCTION SGChangedSource(s: SeqGrabComponent; c: SGChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $106, $7000, $A82A;	{$ENDC}{** Sequence Grab CHANNEL Component Stuff **}FUNCTION SGSetChannelUsage(c: SGChannel; usage: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $80, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelUsage(c: SGChannel; VAR usage: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $81, $7000, $A82A;	{$ENDC}FUNCTION SGSetChannelBounds(c: SGChannel; bounds: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $82, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelBounds(c: SGChannel; VAR bounds: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $83, $7000, $A82A;	{$ENDC}FUNCTION SGSetChannelVolume(c: SGChannel; volume: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $84, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelVolume(c: SGChannel; VAR volume: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $85, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelInfo(c: SGChannel; VAR channelInfo: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $86, $7000, $A82A;	{$ENDC}FUNCTION SGSetChannelPlayFlags(c: SGChannel; playFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $87, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelPlayFlags(c: SGChannel; VAR playFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $88, $7000, $A82A;	{$ENDC}FUNCTION SGSetChannelMaxFrames(c: SGChannel; frameCount: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $89, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelMaxFrames(c: SGChannel; VAR frameCount: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $8A, $7000, $A82A;	{$ENDC}FUNCTION SGSetChannelRefCon(c: SGChannel; refCon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $8B, $7000, $A82A;	{$ENDC}FUNCTION SGSetChannelClip(c: SGChannel; theClip: RgnHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $8C, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelClip(c: SGChannel; VAR theClip: RgnHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $8D, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelSampleDescription(c: SGChannel; sampleDesc: Handle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $8E, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelDeviceList(c: SGChannel; selectionFlags: LONGINT; VAR list: SGDeviceList): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $8F, $7000, $A82A;	{$ENDC}FUNCTION SGSetChannelDevice(c: SGChannel; name: StringPtr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $90, $7000, $A82A;	{$ENDC}FUNCTION SGSetChannelMatrix(c: SGChannel; m: MatrixRecord): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $91, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelMatrix(c: SGChannel; VAR m: MatrixRecord): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $92, $7000, $A82A;	{$ENDC}FUNCTION SGGetChannelTimeScale(c: SGChannel; VAR scale: TimeScale): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $93, $7000, $A82A;	{$ENDC}FUNCTION SGChannelPutPicture(c: SGChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $94, $7000, $A82A;	{$ENDC}FUNCTION SGChannelSetRequestedDataRate(c: SGChannel; bytesPerSecond: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $95, $7000, $A82A;	{$ENDC}FUNCTION SGChannelGetRequestedDataRate(c: SGChannel; VAR bytesPerSecond: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $96, $7000, $A82A;	{$ENDC}FUNCTION SGChannelSetDataSourceName(c: SGChannel; VAR name: Str255; scriptTag: ScriptCode): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $97, $7000, $A82A;	{$ENDC}FUNCTION SGChannelGetDataSourceName(c: SGChannel; VAR name: Str255; VAR scriptTag: ScriptCode): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $98, $7000, $A82A;	{$ENDC}{	calls from seqGrab to Channel}FUNCTION SGInitChannel(c: SGChannel; owner: SeqGrabComponent): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $180, $7000, $A82A;	{$ENDC}FUNCTION SGWriteSamples(c: SGChannel; m: Movie; theFile: AliasHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $181, $7000, $A82A;	{$ENDC}FUNCTION SGGetDataRate(c: SGChannel; VAR bytesPerSecond: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $182, $7000, $A82A;	{$ENDC}FUNCTION SGAlignChannelRect(c: SGChannel; VAR r: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $183, $7000, $A82A;	{$ENDC}{	Dorky dialog panel calls}FUNCTION SGPanelGetDitl(s: SeqGrabComponent; VAR ditl: Handle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $200, $7000, $A82A;	{$ENDC}FUNCTION SGPanelGetTitle(s: SeqGrabComponent; VAR title: Str255): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $201, $7000, $A82A;	{$ENDC}FUNCTION SGPanelCanRun(s: SeqGrabComponent; c: SGChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $202, $7000, $A82A;	{$ENDC}FUNCTION SGPanelInstall(s: SeqGrabComponent; c: SGChannel; d: DialogPtr; itemOffset: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $203, $7000, $A82A;	{$ENDC}FUNCTION SGPanelEvent(s: SeqGrabComponent; c: SGChannel; d: DialogPtr; itemOffset: INTEGER; VAR theEvent: EventRecord; VAR itemHit: INTEGER; VAR handled: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $16, $204, $7000, $A82A;	{$ENDC}FUNCTION SGPanelItem(s: SeqGrabComponent; c: SGChannel; d: DialogPtr; itemOffset: INTEGER; itemNum: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $205, $7000, $A82A;	{$ENDC}FUNCTION SGPanelRemove(s: SeqGrabComponent; c: SGChannel; d: DialogPtr; itemOffset: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $206, $7000, $A82A;	{$ENDC}FUNCTION SGPanelSetGrabber(s: SeqGrabComponent; sg: SeqGrabComponent): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $207, $7000, $A82A;	{$ENDC}FUNCTION SGPanelSetResFile(s: SeqGrabComponent; resRef: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $208, $7000, $A82A;	{$ENDC}FUNCTION SGPanelGetSettings(s: SeqGrabComponent; c: SGChannel; VAR ud: UserData; flags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $209, $7000, $A82A;	{$ENDC}FUNCTION SGPanelSetSettings(s: SeqGrabComponent; c: SGChannel; ud: UserData; flags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $20A, $7000, $A82A;	{$ENDC}FUNCTION SGPanelValidateInput(s: SeqGrabComponent; VAR ok: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $20B, $7000, $A82A;	{$ENDC}FUNCTION SGPanelSetEventFilter(s: SeqGrabComponent; proc: SGModalFilterUPP; refCon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $20C, $7000, $A82A;	{$ENDC}{** Sequence Grab VIDEO CHANNEL Component Stuff **}{	Video stuff}TYPE	SGCompressInfo = RECORD		buffer:					Ptr;		bufferSize:				LONGINT;		similarity:				SInt8;		reserved:				SInt8;	END;	SGGrabProcPtr = ProcPtr;  { FUNCTION SGGrab(c: SGChannel; bufferNum: INTEGER; refCon: LONGINT): ComponentResult; }	SGGrabCompleteProcPtr = ProcPtr;  { FUNCTION SGGrabComplete(c: SGChannel; bufferNum: INTEGER; VAR done: BOOLEAN; refCon: LONGINT): ComponentResult; }	SGDisplayProcPtr = ProcPtr;  { FUNCTION SGDisplay(c: SGChannel; bufferNum: INTEGER; VAR mp: MatrixRecord; clipRgn: RgnHandle; refCon: LONGINT): ComponentResult; }	SGCompressProcPtr = ProcPtr;  { FUNCTION SGCompress(c: SGChannel; bufferNum: INTEGER; refCon: LONGINT): ComponentResult; }	SGCompressCompleteProcPtr = ProcPtr;  { FUNCTION SGCompressComplete(c: SGChannel; bufferNum: INTEGER; VAR done: BOOLEAN; VAR ci: SGCompressInfo; refCon: LONGINT): ComponentResult; }	SGAddFrameProcPtr = ProcPtr;  { FUNCTION SGAddFrame(c: SGChannel; bufferNum: INTEGER; atTime: TimeValue; scale: TimeScale; ci: SGCompressInfo; refCon: LONGINT): ComponentResult; }	SGTransferFrameProcPtr = ProcPtr;  { FUNCTION SGTransferFrame(c: SGChannel; bufferNum: INTEGER; VAR mp: MatrixRecord; clipRgn: RgnHandle; refCon: LONGINT): ComponentResult; }	SGGrabCompressCompleteProcPtr = ProcPtr;  { FUNCTION SGGrabCompressComplete(c: SGChannel; VAR done: BOOLEAN; VAR ci: SGCompressInfo; VAR t: TimeRecord; refCon: LONGINT): ComponentResult; }	SGDisplayCompressProcPtr = ProcPtr;  { FUNCTION SGDisplayCompress(c: SGChannel; dataPtr: Ptr; desc: ImageDescriptionHandle; VAR mp: MatrixRecord; clipRgn: RgnHandle; refCon: LONGINT): ComponentResult; }	SGGrabUPP = UniversalProcPtr;	SGGrabCompleteUPP = UniversalProcPtr;	SGDisplayUPP = UniversalProcPtr;	SGCompressUPP = UniversalProcPtr;	SGCompressCompleteUPP = UniversalProcPtr;	SGAddFrameUPP = UniversalProcPtr;	SGTransferFrameUPP = UniversalProcPtr;	SGGrabCompressCompleteUPP = UniversalProcPtr;	SGDisplayCompressUPP = UniversalProcPtr;	VideoBottles = RECORD		procCount:				INTEGER;		grabProc:				SGGrabUPP;		grabCompleteProc:		SGGrabCompleteUPP;		displayProc:			SGDisplayUPP;		compressProc:			SGCompressUPP;		compressCompleteProc:	SGCompressCompleteUPP;		addFrameProc:			SGAddFrameUPP;		transferFrameProc:		SGTransferFrameUPP;		grabCompressCompleteProc: SGGrabCompressCompleteUPP;		displayCompressProc:	SGDisplayCompressUPP;	END;FUNCTION SGGetSrcVideoBounds(c: SGChannel; VAR r: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $100, $7000, $A82A;	{$ENDC}FUNCTION SGSetVideoRect(c: SGChannel; r: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $101, $7000, $A82A;	{$ENDC}FUNCTION SGGetVideoRect(c: SGChannel; VAR r: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $102, $7000, $A82A;	{$ENDC}FUNCTION SGGetVideoCompressorType(c: SGChannel; VAR compressorType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $103, $7000, $A82A;	{$ENDC}FUNCTION SGSetVideoCompressorType(c: SGChannel; compressorType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $104, $7000, $A82A;	{$ENDC}FUNCTION SGSetVideoCompressor(c: SGChannel; depth: INTEGER; compressor: CompressorComponent; spatialQuality: CodecQ; temporalQuality: CodecQ; keyFrameRate: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $12, $105, $7000, $A82A;	{$ENDC}FUNCTION SGGetVideoCompressor(c: SGChannel; VAR depth: INTEGER; VAR compressor: CompressorComponent; VAR spatialQuality: CodecQ; VAR temporalQuality: CodecQ; VAR keyFrameRate: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $14, $106, $7000, $A82A;	{$ENDC}FUNCTION SGGetVideoDigitizerComponent(c: SGChannel): ComponentInstance;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $107, $7000, $A82A;	{$ENDC}FUNCTION SGSetVideoDigitizerComponent(c: SGChannel; vdig: ComponentInstance): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $108, $7000, $A82A;	{$ENDC}FUNCTION SGVideoDigitizerChanged(c: SGChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $109, $7000, $A82A;	{$ENDC}FUNCTION SGSetVideoBottlenecks(c: SGChannel; VAR vb: VideoBottles): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $10A, $7000, $A82A;	{$ENDC}FUNCTION SGGetVideoBottlenecks(c: SGChannel; VAR vb: VideoBottles): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $10B, $7000, $A82A;	{$ENDC}FUNCTION SGGrabFrame(c: SGChannel; bufferNum: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $10C, $7000, $A82A;	{$ENDC}FUNCTION SGGrabFrameComplete(c: SGChannel; bufferNum: INTEGER; VAR done: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $10D, $7000, $A82A;	{$ENDC}FUNCTION SGDisplayFrame(c: SGChannel; bufferNum: INTEGER; mp: MatrixRecord; clipRgn: RgnHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $10E, $7000, $A82A;	{$ENDC}FUNCTION SGCompressFrame(c: SGChannel; bufferNum: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $10F, $7000, $A82A;	{$ENDC}FUNCTION SGCompressFrameComplete(c: SGChannel; bufferNum: INTEGER; VAR done: BOOLEAN; VAR ci: SGCompressInfo): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $110, $7000, $A82A;	{$ENDC}FUNCTION SGAddFrame(c: SGChannel; bufferNum: INTEGER; atTime: TimeValue; scale: TimeScale; ci: SGCompressInfo): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $E, $111, $7000, $A82A;	{$ENDC}FUNCTION SGTransferFrameForCompress(c: SGChannel; bufferNum: INTEGER; mp: MatrixRecord; clipRgn: RgnHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $112, $7000, $A82A;	{$ENDC}FUNCTION SGSetCompressBuffer(c: SGChannel; depth: INTEGER; compressSize: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $113, $7000, $A82A;	{$ENDC}FUNCTION SGGetCompressBuffer(c: SGChannel; VAR depth: INTEGER; VAR compressSize: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $114, $7000, $A82A;	{$ENDC}FUNCTION SGGetBufferInfo(c: SGChannel; bufferNum: INTEGER; VAR bufferPM: PixMapHandle; VAR bufferRect: Rect; VAR compressBuffer: GWorldPtr; VAR compressBufferRect: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $12, $115, $7000, $A82A;	{$ENDC}FUNCTION SGSetUseScreenBuffer(c: SGChannel; useScreenBuffer: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $116, $7000, $A82A;	{$ENDC}FUNCTION SGGetUseScreenBuffer(c: SGChannel; VAR useScreenBuffer: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $117, $7000, $A82A;	{$ENDC}FUNCTION SGGrabCompressComplete(c: SGChannel; VAR done: BOOLEAN; VAR ci: SGCompressInfo; VAR tr: TimeRecord): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $118, $7000, $A82A;	{$ENDC}FUNCTION SGDisplayCompress(c: SGChannel; dataPtr: Ptr; desc: ImageDescriptionHandle; VAR mp: MatrixRecord; clipRgn: RgnHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $119, $7000, $A82A;	{$ENDC}FUNCTION SGSetFrameRate(c: SGChannel; frameRate: Fixed): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $11A, $7000, $A82A;	{$ENDC}FUNCTION SGGetFrameRate(c: SGChannel; VAR frameRate: Fixed): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $11B, $7000, $A82A;	{$ENDC}{** Sequence Grab SOUND CHANNEL Component Stuff **}{	Sound stuff}FUNCTION SGSetSoundInputDriver(c: SGChannel; driverName: ConstStr255Param): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $100, $7000, $A82A;	{$ENDC}FUNCTION SGGetSoundInputDriver(c: SGChannel): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $101, $7000, $A82A;	{$ENDC}FUNCTION SGSoundInputDriverChanged(c: SGChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $102, $7000, $A82A;	{$ENDC}FUNCTION SGSetSoundRecordChunkSize(c: SGChannel; seconds: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $103, $7000, $A82A;	{$ENDC}FUNCTION SGGetSoundRecordChunkSize(c: SGChannel): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $104, $7000, $A82A;	{$ENDC}FUNCTION SGSetSoundInputRate(c: SGChannel; rate: Fixed): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $105, $7000, $A82A;	{$ENDC}FUNCTION SGGetSoundInputRate(c: SGChannel): Fixed;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $106, $7000, $A82A;	{$ENDC}FUNCTION SGSetSoundInputParameters(c: SGChannel; sampleSize: INTEGER; numChannels: INTEGER; compressionType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $107, $7000, $A82A;	{$ENDC}FUNCTION SGGetSoundInputParameters(c: SGChannel; VAR sampleSize: INTEGER; VAR numChannels: INTEGER; VAR compressionType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $108, $7000, $A82A;	{$ENDC}CONST	sgChannelAtom				= 'chan';	sgChannelSettingsAtom		= 'ctom';	sgChannelDescription		= 'cdsc';	sgChannelSettings			= 'cset';	sgDeviceNameType			= 'name';	sgUsageType					= 'use ';	sgPlayFlagsType				= 'plyf';	sgClipType					= 'clip';	sgMatrixType				= 'mtrx';	sgVolumeType				= 'volu';	sgPanelSettingsAtom			= 'ptom';	sgPanelDescription			= 'pdsc';	sgPanelSettings				= 'pset';	sgcSoundCompressionType		= 'scmp';	sgcSoundSampleRateType		= 'srat';	sgcSoundChannelCountType	= 'schn';	sgcSoundSampleSizeType		= 'ssiz';	sgcSoundInputType			= 'sinp';	sgcSoundGainType			= 'gain';	sgcVideoHueType				= 'hue ';	sgcVideoSaturationType		= 'satr';	sgcVideoContrastType		= 'trst';	sgcVideoSharpnessType		= 'shrp';	sgcVideoBrigtnessType		= 'brit';	sgcVideoBlackLevelType		= 'blkl';	sgcVideoWhiteLevelType		= 'whtl';	sgcVideoInputType			= 'vinp';	sgcVideoFormatType			= 'vstd';	sgcVideoFilterType			= 'vflt';	sgcVideoRectType			= 'vrct';	sgVideoDigitizerType		= 'vdig';	kSGInitializeSelect			= $1;	kSGSetDataOutputSelect		= $2;	kSGGetDataOutputSelect		= $3;	kSGSetGWorldSelect			= $4;	kSGGetGWorldSelect			= $5;	kSGNewChannelSelect			= $6;	kSGDisposeChannelSelect		= $7;	kSGStartPreviewSelect		= $10;	kSGStartRecordSelect		= $11;	kSGIdleSelect				= $12;	kSGStopSelect				= $13;	kSGPauseSelect				= $14;	kSGPrepareSelect			= $15;	kSGReleaseSelect			= $16;	kSGGetMovieSelect			= $17;	kSGSetMaximumRecordTimeSelect = $18;	kSGGetMaximumRecordTimeSelect = $19;	kSGGetStorageSpaceRemainingSelect = $1A;	kSGGetTimeRemainingSelect	= $1B;	kSGGrabPictSelect			= $1C;	kSGGetLastMovieResIDSelect	= $1D;	kSGSetFlagsSelect			= $1E;	kSGGetFlagsSelect			= $1F;	kSGSetDataProcSelect		= $20;	kSGNewChannelFromComponentSelect = $21;	kSGDisposeDeviceListSelect	= $22;	kSGAppendDeviceListToMenuSelect = $23;	kSGSetSettingsSelect		= $24;	kSGGetSettingsSelect		= $25;	kSGGetIndChannelSelect		= $26;	kSGUpdateSelect				= $27;	kSGGetPauseSelect			= $28;	kSGSettingsDialogSelect		= $29;	kSGGetAlignmentProcSelect	= $2A;	kSGSetChannelSettingsSelect	= $2B;	kSGGetChannelSettingsSelect	= $2C;	kSGGetModeSelect			= $2D;	kSGSetDataRefSelect			= $2E;	kSGGetDataRefSelect			= $2F;	kSGNewOutputSelect			= $30;	kSGDisposeOutputSelect		= $31;	kSGSetOutputFlagsSelect		= $32;	kSGSetChannelOutputSelect	= $33;	kSGGetDataOutputStorageSpaceRemainingSelect = $34;	kSGWriteMovieDataSelect		= $100;	kSGAddFrameReferenceSelect	= $101;	kSGGetNextFrameReferenceSelect = $102;	kSGGetTimeBaseSelect		= $103;	kSGSortDeviceListSelect		= $104;	kSGAddMovieDataSelect		= $105;	kSGChangedSourceSelect		= $106;	kSGCSetChannelUsageSelect	= $80;	kSGCGetChannelUsageSelect	= $81;	kSGCSetChannelBoundsSelect	= $82;	kSGCGetChannelBoundsSelect	= $83;	kSGCSetChannelVolumeSelect	= $84;	kSGCGetChannelVolumeSelect	= $85;	kSGCGetChannelInfoSelect	= $86;	kSGCSetChannelPlayFlagsSelect = $87;	kSGCGetChannelPlayFlagsSelect = $88;	kSGCSetChannelMaxFramesSelect = $89;	kSGCGetChannelMaxFramesSelect = $8A;	kSGCSetChannelRefConSelect	= $8B;	kSGCSetChannelClipSelect	= $8C;	kSGCGetChannelClipSelect	= $8D;	kSGCGetChannelSampleDescriptionSelect = $8E;	kSGCGetChannelDeviceListSelect = $8F;	kSGCSetChannelDeviceSelect	= $90;	kSGCSetChannelMatrixSelect	= $91;	kSGCGetChannelMatrixSelect	= $92;	kSGCGetChannelTimeScaleSelect = $93;	kSGCChannelPutPictureSelect	= $94;	kSGCChannelSetRequestedDataRateSelect = $95;	kSGCChannelGetRequestedDataRateSelect = $96;	kSGCChannelSetDataSourceNameSelect = $97;	kSGCChannelGetDataSourceNameSelect = $98;	kSGCInitChannelSelect		= $180;	kSGCWriteSamplesSelect		= $181;	kSGCGetDataRateSelect		= $182;	kSGCAlignChannelRectSelect	= $183;	kSGCPanelGetDitlSelect		= $200;	kSGCPanelGetTitleSelect		= $201;	kSGCPanelCanRunSelect		= $202;	kSGCPanelInstallSelect		= $203;	kSGCPanelEventSelect		= $204;	kSGCPanelItemSelect			= $205;	kSGCPanelRemoveSelect		= $206;	kSGCPanelSetGrabberSelect	= $207;	kSGCPanelSetResFileSelect	= $208;	kSGCPanelGetSettingsSelect	= $209;	kSGCPanelSetSettingsSelect	= $20A;	kSGCPanelValidateInputSelect = $20B;	kSGCPanelSetEventFilterSelect = $20C;	kSGCGetSrcVideoBoundsSelect	= $100;	kSGCSetVideoRectSelect		= $101;	kSGCGetVideoRectSelect		= $102;	kSGCGetVideoCompressorTypeSelect = $103;	kSGCSetVideoCompressorTypeSelect = $104;	kSGCSetVideoCompressorSelect = $105;	kSGCGetVideoCompressorSelect = $106;	kSGCGetVideoDigitizerComponentSelect = $107;	kSGCSetVideoDigitizerComponentSelect = $108;	kSGCVideoDigitizerChangedSelect = $109;	kSGCSetVideoBottlenecksSelect = $10A;	kSGCGetVideoBottlenecksSelect = $10B;	kSGCGrabFrameSelect			= $10C;	kSGCGrabFrameCompleteSelect	= $10D;	kSGCDisplayFrameSelect		= $10E;	kSGCCompressFrameSelect		= $10F;	kSGCCompressFrameCompleteSelect = $110;	kSGCAddFrameSelect			= $111;	kSGCTransferFrameForCompressSelect = $112;	kSGCSetCompressBufferSelect	= $113;	kSGCGetCompressBufferSelect	= $114;	kSGCGetBufferInfoSelect		= $115;	kSGCSetUseScreenBufferSelect = $116;	kSGCGetUseScreenBufferSelect = $117;	kSGCGrabCompressCompleteSelect = $118;	kSGCDisplayCompressSelect	= $119;	kSGCSetFrameRateSelect		= $11A;	kSGCGetFrameRateSelect		= $11B;	kSGCSetSoundInputDriverSelect = $100;	kSGCGetSoundInputDriverSelect = $101;	kSGCSoundInputDriverChangedSelect = $102;	kSGCSetSoundRecordChunkSizeSelect = $103;	kSGCGetSoundRecordChunkSizeSelect = $104;	kSGCSetSoundInputRateSelect	= $105;	kSGCGetSoundInputRateSelect	= $106;	kSGCSetSoundInputParametersSelect = $107;	kSGCGetSoundInputParametersSelect = $108;{ Standard type for video digitizers }	videoDigitizerComponentType	= 'vdig';	vdigInterfaceRev			= 2;{ Input Format Standards }	ntscIn						= 0;							{ current input format }	currentIn					= 0;							{ ntsc input format }	palIn						= 1;							{ pal input format }	secamIn						= 2;							{ secam input format }	ntscReallyIn				= 3;							{ ntsc input format }{ Input Formats }	compositeIn					= 0;							{ input is composite format }	sVideoIn					= 1;							{ input is sVideo format }	rgbComponentIn				= 2;							{ input is rgb component format }	rgbComponentSyncIn			= 3;							{ input is rgb component format (sync on green?)}	yuvComponentIn				= 4;							{ input is yuv component format }	yuvComponentSyncIn			= 5;							{ input is yuv component format (sync on green?) }{ Video Digitizer PlayThru States }	vdPlayThruOff				= 0;	vdPlayThruOn				= 1;{ Input Color Space Modes }	vdDigitizerBW				= 0;							{ black and white }	vdDigitizerRGB				= 1;							{ rgb color }{ Phase Lock Loop Modes }	vdBroadcastMode				= 0;							{ Broadcast / Laser Disk video mode }	vdVTRMode					= 1;							{ VCR / Magnetic media mode }{ Field Select Options }	vdUseAnyField				= 0;							{ Digitizers choice on field use }	vdUseOddField				= 1;							{ Use odd field for half size vert and smaller }	vdUseEvenField				= 2;							{ Use even field for half size vert and smaller }{ vdig types }	vdTypeBasic					= 0;							{ basic, no clipping }	vdTypeAlpha					= 1;							{ supports clipping with alpha channel }	vdTypeMask					= 2;							{ supports clipping with mask plane }	vdTypeKey					= 3;							{ supports clipping with key color(s) }{ Digitizer Input Capability/Current Flags	}	digiInDoesNTSC				= 1 * (2**(0));					{ digitizer supports NTSC input format }	digiInDoesPAL				= 1 * (2**(1));					{ digitizer supports PAL input format }	digiInDoesSECAM				= 1 * (2**(2));					{ digitizer supports SECAM input format }	digiInDoesGenLock			= 1 * (2**(7));					{ digitizer does genlock }	digiInDoesComposite			= 1 * (2**(8));					{ digitizer supports composite input type }	digiInDoesSVideo			= 1 * (2**(9));					{ digitizer supports S-Video input type }	digiInDoesComponent			= 1 * (2**(10));				{ digitizer supports component = rgb, input type }	digiInVTR_Broadcast			= 1 * (2**(11));				{ digitizer can differentiate between the two }	digiInDoesColor				= 1 * (2**(12));				{ digitizer supports color }	digiInDoesBW				= 1 * (2**(13));				{ digitizer supports black & white }{ Digitizer Input Current Flags = these are valid only during active operating conditions,	}	digiInSignalLock			= 1 * (2**(31));				{ digitizer detects input signal is locked, this bit = horiz lock || vertical lock }{ Digitizer Output Capability/Current Flags }	digiOutDoes1				= 1 * (2**(0));					{ digitizer supports 1 bit pixels }	digiOutDoes2				= 1 * (2**(1));					{ digitizer supports 2 bit pixels }	digiOutDoes4				= 1 * (2**(2));					{ digitizer supports 4 bit pixels }	digiOutDoes8				= 1 * (2**(3));					{ digitizer supports 8 bit pixels }	digiOutDoes16				= 1 * (2**(4));					{ digitizer supports 16 bit pixels }	digiOutDoes32				= 1 * (2**(5));					{ digitizer supports 32 bit pixels }	digiOutDoesDither			= 1 * (2**(6));					{ digitizer dithers in indexed modes }	digiOutDoesStretch			= 1 * (2**(7));					{ digitizer can arbitrarily stretch }	digiOutDoesShrink			= 1 * (2**(8));					{ digitizer can arbitrarily shrink }	digiOutDoesMask				= 1 * (2**(9));					{ digitizer can mask to clipping regions }	digiOutDoesDouble			= 1 * (2**(11));				{ digitizer can stretch to exactly double size }	digiOutDoesQuad				= 1 * (2**(12));				{ digitizer can stretch exactly quadruple size }	digiOutDoesQuarter			= 1 * (2**(13));				{ digitizer can shrink to exactly quarter size }	digiOutDoesSixteenth		= 1 * (2**(14));				{ digitizer can shrink to exactly sixteenth size }	digiOutDoesRotate			= 1 * (2**(15));				{ digitizer supports rotate transformations }	digiOutDoesHorizFlip		= 1 * (2**(16));				{ digitizer supports horizontal flips Sx < 0 }	digiOutDoesVertFlip			= 1 * (2**(17));				{ digitizer supports vertical flips Sy < 0 }	digiOutDoesSkew				= 1 * (2**(18));				{ digitizer supports skew = shear,twist, }	digiOutDoesBlend			= 1 * (2**(19));	digiOutDoesWarp				= 1 * (2**(20));	digiOutDoesHW_DMA			= 1 * (2**(21));				{ digitizer not constrained to local device }	digiOutDoesHWPlayThru		= 1 * (2**(22));				{ digitizer doesn't need time to play thru }	digiOutDoesILUT				= 1 * (2**(23));				{ digitizer does inverse LUT for index modes }	digiOutDoesKeyColor			= 1 * (2**(24));				{ digitizer does key color functions too }	digiOutDoesAsyncGrabs		= 1 * (2**(25));				{ digitizer supports async grabs }	digiOutDoesUnreadableScreenBits = 1 * (2**(26));			{ playthru doesn't generate readable bits on screen}	digiOutDoesCompress			= 1 * (2**(27));				{ supports alternate output data types }	digiOutDoesCompressOnly		= 1 * (2**(28));				{ can't provide raw frames anywhere }	digiOutDoesPlayThruDuringCompress = 1 * (2**(29));			{ digi can do playthru while providing compressed data }{ Types }	TYPEVideoDigitizerComponent = ComponentInstance;	VideoDigitizerError = ComponentResult;	DigitizerInfo = RECORD		vdigType:				INTEGER;		inputCapabilityFlags:	LONGINT;		outputCapabilityFlags:	LONGINT;		inputCurrentFlags:		LONGINT;		outputCurrentFlags:		LONGINT;		slot:					INTEGER;								{ temporary for connection purposes }		gdh:					GDHandle;								{ temporary for digitizers that have preferred screen }		maskgdh:				GDHandle;								{ temporary for digitizers that have mask planes }		minDestHeight:			INTEGER;								{ Smallest resizable height }		minDestWidth:			INTEGER;								{ Smallest resizable width }		maxDestHeight:			INTEGER;								{ Largest resizable height }		maxDestWidth:			INTEGER;								{ Largest resizable height }		blendLevels:			INTEGER;								{ Number of blend levels supported (2 if 1 bit mask) }		reserved:				LONGINT;								{ reserved }	END;	VdigType = RECORD		digType:				LONGINT;		reserved:				LONGINT;	END;	VdigTypeList = RECORD		count:					INTEGER;		list:					ARRAY [0..0] OF VdigType;	END;	VdigBufferRec = RECORD		dest:					PixMapHandle;		location:				Point;		reserved:				LONGINT;	END;	VdigBufferRecList = RECORD		count:					INTEGER;		matrix:					MatrixRecordPtr;		mask:					RgnHandle;		list:					ARRAY [0..0] OF VdigBufferRec;	END;	VdigBufferRecListPtr = ^VdigBufferRecList;	VdigBufferRecListHandle = ^VdigBufferRecListPtr;	VdigIntProcPtr = ProcPtr;  { PROCEDURE VdigInt(flags: LONGINT; refcon: LONGINT); }	VdigIntUPP = UniversalProcPtr;	VDCompressionList = RECORD		codec:					CodecComponent;		cType:					CodecType;		typeName:				Str63;		name:					Str63;		formatFlags:			LONGINT;		compressFlags:			LONGINT;		reserved:				LONGINT;	END;	VDCompressionListPtr = ^VDCompressionList;	VDCompressionListHandle = ^VDCompressionListPtr;CONST	dmaDepth1					= 1;	dmaDepth2					= 2;	dmaDepth4					= 4;	dmaDepth8					= 8;	dmaDepth16					= 16;	dmaDepth32					= 32;	dmaDepth2Gray				= 64;	dmaDepth4Gray				= 128;	dmaDepth8Gray				= 256;	kVDIGControlledFrameRate	= -1;{ number of vdig calls}	kvdigSelectors				= 86;FUNCTION VDGetMaxSrcRect(ci: VideoDigitizerComponent; inputStd: INTEGER; VAR maxSrcRect: Rect): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $1, $7000, $A82A;	{$ENDC}FUNCTION VDGetActiveSrcRect(ci: VideoDigitizerComponent; inputStd: INTEGER; VAR activeSrcRect: Rect): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $2, $7000, $A82A;	{$ENDC}FUNCTION VDSetDigitizerRect(ci: VideoDigitizerComponent; VAR digitizerRect: Rect): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $3, $7000, $A82A;	{$ENDC}FUNCTION VDGetDigitizerRect(ci: VideoDigitizerComponent; VAR digitizerRect: Rect): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $4, $7000, $A82A;	{$ENDC}FUNCTION VDGetVBlankRect(ci: VideoDigitizerComponent; inputStd: INTEGER; VAR vBlankRect: Rect): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $5, $7000, $A82A;	{$ENDC}FUNCTION VDGetMaskPixMap(ci: VideoDigitizerComponent; maskPixMap: PixMapHandle): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $6, $7000, $A82A;	{$ENDC}FUNCTION VDGetPlayThruDestination(ci: VideoDigitizerComponent; VAR dest: PixMapHandle; VAR destRect: Rect; VAR m: MatrixRecord; VAR mask: RgnHandle): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $8, $7000, $A82A;	{$ENDC}FUNCTION VDUseThisCLUT(ci: VideoDigitizerComponent; colorTableHandle: CTabHandle): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $9, $7000, $A82A;	{$ENDC}FUNCTION VDSetInputGammaValue(ci: VideoDigitizerComponent; channel1: Fixed; channel2: Fixed; channel3: Fixed): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $A, $7000, $A82A;	{$ENDC}FUNCTION VDGetInputGammaValue(ci: VideoDigitizerComponent; VAR channel1: Fixed; VAR channel2: Fixed; VAR channel3: Fixed): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $B, $7000, $A82A;	{$ENDC}FUNCTION VDSetBrightness(ci: VideoDigitizerComponent; VAR brightness: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $C, $7000, $A82A;	{$ENDC}FUNCTION VDGetBrightness(ci: VideoDigitizerComponent; VAR brightness: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $D, $7000, $A82A;	{$ENDC}FUNCTION VDSetContrast(ci: VideoDigitizerComponent; VAR contrast: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $E, $7000, $A82A;	{$ENDC}FUNCTION VDSetHue(ci: VideoDigitizerComponent; VAR hue: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $F, $7000, $A82A;	{$ENDC}FUNCTION VDSetSharpness(ci: VideoDigitizerComponent; VAR sharpness: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $10, $7000, $A82A;	{$ENDC}FUNCTION VDSetSaturation(ci: VideoDigitizerComponent; VAR saturation: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $11, $7000, $A82A;	{$ENDC}FUNCTION VDGetContrast(ci: VideoDigitizerComponent; VAR contrast: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $12, $7000, $A82A;	{$ENDC}FUNCTION VDGetHue(ci: VideoDigitizerComponent; VAR hue: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $13, $7000, $A82A;	{$ENDC}FUNCTION VDGetSharpness(ci: VideoDigitizerComponent; VAR sharpness: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $14, $7000, $A82A;	{$ENDC}FUNCTION VDGetSaturation(ci: VideoDigitizerComponent; VAR saturation: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $15, $7000, $A82A;	{$ENDC}FUNCTION VDGrabOneFrame(ci: VideoDigitizerComponent): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $16, $7000, $A82A;	{$ENDC}FUNCTION VDGetMaxAuxBuffer(ci: VideoDigitizerComponent; VAR pm: PixMapHandle; VAR r: Rect): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $17, $7000, $A82A;	{$ENDC}FUNCTION VDGetDigitizerInfo(ci: VideoDigitizerComponent; VAR info: DigitizerInfo): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $19, $7000, $A82A;	{$ENDC}FUNCTION VDGetCurrentFlags(ci: VideoDigitizerComponent; VAR inputCurrentFlag: LONGINT; VAR outputCurrentFlag: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $1A, $7000, $A82A;	{$ENDC}FUNCTION VDSetKeyColor(ci: VideoDigitizerComponent; index: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1B, $7000, $A82A;	{$ENDC}FUNCTION VDGetKeyColor(ci: VideoDigitizerComponent; VAR index: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1C, $7000, $A82A;	{$ENDC}FUNCTION VDAddKeyColor(ci: VideoDigitizerComponent; VAR index: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1D, $7000, $A82A;	{$ENDC}FUNCTION VDGetNextKeyColor(ci: VideoDigitizerComponent; index: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1E, $7000, $A82A;	{$ENDC}FUNCTION VDSetKeyColorRange(ci: VideoDigitizerComponent; VAR minRGB: RGBColor; VAR maxRGB: RGBColor): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $1F, $7000, $A82A;	{$ENDC}FUNCTION VDGetKeyColorRange(ci: VideoDigitizerComponent; VAR minRGB: RGBColor; VAR maxRGB: RGBColor): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $20, $7000, $A82A;	{$ENDC}FUNCTION VDSetDigitizerUserInterrupt(ci: VideoDigitizerComponent; flags: LONGINT; userInterruptProc: VdigIntUPP; refcon: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $21, $7000, $A82A;	{$ENDC}FUNCTION VDSetInputColorSpaceMode(ci: VideoDigitizerComponent; colorSpaceMode: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $22, $7000, $A82A;	{$ENDC}FUNCTION VDGetInputColorSpaceMode(ci: VideoDigitizerComponent; VAR colorSpaceMode: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $23, $7000, $A82A;	{$ENDC}FUNCTION VDSetClipState(ci: VideoDigitizerComponent; clipEnable: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $24, $7000, $A82A;	{$ENDC}FUNCTION VDGetClipState(ci: VideoDigitizerComponent; VAR clipEnable: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $25, $7000, $A82A;	{$ENDC}FUNCTION VDSetClipRgn(ci: VideoDigitizerComponent; clipRegion: RgnHandle): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $26, $7000, $A82A;	{$ENDC}FUNCTION VDClearClipRgn(ci: VideoDigitizerComponent; clipRegion: RgnHandle): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $27, $7000, $A82A;	{$ENDC}FUNCTION VDGetCLUTInUse(ci: VideoDigitizerComponent; VAR colorTableHandle: CTabHandle): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $28, $7000, $A82A;	{$ENDC}FUNCTION VDSetPLLFilterType(ci: VideoDigitizerComponent; pllType: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $29, $7000, $A82A;	{$ENDC}FUNCTION VDGetPLLFilterType(ci: VideoDigitizerComponent; VAR pllType: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $2A, $7000, $A82A;	{$ENDC}FUNCTION VDGetMaskandValue(ci: VideoDigitizerComponent; blendLevel: INTEGER; VAR mask: LONGINT; VAR value: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $2B, $7000, $A82A;	{$ENDC}FUNCTION VDSetMasterBlendLevel(ci: VideoDigitizerComponent; VAR blendLevel: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $2C, $7000, $A82A;	{$ENDC}FUNCTION VDSetPlayThruDestination(ci: VideoDigitizerComponent; dest: PixMapHandle; VAR destRect: Rect; VAR m: MatrixRecord; mask: RgnHandle): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $2D, $7000, $A82A;	{$ENDC}FUNCTION VDSetPlayThruOnOff(ci: VideoDigitizerComponent; state: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $2E, $7000, $A82A;	{$ENDC}FUNCTION VDSetFieldPreference(ci: VideoDigitizerComponent; fieldFlag: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $2F, $7000, $A82A;	{$ENDC}FUNCTION VDGetFieldPreference(ci: VideoDigitizerComponent; VAR fieldFlag: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $30, $7000, $A82A;	{$ENDC}FUNCTION VDPreflightDestination(ci: VideoDigitizerComponent; VAR digitizerRect: Rect; VAR dest: PixMap; VAR destRect: Rect; VAR m: MatrixRecord): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $32, $7000, $A82A;	{$ENDC}FUNCTION VDPreflightGlobalRect(ci: VideoDigitizerComponent; theWindow: GrafPtr; VAR globalRect: Rect): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $33, $7000, $A82A;	{$ENDC}FUNCTION VDSetPlayThruGlobalRect(ci: VideoDigitizerComponent; theWindow: GrafPtr; VAR globalRect: Rect): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $34, $7000, $A82A;	{$ENDC}FUNCTION VDSetInputGammaRecord(ci: VideoDigitizerComponent; inputGammaPtr: VDGamRecPtr): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $35, $7000, $A82A;	{$ENDC}FUNCTION VDGetInputGammaRecord(ci: VideoDigitizerComponent; VAR inputGammaPtr: VDGamRecPtr): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $36, $7000, $A82A;	{$ENDC}FUNCTION VDSetBlackLevelValue(ci: VideoDigitizerComponent; VAR blackLevel: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $37, $7000, $A82A;	{$ENDC}FUNCTION VDGetBlackLevelValue(ci: VideoDigitizerComponent; VAR blackLevel: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $38, $7000, $A82A;	{$ENDC}FUNCTION VDSetWhiteLevelValue(ci: VideoDigitizerComponent; VAR whiteLevel: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $39, $7000, $A82A;	{$ENDC}FUNCTION VDGetWhiteLevelValue(ci: VideoDigitizerComponent; VAR whiteLevel: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $3A, $7000, $A82A;	{$ENDC}FUNCTION VDGetVideoDefaults(ci: VideoDigitizerComponent; VAR blackLevel: INTEGER; VAR whiteLevel: INTEGER; VAR brightness: INTEGER; VAR hue: INTEGER; VAR saturation: INTEGER; VAR contrast: INTEGER; VAR sharpness: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $1C, $3B, $7000, $A82A;	{$ENDC}FUNCTION VDGetNumberOfInputs(ci: VideoDigitizerComponent; VAR inputs: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $3C, $7000, $A82A;	{$ENDC}FUNCTION VDGetInputFormat(ci: VideoDigitizerComponent; input: INTEGER; VAR format: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $3D, $7000, $A82A;	{$ENDC}FUNCTION VDSetInput(ci: VideoDigitizerComponent; input: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $3E, $7000, $A82A;	{$ENDC}FUNCTION VDGetInput(ci: VideoDigitizerComponent; VAR input: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $3F, $7000, $A82A;	{$ENDC}FUNCTION VDSetInputStandard(ci: VideoDigitizerComponent; inputStandard: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $40, $7000, $A82A;	{$ENDC}FUNCTION VDSetupBuffers(ci: VideoDigitizerComponent; bufferList: VdigBufferRecListHandle): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $41, $7000, $A82A;	{$ENDC}FUNCTION VDGrabOneFrameAsync(ci: VideoDigitizerComponent; buffer: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $42, $7000, $A82A;	{$ENDC}FUNCTION VDDone(ci: VideoDigitizerComponent; buffer: INTEGER): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $43, $7000, $A82A;	{$ENDC}FUNCTION VDSetCompression(ci: VideoDigitizerComponent; compressType: OSType; depth: INTEGER; VAR bounds: Rect; spatialQuality: CodecQ; temporalQuality: CodecQ; keyFrameRate: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $16, $44, $7000, $A82A;	{$ENDC}FUNCTION VDCompressOneFrameAsync(ci: VideoDigitizerComponent): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $45, $7000, $A82A;	{$ENDC}FUNCTION VDCompressDone(ci: VideoDigitizerComponent; VAR done: BOOLEAN; VAR theData: Ptr; VAR dataSize: LONGINT; VAR similarity: Byte; VAR t: TimeRecord): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $14, $46, $7000, $A82A;	{$ENDC}FUNCTION VDReleaseCompressBuffer(ci: VideoDigitizerComponent; bufferAddr: Ptr): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $47, $7000, $A82A;	{$ENDC}FUNCTION VDGetImageDescription(ci: VideoDigitizerComponent; desc: ImageDescriptionHandle): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $48, $7000, $A82A;	{$ENDC}FUNCTION VDResetCompressSequence(ci: VideoDigitizerComponent): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $49, $7000, $A82A;	{$ENDC}FUNCTION VDSetCompressionOnOff(ci: VideoDigitizerComponent; state: BOOLEAN): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $4A, $7000, $A82A;	{$ENDC}FUNCTION VDGetCompressionTypes(ci: VideoDigitizerComponent; h: VDCompressionListHandle): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $4B, $7000, $A82A;	{$ENDC}FUNCTION VDSetTimeBase(ci: VideoDigitizerComponent; t: TimeBase): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $4C, $7000, $A82A;	{$ENDC}FUNCTION VDSetFrameRate(ci: VideoDigitizerComponent; framesPerSecond: Fixed): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $4D, $7000, $A82A;	{$ENDC}FUNCTION VDGetDataRate(ci: VideoDigitizerComponent; VAR milliSecPerFrame: LONGINT; VAR framesPerSecond: Fixed; VAR bytesPerSecond: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $4E, $7000, $A82A;	{$ENDC}FUNCTION VDGetSoundInputDriver(ci: VideoDigitizerComponent; VAR soundDriverName: Str255): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $4F, $7000, $A82A;	{$ENDC}FUNCTION VDGetDMADepths(ci: VideoDigitizerComponent; VAR depthArray: LONGINT; VAR preferredDepth: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $50, $7000, $A82A;	{$ENDC}FUNCTION VDGetPreferredTimeScale(ci: VideoDigitizerComponent; VAR preferred: TimeScale): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $51, $7000, $A82A;	{$ENDC}FUNCTION VDReleaseAsyncBuffers(ci: VideoDigitizerComponent): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $52, $7000, $A82A;	{$ENDC}{ 83 is reserved for compatibility reasons }FUNCTION VDSetDataRate(ci: VideoDigitizerComponent; bytesPerSecond: LONGINT): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $54, $7000, $A82A;	{$ENDC}FUNCTION VDGetTimeCode(ci: VideoDigitizerComponent; VAR atTime: TimeRecord; timeCodeFormat: UNIV Ptr; timeCodeTime: UNIV Ptr): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $55, $7000, $A82A;	{$ENDC}FUNCTION VDUseSafeBuffers(ci: VideoDigitizerComponent; useSafeBuffers: BOOLEAN): VideoDigitizerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $56, $7000, $A82A;	{$ENDC}CONST	kSelectVDGetMaxSrcRect		= $1;	kSelectVDGetActiveSrcRect	= $2;	kSelectVDSetDigitizerRect	= $3;	kSelectVDGetDigitizerRect	= $4;	kSelectVDGetVBlankRect		= $5;	kSelectVDGetMaskPixMap		= $6;	kSelectVDGetPlayThruDestination = $8;	kSelectVDUseThisCLUT		= $9;	kSelectVDSetInputGammaValue	= $A;	kSelectVDGetInputGammaValue	= $B;	kSelectVDSetBrightness		= $C;	kSelectVDGetBrightness		= $D;	kSelectVDSetContrast		= $E;	kSelectVDSetHue				= $F;	kSelectVDSetSharpness		= $10;	kSelectVDSetSaturation		= $11;	kSelectVDGetContrast		= $12;	kSelectVDGetHue				= $13;	kSelectVDGetSharpness		= $14;	kSelectVDGetSaturation		= $15;	kSelectVDGrabOneFrame		= $16;	kSelectVDGetMaxAuxBuffer	= $17;	kSelectVDGetDigitizerInfo	= $19;	kSelectVDGetCurrentFlags	= $1A;	kSelectVDSetKeyColor		= $1B;	kSelectVDGetKeyColor		= $1C;	kSelectVDAddKeyColor		= $1D;	kSelectVDGetNextKeyColor	= $1E;	kSelectVDSetKeyColorRange	= $1F;	kSelectVDGetKeyColorRange	= $20;	kSelectVDSetDigitizerUserInterrupt = $21;	kSelectVDSetInputColorSpaceMode = $22;	kSelectVDGetInputColorSpaceMode = $23;	kSelectVDSetClipState		= $24;	kSelectVDGetClipState		= $25;	kSelectVDSetClipRgn			= $26;	kSelectVDClearClipRgn		= $27;	kSelectVDGetCLUTInUse		= $28;	kSelectVDSetPLLFilterType	= $29;	kSelectVDGetPLLFilterType	= $2A;	kSelectVDGetMaskandValue	= $2B;	kSelectVDSetMasterBlendLevel = $2C;	kSelectVDSetPlayThruDestination = $2D;	kSelectVDSetPlayThruOnOff	= $2E;	kSelectVDSetFieldPreference	= $2F;	kSelectVDGetFieldPreference	= $30;	kSelectVDPreflightDestination = $32;	kSelectVDPreflightGlobalRect = $33;	kSelectVDSetPlayThruGlobalRect = $34;	kSelectVDSetInputGammaRecord = $35;	kSelectVDGetInputGammaRecord = $36;	kSelectVDSetBlackLevelValue	= $37;	kSelectVDGetBlackLevelValue	= $38;	kSelectVDSetWhiteLevelValue	= $39;	kSelectVDGetWhiteLevelValue	= $3A;	kSelectVDGetVideoDefaults	= $3B;	kSelectVDGetNumberOfInputs	= $3C;	kSelectVDGetInputFormat		= $3D;	kSelectVDSetInput			= $3E;	kSelectVDGetInput			= $3F;	kSelectVDSetInputStandard	= $40;	kSelectVDSetupBuffers		= $41;	kSelectVDGrabOneFrameAsync	= $42;	kSelectVDDone				= $43;	kSelectVDSetCompression		= $44;	kSelectVDCompressOneFrameAsync = $45;	kSelectVDCompressDone		= $46;	kSelectVDReleaseCompressBuffer = $47;	kSelectVDGetImageDescription = $48;	kSelectVDResetCompressSequence = $49;	kSelectVDSetCompressionOnOff = $4A;	kSelectVDGetCompressionTypes = $4B;	kSelectVDSetTimeBase		= $4C;	kSelectVDSetFrameRate		= $4D;	kSelectVDGetDataRate		= $4E;	kSelectVDGetSoundInputDriver = $4F;	kSelectVDGetDMADepths		= $50;	kSelectVDGetPreferredTimeScale = $51;	kSelectVDReleaseAsyncBuffers = $52;	kSelectVDSetDataRate		= $54;	kSelectVDGetTimeCode		= $55;	kSelectVDUseSafeBuffers		= $56;	StandardCompressionType		= 'scdi';	StandardCompressionSubType	= 'imag';TYPE	SCModalFilterProcPtr = ProcPtr;  { FUNCTION SCModalFilter(theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: INTEGER; refcon: LONGINT): BOOLEAN; }	SCModalHookProcPtr = ProcPtr;  { FUNCTION SCModalHook(theDialog: DialogPtr; itemHit: INTEGER; params: UNIV Ptr; refcon: LONGINT): INTEGER; }	SCModalFilterUPP = UniversalProcPtr;	SCModalHookUPP = UniversalProcPtr;CONST	scListEveryCodec			= 1 * (2**(1));	scAllowZeroFrameRate		= 1 * (2**(2));	scAllowZeroKeyFrameRate		= 1 * (2**(3));	scShowBestDepth				= 1 * (2**(4));	scUseMovableModal			= 1 * (2**(5));{	Possible test flags for setting test image.}	scPreferCropping			= 1 * (2**(0));	scPreferScaling				= 1 * (2**(1));	scPreferScalingAndCropping	= scPreferScaling + scPreferCropping;{	Dimensions of the image preview box.}	scTestImageWidth			= 80;	scTestImageHeight			= 80;{	Possible items returned by hookProc.}	scOKItem					= 1;	scCancelItem				= 2;	scCustomItem				= 3;{	Result returned when user cancelled.}	scUserCancelled				= 1;TYPE	SCSpatialSettings = RECORD		codecType:				CodecType;		codec:					CodecComponent;		depth:					INTEGER;		spatialQuality:			CodecQ;	END;	SCTemporalSettings = RECORD		temporalQuality:		CodecQ;		frameRate:				Fixed;		keyFrameRate:			LONGINT;	END;	SCDataRateSettings = RECORD		dataRate:				LONGINT;		frameDuration:			LONGINT;		minSpatialQuality:		CodecQ;		minTemporalQuality:		CodecQ;	END;	SCExtendedProcs = RECORD		filterProc:				SCModalFilterUPP;		hookProc:				SCModalHookUPP;		refcon:					LONGINT;		customName:				Str31;	END;{	Get/SetInfo selectors}CONST	scSpatialSettingsType		= 'sptl';						{ pointer to SCSpatialSettings struct}	scTemporalSettingsType		= 'tprl';						{ pointer to SCTemporalSettings struct}	scDataRateSettingsType		= 'drat';						{ pointer to SCDataRateSettings struct}	scColorTableType			= 'clut';						{ pointer to CTabHandle}	scProgressProcType			= 'prog';						{ pointer to ProgressRecord struct}	scExtendedProcsType			= 'xprc';						{ pointer to SCExtendedProcs struct}	scPreferenceFlagsType		= 'pref';						{ pointer to long}	scSettingsStateType			= 'ssta';						{ pointer to Handle}	scSequenceIDType			= 'sequ';						{ pointer to ImageSequence}	scWindowPositionType		= 'wndw';						{ pointer to Point}	scCodecFlagsType			= 'cflg';						{ pointer to CodecFlags}	scCodecSettingsType			= 'cdec';						{ pointer to Handle}	scForceKeyValueType			= 'ksim';{	scTypeNotFoundErr returned by Get/SetInfo when type cannot be found.}FUNCTION SCPositionRect(ci: ComponentInstance; VAR rp: Rect; VAR where: Point): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $2, $7000, $A82A;	{$ENDC}FUNCTION SCPositionDialog(ci: ComponentInstance; id: INTEGER; VAR where: Point): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $3, $7000, $A82A;	{$ENDC}FUNCTION SCSetTestImagePictHandle(ci: ComponentInstance; testPict: PicHandle; VAR testRect: Rect; testFlags: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $4, $7000, $A82A;	{$ENDC}FUNCTION SCSetTestImagePictFile(ci: ComponentInstance; testFileRef: INTEGER; VAR testRect: Rect; testFlags: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $5, $7000, $A82A;	{$ENDC}FUNCTION SCSetTestImagePixMap(ci: ComponentInstance; testPixMap: PixMapHandle; VAR testRect: Rect; testFlags: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $6, $7000, $A82A;	{$ENDC}FUNCTION SCGetBestDeviceRect(ci: ComponentInstance; VAR r: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $7, $7000, $A82A;	{$ENDC}FUNCTION SCRequestImageSettings(ci: ComponentInstance): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $A, $7000, $A82A;	{$ENDC}FUNCTION SCCompressImage(ci: ComponentInstance; src: PixMapHandle; srcRect: Rect; VAR desc: ImageDescriptionHandle; VAR data: Handle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $B, $7000, $A82A;	{$ENDC}FUNCTION SCCompressPicture(ci: ComponentInstance; srcPicture: PicHandle; dstPicture: PicHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $C, $7000, $A82A;	{$ENDC}FUNCTION SCCompressPictureFile(ci: ComponentInstance; srcRefNum: INTEGER; dstRefNum: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $D, $7000, $A82A;	{$ENDC}FUNCTION SCRequestSequenceSettings(ci: ComponentInstance): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $E, $7000, $A82A;	{$ENDC}FUNCTION SCCompressSequenceBegin(ci: ComponentInstance; src: PixMapHandle; srcRect: Rect; VAR desc: ImageDescriptionHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $F, $7000, $A82A;	{$ENDC}FUNCTION SCCompressSequenceFrame(ci: ComponentInstance; src: PixMapHandle; srcRect: Rect; VAR data: Handle; VAR dataSize: LONGINT; VAR notSyncFlag: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $14, $10, $7000, $A82A;	{$ENDC}FUNCTION SCCompressSequenceEnd(ci: ComponentInstance): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $11, $7000, $A82A;	{$ENDC}FUNCTION SCDefaultPictHandleSettings(ci: ComponentInstance; srcPicture: PicHandle; motion: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $12, $7000, $A82A;	{$ENDC}FUNCTION SCDefaultPictFileSettings(ci: ComponentInstance; srcRef: INTEGER; motion: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $13, $7000, $A82A;	{$ENDC}FUNCTION SCDefaultPixMapSettings(ci: ComponentInstance; src: PixMapHandle; motion: INTEGER): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $14, $7000, $A82A;	{$ENDC}FUNCTION SCGetInfo(ci: ComponentInstance; infoType: OSType; info: UNIV Ptr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $15, $7000, $A82A;	{$ENDC}FUNCTION SCSetInfo(ci: ComponentInstance; infoType: OSType; info: UNIV Ptr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $16, $7000, $A82A;	{$ENDC}FUNCTION SCNewGWorld(ci: ComponentInstance; VAR gwp: GWorldPtr; VAR rp: Rect; flags: GWorldFlags): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $17, $7000, $A82A;	{$ENDC}FUNCTION SCSetCompressFlags(ci: ComponentInstance; flags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $18, $7000, $A82A;	{$ENDC}FUNCTION SCGetCompressFlags(ci: ComponentInstance; VAR flags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $19, $7000, $A82A;	{$ENDC}{ For compatibility with earlier linked StdCompression. }TYPE	SCParams = RECORD		flags:					LONGINT;		theCodecType:			CodecType;		theCodec:				CodecComponent;		spatialQuality:			CodecQ;		temporalQuality:		CodecQ;		depth:					INTEGER;		frameRate:				Fixed;		keyFrameRate:			LONGINT;		reserved1:				LONGINT;		reserved2:				LONGINT;	END;CONST	scGetCompression			= 1;	scShowMotionSettings		= 1 * (2**(0));	scSettingsChangedItem		= -1;FUNCTION OpenStdCompression: ComponentInstance;FUNCTION SCGetCompressionExtended(ci: ComponentInstance; VAR params: SCParams; where: Point; filterProc: SCModalFilterUPP; hookProc: SCModalHookUPP; refcon: LONGINT; customName: StringPtr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $18, $1, $7000, $A82A;	{$ENDC}	TYPEMovieImportComponent = ComponentInstance;	MovieExportComponent = ComponentInstance;CONST	MovieImportType				= 'eat ';	MovieExportType				= 'spit';	canMovieImportHandles		= 1 * (2**(0));	canMovieImportFiles			= 1 * (2**(1));	hasMovieImportUserInterface	= 1 * (2**(2));	canMovieExportHandles		= 1 * (2**(3));	canMovieExportFiles			= 1 * (2**(4));	hasMovieExportUserInterface	= 1 * (2**(5));	dontAutoFileMovieImport		= 1 * (2**(6));	canMovieExportAuxDataHandle	= 1 * (2**(7));	canMovieImportValidateHandles = 1 * (2**(8));	canMovieImportValidateFile	= 1 * (2**(9));	dontRegisterWithEasyOpen	= 1 * (2**(10));	canMovieImportInPlace		= 1 * (2**(11));	movieImportSubTypeIsFileExtension = 1 * (2**(12));	kMovieImportExportOpenSelect = kComponentOpenSelect;	kMovieImportExportCloseSelect = kComponentCloseSelect;	kMovieImportExportCanDoSelect = kComponentCanDoSelect;	kMovieImportExportVersionSelect = kComponentVersionSelect;	kMovieImportHandleSelect	= 1;	kMovieImportFileSelect		= 2;	kMovieImportSetSampleDurationSelect = 3;	kMovieImportSetSampleDescriptionSelect = 4;	kMovieImportSetMediaFileSelect = 5;	kMovieImportSetDimensionsSelect = 6;	kMovieImportSetChunkSizeSelect = 7;	kMovieImportSetProgressProcSelect = 8;	kMovieImportSetAuxiliaryDataSelect = 9;	kMovieImportSetFromScrapSelect = 10;	kMovieImportDoUserDialogSelect = 11;	kMovieImportSetDurationSelect = 12;	kMovieImportGetAuxiliaryDataTypeSelect = 13;	kMovieImportValidateSelect	= 14;	kMovieImportGetFileTypeSelect = 15;	kMovieExportToHandleSelect	= 128;	kMovieExportToFileSelect	= 129;	kMovieExportDoUserDialogSelectOBSOLETE = 130;	kMovieExportGetAuxiliaryDataSelect = 131;	kMovieExportSetProgressProcSelect = 132;	kMovieExportSetSampleDescriptionSelect = 133;	kMovieExportDoUserDialogSelect = 134;	kMovieExportGetCreatorTypeSelect = 135;	movieImportCreateTrack		= 1;	movieImportInParallel		= 2;	movieImportMustUseTrack		= 4;	movieImportResultUsedMultipleTracks = 8;FUNCTION MovieImportHandle(ci: MovieImportComponent; dataH: Handle; theMovie: Movie; targetTrack: Track; VAR usedTrack: Track; atTime: TimeValue; VAR addedDuration: TimeValue; inFlags: LONGINT; VAR outFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $20, $1, $7000, $A82A;	{$ENDC}FUNCTION MovieImportFile(ci: MovieImportComponent; theFile: FSSpec; theMovie: Movie; targetTrack: Track; VAR usedTrack: Track; atTime: TimeValue; VAR addedDuration: TimeValue; inFlags: LONGINT; VAR outFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $20, $2, $7000, $A82A;	{$ENDC}FUNCTION MovieImportSetSampleDuration(ci: MovieImportComponent; duration: TimeValue; scale: TimeScale): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $3, $7000, $A82A;	{$ENDC}FUNCTION MovieImportSetSampleDescription(ci: MovieImportComponent; desc: SampleDescriptionHandle; mediaType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $4, $7000, $A82A;	{$ENDC}FUNCTION MovieImportSetMediaFile(ci: MovieImportComponent; alias: AliasHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $5, $7000, $A82A;	{$ENDC}FUNCTION MovieImportSetDimensions(ci: MovieImportComponent; width: Fixed; height: Fixed): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $6, $7000, $A82A;	{$ENDC}FUNCTION MovieImportSetChunkSize(ci: MovieImportComponent; chunkSize: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $7, $7000, $A82A;	{$ENDC}FUNCTION MovieImportSetProgressProc(ci: MovieImportComponent; proc: MovieProgressUPP; refcon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $8, $7000, $A82A;	{$ENDC}FUNCTION MovieImportSetAuxiliaryData(ci: MovieImportComponent; data: Handle; handleType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $9, $7000, $A82A;	{$ENDC}FUNCTION MovieImportSetFromScrap(ci: MovieImportComponent; fromScrap: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $A, $7000, $A82A;	{$ENDC}FUNCTION MovieImportDoUserDialog(ci: MovieImportComponent; theFile: FSSpec; theData: Handle; VAR canceled: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $B, $7000, $A82A;	{$ENDC}FUNCTION MovieImportSetDuration(ci: MovieImportComponent; duration: TimeValue): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $C, $7000, $A82A;	{$ENDC}FUNCTION MovieImportGetAuxiliaryDataType(ci: MovieImportComponent; VAR auxType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $D, $7000, $A82A;	{$ENDC}FUNCTION MovieImportValidate(ci: MovieImportComponent; theFile: FSSpec; theData: Handle; VAR valid: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $E, $7000, $A82A;	{$ENDC}FUNCTION MovieImportGetFileType(ci: MovieImportComponent; VAR fileType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $F, $7000, $A82A;	{$ENDC}FUNCTION MovieExportToHandle(ci: MovieExportComponent; dataH: Handle; theMovie: Movie; onlyThisTrack: Track; startTime: TimeValue; duration: TimeValue): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $14, $80, $7000, $A82A;	{$ENDC}FUNCTION MovieExportToFile(ci: MovieExportComponent; theFile: FSSpec; theMovie: Movie; onlyThisTrack: Track; startTime: TimeValue; duration: TimeValue): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $14, $81, $7000, $A82A;	{$ENDC}FUNCTION MovieExportGetAuxiliaryData(ci: MovieExportComponent; dataH: Handle; VAR handleType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $83, $7000, $A82A;	{$ENDC}FUNCTION MovieExportSetProgressProc(ci: MovieExportComponent; proc: MovieProgressUPP; refcon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $84, $7000, $A82A;	{$ENDC}FUNCTION MovieExportSetSampleDescription(ci: MovieExportComponent; desc: SampleDescriptionHandle; mediaType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $85, $7000, $A82A;	{$ENDC}FUNCTION MovieExportDoUserDialog(ci: MovieExportComponent; theMovie: Movie; onlyThisTrack: Track; startTime: TimeValue; duration: TimeValue; VAR canceled: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $14, $86, $7000, $A82A;	{$ENDC}FUNCTION MovieExportGetCreatorType(ci: MovieExportComponent; VAR creator: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $87, $7000, $A82A;	{$ENDC}{ Text Export Display Info data structure}TYPE	TextDisplayData = RECORD		displayFlags:			LONGINT;		textJustification:		LONGINT;		bgColor:				RGBColor;		textBox:				Rect;		beginHilite:			INTEGER;		endHilite:				INTEGER;		hiliteColor:			RGBColor;		doHiliteColor:			BOOLEAN;		filler:					SInt8;		scrollDelayDur:			TimeValue;		dropShadowOffset:		Point;		dropShadowTransparency:	INTEGER;	END;	TextExportComponent = ComponentInstance;FUNCTION TextExportGetDisplayData(ci: TextExportComponent; VAR textDisplay: TextDisplayData): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $100, $7000, $A82A;	{$ENDC}{**************	File Preview Components**************}	TYPEpnotComponent = ComponentInstance;CONST	pnotComponentWantsEvents	= 1;	pnotComponentNeedsNoCache	= 2;	kPreviewOpenSelector		= 0;	kPreviewCloseSelector		= -1;	kPreviewCanDoSelector		= -2;	kPreviewVersionSelector		= -3;	kPreviewShowDataSelector	= 1;	kPreviewMakePreviewSelector	= 2;	kPreviewMakePreviewReferenceSelector = 3;	kPreviewEventSelector		= 4;	ShowFilePreviewComponentType = 'pnot';	CreateFilePreviewComponentType = 'pmak';FUNCTION PreviewShowData(p: pnotComponent; dataType: OSType; data: Handle; inHere: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $1, $7000, $A82A;	{$ENDC}FUNCTION PreviewMakePreview(p: pnotComponent; VAR previewType: OSType; VAR previewResult: Handle; sourceFile: FSSpec; progress: ICMProgressProcRecordPtr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $2, $7000, $A82A;	{$ENDC}FUNCTION PreviewMakePreviewReference(p: pnotComponent; VAR previewType: OSType; VAR resID: INTEGER; sourceFile: FSSpec): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $3, $7000, $A82A;	{$ENDC}FUNCTION PreviewEvent(p: pnotComponent; VAR e: EventRecord; VAR handledEvent: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $4, $7000, $A82A;	{$ENDC}TYPE	DataHCompletionProcPtr = ProcPtr;  { PROCEDURE (request: Ptr; refcon: LONGINT; err: OSErr); }CONST	kDataHCanRead				= 1 * (2**(0));	kDataHSpecialRead			= 1 * (2**(1));	kDataHSpecialReadFile		= 1 * (2**(2));	kDataHCanWrite				= 1 * (2**(3));	kDataHSpecialWrite			= 1 * (2**(4));	kDataHSpecialWriteFile		= 1 * (2**(5));	kDataHCanStreamingWrite		= 1 * (2**(6));	kDataHMustCheckDataRef		= 1 * (2**(7));TYPE	DataHVolumeListRecord = RECORD		vRefNum:				INTEGER;		flags:					LONGINT;	END;	DataHVolumeListPtr = ^DataHVolumeListRecord;	DataHVolumeList = ^DataHVolumeListPtr;CONST	kDataHExtendedSchedule		= 'xtnd';TYPE	DataHScheduleRecord = RECORD		timeNeededBy:			TimeRecord;		extendedID:				LONGINT;								{ always is kDataHExtendedSchedule}		extendedVers:			LONGINT;								{ always set to 0}		priority:				Fixed;									{ 100.0 or more means must have. lower numbersÉ}	END;	DataHSchedulePtr = ^DataHScheduleRecord;FUNCTION DataHGetData(dh: DataHandler; h: Handle; hOffset: LONGINT; offset: LONGINT; size: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $2, $7000, $A82A;	{$ENDC}FUNCTION DataHPutData(dh: DataHandler; h: Handle; hOffset: LONGINT; VAR offset: LONGINT; size: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $3, $7000, $A82A;	{$ENDC}FUNCTION DataHFlushData(dh: DataHandler): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $4, $7000, $A82A;	{$ENDC}FUNCTION DataHOpenForWrite(dh: DataHandler): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $5, $7000, $A82A;	{$ENDC}FUNCTION DataHCloseForWrite(dh: DataHandler): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $6, $7000, $A82A;	{$ENDC}FUNCTION DataHOpenForRead(dh: DataHandler): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $8, $7000, $A82A;	{$ENDC}FUNCTION DataHCloseForRead(dh: DataHandler): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $9, $7000, $A82A;	{$ENDC}FUNCTION DataHSetDataRef(dh: DataHandler; dataRef: Handle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $A, $7000, $A82A;	{$ENDC}FUNCTION DataHGetDataRef(dh: DataHandler; VAR dataRef: Handle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $B, $7000, $A82A;	{$ENDC}FUNCTION DataHCompareDataRef(dh: DataHandler; dataRef: Handle; VAR equal: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $C, $7000, $A82A;	{$ENDC}FUNCTION DataHTask(dh: DataHandler): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $D, $7000, $A82A;	{$ENDC}FUNCTION DataHScheduleData(dh: DataHandler; PlaceToPutDataPtr: Ptr; FileOffset: LONGINT; DataSize: LONGINT; RefCon: LONGINT; scheduleRec: DataHSchedulePtr; CompletionRtn: DataHCompletionProcPtr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $18, $E, $7000, $A82A;	{$ENDC}FUNCTION DataHFinishData(dh: DataHandler; PlaceToPutDataPtr: Ptr; Cancel: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $F, $7000, $A82A;	{$ENDC}FUNCTION DataHFlushCache(dh: DataHandler): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $10, $7000, $A82A;	{$ENDC}FUNCTION DataHResolveDataRef(dh: DataHandler; theDataRef: Handle; VAR wasChanged: BOOLEAN; userInterfaceAllowed: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $11, $7000, $A82A;	{$ENDC}FUNCTION DataHGetFileSize(dh: DataHandler; VAR fileSize: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $12, $7000, $A82A;	{$ENDC}FUNCTION DataHCanUseDataRef(dh: DataHandler; dataRef: Handle; VAR useFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $13, $7000, $A82A;	{$ENDC}FUNCTION DataHGetVolumeList(dh: DataHandler; VAR volumeList: DataHVolumeList): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $14, $7000, $A82A;	{$ENDC}FUNCTION DataHWrite(dh: DataHandler; data: Ptr; offset: LONGINT; size: LONGINT; completion: DataHCompletionProcPtr; refCon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $14, $15, $7000, $A82A;	{$ENDC}FUNCTION DataHPreextend(dh: DataHandler; maxToAdd: LONGINT; VAR spaceAdded: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $16, $7000, $A82A;	{$ENDC}FUNCTION DataHSetFileSize(dh: DataHandler; fileSize: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $17, $7000, $A82A;	{$ENDC}FUNCTION DataHGetFreeSpace(dh: DataHandler; VAR freeSize: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $18, $7000, $A82A;	{$ENDC}FUNCTION DataHCreateFile(dh: DataHandler; creator: OSType; deleteExisting: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $19, $7000, $A82A;	{$ENDC}FUNCTION DataHGetPreferredBlockSize(dh: DataHandler; VAR blockSize: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1A, $7000, $A82A;	{$ENDC}FUNCTION DataHGetDeviceIndex(dh: DataHandler; VAR deviceIndex: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1B, $7000, $A82A;	{$ENDC}FUNCTION DataHIsStreamingDataHandler(dh: DataHandler; VAR yes: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1C, $7000, $A82A;	{$ENDC}FUNCTION DataHGetDataInBuffer(dh: DataHandler; startOffset: LONGINT; VAR size: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $1D, $7000, $A82A;	{$ENDC}FUNCTION DataHGetScheduleAheadTime(dh: DataHandler; VAR millisecs: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1E, $7000, $A82A;	{$ENDC}FUNCTION DataHPlaybackHints(dh: DataHandler; flags: LONGINT; minFileOffset: LONGINT; maxFileOffset: LONGINT; bytesPerSecond: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $103, $7000, $A82A;	{$ENDC}CONST	kDataHGetDataSelect			= $2;	kDataHPutDataSelect			= $3;	kDataHFlushDataSelect		= $4;	kDataHOpenForWriteSelect	= $5;	kDataHCloseForWriteSelect	= $6;	kDataHOpenForReadSelect		= $8;	kDataHCloseForReadSelect	= $9;	kDataHSetDataRefSelect		= $A;	kDataHGetDataRefSelect		= $B;	kDataHCompareDataRefSelect	= $C;	kDataHTaskSelect			= $D;	kDataHScheduleDataSelect	= $E;	kDataHFinishDataSelect		= $F;	kDataHFlushCacheSelect		= $10;	kDataHResolveDataRefSelect	= $11;	kDataHGetFileSizeSelect		= $12;	kDataHCanUseDataRefSelect	= $13;	kDataHGetVolumeListSelect	= $14;	kDataHWriteSelect			= $15;	kDataHPreextendSelect		= $16;	kDataHSetFileSizeSelect		= $17;	kDataHGetFreeSpaceSelect	= $18;	kDataHCreateFileSelect		= $19;	kDataHGetPreferredBlockSizeSelect = $1A;	kDataHGetDeviceIndexSelect	= $1B;	kDataHIsStreamingDataHandlerSelect = $1C;	kDataHGetDataInBufferSelect	= $1D;	kDataHGetScheduleAheadTimeSelect = $1E;	kDataHPlaybackHintsSelect	= $103;	kMusicComponentType			= 'musi';	TYPEMusicComponent = ComponentInstance;{ MusicSynthesizerFlags}CONST	kSynthesizerDynamicVoice	= 1;							{ can reassign voices/channels (else, hogs all channels in mask }	kSynthesizerUsesMIDIPort	= 2;							{ must be patched through MIDI Manager }	kSynthesizerMicrotone		= 4;							{ can play microtonal scales }	kSynthesizerLimitedMicrotone = 8;							{ can play microtones, but only on 1-voice parts }	kSynthesizerMixedDrums		= 16;							{ any part can play drum parts, total = instrument parts }	kSynthesizerSoftware		= 32;							{ implemented in main CPU software == uses cpu cycles }	kSynthesizerGMSuperset		= 8192;	kSynthesizerGM				= 16384;						{ synth is a GM device }{ * Note that these controller numbers * are _not_ identical to the MIDI controller numbers. * These are _signed_ 8.8 values, and the LSB's are * always sent to a MIDI device. Controllers 32-63 are * reserved (for MIDI, they are LSB's for 0-31, but we * always send both). * * The full range, therefore, is -128.00 to 127.7f. * * _Excepting_ _volume_, all controls default to zero. * * Pitch bend is specified in fractional semitones! No * more "pitch bend range" nonsense. You can bend as far * as you want, any time you want. }	kControllerModulationWheel	= 1;	kControllerBreath			= 2;	kControllerFoot				= 4;	kControllerPortamentoTime	= 5;	kControllerVolume			= 7;	kControllerBalance			= 8;	kControllerPan				= 10;							{ 0 - "default", 1 - n: positioned in output 1-n (incl fractions) }	kControllerExpression		= 11;	kControllerPitchBend		= 32;							{ positive & negative semitones, with 7 bits fraction }	kControllerAfterTouch		= 33;	kControllerSustain			= 64;							{ boolean - positive for on, 0 or negative off }	kControllerPortamento		= 65;							{ boolean }	kControllerSostenuto		= 66;							{ boolean }	kControllerSoftPedal		= 67;							{ boolean }	kControllerReverb			= 91;	kControllerTremolo			= 92;	kControllerChorus			= 93;	kControllerCeleste			= 94;	kControllerPhaser			= 95;	kControllerMaximum			= $7FFF;						{ +01111111.11111111 }	kControllerMinimum			= $8000;						{ -10000000.00000000 }TYPE	SynthesizerDescription = RECORD		synthType:				OSType;									{ synthesizer type (usually same as comp.subtype }		name:					Str31;									{ text name of synthesizer type }		flags:					LONGINT;								{ from the above enum }		voiceCount:				LONGINT;								{ maximum polyphony }		partCount:				LONGINT;								{ maximum multi-timbrality (and midi channels) }		instrumentCount:		LONGINT;								{ non gm, built in (rom) instruments only }		modifiableInstrumentCount: LONGINT;								{ plus n-more are user modifiable }		channelMask:			LONGINT;								{ (midi device only) which channels device always uses }		drumPartCount:			LONGINT;								{ maximum multi-timbrality of drum parts }		drumCount:				LONGINT;								{ non gm, built in (rom) drumkits only }		modifiableDrumCount:	LONGINT;								{ plus n-more are user modifiable }		drumChannelMask:		LONGINT;								{ (midi device only) which channels device always uses }		outputCount:			LONGINT;								{ number of audio outputs (usually two) }		latency:				LONGINT;								{ response time in µSec }		controllers:			ARRAY [0..3] OF LONGINT;				{ array of 128 bits }		gmInstruments:			ARRAY [0..3] OF LONGINT;				{ array of 128 bits }		gmDrums:				ARRAY [0..3] OF LONGINT;				{ array of 128 bits }	END;{ constant to use to specify dynamic voicing }CONST	kVoiceCountDynamic			= -1;TYPE	ToneDescription = RECORD		synthesizerType:		OSType;									{ synthesizer type }		synthesizerName:		Str31;									{ name of instantiation of synth }		instrumentName:			Str31;									{ preferred name for human use }		instrumentNumber:		LONGINT;								{ inst-number used if synth-name matches }		gmNumber:				LONGINT;								{ Best matching general MIDI number }	END;{ (first value is "no drum". instrument numbers from 16384->16384+128 are drumkits, and for GM they are _defined_ drumkits! }CONST	kFirstDrumkit				= 16384;	kLastDrumkit				= 0+(kFirstDrumkit + 128);{ InstrumentMatch}	kInstrumentMatchSynthesizerType = 1;	kInstrumentMatchSynthesizerName = 2;	kInstrumentMatchName		= 4;	kInstrumentMatchNumber		= 8;	kInstrumentMatchGMNumber	= 16;{ KnobFlags}	kKnobRealtime				= 1;							{ Knob can be changed interactively as part of a sequence (ie knob can be changed at interrupt time) }	kKnobNextNote				= 2;							{ Knob only takes effect on the next note played }	kKnobAction					= 4;							{ setting the knob does something immediate }	kKnobNotInstrument			= 8;							{ indicates that the knob isn't in the instrument handle }	kKnobAffectsOthers			= 16;							{ other knobs will change value from this one }	kKnobMinorGroupStart		= 64;							{ knob is first in some logical subgroup of knobs }	kKnobGroupStart				= 128;							{ knob is first in some logical group of knobs }{ One of these may be used at a time. }	kKnobTypeNumber				= 0 * (2**(12));	kKnobTypeBoolean			= 1 * (2**(12));	kKnobTypeNote				= 2 * (2**(12));	kKnobTypePan				= 3 * (2**(12));	kKnobTypeInstrument			= 4 * (2**(12));				{ knob value = reference to another instrument number }	kKnobTypeSetting			= 5 * (2**(12));				{ knob value is 1 of n different things (eg, fm algorithms) }{ a knob with this value means, we don't know it. }	kUnknownKnobValue			= $7FFFFFFF;TYPE	KnobDescription = RECORD		name:					Str31;		lowValue:				LONGINT;		highValue:				LONGINT;		defaultValue:			LONGINT;								{ a default instrument is made of all default values }		flags:					LONGINT;	END;	InstrumentData = RECORD		tone:					ToneDescription;		knobCount:				LONGINT;		knob:					ARRAY [0..0] OF LONGINT;	END;	InstrumentDataPtr = ^InstrumentData;	InstrumentDataHandle = ^InstrumentDataPtr;	FlatInstrument = RECORD		tone:					ToneDescription;		size:					LONGINT;								{ size in bytes of the following data, including size field (excluding tonedescription) }		data:					ARRAY [0..3] OF SInt8;	END;	InstrumentAboutInfo = RECORD		p:						PicHandle;		author:					Str255;		copyright:				Str255;		other:					Str255;	END;	MusicMIDIPacket = RECORD		length:					INTEGER;		reserved:				LONGINT;		data:					ARRAY [0..248] OF SInt8;	END;	MusicMIDISendProcPtr = ProcPtr;  { FUNCTION (self: MusicComponent; refCon: LONGINT; VAR mmp: MusicMIDIPacket): ComponentResult; }{--------------------------------}CONST	kMusicFirstSelect			= 0;	kMusicGetDescriptionSelect	= 1;	kMusicGetPartSelect			= 2;	kMusicSetPartSelect			= 3;	kMusicSetInstrumentNumberSelect = 4;	kMusicGetInstrumentNumberSelect = 5;	kMusicStoreInstrumentSelect	= 6;	kMusicGetInstrumentSelect	= 7;	kMusicSetInstrumentSelect	= 8;	kMusicDummyOne				= 9;	kMusicDummyTwo				= 10;	kMusicDummyThree			= 11;	kMusicDummyFour				= 12;	kMusicGetInstrumentKnobDescriptionSelect = 13;	kMusicGetDrumKnobDescriptionSelect = 14;	kMusicGetKnobDescriptionSelect = 15;	kMusicGetPartKnobSelect		= 16;	kMusicSetPartKnobSelect		= 17;	kMusicGetKnobSelect			= 18;	kMusicSetKnobSelect			= 19;	kMusicGetPartNameSelect		= 20;	kMusicSetPartNameSelect		= 21;	kMusicFindToneSelect		= 22;	kMusicPlayNoteSelect		= 23;	kMusicResetPartSelect		= 24;	kMusicSetControllerSelect	= 25;	kMusicGetControllerSelect	= 26;	kMusicGetMIDIProcSelect		= 27;	kMusicSetMIDIProcSelect		= 28;	kMusicGetInstrumentNamesSelect = 29;	kMusicGetDrumNamesSelect	= 30;	kMusicGetMasterTuneSelect	= 31;	kMusicSetMasterTuneSelect	= 32;	kMusicSetFlatInstrumentSelect = 33;	kMusicGetInstrumentAboutInfoSelect = 34;	notImplementedMusicErr		= 0+($80000000 + ((-2100 - 1)));	cantSendToSynthesizerErr	= 0+($80000000 + ((-2100 - 2)));	cantReceiveFromSynthesizerErr = 0+($80000000 + ((-2100 - 3)));	illegalVoiceAllocationErr	= 0+($80000000 + ((-2100 - 4)));	illegalPartErr				= 0+($80000000 + ((-2100 - 5)));	illegalChannelErr			= 0+($80000000 + ((-2100 - 6)));	illegalKnobErr				= 0+($80000000 + ((-2100 - 7)));	illegalKnobValueErr			= 0+($80000000 + ((-2100 - 8)));	illegalInstrumentErr		= 0+($80000000 + ((-2100 - 9)));	illegalControllerErr		= 0+($80000000 + ((-2100 - 10)));	midiManagerAbsentErr		= 0+($80000000 + ((-2100 - 11)));	synthesizerNotRespondingErr	= 0+($80000000 + ((-2100 - 12)));	synthesizerErr				= 0+($80000000 + ((-2100 - 13)));	illegalNoteChannelErr		= 0+($80000000 + ((-2100 - 14)));	noteChannelNotAllocatedErr	= 0+($80000000 + ((-2100 - 15)));	tunePlayerFullErr			= 0+($80000000 + ((-2100 - 16)));	tuneParseErr				= 0+($80000000 + ((-2100 - 17)));	kGMType						= 'gm  ';{-----------------------------------------	Capabilities and Voice Allocation-----------------------------------------}FUNCTION MusicGetPart(mc: MusicComponent; part: LONGINT; VAR midiChannel: LONGINT; VAR polyphony: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $2, $7000, $A82A;	{$ENDC}FUNCTION MusicSetPart(mc: MusicComponent; part: LONGINT; midiChannel: LONGINT; polyphony: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $3, $7000, $A82A;	{$ENDC}FUNCTION MusicGetDescription(mc: MusicComponent; VAR sd: SynthesizerDescription): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1, $7000, $A82A;	{$ENDC}FUNCTION MusicGetInstrumentAboutInfo(mc: MusicComponent; part: LONGINT; VAR iai: InstrumentAboutInfo): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $22, $7000, $A82A;	{$ENDC}{-----------------------------------------	Instrument Loading and Storing-----------------------------------------}FUNCTION MusicSetInstrumentNumber(mc: MusicComponent; part: LONGINT; instrumentNumber: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $4, $7000, $A82A;	{$ENDC}FUNCTION MusicGetInstrumentNumber(mc: MusicComponent; part: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $5, $7000, $A82A;	{$ENDC}FUNCTION MusicStoreInstrument(mc: MusicComponent; part: LONGINT; instrumentNumber: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $6, $7000, $A82A;	{$ENDC}FUNCTION MusicGetInstrument(mc: MusicComponent; part: LONGINT; VAR iH: InstrumentDataHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $7, $7000, $A82A;	{$ENDC}FUNCTION MusicSetInstrument(mc: MusicComponent; part: LONGINT; iH: InstrumentDataHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $8, $7000, $A82A;	{$ENDC}FUNCTION MusicSetFlatInstrument(mc: MusicComponent; part: LONGINT; VAR flatInstrument: FlatInstrument): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $21, $7000, $A82A;	{$ENDC}{-----------------------------------------	Instrument Knobs-----------------------------------------}FUNCTION MusicGetInstrumentKnobDescription(mc: MusicComponent; knobNumber: LONGINT; VAR mkd: KnobDescription): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $D, $7000, $A82A;	{$ENDC}FUNCTION MusicGetDrumKnobDescription(mc: MusicComponent; knobNumber: LONGINT; VAR mkd: KnobDescription): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $E, $7000, $A82A;	{$ENDC}FUNCTION MusicGetPartKnob(mc: MusicComponent; part: LONGINT; knobNumber: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $10, $7000, $A82A;	{$ENDC}FUNCTION MusicSetPartKnob(mc: MusicComponent; part: LONGINT; knobNumber: LONGINT; knobValue: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $11, $7000, $A82A;	{$ENDC}{-----------------------------------------	Synthesizer Knobs-----------------------------------------}FUNCTION MusicGetKnobDescription(mc: MusicComponent; knobNumber: LONGINT; VAR mkd: KnobDescription): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $F, $7000, $A82A;	{$ENDC}FUNCTION MusicGetKnob(mc: MusicComponent; knobNumber: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $12, $7000, $A82A;	{$ENDC}FUNCTION MusicSetKnob(mc: MusicComponent; knobNumber: LONGINT; knobValue: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $13, $7000, $A82A;	{$ENDC}{-----------------------------------------	Names of Instruments-----------------------------------------}FUNCTION MusicGetPartName(mc: MusicComponent; part: LONGINT; VAR name: Str31): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $14, $7000, $A82A;	{$ENDC}FUNCTION MusicSetPartName(mc: MusicComponent; part: LONGINT; VAR name: Str31): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $15, $7000, $A82A;	{$ENDC}FUNCTION MusicFindTone(mc: MusicComponent; VAR td: ToneDescription; VAR instrumentNumber: LONGINT; VAR fit: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $16, $7000, $A82A;	{$ENDC}FUNCTION MusicGetInstrumentNames(mc: MusicComponent; modifiableInstruments: LONGINT; VAR instrumentNames: Handle; VAR instrumentCategoryLasts: Handle; VAR instrumentCategoryNames: Handle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $1D, $7000, $A82A;	{$ENDC}FUNCTION MusicGetDrumNames(mc: MusicComponent; modifiableInstruments: LONGINT; VAR instrumentNumbers: Handle; VAR instrumentNames: Handle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $1E, $7000, $A82A;	{$ENDC}{-----------------------------------------	Realtime Actions-----------------------------------------}FUNCTION MusicPlayNote(mc: MusicComponent; part: LONGINT; pitch: LONGINT; velocity: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $17, $7000, $A82A;	{$ENDC}FUNCTION MusicResetPart(mc: MusicComponent; part: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $18, $7000, $A82A;	{$ENDC}FUNCTION MusicSetController(mc: MusicComponent; part: LONGINT; controllerNumber: LONGINT; controllerValue: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $19, $7000, $A82A;	{$ENDC}FUNCTION MusicGetController(mc: MusicComponent; part: LONGINT; controllerNumber: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $1A, $7000, $A82A;	{$ENDC}{-----------------------------------------	Finding the Hardware-----------------------------------------}FUNCTION MusicGetMIDIProc(mc: MusicComponent; VAR midiSendProc: MusicMIDISendProcPtr; VAR refCon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $1B, $7000, $A82A;	{$ENDC}FUNCTION MusicSetMIDIProc(mc: MusicComponent; midiSendProc: MusicMIDISendProcPtr; refCon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $1C, $7000, $A82A;	{$ENDC}FUNCTION MusicSetMasterTune(mc: MusicComponent; masterTune: Fixed): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $20, $7000, $A82A;	{$ENDC}FUNCTION MusicGetMasterTune(mc: MusicComponent): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $1F, $7000, $A82A;	{$ENDC}{--------------------------	Types--------------------------}	TYPENoteChannel = Ptr;	SynthesizerConnections = RECORD		clientID:				OSType;		inputPortID:			OSType;		outputPortID:			OSType;		midiChannel:			LONGINT;								{ The system channel, others are configurable }		flags:					LONGINT;		reserved:				ARRAY [0..2] OF LONGINT;				{ should be zero, used for MIDI device only }	END;	NoteRequest = RECORD		polyphony:				LONGINT;								{ Maximum number of voices }		typicalPolyphony:		Fixed;									{ Hint for level mixing }		tone:					ToneDescription;	END;CONST	kNAFirstSelector			= -7;	kNATargetSelect				= -6;	kNARegisterSelect			= -5;	kNAVersionSelect			= -4;	kNACanDoSelect				= -3;	kNACloseSelect				= -2;	kNAOpenSelect				= -1;	kNARegisterMusicDeviceSelect = 0;	kNAUnregisterMusicDeviceSelect = 1;	kNAGetRegisteredMusicDeviceSelect = 2;	kNASaveMusicConfigurationSelect = 3;	kNANewNoteChannelSelect		= 4;	kNADisposeNoteChannelSelect	= 5;	kNAGetNoteChannelInfoSelect	= 6;	kNAPrerollNoteChannelSelect	= 7;	kNAUnrollNoteChannelSelect	= 8;	kNAEngageNoteChannelSelect	= 9;	kNADisengageNoteChannelSelect = 10;	kNASetNoteChannelVolumeSelect = 11;	kNAResetNoteChannelSelect	= 12;	kNAPlayNoteSelect			= 13;	kNASetControllerSelect		= 14;	kNASetKnobSelect			= 15;	kNAFindNoteChannelToneSelect = 16;	kNASetNoteChannelInstrumentSelect = 17;	kNAPickInstrumentSelect		= 18;	kNAPickArrangementSelect	= 19;	kNAGetStatusBlockSelect		= 20;	kNASetDefaultMIDIInputSelect = 21;	kNAGetDefaultMIDIInputSelect = 22;	kNAGetNoteChannelStateSelect = 23;	kNASetNoteChannelStateSelect = 24;	kNAUseDefaultMIDIInputSelect = 25;	kNALoseDefaultMIDIInputSelect = 26;	kNAStuffToneDescriptionSelect = 27;	kNACopyrightDialogSelect	= 28;	kNASetFlatInstrumentSelect	= 29;	kNASetInstrumentSelect		= 30;	kNALastSelector				= 31;	TYPENoteAllocator = ComponentInstance;CONST	kPickDontMix				= 1;							{ dont mix instruments with drum sounds }	kPickSameSynth				= 2;							{ only allow the same device that went in, to come out }TYPE	MusicMIDIReadHookProcPtr = ProcPtr;  { FUNCTION (VAR mp: MusicMIDIPacket; myRefCon: LONGINT): ComponentResult; }CONST	kNoteAllocatorType			= 'nota';{--------------------------------	Note Allocator Prototypes--------------------------------}{ System Configuration }FUNCTION NARegisterMusicDevice(na: NoteAllocator; synthType: OSType; VAR name: Str31; VAR connections: SynthesizerConnections): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, 0, $7000, $A82A;	{$ENDC}FUNCTION NAUnregisterMusicDevice(na: NoteAllocator; index: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $1, $7000, $A82A;	{$ENDC}FUNCTION NAGetRegisteredMusicDevice(na: NoteAllocator; index: LONGINT; VAR synthType: OSType; VAR name: Str31; VAR connections: SynthesizerConnections; VAR mc: MusicComponent): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $14, $2, $7000, $A82A;	{$ENDC}FUNCTION NASetDefaultMIDIInput(na: NoteAllocator; VAR sc: SynthesizerConnections): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $15, $7000, $A82A;	{$ENDC}FUNCTION NAGetDefaultMIDIInput(na: NoteAllocator; VAR sc: SynthesizerConnections): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $16, $7000, $A82A;	{$ENDC}FUNCTION NASaveMusicConfiguration(na: NoteAllocator): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $3, $7000, $A82A;	{$ENDC}{ * Allocation }FUNCTION NANewNoteChannel(na: NoteAllocator; VAR noteRequest: NoteRequest; VAR outChannel: NoteChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $4, $7000, $A82A;	{$ENDC}FUNCTION NADisposeNoteChannel(na: NoteAllocator; noteChannel: NoteChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $5, $7000, $A82A;	{$ENDC}FUNCTION NAGetNoteChannelInfo(na: NoteAllocator; noteChannel: NoteChannel; VAR index: LONGINT; VAR part: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $6, $7000, $A82A;	{$ENDC}FUNCTION NAUseDefaultMIDIInput(na: NoteAllocator; readHook: MusicMIDIReadHookProcPtr; refCon: LONGINT; flags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $19, $7000, $A82A;	{$ENDC}FUNCTION NALoseDefaultMIDIInput(na: NoteAllocator): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $1A, $7000, $A82A;	{$ENDC}{ * Setup }FUNCTION NAPrerollNoteChannel(na: NoteAllocator; noteChannel: NoteChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $7, $7000, $A82A;	{$ENDC}FUNCTION NAUnrollNoteChannel(na: NoteAllocator; noteChannel: NoteChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $8, $7000, $A82A;	{$ENDC}FUNCTION NAEngageNoteChannel(na: NoteAllocator; noteChannel: NoteChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $9, $7000, $A82A;	{$ENDC}FUNCTION NADisengageNoteChannel(na: NoteAllocator; noteChannel: NoteChannel; silenceNotes: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $A, $7000, $A82A;	{$ENDC}FUNCTION NAGetNoteChannelState(na: NoteAllocator; noteChannel: NoteChannel; instrumentNumber: LONGINT; VAR state: Handle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $17, $7000, $A82A;	{$ENDC}FUNCTION NASetNoteChannelState(na: NoteAllocator; noteChannel: NoteChannel; instrumentNumber: LONGINT; state: Handle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $18, $7000, $A82A;	{$ENDC}FUNCTION NAResetNoteChannel(na: NoteAllocator; noteChannel: NoteChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $C, $7000, $A82A;	{$ENDC}FUNCTION NASetNoteChannelVolume(na: NoteAllocator; noteChannel: NoteChannel; volume: Fixed): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $B, $7000, $A82A;	{$ENDC}FUNCTION NASetInstrument(na: NoteAllocator; noteChannel: NoteChannel; VAR instrumentData: InstrumentData): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $1E, $7000, $A82A;	{$ENDC}FUNCTION NASetFlatInstrument(na: NoteAllocator; noteChannel: NoteChannel; VAR flatInstrument: FlatInstrument): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $1D, $7000, $A82A;	{$ENDC}{ Control }FUNCTION NAPlayNote(na: NoteAllocator; noteChannel: NoteChannel; pitch: LONGINT; velocity: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $D, $7000, $A82A;	{$ENDC}FUNCTION NASetController(na: NoteAllocator; noteChannel: NoteChannel; controllerNumber: LONGINT; controllerValue: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $E, $7000, $A82A;	{$ENDC}FUNCTION NASetKnob(na: NoteAllocator; noteChannel: NoteChannel; knobNumber: LONGINT; knobValue: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $F, $7000, $A82A;	{$ENDC}FUNCTION NAFindNoteChannelTone(na: NoteAllocator; noteChannel: NoteChannel; VAR td: ToneDescription; VAR instrumentNumber: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $10, $7000, $A82A;	{$ENDC}FUNCTION NASetNoteChannelInstrument(na: NoteAllocator; noteChannel: NoteChannel; instrumentNumber: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $11, $7000, $A82A;	{$ENDC}{ * User Interface }FUNCTION NAPickInstrument(na: NoteAllocator; filterProc: ModalFilterUPP; prompt: StringPtr; VAR sd: ToneDescription; flags: LONGINT; refCon: LONGINT; VAR flatList: Ptr; VAR flatChoiceIndex: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $1C, $12, $7000, $A82A;	{$ENDC}FUNCTION NAStuffToneDescription(na: NoteAllocator; gmNumber: LONGINT; VAR td: ToneDescription): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $1B, $7000, $A82A;	{$ENDC}FUNCTION NAPickArrangement(na: NoteAllocator; filterProc: ModalFilterUPP; prompt: StringPtr; partCount: LONGINT; VAR noteRequestList: NoteRequest; t: Track; songName: StringPtr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $18, $13, $7000, $A82A;	{$ENDC}FUNCTION NACopyrightDialog(na: NoteAllocator; p: PicHandle; author: StringPtr; copyright: StringPtr; other: StringPtr; title: StringPtr; filterProc: ModalFilterUPP; refCon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $1C, $1C, $7000, $A82A;	{$ENDC}{ * Note Allocator interior views }TYPE	NAStatPiece = RECORD		clientName:				Str31;		synthesizerName:		Str31;		part:					LONGINT;		midiChannel:			LONGINT;		polyphony:				LONGINT;		valid:					LONGINT;	END;	NAStat = RECORD		pieceCount:				LONGINT;		piece:					ARRAY [0..63] OF NAStatPiece;	END;FUNCTION NAGetStatusBlock(na: NoteAllocator; VAR stat: NAStat): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $14, $7000, $A82A;	{$ENDC}{--------------------------	Types--------------------------}{ Deepest you can queue tune segments }CONST	kTuneQueueDepth				= 8;TYPE	TuneStatus = RECORD		tune:					^LONGINT;								{ currently playing tune }		tunePtr:				^LONGINT;								{ position within currently playing piece }		time:					TimeValue;								{ current tune time }		queueCount:				INTEGER;								{ how many pieces queued up? }		queueSpots:				INTEGER;								{ How many more tunepieces can be queued }		queueTime:				TimeValue;								{ How much time is queued up? (can be very inaccurate) }		reserved:				ARRAY [0..2] OF LONGINT;	END;CONST	kStopTuneFade				= 1;							{ do a quick, synchronous fadeout }	kStopTuneSustain			= 2;							{ don't silece notes }	kStopTuneInstant			= 4;							{ silence notes fast (else, decay them) }	kStopTuneReleaseChannels	= 8;							{ afterwards, let the channels go }	kTuneSelect					= 3;	kTuneSetHeaderSelect		= 4;	kTuneGetTimeBaseSelect		= 5;	kTuneSetTimeScaleSelect		= 6;	kTuneGetTimeScaleSelect		= 7;	kTuneGetIndexedNoteChannelSelect = 8;	kTuneDummy					= 9;	kTuneQueueSelect			= 10;	kTuneInstantSelect			= 11;	kTuneGetStatusSelect		= 12;	kTuneStopSelect				= 13;	kTuneResumeSelect			= 14;	kTuneFlushSelect			= 15;	kTuneSetVolumeSelect		= 16;	kTuneGetVolumeSelect		= 17;	kTunePrerollSelect			= 18;	kTuneUnrollSelect			= 19;	kTuneLastSelector			= 20;TYPE	TuneCallBackProcPtr = ProcPtr;  { PROCEDURE (status: TuneStatus; refCon: LONGINT); }	TunePlayer = ComponentInstance;CONST	kMaxTunePlayerParts			= 32;	kTunePlayerType				= 'tune';{--------------------------	Prototypes--------------------------}FUNCTION TuneSetHeader(tp: TunePlayer; VAR header: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $4, $7000, $A82A;	{$ENDC}FUNCTION TuneGetTimeBase(tp: TunePlayer; VAR tb: TimeBase): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $5, $7000, $A82A;	{$ENDC}FUNCTION TuneSetTimeScale(tp: TunePlayer; scale: TimeScale): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $6, $7000, $A82A;	{$ENDC}FUNCTION TuneGetTimeScale(tp: TunePlayer; VAR scale: TimeScale): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $7, $7000, $A82A;	{$ENDC}FUNCTION TuneGetIndexedNoteChannel(tp: TunePlayer; i: LONGINT; VAR nc: NoteChannel): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $8, $7000, $A82A;	{$ENDC}{ * Values for when to start. }CONST	kTuneStartNow				= 1;							{ start after buffer is implied }	kTuneDontClipNotes			= 2;							{ allow notes to finish their durations outside sample }	kTuneExcludeEdgeNotes		= 4;							{ dont play notes that start at end of tune }	kTuneStartNewMaster			= 16384;FUNCTION TuneQueue(tp: TunePlayer; VAR tune: LONGINT; tuneRate: Fixed; tuneStartPosition: LONGINT; tuneStopPosition: LONGINT; queueFlags: LONGINT; callBackProc: TuneCallBackProcPtr; refCon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $1C, $A, $7000, $A82A;	{$ENDC}FUNCTION TuneInstant(tp: TunePlayer; VAR tune: LONGINT; tunePosition: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $B, $7000, $A82A;	{$ENDC}FUNCTION TuneGetStatus(tp: TunePlayer; VAR status: TuneStatus): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $C, $7000, $A82A;	{$ENDC}{ * Values for when to start. }CONST	kStopSustain				= 1;							{ Leaves notes playing, not silent }	kStopFadeout				= 2;							{ Does a synchronous fade-out }FUNCTION TuneStop(tp: TunePlayer; stopFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $D, $7000, $A82A;	{$ENDC}FUNCTION TuneResume(tp: TunePlayer): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $E, $7000, $A82A;	{$ENDC}FUNCTION TuneFlush(tp: TunePlayer): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $F, $7000, $A82A;	{$ENDC}FUNCTION TuneSetVolume(tp: TunePlayer; volume: Fixed): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $10, $7000, $A82A;	{$ENDC}FUNCTION TuneGetVolume(tp: TunePlayer): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $11, $7000, $A82A;	{$ENDC}FUNCTION TunePreroll(tp: TunePlayer): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $12, $7000, $A82A;	{$ENDC}FUNCTION TuneUnroll(tp: TunePlayer): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $13, $7000, $A82A;	{$ENDC}{$IFC UNDEFINED __MusicTrackEvent__ }{$SETC __MusicTrackEvent__ := 1}	TYPEMusicOpWord = LONGINT;	MusicOpWordPtr = ^LONGINT;{ 	QuickTime Music Track Event Formats:	At this time, QuickTime music tracks support 5 different event types -- REST events,	short NOTE events, short CONTROL events, short GENERAL events, Long NOTE events,	long CONTROL events, and variable GENERAL events.		¥ REST Event (4 bytes/event):			(0 0 0) (5-bit UNUSED) (24-bit Rest Duration)		¥ÊShort NOTE Events (4 bytes/event):			(0 0 1) (5-bit Instrument) (6-bit Pitch) (7-bit Volume) (11-bit Duration)			where:	Pitch is offset by 32 (Actual pitch = pitch field + 32)		¥ÊShort CONTROL Events (4 bytes/event):			(0 1 0) (5-bit Instrument) (8-bit Controller) (1-bit UNUSED) (1-bit Sign) (7-bit MSB) (7-bit LSB)																		 ( or 15-bit Signed Value)		¥ Short GENERAL Event (4 bytes/event):			(0 1 1) (1-bit UNUSED) (12-bit Sub-Type) (16-bit Value)		¥ Long NOTE Events (8 bytes/event):			(1 0 0 1) (12-bit Instrument) (1-bit UNUSED) (7-bit Pitch) (1-bit UNUSED) (7-bit Volume)			(1 0) (8-bit UNUSED) (22-bit Duration)		¥ÊLong CONTROL Event (8 bytes/event):			(1 0 1 0) (12-bit Instrument) (16-bit Value MSB)			(1 0) (14-bit Controller) (16-bit Value LSB)		¥ÊLong KNOB Event (8 bytes/event):			(1 0 1 1) (12-bit Sub-Type) (16-bit Value MSB)			(1 0) (14-bit KNOB) (16-bit Value LSB)		¥ÊVariable GENERAL Length Events (N bytes/event):			(1 1 1 1) (12-bit Sub-Type) (16-bit Length)				:			(32-bit Data values)				:			(1 1) (14-bit UNUSED) (16-bit Length)			where:	Length field is the number of LONG words in the record.					Lengths include the first and last long words (Minimum length = 2)	The following event type values have not been used yet and are reserved for	future expansion:		¥ (1 0 0 0)		(8 bytes/event)		¥ (1 1 0 0)		(N bytes/event)		¥ (1 1 0 1)		(N bytes/event)		¥ (1 1 1 0)		(N bytes/event)	For all events, the following generalizations apply:		-	All duration values are specified in Millisecond units.		- 	Pitch values are intended to map directly to the MIDI key numbers.		-	Controllers from 0 to 127 correspond to the standard MIDI controllers.			Controllers greater than 127 correspond to other controls (i.e., Pitch Bend,			Key Pressure, and Channel Pressure).}{ Defines for the implemented music event data fields}CONST	kRestEventType				= $0;							{ lower 3-bits }	kNoteEventType				= $1;							{ lower 3-bits }	kControlEventType			= $2;							{ lower 3-bits }	kMarkerEventType			= $3;							{ lower 3-bits }	kUndefined1EventType		= $8;							{ 4-bits }	kXNoteEventType				= $9;							{ 4-bits }	kXControlEventType			= $A;							{ 4-bits }	kKnobEventType				= $B;							{ 4-bits }	kUndefined2EventType		= $C;							{ 4-bits }	kUndefined3EventType		= $D;							{ 4-bits }	kUndefined4EventType		= $E;							{ 4-bits }	kGeneralEventType			= $F;							{ 4-bits }	kXEventLengthBits			= $2;							{ 2 bits: indicates 8-byte event record }	kGeneralEventLengthBits		= $3;							{ 2 bits: indicates variable length event record }	kEventLen					= 1;							{ length of events in long words }	kXEventLen					= 2;	kRestEventLen				= kEventLen;					{ length of events in long words }	kNoteEventLen				= kEventLen;	kControlEventLen			= kEventLen;	kMarkerEventLen				= kEventLen;	kXNoteEventLen				= kXEventLen;	kXControlEventLen			= kXEventLen;	kGeneralEventLen			= kXEventLen;					{ 2 or more, however }{ Universal Event Defines}	kEventLengthFieldPos		= 30;							{ by looking at these two bits of the 1st or last word 			 }	kEventLengthFieldWidth		= 2;							{ of an event you can determine the event length 					 }{ length field: 0 & 1 => 1 long; 2 => 2 longs; 3 => variable length }	kEventTypeFieldPos			= 29;							{ event type field for short events }	kEventTypeFieldWidth		= 3;							{ short type is 3 bits }	kXEventTypeFieldPos			= 28;							{ event type field for extended events }	kXEventTypeFieldWidth		= 4;							{ extended type is 4 bits }	kEventInstrumentFieldPos	= 24;	kEventInstrumentFieldWidth	= 5;	kXEventInstrumentFieldPos	= 16;							{ in the 1st long word }	kXEventInstrumentFieldWidth	= 12;{ Rest Events}	kRestEventDurationFieldPos	= 0;	kRestEventDurationFieldWidth = 24;	kRestEventDurationMax		= 0+((1 * (2**(kRestEventDurationFieldWidth))) - 1);{ Note Events}	kNoteEventPitchFieldPos		= 18;	kNoteEventPitchFieldWidth	= 6;	kNoteEventPitchOffset		= 32;							{ add to value in pitch field to get actual pitch }	kNoteEventVolumeFieldPos	= 11;	kNoteEventVolumeFieldWidth	= 7;	kNoteEventVolumeOffset		= 0;							{ add to value in volume field to get actual volume }	kNoteEventDurationFieldPos	= 0;	kNoteEventDurationFieldWidth = 11;	kNoteEventDurationMax		= 0+((1 * (2**(kNoteEventDurationFieldWidth))) - 1);	kXNoteEventPitchFieldPos	= 0;							{ in the 1st long word }	kXNoteEventPitchFieldWidth	= 16;	kXNoteEventDurationFieldPos	= 0;							{ in the 2nd long word }	kXNoteEventDurationFieldWidth = 22;	kXNoteEventDurationMax		= 0+((1 * (2**(kXNoteEventDurationFieldWidth))) - 1);	kXNoteEventVolumeFieldPos	= 22;							{ in the 2nd long word }	kXNoteEventVolumeFieldWidth	= 7;{ Control Events}	kControlEventControllerFieldPos = 16;	kControlEventControllerFieldWidth = 8;	kControlEventValueFieldPos	= 0;	kControlEventValueFieldWidth = 16;	kXControlEventControllerFieldPos = 0;						{ in the 2nd long word }	kXControlEventControllerFieldWidth = 16;	kXControlEventValueFieldPos	= 0;							{ in the 1st long word }	kXControlEventValueFieldWidth = 16;{ Knob Events}	kKnobEventValueHighFieldPos	= 0;							{ 1st long word }	kKnobEventValueHighFieldWidth = 16;	kKnobEventKnobFieldPos		= 16;							{ 2nd long word }	kKnobEventKnobFieldWidth	= 14;	kKnobEventValueLowFieldPos	= 0;							{ 2nd long word }	kKnobEventValueLowFieldWidth = 16;{ Marker Events}	kMarkerEventSubtypeFieldPos	= 16;	kMarkerEventSubtypeFieldWidth = 8;	kMarkerEventValueFieldPos	= 0;	kMarkerEventValueFieldWidth	= 16;{ General Events}	kGeneralEventSubtypeFieldPos = 16;							{ in the last long word }	kGeneralEventSubtypeFieldWidth = 14;	kGeneralEventLengthFieldPos	= 0;							{ in the 1st & last long words }	kGeneralEventLengthFieldWidth = 16;	kGeneralEventNoteRequest	= 1;							{ Encapsulates NoteRequest data structure }	kGeneralEventInstrument		= 2;							{ Encapsulates poly, typical poly, followed by InstrumentData record }	kGeneralEventFlatInstrument	= 3;							{ Encapsulates poly, typical poly, followed by FlatInstrument record }	kGeneralEventPartName		= 4;							{ Brackets 2 longs follwed by a pascal string (padded to long alignment) }	kGeneralEventPartKey		= 5;							{ Brackets 2 longs }{$ENDC}{$IFC UNDEFINED _TimeCodeMediaHandler_ }{$SETC _TimeCodeMediaHandler_ := 1}CONST	TimeCodeMediaType			= 'tmcd';	TCSourceRefNameType			= 'name';	tcDropFrame					= 1 * (2**(0));	tc24HourMax					= 1 * (2**(1));	tcNegTimesOK				= 1 * (2**(2));	tcCounter					= 1 * (2**(3));TYPE	TimeCodeDef = RECORD		flags:					LONGINT;								{ drop-frame, etc. }		fTimeScale:				TimeScale;								{ time scale of frameDuration (eg. 2997) }		frameDuration:			TimeValue;								{ duration of each frame (eg. 100) }		numFrames:				SInt8;									{ number of frames per second for timecode (eg. 30), number of frames per tick for counter mode }		padding:				SInt8;									{ unused padding byte }	END;CONST{ negative bit is in minutes }	tctNegFlag					= $80;TYPE	TimeCodeTime = RECORD		hours:					SInt8;		minutes:				SInt8;		seconds:				SInt8;		frames:					SInt8;	END;	TimeCodeCounter = RECORD		counter:				LONGINT;	END;	TimeCodeRecord = RECORD		CASE INTEGER OF		0: (			t:							TimeCodeTime;		   );		1: (			c:							TimeCodeCounter;		   );	END;	TimeCodeDescription = RECORD		descSize:				LONGINT;								{ standard sample description header }		dataFormat:				LONGINT;		resvd1:					LONGINT;		resvd2:					INTEGER;		dataRefIndex:			INTEGER;		flags:					LONGINT;								{ timecode specific stuff }		timeCodeDef:			TimeCodeDef;		srcRef:					ARRAY [0..0] OF LONGINT;	END;	TimeCodeDescriptionPtr = ^TimeCodeDescription;	TimeCodeDescriptionHandle = ^TimeCodeDescriptionPtr;CONST	tcdfShowTimeCode			= 1 * (2**(0));	kTCGetCurrentTimeCodeSelect	= 257;	kTCGetTimeCodeAtTimeSelect	= 258;	kTCTimeCodeToStringSelect	= 259;	kTCTimeCodeToFrameNumberSelect = 260;	kTCFrameNumberToTimeCodeSelect = 261;	kTCGetSourceRefSelect		= 262;	kTCSetSourceRefSelect		= 263;	kTCSetTimeCodeFlagsSelect	= 264;	kTCGetTimeCodeFlagsSelect	= 265;	kTCSetDisplayOptionsSelect	= 266;	kTCGetDisplayOptionsSelect	= 267;TYPE	TCTextOptions = RECORD		txFont:					INTEGER;		txFace:					INTEGER;		txSize:					INTEGER;		foreColor:				RGBColor;		backColor:				RGBColor;	END;	TCTextOptionsPtr = ^TCTextOptions;FUNCTION TCGetCurrentTimeCode(mh: MediaHandler; VAR frameNum: LONGINT; VAR tcdef: TimeCodeDef; VAR tcrec: TimeCodeRecord; VAR srcRefH: UserData): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $101, $7000, $A82A;	{$ENDC}FUNCTION TCGetTimeCodeAtTime(mh: MediaHandler; mediaTime: TimeValue; VAR frameNum: LONGINT; VAR tcdef: TimeCodeDef; VAR tcdata: TimeCodeRecord; VAR srcRefH: UserData): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $14, $102, $7000, $A82A;	{$ENDC}FUNCTION TCTimeCodeToFrameNumber(mh: MediaHandler; VAR tcdef: TimeCodeDef; VAR tcrec: TimeCodeRecord; VAR frameNumber: LONGINT): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $104, $7000, $A82A;	{$ENDC}FUNCTION TCFrameNumberToTimeCode(mh: MediaHandler; frameNumber: LONGINT; VAR tcdef: TimeCodeDef; VAR tcrec: TimeCodeRecord): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $105, $7000, $A82A;	{$ENDC}FUNCTION TCTimeCodeToString(mh: MediaHandler; VAR tcdef: TimeCodeDef; VAR tcrec: TimeCodeRecord; tcStr: StringPtr): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $103, $7000, $A82A;	{$ENDC}FUNCTION TCGetSourceRef(mh: MediaHandler; tcdH: TimeCodeDescriptionHandle; VAR srefH: UserData): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $106, $7000, $A82A;	{$ENDC}FUNCTION TCSetSourceRef(mh: MediaHandler; tcdH: TimeCodeDescriptionHandle; srefH: UserData): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $107, $7000, $A82A;	{$ENDC}FUNCTION TCSetTimeCodeFlags(mh: MediaHandler; flags: LONGINT; flagsMask: LONGINT): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $108, $7000, $A82A;	{$ENDC}FUNCTION TCGetTimeCodeFlags(mh: MediaHandler; VAR flags: LONGINT): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $109, $7000, $A82A;	{$ENDC}FUNCTION TCSetDisplayOptions(mh: MediaHandler; textOptions: TCTextOptionsPtr): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $10A, $7000, $A82A;	{$ENDC}FUNCTION TCGetDisplayOptions(mh: MediaHandler; textOptions: TCTextOptionsPtr): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $10B, $7000, $A82A;	{$ENDC}{$ENDC}CONST	uppSGDataProcInfo = $003BFFE0; { FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param, 2 byte param, 4 byte param): 2 byte result; }	uppSGModalFilterProcInfo = $00003FD0; { FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param): 1 byte result; }	uppSGGrabProcInfo = $00000EF0; { FUNCTION (4 byte param, 2 byte param, 4 byte param): 4 byte result; }	uppSGGrabCompleteProcInfo = $00003EF0; { FUNCTION (4 byte param, 2 byte param, 4 byte param, 4 byte param): 4 byte result; }	uppSGDisplayProcInfo = $0000FEF0; { FUNCTION (4 byte param, 2 byte param, 4 byte param, 4 byte param, 4 byte param): 4 byte result; }	uppSGCompressProcInfo = $00000EF0; { FUNCTION (4 byte param, 2 byte param, 4 byte param): 4 byte result; }	uppSGCompressCompleteProcInfo = $0000FEF0; { FUNCTION (4 byte param, 2 byte param, 4 byte param, 4 byte param, 4 byte param): 4 byte result; }	uppSGAddFrameProcInfo = $0003FEF0; { FUNCTION (4 byte param, 2 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param): 4 byte result; }	uppSGTransferFrameProcInfo = $0000FEF0; { FUNCTION (4 byte param, 2 byte param, 4 byte param, 4 byte param, 4 byte param): 4 byte result; }	uppSGGrabCompressCompleteProcInfo = $0000FFF0; { FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param): 4 byte result; }	uppSGDisplayCompressProcInfo = $0003FFF0; { FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param, 4 byte param): 4 byte result; }	uppVdigIntProcInfo = $000003C0; { PROCEDURE (4 byte param, 4 byte param); }	uppSCModalFilterProcInfo = $00003FD0; { FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param): 1 byte result; }	uppSCModalHookProcInfo = $00003EE0; { FUNCTION (4 byte param, 2 byte param, 4 byte param, 4 byte param): 2 byte result; }FUNCTION NewSGDataProc(userRoutine: SGDataProcPtr): SGDataUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSGModalFilterProc(userRoutine: SGModalFilterProcPtr): SGModalFilterUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSGGrabProc(userRoutine: SGGrabProcPtr): SGGrabUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSGGrabCompleteProc(userRoutine: SGGrabCompleteProcPtr): SGGrabCompleteUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSGDisplayProc(userRoutine: SGDisplayProcPtr): SGDisplayUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSGCompressProc(userRoutine: SGCompressProcPtr): SGCompressUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSGCompressCompleteProc(userRoutine: SGCompressCompleteProcPtr): SGCompressCompleteUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSGAddFrameProc(userRoutine: SGAddFrameProcPtr): SGAddFrameUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSGTransferFrameProc(userRoutine: SGTransferFrameProcPtr): SGTransferFrameUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSGGrabCompressCompleteProc(userRoutine: SGGrabCompressCompleteProcPtr): SGGrabCompressCompleteUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSGDisplayCompressProc(userRoutine: SGDisplayCompressProcPtr): SGDisplayCompressUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewVdigIntProc(userRoutine: VdigIntProcPtr): VdigIntUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSCModalFilterProc(userRoutine: SCModalFilterProcPtr): SCModalFilterUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewSCModalHookProc(userRoutine: SCModalHookProcPtr): SCModalHookUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION CallSGDataProc(c: SGChannel; p: Ptr; len: LONGINT; VAR offset: LONGINT; chRefCon: LONGINT; time: TimeValue; writeType: INTEGER; refCon: LONGINT; userRoutine: SGDataUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSGModalFilterProc(theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: INTEGER; refCon: LONGINT; userRoutine: SGModalFilterUPP): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSGGrabProc(c: SGChannel; bufferNum: INTEGER; refCon: LONGINT; userRoutine: SGGrabUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSGGrabCompleteProc(c: SGChannel; bufferNum: INTEGER; VAR done: BOOLEAN; refCon: LONGINT; userRoutine: SGGrabCompleteUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSGDisplayProc(c: SGChannel; bufferNum: INTEGER; VAR mp: MatrixRecord; clipRgn: RgnHandle; refCon: LONGINT; userRoutine: SGDisplayUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSGCompressProc(c: SGChannel; bufferNum: INTEGER; refCon: LONGINT; userRoutine: SGCompressUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSGCompressCompleteProc(c: SGChannel; bufferNum: INTEGER; VAR done: BOOLEAN; VAR ci: SGCompressInfo; refCon: LONGINT; userRoutine: SGCompressCompleteUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSGAddFrameProc(c: SGChannel; bufferNum: INTEGER; atTime: TimeValue; scale: TimeScale; ci: SGCompressInfo; refCon: LONGINT; userRoutine: SGAddFrameUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSGTransferFrameProc(c: SGChannel; bufferNum: INTEGER; VAR mp: MatrixRecord; clipRgn: RgnHandle; refCon: LONGINT; userRoutine: SGTransferFrameUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSGGrabCompressCompleteProc(c: SGChannel; VAR done: BOOLEAN; VAR ci: SGCompressInfo; VAR t: TimeRecord; refCon: LONGINT; userRoutine: SGGrabCompressCompleteUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSGDisplayCompressProc(c: SGChannel; dataPtr: Ptr; desc: ImageDescriptionHandle; VAR mp: MatrixRecord; clipRgn: RgnHandle; refCon: LONGINT; userRoutine: SGDisplayCompressUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}PROCEDURE CallVdigIntProc(flags: LONGINT; refcon: LONGINT; userRoutine: VdigIntUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSCModalFilterProc(theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: INTEGER; refcon: LONGINT; userRoutine: SCModalFilterUPP): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallSCModalHookProc(theDialog: DialogPtr; itemHit: INTEGER; params: UNIV Ptr; refcon: LONGINT; userRoutine: SCModalHookUPP): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := QuickTimeComponentsIncludes}{$ENDC} {__QUICKTIMECOMPONENTS__}{$IFC NOT UsingIncludes} END.{$ENDC}