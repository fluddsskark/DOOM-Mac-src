{ 	File:		Windows.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT Windows; INTERFACE{$ENDC}{$IFC UNDEFINED __WINDOWS__}{$SETC __WINDOWS__ := 1}{$I+}{$SETC WindowsIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __MEMORY__}{$I Memory.p}{$ENDC}{	Types.p														}{		ConditionalMacros.p										}{	MixedMode.p													}{$IFC UNDEFINED __QUICKDRAW__}{$I Quickdraw.p}{$ENDC}{	QuickdrawText.p												}{$IFC UNDEFINED __EVENTS__}{$I Events.p}{$ENDC}{	OSUtils.p													}{$IFC UNDEFINED __CONTROLS__}{$I Controls.p}{$ENDC}{	Menus.p														}{$PUSH}{$ALIGN MAC68K}{$LibExport+}CONST	documentProc				= 0;	dBoxProc					= 1;	plainDBox					= 2;	altDBoxProc					= 3;	noGrowDocProc				= 4;	movableDBoxProc				= 5;	zoomDocProc					= 8;	zoomNoGrow					= 12;	rDocProc					= 16;{ floating window defproc ids }	floatProc					= 1985;	floatGrowProc				= 1987;	floatZoomProc				= 1989;	floatZoomGrowProc			= 1991;	floatSideProc				= 1993;	floatSideGrowProc			= 1995;	floatSideZoomProc			= 1997;	floatSideZoomGrowProc		= 1999;{ window kinds }	dialogKind					= 2;	userKind					= 8;{FindWindow Result Codes}	inDesk						= 0;	inMenuBar					= 1;	inSysWindow					= 2;	inContent					= 3;	inDrag						= 4;	inGrow						= 5;	inGoAway					= 6;	inZoomIn					= 7;	inZoomOut					= 8;{window messages}	wDraw						= 0;	wHit						= 1;	wCalcRgns					= 2;	wNew						= 3;	wDispose					= 4;	wGrow						= 5;	wDrawGIcon					= 6;	deskPatID					= 16;{Window Part Identifiers which correlate color table entries with window elements}	wContentColor				= 0;	wFrameColor					= 1;	wTextColor					= 2;	wHiliteColor				= 3;	wTitleBarColor				= 4;	wNoHit						= 0;	wInContent					= 1;	wInDrag						= 2;	wInGrow						= 3;	wInGoAway					= 4;	wInZoomIn					= 5;	wInZoomOut					= 6;TYPE	WindowDefProcPtr = ProcPtr;  { FUNCTION WindowDef(varCode: INTEGER; theWindow: WindowRef; message: INTEGER; param: LONGINT): LONGINT; }	{		DeskHookProcPtr uses register based parameters on the 68k and cannot		be written in or called from a high-level language without the help of		mixed mode or assembly glue.		In:		 => mouseClick  	D0.B		 => *theEvent   	A0.L	}	DeskHookProcPtr = ProcPtr;  { PROCEDURE DeskHook(mouseClick: BOOLEAN; VAR theEvent: EventRecord); }	WindowDefUPP = UniversalProcPtr;	DeskHookUPP = UniversalProcPtr;CONST	uppWindowDefProcInfo = $00003BB0; { FUNCTION (2 byte param, 4 byte param, 2 byte param, 4 byte param): 4 byte result; }	uppDeskHookProcInfo = $00130802; { Register PROCEDURE (1 byte in D0, 4 bytes in A0); }FUNCTION NewWindowDefProc(userRoutine: WindowDefProcPtr): WindowDefUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewDeskHookProc(userRoutine: DeskHookProcPtr): DeskHookUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION CallWindowDefProc(varCode: INTEGER; theWindow: WindowRef; message: INTEGER; param: LONGINT; userRoutine: WindowDefUPP): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}PROCEDURE CallDeskHookProc(mouseClick: BOOLEAN; VAR theEvent: EventRecord; userRoutine: DeskHookUPP);	{$IFC NOT GENERATINGCFM}	{To be implemented:  Glue to move parameters into registers.}	{$ENDC}FUNCTION GetGrayRgn : RgnHandle;	{$IFC NOT CFMSYSTEMCALLS}	INLINE $2EB8, $09EE;			{ MOVE.L $09EE,(SP) }	{$ENDC}TYPE	WinCTab = RECORD		wCSeed:					LONGINT;								{reserved}		wCReserved:				INTEGER;								{reserved}		ctSize:					INTEGER;								{usually 4 for windows}		ctTable:				ARRAY [0..4] OF ColorSpec;	END;	WCTabPtr = ^WinCTab;	WCTabHandle = ^WCTabPtr;PROCEDURE InitWindows;	{$IFC NOT GENERATINGCFM}	INLINE $A912;	{$ENDC}PROCEDURE GetWMgrPort(VAR wPort: GrafPtr);	{$IFC NOT GENERATINGCFM}	INLINE $A910;	{$ENDC}FUNCTION NewWindow(wStorage: UNIV Ptr; boundsRect: Rect; title: ConstStr255Param; visible: BOOLEAN; theProc: INTEGER; behind: WindowRef; goAwayFlag: BOOLEAN; refCon: LONGINT): WindowRef;	{$IFC NOT GENERATINGCFM}	INLINE $A913;	{$ENDC}FUNCTION GetNewWindow(windowID: INTEGER; wStorage: UNIV Ptr; behind: WindowRef): WindowRef;	{$IFC NOT GENERATINGCFM}	INLINE $A9BD;	{$ENDC}PROCEDURE CloseWindow(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A92D;	{$ENDC}PROCEDURE DisposeWindow(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A914;	{$ENDC}PROCEDURE GetWTitle(theWindow: WindowRef; VAR title: Str255);	{$IFC NOT GENERATINGCFM}	INLINE $A919;	{$ENDC}PROCEDURE SelectWindow(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A91F;	{$ENDC}PROCEDURE HideWindow(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A916;	{$ENDC}PROCEDURE ShowWindow(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A915;	{$ENDC}PROCEDURE ShowHide(theWindow: WindowRef; showFlag: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $A908;	{$ENDC}PROCEDURE HiliteWindow(theWindow: WindowRef; fHilite: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $A91C;	{$ENDC}PROCEDURE BringToFront(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A920;	{$ENDC}PROCEDURE SendBehind(theWindow: WindowRef; behindWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A921;	{$ENDC}FUNCTION FrontWindow: WindowRef;	{$IFC NOT GENERATINGCFM}	INLINE $A924;	{$ENDC}PROCEDURE DrawGrowIcon(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A904;	{$ENDC}PROCEDURE MoveWindow(theWindow: WindowRef; hGlobal: INTEGER; vGlobal: INTEGER; front: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $A91B;	{$ENDC}PROCEDURE SizeWindow(theWindow: WindowRef; w: INTEGER; h: INTEGER; fUpdate: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $A91D;	{$ENDC}PROCEDURE ZoomWindow(theWindow: WindowRef; partCode: INTEGER; front: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $A83A;	{$ENDC}PROCEDURE InvalRect(badRect: Rect);	{$IFC NOT GENERATINGCFM}	INLINE $A928;	{$ENDC}PROCEDURE InvalRgn(badRgn: RgnHandle);	{$IFC NOT GENERATINGCFM}	INLINE $A927;	{$ENDC}PROCEDURE ValidRect(goodRect: Rect);	{$IFC NOT GENERATINGCFM}	INLINE $A92A;	{$ENDC}PROCEDURE ValidRgn(goodRgn: RgnHandle);	{$IFC NOT GENERATINGCFM}	INLINE $A929;	{$ENDC}PROCEDURE BeginUpdate(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A922;	{$ENDC}PROCEDURE EndUpdate(theWindow: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A923;	{$ENDC}PROCEDURE SetWRefCon(theWindow: WindowRef; data: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $A918;	{$ENDC}FUNCTION GetWRefCon(theWindow: WindowRef): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $A917;	{$ENDC}PROCEDURE SetWindowPic(theWindow: WindowRef; pic: PicHandle);	{$IFC NOT GENERATINGCFM}	INLINE $A92E;	{$ENDC}FUNCTION GetWindowPic(theWindow: WindowRef): PicHandle;	{$IFC NOT GENERATINGCFM}	INLINE $A92F;	{$ENDC}FUNCTION CheckUpdate(VAR theEvent: EventRecord): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $A911;	{$ENDC}PROCEDURE ClipAbove(window: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A90B;	{$ENDC}PROCEDURE SaveOld(window: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A90E;	{$ENDC}PROCEDURE DrawNew(window: WindowRef; update: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $A90F;	{$ENDC}PROCEDURE PaintOne(window: WindowRef; clobberedRgn: RgnHandle);	{$IFC NOT GENERATINGCFM}	INLINE $A90C;	{$ENDC}PROCEDURE PaintBehind(startWindow: WindowRef; clobberedRgn: RgnHandle);	{$IFC NOT GENERATINGCFM}	INLINE $A90D;	{$ENDC}PROCEDURE CalcVis(window: WindowRef);	{$IFC NOT GENERATINGCFM}	INLINE $A909;	{$ENDC}PROCEDURE CalcVisBehind(startWindow: WindowRef; clobberedRgn: RgnHandle);	{$IFC NOT GENERATINGCFM}	INLINE $A90A;	{$ENDC}FUNCTION GrowWindow(theWindow: WindowRef; startPt: Point; bBox: Rect): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $A92B;	{$ENDC}FUNCTION FindWindow(thePoint: Point; VAR theWindow: WindowRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A92C;	{$ENDC}FUNCTION PinRect(theRect: Rect; thePt: Point): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $A94E;	{$ENDC}FUNCTION DragGrayRgn(theRgn: RgnHandle; startPt: Point; limitRect: Rect; slopRect: Rect; axis: INTEGER; actionProc: DragGrayRgnUPP): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $A905;	{$ENDC}FUNCTION DragTheRgn(theRgn: RgnHandle; startPt: Point; limitRect: Rect; slopRect: Rect; axis: INTEGER; actionProc: DragGrayRgnUPP): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $A926;	{$ENDC}FUNCTION TrackBox(theWindow: WindowRef; thePt: Point; partCode: INTEGER): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $A83B;	{$ENDC}PROCEDURE GetCWMgrPort(VAR wMgrCPort: CGrafPtr);	{$IFC NOT GENERATINGCFM}	INLINE $AA48;	{$ENDC}PROCEDURE SetWinColor(theWindow: WindowRef; newColorTable: WCTabHandle);	{$IFC NOT GENERATINGCFM}	INLINE $AA41;	{$ENDC}PROCEDURE SetDeskCPat(deskPixPat: PixPatHandle);	{$IFC NOT GENERATINGCFM}	INLINE $AA47;	{$ENDC}FUNCTION NewCWindow(wStorage: UNIV Ptr; boundsRect: Rect; title: ConstStr255Param; visible: BOOLEAN; procID: INTEGER; behind: WindowRef; goAwayFlag: BOOLEAN; refCon: LONGINT): WindowRef;	{$IFC NOT GENERATINGCFM}	INLINE $AA45;	{$ENDC}FUNCTION GetNewCWindow(windowID: INTEGER; wStorage: UNIV Ptr; behind: WindowRef): WindowRef;	{$IFC NOT GENERATINGCFM}	INLINE $AA46;	{$ENDC}FUNCTION GetWVariant(theWindow: WindowRef): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $A80A;	{$ENDC}PROCEDURE SetWTitle(theWindow: WindowRef; title: ConstStr255Param);	{$IFC NOT GENERATINGCFM}	INLINE $A91A;	{$ENDC}FUNCTION TrackGoAway(theWindow: WindowRef; thePt: Point): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $A91E;	{$ENDC}PROCEDURE DragWindow(theWindow: WindowRef; startPt: Point; boundsRect: Rect);	{$IFC NOT GENERATINGCFM}	INLINE $A925;	{$ENDC}{$IFC NOT STRICT_WINDOWS }	TYPEWindowPeek = ^WindowRecord;	WindowRecord = RECORD		port:					GrafPort;		windowKind:				INTEGER;		visible:				BOOLEAN;		hilited:				BOOLEAN;		goAwayFlag:				BOOLEAN;		spareFlag:				BOOLEAN;		strucRgn:				RgnHandle;		contRgn:				RgnHandle;		updateRgn:				RgnHandle;		windowDefProc:			Handle;		dataHandle:				Handle;		titleHandle:			StringHandle;		titleWidth:				INTEGER;		controlList:			ControlRef;		nextWindow:				WindowPeek;		windowPic:				PicHandle;		refCon:					LONGINT;	END;	CWindowPeek = ^CWindowRecord;	CWindowRecord = RECORD		port:					CGrafPort;		windowKind:				INTEGER;		visible:				BOOLEAN;		hilited:				BOOLEAN;		goAwayFlag:				BOOLEAN;		spareFlag:				BOOLEAN;		strucRgn:				RgnHandle;		contRgn:				RgnHandle;		updateRgn:				RgnHandle;		windowDefProc:			Handle;		dataHandle:				Handle;		titleHandle:			StringHandle;		titleWidth:				INTEGER;		controlList:			ControlRef;		nextWindow:				CWindowPeek;		windowPic:				PicHandle;		refCon:					LONGINT;	END;	WStateData = RECORD		userState:				Rect;									{user state}		stdState:				Rect;									{standard state}	END;	WStateDataPtr = ^WStateData;	WStateDataHandle = ^WStateDataPtr;	AuxWinPtr = ^AuxWinRec;	AuxWinHandle = ^AuxWinPtr;	AuxWinRec = RECORD		awNext:					AuxWinHandle;							{handle to next AuxWinRec}		awOwner:				WindowRef;								{ptr to window }		awCTable:				CTabHandle;								{color table for this window}		reserved:				UInt32;									{  }		awFlags:				LONGINT;								{reserved for expansion}		awReserved:				CTabHandle;								{reserved for expansion}		awRefCon:				LONGINT;								{user Constant}	END;FUNCTION GetAuxWin(theWindow: WindowRef; VAR awHndl: AuxWinHandle): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $AA42;	{$ENDC}{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := WindowsIncludes}{$ENDC} {__WINDOWS__}{$IFC NOT UsingIncludes} END.{$ENDC}