{ 	File:		Movies.p  	Copyright:	© 1984-1994 by Apple Computer, Inc. 				All rights reserved.  	Version:	Universal Interfaces 2.0a1.  ETO #15, MPW prerelease.  Sunday, July 17, 1994.   	Bugs?:		If you find a problem with this file, send the file and version 				information (from above) and the problem description to:  					Internet:	apple.bugs@applelink.apple.com 					AppleLink:	APPLE.BUGS }{$IFC UNDEFINED UsingIncludes}{$SETC UsingIncludes := 0}{$ENDC}{$IFC NOT UsingIncludes} UNIT Movies; INTERFACE{$ENDC}{$IFC UNDEFINED __MOVIES__}{$SETC __MOVIES__ := 1}{$I+}{$SETC MoviesIncludes := UsingIncludes}{$SETC UsingIncludes := 1}{$IFC UNDEFINED __QUICKDRAW__}{$I Quickdraw.p}{$ENDC}{	Types.p														}{		ConditionalMacros.p										}{	MixedMode.p													}{	QuickdrawText.p												}{$IFC UNDEFINED __ALIASES__}{$I Aliases.p}{$ENDC}{	AppleTalk.p													}{		OSUtils.p												}{	Files.p														}{$IFC UNDEFINED __EVENTS__}{$I Events.p}{$ENDC}{$IFC UNDEFINED __MENUS__}{$I Menus.p}{$ENDC}{	Memory.p													}{$IFC UNDEFINED __COMPONENTS__}{$I Components.p}{$ENDC}{$IFC UNDEFINED __IMAGECOMPRESSION__}{$I ImageCompression.p}{$ENDC}{	QDOffscreen.p												}{		Errors.p												}{	Windows.p													}{		Controls.p												}{	StandardFile.p												}{		Dialogs.p												}{			TextEdit.p											}{$PUSH}{$ALIGN MAC68K}{$LibExport+}CONST	MovieFileType				= 'MooV';{  "kFix1" is defined in FixMath as "fixed1"  }{ error codes are in Errors.[haa] }{ gestalt codes are in Gestalt.[hpa] }	MediaHandlerType			= 'mhlr';	DataHandlerType				= 'dhlr';	VideoMediaType				= 'vide';	SoundMediaType				= 'soun';	TextMediaType				= 'text';	BaseMediaType				= 'gnrc';	VisualMediaCharacteristic	= 'eyes';	AudioMediaCharacteristic	= 'ears';	DoTheRightThing				= 0;TYPE	MovieRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	Movie = ^MovieRecord;	TrackRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	Track = ^TrackRecord;	MediaRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	Media = ^MediaRecord;	UserDataRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	UserData = ^UserDataRecord;	TrackEditStateRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	TrackEditState = ^TrackEditStateRecord;	MovieEditStateRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	MovieEditState = ^MovieEditStateRecord;	SampleDescription = RECORD		descSize:				LONGINT;		dataFormat:				LONGINT;		resvd1:					LONGINT;		resvd2:					INTEGER;		dataRefIndex:			INTEGER;	END;	SampleDescriptionPtr = ^SampleDescription;	SampleDescriptionHandle = ^SampleDescriptionPtr;	SoundDescription = RECORD		descSize:				LONGINT;								{ total size of SoundDescription including extra data }		dataFormat:				LONGINT;								{  }		resvd1:					LONGINT;								{ reserved for apple use }		resvd2:					INTEGER;		dataRefIndex:			INTEGER;		version:				INTEGER;								{ which version is this data }		revlevel:				INTEGER;								{ what version of that codec did this }		vendor:					LONGINT;								{ whose  codec compressed this data }		numChannels:			INTEGER;								{ number of channels of sound }		sampleSize:				INTEGER;								{ number of bits per sample }		compressionID:			INTEGER;								{ sound compression used, 0 if none }		packetSize:				INTEGER;								{ packet size for compression, 0 if no compression }		sampleRate:				Fixed;									{ sample rate sound is captured at }	END;	SoundDescriptionPtr = ^SoundDescription;	SoundDescriptionHandle = ^SoundDescriptionPtr;	TextDescription = RECORD		size:					LONGINT;								{ Total size of TextDescription}		format:					LONGINT;								{ 'text' (field name can't be "type" because it is a reserved word in pascal)}		resvd1:					LONGINT;		resvd2:					INTEGER;		dataRefIndex:			INTEGER;		displayFlags:			LONGINT;								{ see enum below for flag values}		textJustification:		LONGINT;								{ Can be: teCenter,teFlush -Default,-Right,-Left}		bgColor:				RGBColor;								{ Background color}		defaultTextBox:			Rect;									{ Location to place the text within the track bounds}		defaultStyle:			ScrpSTElement;							{ Default style (struct defined in TextEdit.h)}		defaultFontName:		PACKED ARRAY [0..0] OF CHAR;			{ Font Name (pascal string - struct extended to fit)}	END;	TextDescriptionPtr = ^TextDescription;	TextDescriptionHandle = ^TextDescriptionPtr;CONST	dfDontDisplay				= 1 * (2**(0));					{ Don't display the text}	dfDontAutoScale				= 1 * (2**(1));					{ Don't scale text as track bounds grows or shrinks}	dfClipToTextBox				= 1 * (2**(2));					{ Clip update to the textbox}	dfUseMovieBGColor			= 1 * (2**(3));					{ Set text background to movie's background color}	dfShrinkTextBoxToFit		= 1 * (2**(4));					{ Compute minimum box to fit the sample}	dfScrollIn					= 1 * (2**(5));					{ Scroll text in until last of text is in view}	dfScrollOut					= 1 * (2**(6));					{ Scroll text out until last of text is gone (if both set, scroll in then out)}	dfHorizScroll				= 1 * (2**(7));					{ Scroll text horizontally (otherwise it's vertical)}	dfReverseScroll				= 1 * (2**(8));					{ vert: scroll down rather than up; horiz: scroll backwards (justfication dependent)}	dfContinuousScroll			= 1 * (2**(9));					{ new samples cause previous samples to scroll out}	dfFlowHoriz					= 1 * (2**(10));				{ horiz scroll text flows in textbox rather than extend to right}	dfDropShadow				= 1 * (2**(12));				{ display text with a drop shadow}	dfAntiAlias					= 1 * (2**(13));				{ attempt to display text anti aliased}	dfKeyedText					= 1 * (2**(14));				{ key the text over background}	dfInverseHilite				= 1 * (2**(15));				{ Use inverse hiliting rather than using hilite color}	searchTextDontGoToFoundTime	= 1 * (2**(16));	searchTextDontHiliteFoundText = 1 * (2**(17));	searchTextOneTrackOnly		= 1 * (2**(18));	searchTextEnabledTracksOnly	= 1 * (2**(19));{ progress messages }	movieProgressOpen			= 0;	movieProgressUpdatePercent	= 1;	movieProgressClose			= 2;{ progress operations }	progressOpFlatten			= 1;	progressOpInsertTrackSegment = 2;	progressOpInsertMovieSegment = 3;	progressOpPaste				= 4;	progressOpAddMovieSelection	= 5;	progressOpCopy				= 6;	progressOpCut				= 7;	progressOpLoadMovieIntoRam	= 8;	progressOpLoadTrackIntoRam	= 9;	progressOpLoadMediaIntoRam	= 10;	progressOpImportMovie		= 11;	progressOpExportMovie		= 12;	mediaQualityDraft			= $0000;	mediaQualityNormal			= $0040;	mediaQualityBetter			= $0080;	mediaQualityBest			= $00C0;TYPE	MovieRgnCoverProcPtr = ProcPtr;  { FUNCTION MovieRgnCover(theMovie: Movie; changedRgn: RgnHandle; refcon: LONGINT): OSErr; }	MovieProgressProcPtr = ProcPtr;  { FUNCTION MovieProgress(theMovie: Movie; message: INTEGER; whatOperation: INTEGER; percentDone: Fixed; refcon: LONGINT): OSErr; }	MovieDrawingCompleteProcPtr = ProcPtr;  { FUNCTION MovieDrawingComplete(theMovie: Movie; refCon: LONGINT): OSErr; }	TrackTransferProcPtr = ProcPtr;  { FUNCTION TrackTransfer(t: Track; refCon: LONGINT): OSErr; }	GetMovieProcPtr = ProcPtr;  { FUNCTION GetMovie(offset: LONGINT; size: LONGINT; dataPtr: UNIV Ptr; refCon: UNIV Ptr): OSErr; }	MovieRgnCoverUPP = UniversalProcPtr;	MovieProgressUPP = UniversalProcPtr;	MovieDrawingCompleteUPP = UniversalProcPtr;	TrackTransferUPP = UniversalProcPtr;	GetMovieUPP = UniversalProcPtr;	MediaHandler = ComponentInstance;	DataHandler = ComponentInstance;	MediaHandlerComponent = Component;	DataHandlerComponent = Component;	HandlerError = ComponentResult;	TimeValue = LONGINT;	TimeScale = LONGINT;	CompTimeValue = wide;CONST	loopTimeBase				= 1;	palindromeLoopTimeBase		= 2;	maintainTimeBaseZero		= 4;	TYPETimeBaseFlags = LONGINT;	TimeBaseRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	TimeBase = ^TimeBaseRecord;	CallBackRecord = RECORD		data:					ARRAY [0..0] OF LONGINT;	END;	QTCallBack = ^CallBackRecord;	TimeRecord = RECORD		value:					CompTimeValue;							{ units }		scale:					TimeScale;								{ units per second }		base:					TimeBase;	END;{ CallBack equates }CONST	triggerTimeFwd				= $0001;						{ when curTime exceeds triggerTime going forward }	triggerTimeBwd				= $0002;						{ when curTime exceeds triggerTime going backwards }	triggerTimeEither			= $0003;						{ when curTime exceeds triggerTime going either direction }	triggerRateLT				= $0004;						{ when rate changes to less than trigger value }	triggerRateGT				= $0008;						{ when rate changes to greater than trigger value }	triggerRateEqual			= $0010;						{ when rate changes to equal trigger value }	triggerRateLTE				= triggerRateLT + triggerRateEqual;	triggerRateGTE				= triggerRateGT + triggerRateEqual;	triggerRateNotEqual			= triggerRateGT + triggerRateEqual + triggerRateLT;	triggerRateChange			= 0;	triggerAtStart				= $0001;	triggerAtStop				= $0002;	TYPEQTCallBackFlags = INTEGER;CONST	timeBaseBeforeStartTime		= 1;	timeBaseAfterStopTime		= 2;	TYPETimeBaseStatus = LONGINT;CONST	callBackAtTime				= 1;	callBackAtRate				= 2;	callBackAtTimeJump			= 3;	callBackAtExtremes			= 4;	callBackAtInterrupt			= $8000;	callBackAtDeferredTask		= $4000;	TYPEQTCallBackType = INTEGER;	QTCallBackProcPtr = ProcPtr;  { PROCEDURE QTCallBack(cb: QTCallBack; refCon: LONGINT); }	QTCallBackUPP = UniversalProcPtr;CONST	qtcbNeedsRateChanges		= 1;							{ wants to know about rate changes }	qtcbNeedsTimeChanges		= 2;							{ wants to know about time changes }	qtcbNeedsStartStopChanges	= 4;							{ wants to know when TimeBase start/stop is changed}TYPE	QTCallBackHeader = RECORD		callBackFlags:			LONGINT;		reserved1:				LONGINT;		qtPrivate:				ARRAY [0..39] OF CHAR;	END;	QTSyncTaskProcPtr = ProcPtr;  { PROCEDURE (task: UNIV Ptr); }	QTSyncTaskRecord = RECORD		qLink:					Ptr;		proc:					QTSyncTaskProcPtr;	END;	QTSyncTaskPtr = ^QTSyncTaskRecord;CONST	keepInRam					= 1 * (2**(0));					{ load and make non-purgable}	unkeepInRam					= 1 * (2**(1));					{ mark as purgable}	flushFromRam				= 1 * (2**(2));					{ empty those handles}	loadForwardTrackEdits		= 1 * (2**(3));					{	load track edits into ram for playing forward}	loadBackwardTrackEdits		= 1 * (2**(4));					{	load track edits into ram for playing in reverse}TYPE	MoviePreviewCallOutProcPtr = ProcPtr;  { FUNCTION MoviePreviewCallOut(refcon: LONGINT): BOOLEAN; }	MoviePreviewCallOutUPP = UniversalProcPtr;CONST	newMovieActive				= 1 * (2**(0));	newMovieDontResolveDataRefs	= 1 * (2**(1));	newMovieDontAskUnresolvedDataRefs = 1 * (2**(2));	newMovieDontAutoAlternates	= 1 * (2**(3));{ track usage bits }	trackUsageInMovie			= 1 * (2**(1));	trackUsageInPreview			= 1 * (2**(2));	trackUsageInPoster			= 1 * (2**(3));{ Add/GetMediaSample flags }	mediaSampleNotSync			= 1 * (2**(0));					{ sample is not a sync sample (eg. is frame differenced }	mediaSampleShadowSync		= 1 * (2**(1));					{ sample is a shadow sync }	pasteInParallel				= 1;	showUserSettingsDialog		= 2;	movieToFileOnlyExport		= 4;	nextTimeMediaSample			= 1 * (2**(0));	nextTimeMediaEdit			= 1 * (2**(1));	nextTimeTrackEdit			= 1 * (2**(2));	nextTimeSyncSample			= 1 * (2**(3));	nextTimeEdgeOK				= 1 * (2**(14));	nextTimeIgnoreActiveSegment	= 1 * (2**(15));	TYPEnextTimeFlagsEnum = INTEGER;CONST	createMovieFileDeleteCurFile = 1 * (2**(31));	createMovieFileDontCreateMovie = 1 * (2**(30));	createMovieFileDontOpenFile	= 1 * (2**(29));	TYPEcreateMovieFileFlagsEnum = LONGINT;CONST	flattenAddMovieToDataFork	= 1 * (2**(0));	flattenActiveTracksOnly		= 1 * (2**(2));	flattenDontInterleaveFlatten = 1 * (2**(3));	TYPEmovieFlattenFlagsEnum = LONGINT;CONST{ magic res ID }	movieInDataForkResID		= -1;	mcTopLeftMovie				= 1 * (2**(0));					{ usually centered }	mcScaleMovieToFit			= 1 * (2**(1));					{ usually only scales down }	mcWithBadge					= 1 * (2**(2));					{ give me a badge }	mcNotVisible				= 1 * (2**(3));					{ don't show controller }	mcWithFrame					= 1 * (2**(4));					{ gimme a frame }	movieScrapDontZeroScrap		= 1 * (2**(0));	movieScrapOnlyPutMovie		= 1 * (2**(1));	dataRefSelfReference		= 1 * (2**(0));	dataRefWasNotResolved		= 1 * (2**(1));	TYPEdataRefAttributesFlags = LONGINT;CONST	hintsScrubMode				= 1 * (2**(0));					{ mask == && (if flags == scrub on, flags != scrub off) }	hintsLoop					= 1 * (2**(1));	hintsDontPurge				= 1 * (2**(2));	hintsUseScreenBuffer		= 1 * (2**(5));	hintsAllowInterlace			= 1 * (2**(6));	hintsUseSoundInterp			= 1 * (2**(7));	hintsHighQuality			= 1 * (2**(8));					{ slooooow }	hintsPalindrome				= 1 * (2**(9));	hintsInactive				= 1 * (2**(11));	TYPEplayHintsEnum = LONGINT;CONST	mediaHandlerFlagBaseClient	= 1;	TYPEmediaHandlerFlagsEnum = LONGINT;CONST	movieTrackMediaType			= 1 * (2**(0));	movieTrackCharacteristic	= 1 * (2**(1));	movieTrackEnabledOnly		= 1 * (2**(2));TYPE	SampleReferenceRecord = RECORD		dataOffset:				LONGINT;		dataSize:				LONGINT;		durationPerSample:		TimeValue;		numberOfSamples:		LONGINT;		sampleFlags:			INTEGER;	END;	SampleReferencePtr = ^SampleReferenceRecord;{****  Media Sample Description****}	MusicDescription = RECORD		size:					LONGINT;		mType:					LONGINT;								{ 'musi' }		resvd1:					LONGINT;		resvd2:					INTEGER;		dataRefIndex:			INTEGER;		musicFlags:				LONGINT;		headerData:				ARRAY [0..0] OF LONGINT;				{ variable size! }	END;	MusicDescriptionPtr = ^MusicDescription;	MusicDescriptionHandle = ^MusicDescriptionPtr;{************************* Initialization Routines*************************}FUNCTION EnterMovies: OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7001, $AAAA;	{$ENDC}PROCEDURE ExitMovies;	{$IFC NOT GENERATINGCFM}	INLINE $7002, $AAAA;	{$ENDC}{************************* Error Routines*************************}TYPE	MoviesErrorProcPtr = ProcPtr;  { PROCEDURE MoviesError(theErr: OSErr; refcon: LONGINT); }	MoviesErrorUPP = UniversalProcPtr;FUNCTION GetMoviesError: OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7003, $AAAA;	{$ENDC}PROCEDURE ClearMoviesStickyError;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $DE, $AAAA;	{$ENDC}FUNCTION GetMoviesStickyError: OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7004, $AAAA;	{$ENDC}PROCEDURE SetMoviesErrorProc(errProc: MoviesErrorUPP; refcon: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $EF, $AAAA;	{$ENDC}{************************* Idle Routines*************************}PROCEDURE MoviesTask(theMovie: Movie; maxMilliSecToUse: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $7005, $AAAA;	{$ENDC}FUNCTION PrerollMovie(theMovie: Movie; time: TimeValue; Rate: Fixed): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7006, $AAAA;	{$ENDC}FUNCTION LoadMovieIntoRam(theMovie: Movie; time: TimeValue; duration: TimeValue; flags: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7007, $AAAA;	{$ENDC}FUNCTION LoadTrackIntoRam(theTrack: Track; time: TimeValue; duration: TimeValue; flags: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $16E, $AAAA;	{$ENDC}FUNCTION LoadMediaIntoRam(theMedia: Media; time: TimeValue; duration: TimeValue; flags: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7008, $AAAA;	{$ENDC}PROCEDURE SetMovieActive(theMovie: Movie; active: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $7009, $AAAA;	{$ENDC}FUNCTION GetMovieActive(theMovie: Movie): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $700A, $AAAA;	{$ENDC}{************************* calls for playing movies, previews, posters*************************}PROCEDURE StartMovie(theMovie: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $700B, $AAAA;	{$ENDC}PROCEDURE StopMovie(theMovie: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $700C, $AAAA;	{$ENDC}PROCEDURE GoToBeginningOfMovie(theMovie: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $700D, $AAAA;	{$ENDC}PROCEDURE GoToEndOfMovie(theMovie: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $700E, $AAAA;	{$ENDC}FUNCTION IsMovieDone(theMovie: Movie): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $DD, $AAAA;	{$ENDC}FUNCTION GetMoviePreviewMode(theMovie: Movie): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $700F, $AAAA;	{$ENDC}PROCEDURE SetMoviePreviewMode(theMovie: Movie; usePreview: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $7010, $AAAA;	{$ENDC}PROCEDURE ShowMoviePoster(theMovie: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $7011, $AAAA;	{$ENDC}PROCEDURE PlayMoviePreview(theMovie: Movie; callOutProc: MoviePreviewCallOutUPP; refcon: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $F2, $AAAA;	{$ENDC}{************************* calls for controlling movies & tracks which are playing*************************}FUNCTION GetMovieTimeBase(theMovie: Movie): TimeBase;	{$IFC NOT GENERATINGCFM}	INLINE $7012, $AAAA;	{$ENDC}PROCEDURE SetMovieMasterTimeBase(theMovie: Movie; tb: TimeBase; slaveZero: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $167, $AAAA;	{$ENDC}PROCEDURE SetMovieMasterClock(theMovie: Movie; clockMeister: Component; slaveZero: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $168, $AAAA;	{$ENDC}PROCEDURE GetMovieGWorld(theMovie: Movie; VAR port: CGrafPtr; VAR gdh: GDHandle);	{$IFC NOT GENERATINGCFM}	INLINE $7015, $AAAA;	{$ENDC}PROCEDURE SetMovieGWorld(theMovie: Movie; port: CGrafPtr; gdh: GDHandle);	{$IFC NOT GENERATINGCFM}	INLINE $7016, $AAAA;	{$ENDC}CONST	movieDrawingCallWhenChanged	= 0;	movieDrawingCallAlways		= 1;PROCEDURE SetMovieDrawingCompleteProc(theMovie: Movie; flags: LONGINT; proc: MovieDrawingCompleteUPP; refCon: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1DE, $AAAA;	{$ENDC}FUNCTION GetNextTrackForCompositing(theMovie: Movie; theTrack: Track): Track;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1FA, $AAAA;	{$ENDC}FUNCTION GetPrevTrackForCompositing(theMovie: Movie; theTrack: Track): Track;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1FB, $AAAA;	{$ENDC}PROCEDURE SetTrackGWorld(theTrack: Track; port: CGrafPtr; gdh: GDHandle; proc: TrackTransferUPP; refCon: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $9D, $AAAA;	{$ENDC}FUNCTION GetMoviePict(theMovie: Movie; time: TimeValue): PicHandle;	{$IFC NOT GENERATINGCFM}	INLINE $701D, $AAAA;	{$ENDC}FUNCTION GetTrackPict(theTrack: Track; time: TimeValue): PicHandle;	{$IFC NOT GENERATINGCFM}	INLINE $701E, $AAAA;	{$ENDC}FUNCTION GetMoviePosterPict(theMovie: Movie): PicHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $F7, $AAAA;	{$ENDC}{ called between Begin & EndUpdate }FUNCTION UpdateMovie(theMovie: Movie): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $701F, $AAAA;	{$ENDC}{*** spatial movie routines ***}PROCEDURE GetMovieBox(theMovie: Movie; VAR boxRect: Rect);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $F9, $AAAA;	{$ENDC}PROCEDURE SetMovieBox(theMovie: Movie; boxRect: Rect);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $FA, $AAAA;	{$ENDC}{* movie display clip }FUNCTION GetMovieDisplayClipRgn(theMovie: Movie): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $FC, $AAAA;	{$ENDC}PROCEDURE SetMovieDisplayClipRgn(theMovie: Movie; theClip: RgnHandle);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $FD, $AAAA;	{$ENDC}{* movie src clip }FUNCTION GetMovieClipRgn(theMovie: Movie): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $100, $AAAA;	{$ENDC}PROCEDURE SetMovieClipRgn(theMovie: Movie; theClip: RgnHandle);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $101, $AAAA;	{$ENDC}{* track src clip }FUNCTION GetTrackClipRgn(theTrack: Track): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $102, $AAAA;	{$ENDC}PROCEDURE SetTrackClipRgn(theTrack: Track; theClip: RgnHandle);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $103, $AAAA;	{$ENDC}{* bounds in display space (not clipped by display clip) }FUNCTION GetMovieDisplayBoundsRgn(theMovie: Movie): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $FB, $AAAA;	{$ENDC}FUNCTION GetTrackDisplayBoundsRgn(theTrack: Track): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $112, $AAAA;	{$ENDC}{* bounds in movie space }FUNCTION GetMovieBoundsRgn(theMovie: Movie): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $FE, $AAAA;	{$ENDC}FUNCTION GetTrackMovieBoundsRgn(theTrack: Track): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $FF, $AAAA;	{$ENDC}{* bounds in track space }FUNCTION GetTrackBoundsRgn(theTrack: Track): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $111, $AAAA;	{$ENDC}{* mattes - always in track space }FUNCTION GetTrackMatte(theTrack: Track): PixMapHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $115, $AAAA;	{$ENDC}PROCEDURE SetTrackMatte(theTrack: Track; theMatte: PixMapHandle);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $116, $AAAA;	{$ENDC}PROCEDURE DisposeMatte(theMatte: PixMapHandle);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $14A, $AAAA;	{$ENDC}{************************* calls for getting/saving movies*************************}FUNCTION NewMovie(flags: LONGINT): Movie;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $187, $AAAA;	{$ENDC}FUNCTION PutMovieIntoHandle(theMovie: Movie; publicMovie: Handle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7022, $AAAA;	{$ENDC}FUNCTION PutMovieIntoDataFork(theMovie: Movie; fRefNum: INTEGER; offset: LONGINT; maxSize: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1B4, $AAAA;	{$ENDC}PROCEDURE DisposeMovie(theMovie: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $7023, $AAAA;	{$ENDC}{************************* Movie State Routines*************************}FUNCTION GetMovieCreationTime(theMovie: Movie): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7026, $AAAA;	{$ENDC}FUNCTION GetMovieModificationTime(theMovie: Movie): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7027, $AAAA;	{$ENDC}FUNCTION GetMovieTimeScale(theMovie: Movie): TimeScale;	{$IFC NOT GENERATINGCFM}	INLINE $7029, $AAAA;	{$ENDC}PROCEDURE SetMovieTimeScale(theMovie: Movie; timeScale: TimeScale);	{$IFC NOT GENERATINGCFM}	INLINE $702A, $AAAA;	{$ENDC}FUNCTION GetMovieDuration(theMovie: Movie): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $702B, $AAAA;	{$ENDC}FUNCTION GetMovieRate(theMovie: Movie): Fixed;	{$IFC NOT GENERATINGCFM}	INLINE $702C, $AAAA;	{$ENDC}PROCEDURE SetMovieRate(theMovie: Movie; rate: Fixed);	{$IFC NOT GENERATINGCFM}	INLINE $702D, $AAAA;	{$ENDC}FUNCTION GetMoviePreferredRate(theMovie: Movie): Fixed;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $F3, $AAAA;	{$ENDC}PROCEDURE SetMoviePreferredRate(theMovie: Movie; rate: Fixed);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $F4, $AAAA;	{$ENDC}FUNCTION GetMoviePreferredVolume(theMovie: Movie): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $F5, $AAAA;	{$ENDC}PROCEDURE SetMoviePreferredVolume(theMovie: Movie; volume: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $F6, $AAAA;	{$ENDC}FUNCTION GetMovieVolume(theMovie: Movie): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $702E, $AAAA;	{$ENDC}PROCEDURE SetMovieVolume(theMovie: Movie; volume: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $702F, $AAAA;	{$ENDC}PROCEDURE GetMovieMatrix(theMovie: Movie; VAR matrix: MatrixRecord);	{$IFC NOT GENERATINGCFM}	INLINE $7031, $AAAA;	{$ENDC}PROCEDURE SetMovieMatrix(theMovie: Movie; matrix: MatrixRecord);	{$IFC NOT GENERATINGCFM}	INLINE $7032, $AAAA;	{$ENDC}PROCEDURE GetMoviePreviewTime(theMovie: Movie; VAR previewTime: TimeValue; VAR previewDuration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $7033, $AAAA;	{$ENDC}PROCEDURE SetMoviePreviewTime(theMovie: Movie; previewTime: TimeValue; previewDuration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $7034, $AAAA;	{$ENDC}FUNCTION GetMoviePosterTime(theMovie: Movie): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $7035, $AAAA;	{$ENDC}PROCEDURE SetMoviePosterTime(theMovie: Movie; posterTime: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $7036, $AAAA;	{$ENDC}PROCEDURE GetMovieSelection(theMovie: Movie; VAR selectionTime: TimeValue; VAR selectionDuration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $7037, $AAAA;	{$ENDC}PROCEDURE SetMovieSelection(theMovie: Movie; selectionTime: TimeValue; selectionDuration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $7038, $AAAA;	{$ENDC}PROCEDURE SetMovieActiveSegment(theMovie: Movie; startTime: TimeValue; duration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $15C, $AAAA;	{$ENDC}PROCEDURE GetMovieActiveSegment(theMovie: Movie; VAR startTime: TimeValue; VAR duration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $15D, $AAAA;	{$ENDC}FUNCTION GetMovieTime(theMovie: Movie; VAR currentTime: TimeRecord): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $7039, $AAAA;	{$ENDC}PROCEDURE SetMovieTime(theMovie: Movie; newtime: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $703C, $AAAA;	{$ENDC}PROCEDURE SetMovieTimeValue(theMovie: Movie; newtime: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $703D, $AAAA;	{$ENDC}FUNCTION GetMovieUserData(theMovie: Movie): UserData;	{$IFC NOT GENERATINGCFM}	INLINE $703E, $AAAA;	{$ENDC}{************************* Track/Media finding routines*************************}FUNCTION GetMovieTrackCount(theMovie: Movie): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $703F, $AAAA;	{$ENDC}FUNCTION GetMovieTrack(theMovie: Movie; trackID: LONGINT): Track;	{$IFC NOT GENERATINGCFM}	INLINE $7040, $AAAA;	{$ENDC}FUNCTION GetMovieIndTrack(theMovie: Movie; index: LONGINT): Track;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $117, $AAAA;	{$ENDC}FUNCTION GetMovieIndTrackType(theMovie: Movie; index: LONGINT; trackType: OSType; flags: LONGINT): Track;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $208, $AAAA;	{$ENDC}FUNCTION GetTrackID(theTrack: Track): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $127, $AAAA;	{$ENDC}FUNCTION GetTrackMovie(theTrack: Track): Movie;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $D0, $AAAA;	{$ENDC}{************************* Track creation routines*************************}FUNCTION NewMovieTrack(theMovie: Movie; width: Fixed; height: Fixed; trackVolume: INTEGER): Track;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $188, $AAAA;	{$ENDC}PROCEDURE DisposeMovieTrack(theTrack: Track);	{$IFC NOT GENERATINGCFM}	INLINE $7042, $AAAA;	{$ENDC}{************************* Track State routines*************************}FUNCTION GetTrackCreationTime(theTrack: Track): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7043, $AAAA;	{$ENDC}FUNCTION GetTrackModificationTime(theTrack: Track): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7044, $AAAA;	{$ENDC}FUNCTION GetTrackEnabled(theTrack: Track): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $7045, $AAAA;	{$ENDC}PROCEDURE SetTrackEnabled(theTrack: Track; isEnabled: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $7046, $AAAA;	{$ENDC}FUNCTION GetTrackUsage(theTrack: Track): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7047, $AAAA;	{$ENDC}PROCEDURE SetTrackUsage(theTrack: Track; usage: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $7048, $AAAA;	{$ENDC}FUNCTION GetTrackDuration(theTrack: Track): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $704B, $AAAA;	{$ENDC}FUNCTION GetTrackOffset(theTrack: Track): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $704C, $AAAA;	{$ENDC}PROCEDURE SetTrackOffset(theTrack: Track; movieOffsetTime: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $704D, $AAAA;	{$ENDC}FUNCTION GetTrackLayer(theTrack: Track): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $7050, $AAAA;	{$ENDC}PROCEDURE SetTrackLayer(theTrack: Track; layer: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $7051, $AAAA;	{$ENDC}FUNCTION GetTrackAlternate(theTrack: Track): Track;	{$IFC NOT GENERATINGCFM}	INLINE $7052, $AAAA;	{$ENDC}PROCEDURE SetTrackAlternate(theTrack: Track; alternateT: Track);	{$IFC NOT GENERATINGCFM}	INLINE $7053, $AAAA;	{$ENDC}PROCEDURE SetAutoTrackAlternatesEnabled(theMovie: Movie; enable: BOOLEAN);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $15E, $AAAA;	{$ENDC}PROCEDURE SelectMovieAlternates(theMovie: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $15F, $AAAA;	{$ENDC}FUNCTION GetTrackVolume(theTrack: Track): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $7054, $AAAA;	{$ENDC}PROCEDURE SetTrackVolume(theTrack: Track; volume: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $7055, $AAAA;	{$ENDC}PROCEDURE GetTrackMatrix(theTrack: Track; VAR matrix: MatrixRecord);	{$IFC NOT GENERATINGCFM}	INLINE $7056, $AAAA;	{$ENDC}PROCEDURE SetTrackMatrix(theTrack: Track; matrix: MatrixRecord);	{$IFC NOT GENERATINGCFM}	INLINE $7057, $AAAA;	{$ENDC}PROCEDURE GetTrackDimensions(theTrack: Track; VAR width: Fixed; VAR height: Fixed);	{$IFC NOT GENERATINGCFM}	INLINE $705D, $AAAA;	{$ENDC}PROCEDURE SetTrackDimensions(theTrack: Track; width: Fixed; height: Fixed);	{$IFC NOT GENERATINGCFM}	INLINE $705E, $AAAA;	{$ENDC}FUNCTION GetTrackUserData(theTrack: Track): UserData;	{$IFC NOT GENERATINGCFM}	INLINE $705F, $AAAA;	{$ENDC}{************************* get Media routines*************************}FUNCTION NewTrackMedia(theTrack: Track; mediaType: OSType; timeScale: TimeScale; dataRef: Handle; dataRefType: OSType): Media;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $18E, $AAAA;	{$ENDC}PROCEDURE DisposeTrackMedia(theMedia: Media);	{$IFC NOT GENERATINGCFM}	INLINE $7061, $AAAA;	{$ENDC}FUNCTION GetTrackMedia(theTrack: Track): Media;	{$IFC NOT GENERATINGCFM}	INLINE $7062, $AAAA;	{$ENDC}FUNCTION GetMediaTrack(theMedia: Media): Track;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $C5, $AAAA;	{$ENDC}{************************* Media State routines*************************}FUNCTION GetMediaCreationTime(theMedia: Media): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7066, $AAAA;	{$ENDC}FUNCTION GetMediaModificationTime(theMedia: Media): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7067, $AAAA;	{$ENDC}FUNCTION GetMediaTimeScale(theMedia: Media): TimeScale;	{$IFC NOT GENERATINGCFM}	INLINE $7068, $AAAA;	{$ENDC}PROCEDURE SetMediaTimeScale(theMedia: Media; timeScale: TimeScale);	{$IFC NOT GENERATINGCFM}	INLINE $7069, $AAAA;	{$ENDC}FUNCTION GetMediaDuration(theMedia: Media): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $706A, $AAAA;	{$ENDC}FUNCTION GetMediaLanguage(theMedia: Media): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $706B, $AAAA;	{$ENDC}PROCEDURE SetMediaLanguage(theMedia: Media; language: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $706C, $AAAA;	{$ENDC}FUNCTION GetMediaQuality(theMedia: Media): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $706D, $AAAA;	{$ENDC}PROCEDURE SetMediaQuality(theMedia: Media; quality: INTEGER);	{$IFC NOT GENERATINGCFM}	INLINE $706E, $AAAA;	{$ENDC}PROCEDURE GetMediaHandlerDescription(theMedia: Media; VAR mediaType: OSType; VAR creatorName: Str255; VAR creatorManufacturer: OSType);	{$IFC NOT GENERATINGCFM}	INLINE $706F, $AAAA;	{$ENDC}FUNCTION GetMediaUserData(theMedia: Media): UserData;	{$IFC NOT GENERATINGCFM}	INLINE $7070, $AAAA;	{$ENDC}{************************* Media Handler routines*************************}FUNCTION GetMediaHandler(theMedia: Media): MediaHandler;	{$IFC NOT GENERATINGCFM}	INLINE $7071, $AAAA;	{$ENDC}FUNCTION SetMediaHandler(theMedia: Media; mH: MediaHandlerComponent): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $190, $AAAA;	{$ENDC}{************************* Media's Data routines*************************}FUNCTION BeginMediaEdits(theMedia: Media): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7072, $AAAA;	{$ENDC}FUNCTION EndMediaEdits(theMedia: Media): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7073, $AAAA;	{$ENDC}FUNCTION SetMediaDefaultDataRefIndex(theMedia: Media; index: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1E0, $AAAA;	{$ENDC}PROCEDURE GetMediaDataHandlerDescription(theMedia: Media; index: INTEGER; VAR dhType: OSType; VAR creatorName: Str255; VAR creatorManufacturer: OSType);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $19E, $AAAA;	{$ENDC}FUNCTION GetMediaDataHandler(theMedia: Media; index: INTEGER): DataHandler;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $19F, $AAAA;	{$ENDC}FUNCTION SetMediaDataHandler(theMedia: Media; index: INTEGER; dataHandler: DataHandlerComponent): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1A0, $AAAA;	{$ENDC}FUNCTION GetDataHandler(dataRef: Handle; dataHandlerSubType: OSType; flags: LONGINT): Component;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1ED, $AAAA;	{$ENDC}{************************* Media Sample Table Routines*************************}FUNCTION GetMediaSampleDescriptionCount(theMedia: Media): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7077, $AAAA;	{$ENDC}PROCEDURE GetMediaSampleDescription(theMedia: Media; index: LONGINT; descH: SampleDescriptionHandle);	{$IFC NOT GENERATINGCFM}	INLINE $7078, $AAAA;	{$ENDC}FUNCTION SetMediaSampleDescription(theMedia: Media; index: LONGINT; descH: SampleDescriptionHandle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1D0, $AAAA;	{$ENDC}FUNCTION GetMediaSampleCount(theMedia: Media): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $7079, $AAAA;	{$ENDC}PROCEDURE SampleNumToMediaTime(theMedia: Media; logicalSampleNum: LONGINT; VAR sampleTime: TimeValue; VAR sampleDuration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $707A, $AAAA;	{$ENDC}PROCEDURE MediaTimeToSampleNum(theMedia: Media; time: TimeValue; VAR sampleNum: LONGINT; VAR sampleTime: TimeValue; VAR sampleDuration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $707B, $AAAA;	{$ENDC}FUNCTION AddMediaSample(theMedia: Media; dataIn: Handle; inOffset: LONGINT; size: LONGINT; durationPerSample: TimeValue; sampleDescriptionH: SampleDescriptionHandle; numberOfSamples: LONGINT; sampleFlags: INTEGER; VAR sampleTime: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $707C, $AAAA;	{$ENDC}FUNCTION AddMediaSampleReference(theMedia: Media; dataOffset: LONGINT; size: LONGINT; durationPerSample: TimeValue; sampleDescriptionH: SampleDescriptionHandle; numberOfSamples: LONGINT; sampleFlags: INTEGER; VAR sampleTime: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $707D, $AAAA;	{$ENDC}FUNCTION AddMediaSampleReferences(theMedia: Media; sampleDescriptionH: SampleDescriptionHandle; numberOfSamples: LONGINT; sampleRefs: SampleReferencePtr; VAR sampleTime: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1F7, $AAAA;	{$ENDC}FUNCTION GetMediaSample(theMedia: Media; dataOut: Handle; maxSizeToGrow: LONGINT; VAR size: LONGINT; time: TimeValue; VAR sampleTime: TimeValue; VAR durationPerSample: TimeValue; sampleDescriptionH: SampleDescriptionHandle; VAR sampleDescriptionIndex: LONGINT; maxNumberOfSamples: LONGINT; VAR numberOfSamples: LONGINT; VAR sampleFlags: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $707E, $AAAA;	{$ENDC}FUNCTION GetMediaSampleReference(theMedia: Media; VAR dataOffset: LONGINT; VAR size: LONGINT; time: TimeValue; VAR sampleTime: TimeValue; VAR durationPerSample: TimeValue; sampleDescriptionH: SampleDescriptionHandle; VAR sampleDescriptionIndex: LONGINT; maxNumberOfSamples: LONGINT; VAR numberOfSamples: LONGINT; VAR sampleFlags: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $707F, $AAAA;	{$ENDC}FUNCTION SetMediaPreferredChunkSize(theMedia: Media; maxChunkSize: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1F8, $AAAA;	{$ENDC}FUNCTION GetMediaPreferredChunkSize(theMedia: Media; VAR maxChunkSize: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1F9, $AAAA;	{$ENDC}FUNCTION SetMediaShadowSync(theMedia: Media; frameDiffSampleNum: LONGINT; syncSampleNum: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $121, $AAAA;	{$ENDC}FUNCTION GetMediaShadowSync(theMedia: Media; frameDiffSampleNum: LONGINT; VAR syncSampleNum: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $122, $AAAA;	{$ENDC}{************************* Editing Routines*************************}FUNCTION InsertMediaIntoTrack(theTrack: Track; trackStart: TimeValue; mediaTime: TimeValue; mediaDuration: TimeValue; mediaRate: Fixed): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $183, $AAAA;	{$ENDC}FUNCTION InsertTrackSegment(srcTrack: Track; dstTrack: Track; srcIn: TimeValue; srcDuration: TimeValue; dstIn: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $85, $AAAA;	{$ENDC}FUNCTION InsertMovieSegment(srcMovie: Movie; dstMovie: Movie; srcIn: TimeValue; srcDuration: TimeValue; dstIn: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $86, $AAAA;	{$ENDC}FUNCTION InsertEmptyTrackSegment(dstTrack: Track; dstIn: TimeValue; dstDuration: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $87, $AAAA;	{$ENDC}FUNCTION InsertEmptyMovieSegment(dstMovie: Movie; dstIn: TimeValue; dstDuration: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $88, $AAAA;	{$ENDC}FUNCTION DeleteTrackSegment(theTrack: Track; startTime: TimeValue; duration: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $89, $AAAA;	{$ENDC}FUNCTION DeleteMovieSegment(theMovie: Movie; startTime: TimeValue; duration: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $8A, $AAAA;	{$ENDC}FUNCTION ScaleTrackSegment(theTrack: Track; startTime: TimeValue; oldDuration: TimeValue; newDuration: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $8B, $AAAA;	{$ENDC}FUNCTION ScaleMovieSegment(theMovie: Movie; startTime: TimeValue; oldDuration: TimeValue; newDuration: TimeValue): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $8C, $AAAA;	{$ENDC}{************************* Hi-level Editing Routines*************************}FUNCTION CutMovieSelection(theMovie: Movie): Movie;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $8D, $AAAA;	{$ENDC}FUNCTION CopyMovieSelection(theMovie: Movie): Movie;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $8E, $AAAA;	{$ENDC}PROCEDURE PasteMovieSelection(theMovie: Movie; src: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $8F, $AAAA;	{$ENDC}PROCEDURE AddMovieSelection(theMovie: Movie; src: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $152, $AAAA;	{$ENDC}PROCEDURE ClearMovieSelection(theMovie: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $E1, $AAAA;	{$ENDC}FUNCTION PasteHandleIntoMovie(h: Handle; handleType: OSType; theMovie: Movie; flags: LONGINT; userComp: ComponentInstance): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $CB, $AAAA;	{$ENDC}FUNCTION PutMovieIntoTypedHandle(theMovie: Movie; targetTrack: Track; handleType: OSType; publicMovie: Handle; start: TimeValue; dur: TimeValue; flags: LONGINT; userComp: ComponentInstance): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1CD, $AAAA;	{$ENDC}FUNCTION IsScrapMovie(targetTrack: Track): Component;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $CC, $AAAA;	{$ENDC}{************************* Middle-level Editing Routines*************************}FUNCTION CopyTrackSettings(srcTrack: Track; dstTrack: Track): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $153, $AAAA;	{$ENDC}FUNCTION CopyMovieSettings(srcMovie: Movie; dstMovie: Movie): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $154, $AAAA;	{$ENDC}FUNCTION AddEmptyTrackToMovie(srcTrack: Track; dstMovie: Movie; dataRef: Handle; dataRefType: OSType; VAR dstTrack: Track): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $7074, $AAAA;	{$ENDC}{************************* movie & track edit state routines*************************}FUNCTION NewMovieEditState(theMovie: Movie): MovieEditState;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $104, $AAAA;	{$ENDC}FUNCTION UseMovieEditState(theMovie: Movie; toState: MovieEditState): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $105, $AAAA;	{$ENDC}FUNCTION DisposeMovieEditState(state: MovieEditState): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $106, $AAAA;	{$ENDC}FUNCTION NewTrackEditState(theTrack: Track): TrackEditState;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $107, $AAAA;	{$ENDC}FUNCTION UseTrackEditState(theTrack: Track; state: TrackEditState): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $108, $AAAA;	{$ENDC}FUNCTION DisposeTrackEditState(state: TrackEditState): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $109, $AAAA;	{$ENDC}{************************* track reference routines*************************}FUNCTION AddTrackReference(theTrack: Track; refTrack: Track; refType: OSType; VAR addedIndex: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1F0, $AAAA;	{$ENDC}FUNCTION DeleteTrackReference(theTrack: Track; refType: OSType; index: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1F1, $AAAA;	{$ENDC}FUNCTION SetTrackReference(theTrack: Track; refTrack: Track; refType: OSType; index: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1F2, $AAAA;	{$ENDC}FUNCTION GetTrackReference(theTrack: Track; refType: OSType; index: LONGINT): Track;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1F3, $AAAA;	{$ENDC}FUNCTION GetNextTrackReferenceType(theTrack: Track; refType: OSType): OSType;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1F4, $AAAA;	{$ENDC}FUNCTION GetTrackReferenceCount(theTrack: Track; refType: OSType): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1F5, $AAAA;	{$ENDC}{************************* high level file conversion routines*************************}FUNCTION ConvertFileToMovieFile(inputFile: FSSpec; outputFile: FSSpec; creator: OSType; scriptTag: ScriptCode; VAR resID: INTEGER; flags: LONGINT; userComp: ComponentInstance; proc: MovieProgressUPP; refCon: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1CB, $AAAA;	{$ENDC}FUNCTION ConvertMovieToFile(theMovie: Movie; onlyTrack: Track; VAR outputFile: FSSpec; fileType: OSType; creator: OSType; scriptTag: ScriptCode; VAR resID: INTEGER; flags: LONGINT; userComp: ComponentInstance): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1CC, $AAAA;	{$ENDC}{************************* Movie Timebase Conversion Routines*************************}FUNCTION TrackTimeToMediaTime(value: TimeValue; theTrack: Track): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $96, $AAAA;	{$ENDC}FUNCTION GetTrackEditRate(theTrack: Track; atTime: TimeValue): Fixed;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $123, $AAAA;	{$ENDC}{************************* Miscellaneous Routines*************************}FUNCTION GetMovieDataSize(theMovie: Movie; startTime: TimeValue; duration: TimeValue): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $98, $AAAA;	{$ENDC}FUNCTION GetTrackDataSize(theTrack: Track; startTime: TimeValue; duration: TimeValue): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $149, $AAAA;	{$ENDC}FUNCTION GetMediaDataSize(theMedia: Media; startTime: TimeValue; duration: TimeValue): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $99, $AAAA;	{$ENDC}FUNCTION PtInMovie(theMovie: Movie; pt: Point): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $9A, $AAAA;	{$ENDC}FUNCTION PtInTrack(theTrack: Track; pt: Point): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $9B, $AAAA;	{$ENDC}{************************* Group Selection Routines*************************}PROCEDURE SetMovieLanguage(theMovie: Movie; language: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $9C, $AAAA;	{$ENDC}{************************* User Data*************************}FUNCTION GetUserData(theUserData: UserData; data: Handle; udType: OSType; index: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $9E, $AAAA;	{$ENDC}FUNCTION AddUserData(theUserData: UserData; data: Handle; udType: OSType): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $9F, $AAAA;	{$ENDC}FUNCTION RemoveUserData(theUserData: UserData; udType: OSType; index: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $A0, $AAAA;	{$ENDC}FUNCTION CountUserDataType(theUserData: UserData; udType: OSType): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $14B, $AAAA;	{$ENDC}FUNCTION GetNextUserDataType(theUserData: UserData; udType: OSType): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1A5, $AAAA;	{$ENDC}FUNCTION GetUserDataItem(theUserData: UserData; data: UNIV Ptr; size: LONGINT; udType: OSType; index: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $126, $AAAA;	{$ENDC}FUNCTION SetUserDataItem(theUserData: UserData; data: UNIV Ptr; size: LONGINT; udType: OSType; index: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $12E, $AAAA;	{$ENDC}FUNCTION AddUserDataText(theUserData: UserData; data: Handle; udType: OSType; index: LONGINT; itlRegionTag: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $14C, $AAAA;	{$ENDC}FUNCTION GetUserDataText(theUserData: UserData; data: Handle; udType: OSType; index: LONGINT; itlRegionTag: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $14D, $AAAA;	{$ENDC}FUNCTION RemoveUserDataText(theUserData: UserData; udType: OSType; index: LONGINT; itlRegionTag: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $14E, $AAAA;	{$ENDC}FUNCTION NewUserData(VAR theUserData: UserData): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $12F, $AAAA;	{$ENDC}FUNCTION DisposeUserData(theUserData: UserData): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $130, $AAAA;	{$ENDC}FUNCTION NewUserDataFromHandle(h: Handle; VAR theUserData: UserData): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $131, $AAAA;	{$ENDC}FUNCTION PutUserDataIntoHandle(theUserData: UserData; h: Handle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $132, $AAAA;	{$ENDC}PROCEDURE GetMediaNextInterestingTime(theMedia: Media; interestingTimeFlags: INTEGER; time: TimeValue; rate: Fixed; VAR interestingTime: TimeValue; VAR interestingDuration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $16D, $AAAA;	{$ENDC}PROCEDURE GetTrackNextInterestingTime(theTrack: Track; interestingTimeFlags: INTEGER; time: TimeValue; rate: Fixed; VAR interestingTime: TimeValue; VAR interestingDuration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $E2, $AAAA;	{$ENDC}PROCEDURE GetMovieNextInterestingTime(theMovie: Movie; interestingTimeFlags: INTEGER; numMediaTypes: INTEGER; whichMediaTypes: OSType; time: TimeValue; rate: Fixed; VAR interestingTime: TimeValue; VAR interestingDuration: TimeValue);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $10E, $AAAA;	{$ENDC}FUNCTION CreateMovieFile(fileSpec: FSSpec; creator: OSType; scriptTag: ScriptCode; createMovieFileFlags: LONGINT; VAR resRefNum: INTEGER; VAR newmovie: Movie): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $191, $AAAA;	{$ENDC}FUNCTION OpenMovieFile(fileSpec: FSSpec; VAR resRefNum: INTEGER; perms: ByteParameter): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $192, $AAAA;	{$ENDC}FUNCTION CloseMovieFile(resRefNum: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $D5, $AAAA;	{$ENDC}FUNCTION DeleteMovieFile(fileSpec: FSSpec): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $175, $AAAA;	{$ENDC}FUNCTION NewMovieFromFile(VAR theMovie: Movie; resRefNum: INTEGER; VAR resId: INTEGER; resName: StringPtr; newMovieFlags: INTEGER; VAR dataRefWasChanged: BOOLEAN): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $F0, $AAAA;	{$ENDC}FUNCTION NewMovieFromHandle(VAR theMovie: Movie; h: Handle; newMovieFlags: INTEGER; VAR dataRefWasChanged: BOOLEAN): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $F1, $AAAA;	{$ENDC}FUNCTION NewMovieFromDataFork(VAR theMovie: Movie; fRefNum: INTEGER; fileOffset: LONGINT; newMovieFlags: INTEGER; VAR dataRefWasChanged: BOOLEAN): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1B3, $AAAA;	{$ENDC}FUNCTION NewMovieFromUserProc(VAR m: Movie; flags: INTEGER; VAR dataRefWasChanged: BOOLEAN; getProc: GetMovieUPP; refCon: UNIV Ptr; defaultDataRef: Handle; dataRefType: OSType): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1EC, $AAAA;	{$ENDC}FUNCTION AddMovieResource(theMovie: Movie; resRefNum: INTEGER; VAR resId: INTEGER; resName: StringPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $D7, $AAAA;	{$ENDC}FUNCTION UpdateMovieResource(theMovie: Movie; resRefNum: INTEGER; resId: INTEGER; resName: StringPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $D8, $AAAA;	{$ENDC}FUNCTION RemoveMovieResource(resRefNum: INTEGER; resId: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $176, $AAAA;	{$ENDC}FUNCTION HasMovieChanged(theMovie: Movie): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $D9, $AAAA;	{$ENDC}PROCEDURE ClearMovieChanged(theMovie: Movie);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $113, $AAAA;	{$ENDC}FUNCTION SetMovieDefaultDataRef(theMovie: Movie; dataRef: Handle; dataRefType: OSType): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1C1, $AAAA;	{$ENDC}FUNCTION GetMovieDefaultDataRef(theMovie: Movie; VAR dataRef: Handle; VAR dataRefType: OSType): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1D2, $AAAA;	{$ENDC}FUNCTION SetMovieColorTable(theMovie: Movie; ctab: CTabHandle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $205, $AAAA;	{$ENDC}FUNCTION GetMovieColorTable(theMovie: Movie; VAR ctab: CTabHandle): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $206, $AAAA;	{$ENDC}PROCEDURE FlattenMovie(theMovie: Movie; movieFlattenFlags: LONGINT; theFile: FSSpec; creator: OSType; scriptTag: ScriptCode; createMovieFileFlags: LONGINT; VAR resId: INTEGER; resName: StringPtr);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $19B, $AAAA;	{$ENDC}FUNCTION FlattenMovieData(theMovie: Movie; movieFlattenFlags: LONGINT; theFile: FSSpec; creator: OSType; scriptTag: ScriptCode; createMovieFileFlags: LONGINT): Movie;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $19C, $AAAA;	{$ENDC}PROCEDURE SetMovieProgressProc(theMovie: Movie; p: MovieProgressUPP; refcon: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $19A, $AAAA;	{$ENDC}{************************* Video Media routines*************************}FUNCTION GetVideoMediaGraphicsMode(mh: MediaHandler; VAR graphicsMode: LONGINT; VAR opColor: RGBColor): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $101, $7000, $A82A;	{$ENDC}FUNCTION SetVideoMediaGraphicsMode(mh: MediaHandler; graphicsMode: LONGINT; opColor: RGBColor): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $102, $7000, $A82A;	{$ENDC}{************************* Sound Media routines*************************}FUNCTION GetSoundMediaBalance(mh: MediaHandler; VAR balance: INTEGER): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $101, $7000, $A82A;	{$ENDC}FUNCTION SetSoundMediaBalance(mh: MediaHandler; balance: INTEGER): HandlerError;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $102, $7000, $A82A;	{$ENDC}{************************* Text Media routines*************************}{ Return displayFlags for TextProc }CONST	txtProcDefaultDisplay		= 0;							{	Use the media's default}	txtProcDontDisplay			= 1;							{	Don't display the text}	txtProcDoDisplay			= 2;							{	Do display the text}TYPE	TextMediaProcPtr = ProcPtr;  { FUNCTION TextMedia(theText: Handle; theMovie: Movie; VAR displayFlag: INTEGER; refcon: LONGINT): OSErr; }	TextMediaUPP = UniversalProcPtr;FUNCTION SetTextProc(mh: MediaHandler; TextProc: TextMediaUPP; refcon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $101, $7000, $A82A;	{$ENDC}FUNCTION AddTextSample(mh: MediaHandler; text: Ptr; size: LONGINT; fontNumber: INTEGER; fontSize: INTEGER; textFace: Style; VAR textColor: RGBColor; VAR backColor: RGBColor; textJustification: INTEGER; VAR textBox: Rect; displayFlags: LONGINT; scrollDelay: TimeValue; hiliteStart: INTEGER; hiliteEnd: INTEGER; VAR rgbHiliteColor: RGBColor; duration: TimeValue; VAR sampleTime: TimeValue): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $34, $102, $7000, $A82A;	{$ENDC}FUNCTION AddTESample(mh: MediaHandler; hTE: TEHandle; VAR backColor: RGBColor; textJustification: INTEGER; VAR textBox: Rect; displayFlags: LONGINT; scrollDelay: TimeValue; hiliteStart: INTEGER; hiliteEnd: INTEGER; VAR rgbHiliteColor: RGBColor; duration: TimeValue; VAR sampleTime: TimeValue): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $26, $103, $7000, $A82A;	{$ENDC}FUNCTION AddHiliteSample(mh: MediaHandler; hiliteStart: INTEGER; hiliteEnd: INTEGER; VAR rgbHiliteColor: RGBColor; duration: TimeValue; VAR sampleTime: TimeValue): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $104, $7000, $A82A;	{$ENDC}CONST	findTextEdgeOK				= 1 * (2**(0));					{ Okay to find text at specified sample time}	findTextCaseSensitive		= 1 * (2**(1));					{ Case sensitive search}	findTextReverseSearch		= 1 * (2**(2));					{ Search from sampleTime backwards}	findTextWrapAround			= 1 * (2**(3));					{ Wrap search when beginning or end of movie is hit}	findTextUseOffset			= 1 * (2**(4));					{ Begin search at the given character offset into sample rather than edge}FUNCTION FindNextText(mh: MediaHandler; text: Ptr; size: LONGINT; findFlags: INTEGER; startTime: TimeValue; VAR foundTime: TimeValue; VAR foundDuration: TimeValue; VAR offset: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $1A, $105, $7000, $A82A;	{$ENDC}FUNCTION HiliteTextSample(mh: MediaHandler; sampleTime: TimeValue; hiliteStart: INTEGER; hiliteEnd: INTEGER; VAR rgbHiliteColor: RGBColor): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $106, $7000, $A82A;	{$ENDC}CONST	dropShadowOffsetType		= 'drpo';	dropShadowTranslucencyType	= 'drpt';FUNCTION SetTextSampleData(mh: MediaHandler; data: UNIV Ptr; dataType: OSType): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $107, $7000, $A82A;	{$ENDC}FUNCTION MovieSearchText(theMovie: Movie; text: Ptr; size: LONGINT; searchFlags: LONGINT; VAR searchTrack: Track; VAR searchTime: TimeValue; VAR searchOffset: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $207, $AAAA;	{$ENDC}PROCEDURE GetPosterBox(theMovie: Movie; VAR boxRect: Rect);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $16F, $AAAA;	{$ENDC}PROCEDURE SetPosterBox(theMovie: Movie; boxRect: Rect);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $170, $AAAA;	{$ENDC}FUNCTION GetMovieSegmentDisplayBoundsRgn(theMovie: Movie; time: TimeValue; duration: TimeValue): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $16C, $AAAA;	{$ENDC}FUNCTION GetTrackSegmentDisplayBoundsRgn(theTrack: Track; time: TimeValue; duration: TimeValue): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $16B, $AAAA;	{$ENDC}PROCEDURE SetMovieCoverProcs(theMovie: Movie; uncoverProc: MovieRgnCoverUPP; coverProc: MovieRgnCoverUPP; refcon: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $179, $AAAA;	{$ENDC}FUNCTION GetMovieCoverProcs(theMovie: Movie; VAR uncoverProc: MovieRgnCoverUPP; VAR coverProc: MovieRgnCoverUPP; VAR refcon: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1DD, $AAAA;	{$ENDC}FUNCTION GetTrackStatus(theTrack: Track): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $172, $AAAA;	{$ENDC}FUNCTION GetMovieStatus(theMovie: Movie; VAR firstProblemTrack: Track): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $173, $AAAA;	{$ENDC}{***	Movie Controller support routines***}FUNCTION NewMovieController(theMovie: Movie; movieRect: Rect; someFlags: LONGINT): ComponentInstance;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $18A, $AAAA;	{$ENDC}PROCEDURE DisposeMovieController(mc: ComponentInstance);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $18B, $AAAA;	{$ENDC}PROCEDURE ShowMovieInformation(theMovie: Movie; filterProc: ModalFilterUPP; refCon: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $209, $AAAA;	{$ENDC}{****	Scrap routines****}FUNCTION PutMovieOnScrap(theMovie: Movie; movieScrapFlags: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $18C, $AAAA;	{$ENDC}FUNCTION NewMovieFromScrap(newMovieFlags: LONGINT): Movie;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $18D, $AAAA;	{$ENDC}{****	DataRef routines****}FUNCTION GetMediaDataRef(theMedia: Media; index: INTEGER; VAR dataRef: Handle; VAR dataRefType: OSType; VAR dataRefAttributes: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $197, $AAAA;	{$ENDC}FUNCTION SetMediaDataRef(theMedia: Media; index: INTEGER; dataRef: Handle; dataRefType: OSType): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1C9, $AAAA;	{$ENDC}FUNCTION SetMediaDataRefAttributes(theMedia: Media; index: INTEGER; dataRefAttributes: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1CA, $AAAA;	{$ENDC}FUNCTION AddMediaDataRef(theMedia: Media; VAR index: INTEGER; dataRef: Handle; dataRefType: OSType): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $198, $AAAA;	{$ENDC}FUNCTION GetMediaDataRefCount(theMedia: Media; VAR count: INTEGER): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $199, $AAAA;	{$ENDC}{****	Playback hint routines****}PROCEDURE SetMoviePlayHints(theMovie: Movie; flags: LONGINT; flagsMask: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1A1, $AAAA;	{$ENDC}PROCEDURE SetMediaPlayHints(theMedia: Media; flags: LONGINT; flagsMask: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1A2, $AAAA;	{$ENDC}{****	Load time track hints****}CONST	preloadAlways				= 1 * (2**(0));	preloadOnlyIfEnabled		= 1 * (2**(1));PROCEDURE SetTrackLoadSettings(theTrack: Track; preloadTime: TimeValue; preloadDuration: TimeValue; preloadFlags: LONGINT; defaultHints: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1E3, $AAAA;	{$ENDC}PROCEDURE GetTrackLoadSettings(theTrack: Track; VAR preloadTime: TimeValue; VAR preloadDuration: TimeValue; VAR preloadFlags: LONGINT; VAR defaultHints: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $1E4, $AAAA;	{$ENDC}CONST	MovieControllerComponentType = 'play';	TYPEMovieController = ComponentInstance;CONST	mcActionIdle				= 1;							{ no param}	mcActionDraw				= 2;							{ param is WindowPtr}	mcActionActivate			= 3;							{ no param}	mcActionDeactivate			= 4;							{ no param}	mcActionMouseDown			= 5;							{ param is pointer to EventRecord}	mcActionKey					= 6;							{ param is pointer to EventRecord}	mcActionPlay				= 8;							{ param is Fixed, play rate}	mcActionGoToTime			= 12;							{ param is TimeRecord}	mcActionSetVolume			= 14;							{ param is a short}	mcActionGetVolume			= 15;							{ param is pointer to a short}	mcActionStep				= 18;							{ param is number of steps (short)}	mcActionSetLooping			= 21;							{ param is Boolean}	mcActionGetLooping			= 22;							{ param is pointer to a Boolean}	mcActionSetLoopIsPalindrome	= 23;							{ param is Boolean}	mcActionGetLoopIsPalindrome	= 24;							{ param is pointer to a Boolean}	mcActionSetGrowBoxBounds	= 25;							{ param is a Rect}	mcActionControllerSizeChanged = 26;							{ no param}	mcActionSetSelectionBegin	= 29;							{ param is TimeRecord}	mcActionSetSelectionDuration = 30;							{ param is TimeRecord, action only taken on set-duration}	mcActionSetKeysEnabled		= 32;							{ param is Boolean}	mcActionGetKeysEnabled		= 33;							{ param is pointer to Boolean}	mcActionSetPlaySelection	= 34;							{ param is Boolean}	mcActionGetPlaySelection	= 35;							{ param is pointer to Boolean}	mcActionSetUseBadge			= 36;							{ param is Boolean}	mcActionGetUseBadge			= 37;							{ param is pointer to Boolean}	mcActionSetFlags			= 38;							{ param is long of flags}	mcActionGetFlags			= 39;							{ param is pointer to a long of flags}	mcActionSetPlayEveryFrame	= 40;							{ param is Boolean}	mcActionGetPlayEveryFrame	= 41;							{ param is pointer to Boolean}	mcActionGetPlayRate			= 42;							{ param is pointer to Fixed}	mcActionShowBalloon			= 43;							{ param is a pointer to a boolean. set to false to stop balloon}	mcActionBadgeClick			= 44;							{ param is pointer to Boolean. set to false to ignore click}	mcActionMovieClick			= 45;							{ param is pointer to event record. change ÒwhatÓ to nullEvt to kill click}	mcActionSuspend				= 46;							{ no param}	mcActionResume				= 47;							{ no param}	mcActionSetControllerKeysEnabled = 48;						{ param is Boolean}	mcActionGetTimeSliderRect	= 49;							{ param is pointer to rect}	mcActionMovieEdited			= 50;							{ no param}	mcActionGetDragEnabled		= 51;							{ param is pointer to Boolean}	mcActionSetDragEnabled		= 52;							{ param is Boolean}	TYPEmcAction = INTEGER;CONST	mcFlagSuppressMovieFrame	= 1 * (2**(0));	mcFlagSuppressStepButtons	= 1 * (2**(1));	mcFlagSuppressSpeakerButton	= 1 * (2**(2));	mcFlagsUseWindowPalette		= 1 * (2**(3));	mcFlagsDontInvalidate		= 1 * (2**(4));	mcPositionDontInvalidate	= 1 * (2**(5));	TYPEmcFlags = LONGINT;	MCActionFilterProcPtr = ProcPtr;  { FUNCTION MCActionFilter(mc: MovieController; VAR action: INTEGER; params: UNIV Ptr): BOOLEAN; }	MCActionFilterWithRefConProcPtr = ProcPtr;  { FUNCTION MCActionFilterWithRefCon(mc: MovieController; action: INTEGER; params: UNIV Ptr; refCon: LONGINT): BOOLEAN; }	MCActionFilterUPP = UniversalProcPtr;	MCActionFilterWithRefConUPP = UniversalProcPtr;CONST	mcInfoUndoAvailable			= 1 * (2**(0));	mcInfoCutAvailable			= 1 * (2**(1));	mcInfoCopyAvailable			= 1 * (2**(2));	mcInfoPasteAvailable		= 1 * (2**(3));	mcInfoClearAvailable		= 1 * (2**(4));	mcInfoHasSound				= 1 * (2**(5));	mcInfoIsPlaying				= 1 * (2**(6));	mcInfoIsLooping				= 1 * (2**(7));	mcInfoIsInPalindrome		= 1 * (2**(8));	mcInfoEditingEnabled		= 1 * (2**(9));{ menu item codes}	mcMenuUndo					= 1;	mcMenuCut					= 3;	mcMenuCopy					= 4;	mcMenuPaste					= 5;	mcMenuClear					= 6;{ target management }FUNCTION MCSetMovie(mc: MovieController; theMovie: Movie; movieWindow: WindowPtr; where: Point): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $2, $7000, $A82A;	{$ENDC}FUNCTION MCGetMovie(mc: MovieController): Movie;	{$IFC NOT GENERATINGCFM}	INLINE $4267, $2F3C, $2, $5, $7000, $A82A;	{$ENDC}FUNCTION MCRemoveMovie(mc: MovieController): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $6, $7000, $A82A;	{$ENDC}{ event handling etc. }FUNCTION MCIsPlayerEvent(mc: MovieController; e: EventRecord): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $7, $7000, $A82A;	{$ENDC}{ obsolete. use MCSetActionFilterWithRefCon instead. }FUNCTION MCSetActionFilter(mc: MovieController; blob: MCActionFilterUPP): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $8, $7000, $A82A;	{$ENDC}{	proc is of the form:		Boolean UserPlayerFilter(MovieController mc, short *action, void *params) =	proc returns TRUE if it handles the action, FALSE if not	action is passed as a VAR so that it could be changed by filter (ick)	this is consistent with the current dialog manager stuff	params is any potential parameters that go with the action <triple ick>		such as set playback rate to xxx.}FUNCTION MCDoAction(mc: MovieController; action: INTEGER; params: UNIV Ptr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $9, $7000, $A82A;	{$ENDC}{ state type things }FUNCTION MCSetControllerAttached(mc: MovieController; attach: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $A, $7000, $A82A;	{$ENDC}FUNCTION MCIsControllerAttached(mc: MovieController): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $B, $7000, $A82A;	{$ENDC}FUNCTION MCSetControllerPort(mc: MovieController; gp: CGrafPtr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $C, $7000, $A82A;	{$ENDC}FUNCTION MCGetControllerPort(mc: MovieController): CGrafPtr;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $D, $7000, $A82A;	{$ENDC}FUNCTION MCSetVisible(mc: MovieController; visible: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $E, $7000, $A82A;	{$ENDC}FUNCTION MCGetVisible(mc: MovieController): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $F, $7000, $A82A;	{$ENDC}FUNCTION MCGetControllerBoundsRect(mc: MovieController; VAR bounds: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $10, $7000, $A82A;	{$ENDC}FUNCTION MCSetControllerBoundsRect(mc: MovieController; bounds: Rect): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $11, $7000, $A82A;	{$ENDC}FUNCTION MCGetControllerBoundsRgn(mc: MovieController): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $12, $7000, $A82A;	{$ENDC}FUNCTION MCGetWindowRgn(mc: MovieController; w: WindowPtr): RgnHandle;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $13, $7000, $A82A;	{$ENDC}{ other stuff }FUNCTION MCMovieChanged(mc: MovieController; m: Movie): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $14, $7000, $A82A;	{$ENDC}{	called when the app has changed thing about the movie (like bounding rect) or rate. So that we		can update our graphical (and internal) state accordingly.}FUNCTION MCSetDuration(mc: MovieController; duration: TimeValue): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $15, $7000, $A82A;	{$ENDC}{	duration to use for time slider -- will be reset next time MCMovieChanged is called		or MCSetMovie is called}FUNCTION MCGetCurrentTime(mc: MovieController; VAR scale: TimeScale): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $16, $7000, $A82A;	{$ENDC}{	returns the time value and the time scale it is on. if there are no movies, the		time scale is passed back as 0. scale is an optional parameter}FUNCTION MCNewAttachedController(mc: MovieController; theMovie: Movie; w: WindowPtr; where: Point): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $17, $7000, $A82A;	{$ENDC}{	makes m the only movie attached to the controller. makes the controller visible.	the window and where parameters are passed a long to MCSetMovie and behave as	described there}FUNCTION MCDraw(mc: MovieController; w: WindowPtr): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $18, $7000, $A82A;	{$ENDC}FUNCTION MCActivate(mc: MovieController; w: WindowPtr; activate: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $19, $7000, $A82A;	{$ENDC}FUNCTION MCIdle(mc: MovieController): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $1A, $7000, $A82A;	{$ENDC}FUNCTION MCKey(mc: MovieController; key: ByteParameter; modifiers: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $6, $1B, $7000, $A82A;	{$ENDC}FUNCTION MCClick(mc: MovieController; w: WindowPtr; where: Point; when: LONGINT; modifiers: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $10, $1C, $7000, $A82A;	{$ENDC}{	calls for editing}FUNCTION MCEnableEditing(mc: MovieController; enabled: BOOLEAN): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $2, $1D, $7000, $A82A;	{$ENDC}FUNCTION MCIsEditingEnabled(mc: MovieController): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $1E, $7000, $A82A;	{$ENDC}FUNCTION MCCopy(mc: MovieController): Movie;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $1F, $7000, $A82A;	{$ENDC}FUNCTION MCCut(mc: MovieController): Movie;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $20, $7000, $A82A;	{$ENDC}FUNCTION MCPaste(mc: MovieController; srcMovie: Movie): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $21, $7000, $A82A;	{$ENDC}FUNCTION MCClear(mc: MovieController): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $22, $7000, $A82A;	{$ENDC}FUNCTION MCUndo(mc: MovieController): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, 0, $23, $7000, $A82A;	{$ENDC}{ *	somewhat special stuff }FUNCTION MCPositionController(mc: MovieController; movieRect: Rect; controllerRect: Rect; someFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $C, $24, $7000, $A82A;	{$ENDC}FUNCTION MCGetControllerInfo(mc: MovieController; VAR someFlags: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $4, $25, $7000, $A82A;	{$ENDC}FUNCTION MCSetClip(mc: MovieController; theClip: RgnHandle; movieClip: RgnHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $28, $7000, $A82A;	{$ENDC}FUNCTION MCGetClip(mc: MovieController; VAR theClip: RgnHandle; VAR movieClip: RgnHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $29, $7000, $A82A;	{$ENDC}FUNCTION MCDrawBadge(mc: MovieController; movieRgn: RgnHandle; VAR badgeRgn: RgnHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $2A, $7000, $A82A;	{$ENDC}FUNCTION MCSetUpEditMenu(mc: MovieController; modifiers: LONGINT; mh: MenuHandle): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $2B, $7000, $A82A;	{$ENDC}FUNCTION MCGetMenuString(mc: MovieController; modifiers: LONGINT; item: INTEGER; VAR aString: Str255): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $A, $2C, $7000, $A82A;	{$ENDC}FUNCTION MCSetActionFilterWithRefCon(mc: MovieController; blob: MCActionFilterWithRefConUPP; refCon: LONGINT): ComponentResult;	{$IFC NOT GENERATINGCFM}	INLINE $2F3C, $8, $2D, $7000, $A82A;	{$ENDC}CONST	kMCSetMovieSelect			= $2;	kMCGetIndMovieSelect		= $5;	kMCMCGetMovieExtendedSelect	= $5;	kMCRemoveMovieSelect		= $6;	kMCIsPlayerEventSelect		= $7;	kMCSetActionFilterSelect	= $8;	kMCDoActionSelect			= $9;	kMCSetControllerAttachedSelect = $A;	kMCIsControllerAttachedSelect = $B;	kMCSetControllerPortSelect	= $C;	kMCGetControllerPortSelect	= $D;	kMCSetVisibleSelect			= $E;	kMCGetVisibleSelect			= $F;	kMCGetControllerBoundsRectSelect = $10;	kMCSetControllerBoundsRectSelect = $11;	kMCGetControllerBoundsRgnSelect = $12;	kMCGetWindowRgnSelect		= $13;	kMCMovieChangedSelect		= $14;	kMCSetDurationSelect		= $15;	kMCGetCurrentTimeSelect		= $16;	kMCNewAttachedControllerSelect = $17;	kMCDrawSelect				= $18;	kMCActivateSelect			= $19;	kMCIdleSelect				= $1A;	kMCKeySelect				= $1B;	kMCClickSelect				= $1C;	kMCEnableEditingSelect		= $1D;	kMCIsEditingEnabledSelect	= $1E;	kMCCopySelect				= $1F;	kMCCutSelect				= $20;	kMCPasteSelect				= $21;	kMCClearSelect				= $22;	kMCUndoSelect				= $23;	kMCPositionControllerSelect	= $24;	kMCGetControllerInfoSelect	= $25;	kMCSetClipSelect			= $28;	kMCGetClipSelect			= $29;	kMCDrawBadgeSelect			= $2A;	kMCSetUpEditMenuSelect		= $2B;	kMCGetMenuStringSelect		= $2C;	kMCSetActionFilterWithRefConSelect = $2D;{****************************************										**  		T  I  M  E  B  A  S  E			**										****************************************}FUNCTION NewTimeBase: TimeBase;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $A5, $AAAA;	{$ENDC}PROCEDURE DisposeTimeBase(tb: TimeBase);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $B6, $AAAA;	{$ENDC}FUNCTION GetTimeBaseTime(tb: TimeBase; s: TimeScale; VAR tr: TimeRecord): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $A6, $AAAA;	{$ENDC}PROCEDURE SetTimeBaseTime(tb: TimeBase; tr: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $A7, $AAAA;	{$ENDC}PROCEDURE SetTimeBaseValue(tb: TimeBase; t: TimeValue; s: TimeScale);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $A8, $AAAA;	{$ENDC}FUNCTION GetTimeBaseRate(tb: TimeBase): Fixed;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $A9, $AAAA;	{$ENDC}PROCEDURE SetTimeBaseRate(tb: TimeBase; r: Fixed);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $AA, $AAAA;	{$ENDC}FUNCTION GetTimeBaseStartTime(tb: TimeBase; s: TimeScale; VAR tr: TimeRecord): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $AB, $AAAA;	{$ENDC}PROCEDURE SetTimeBaseStartTime(tb: TimeBase; tr: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $AC, $AAAA;	{$ENDC}FUNCTION GetTimeBaseStopTime(tb: TimeBase; s: TimeScale; VAR tr: TimeRecord): TimeValue;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $AD, $AAAA;	{$ENDC}PROCEDURE SetTimeBaseStopTime(tb: TimeBase; tr: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $AE, $AAAA;	{$ENDC}FUNCTION GetTimeBaseFlags(tb: TimeBase): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $B1, $AAAA;	{$ENDC}PROCEDURE SetTimeBaseFlags(tb: TimeBase; timeBaseFlags: LONGINT);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $B2, $AAAA;	{$ENDC}PROCEDURE SetTimeBaseMasterTimeBase(slave: TimeBase; master: TimeBase; slaveZero: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $B4, $AAAA;	{$ENDC}FUNCTION GetTimeBaseMasterTimeBase(tb: TimeBase): TimeBase;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $AF, $AAAA;	{$ENDC}PROCEDURE SetTimeBaseMasterClock(slave: TimeBase; clockMeister: Component; slaveZero: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $B3, $AAAA;	{$ENDC}FUNCTION GetTimeBaseMasterClock(tb: TimeBase): ComponentInstance;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $B0, $AAAA;	{$ENDC}PROCEDURE ConvertTime(VAR inout: TimeRecord; newBase: TimeBase);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $B5, $AAAA;	{$ENDC}PROCEDURE ConvertTimeScale(VAR inout: TimeRecord; newScale: TimeScale);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $B7, $AAAA;	{$ENDC}PROCEDURE AddTime(VAR dst: TimeRecord; src: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $10C, $AAAA;	{$ENDC}PROCEDURE SubtractTime(VAR dst: TimeRecord; src: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $10D, $AAAA;	{$ENDC}FUNCTION GetTimeBaseStatus(tb: TimeBase; VAR unpinnedTime: TimeRecord): LONGINT;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $10B, $AAAA;	{$ENDC}PROCEDURE SetTimeBaseZero(tb: TimeBase; VAR zero: TimeRecord);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $128, $AAAA;	{$ENDC}FUNCTION GetTimeBaseEffectiveRate(tb: TimeBase): Fixed;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $124, $AAAA;	{$ENDC}{****************************************										**  		C  A  L  L  B  A  C  K 			**										****************************************}FUNCTION NewCallBack(tb: TimeBase; cbType: INTEGER): QTCallBack;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $EB, $AAAA;	{$ENDC}PROCEDURE DisposeCallBack(cb: QTCallBack);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $EC, $AAAA;	{$ENDC}FUNCTION GetCallBackType(cb: QTCallBack): INTEGER;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $ED, $AAAA;	{$ENDC}FUNCTION GetCallBackTimeBase(cb: QTCallBack): TimeBase;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $EE, $AAAA;	{$ENDC}FUNCTION CallMeWhen(cb: QTCallBack; callBackProc: QTCallBackUPP; refCon: LONGINT; param1: LONGINT; param2: LONGINT; param3: LONGINT): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $B8, $AAAA;	{$ENDC}PROCEDURE CancelCallBack(cb: QTCallBack);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $B9, $AAAA;	{$ENDC}{****************************************										**  		C L O C K   C A L L B A C K  	**  		      S U P P O R T  			**										****************************************}FUNCTION AddCallBackToTimeBase(cb: QTCallBack): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $129, $AAAA;	{$ENDC}FUNCTION RemoveCallBackFromTimeBase(cb: QTCallBack): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $12A, $AAAA;	{$ENDC}FUNCTION GetFirstCallBack(tb: TimeBase): QTCallBack;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $12B, $AAAA;	{$ENDC}FUNCTION GetNextCallBack(cb: QTCallBack): QTCallBack;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $12C, $AAAA;	{$ENDC}PROCEDURE ExecuteCallBack(cb: QTCallBack);	{$IFC NOT GENERATINGCFM}	INLINE $303C, $12D, $AAAA;	{$ENDC}{****************************************										**  		S Y N C    T A S K S		  	**  		      S U P P O R T  			**										****************************************}FUNCTION QueueSyncTask(task: QTSyncTaskPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $203, $AAAA;	{$ENDC}FUNCTION DequeueSyncTask(qElem: QTSyncTaskPtr): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $303C, $204, $AAAA;	{$ENDC}{ UPP call backs }CONST	uppMovieRgnCoverProcInfo = $00000FE0; { FUNCTION (4 byte param, 4 byte param, 4 byte param): 2 byte result; }	uppMovieProgressProcInfo = $0000FAE0; { FUNCTION (4 byte param, 2 byte param, 2 byte param, 4 byte param, 4 byte param): 2 byte result; }	uppMovieDrawingCompleteProcInfo = $000003E0; { FUNCTION (4 byte param, 4 byte param): 2 byte result; }	uppTrackTransferProcInfo = $000003E0; { FUNCTION (4 byte param, 4 byte param): 2 byte result; }	uppGetMovieProcInfo = $00003FE0; { FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param): 2 byte result; }	uppQTCallBackProcInfo = $000003C0; { PROCEDURE (4 byte param, 4 byte param); }	uppMoviePreviewCallOutProcInfo = $000000D0; { FUNCTION (4 byte param): 1 byte result; }	uppMoviesErrorProcInfo = $00000380; { PROCEDURE (2 byte param, 4 byte param); }	uppTextMediaProcInfo = $00003FE0; { FUNCTION (4 byte param, 4 byte param, 4 byte param, 4 byte param): 2 byte result; }	uppMCActionFilterProcInfo = $00000FD0; { FUNCTION (4 byte param, 4 byte param, 4 byte param): 1 byte result; }	uppMCActionFilterWithRefConProcInfo = $00003ED0; { FUNCTION (4 byte param, 2 byte param, 4 byte param, 4 byte param): 1 byte result; }FUNCTION NewMovieRgnCoverProc(userRoutine: MovieRgnCoverProcPtr): MovieRgnCoverUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewMovieProgressProc(userRoutine: MovieProgressProcPtr): MovieProgressUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewMovieDrawingCompleteProc(userRoutine: MovieDrawingCompleteProcPtr): MovieDrawingCompleteUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewTrackTransferProc(userRoutine: TrackTransferProcPtr): TrackTransferUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewGetMovieProc(userRoutine: GetMovieProcPtr): GetMovieUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewQTCallBackProc(userRoutine: QTCallBackProcPtr): QTCallBackUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewMoviePreviewCallOutProc(userRoutine: MoviePreviewCallOutProcPtr): MoviePreviewCallOutUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewMoviesErrorProc(userRoutine: MoviesErrorProcPtr): MoviesErrorUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewTextMediaProc(userRoutine: TextMediaProcPtr): TextMediaUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewMCActionFilterProc(userRoutine: MCActionFilterProcPtr): MCActionFilterUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION NewMCActionFilterWithRefConProc(userRoutine: MCActionFilterWithRefConProcPtr): MCActionFilterWithRefConUPP;	{$IFC NOT GENERATINGCFM }	INLINE $2E9F;	{$ENDC}FUNCTION CallMovieRgnCoverProc(theMovie: Movie; changedRgn: RgnHandle; refcon: LONGINT; userRoutine: MovieRgnCoverUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallMovieProgressProc(theMovie: Movie; message: INTEGER; whatOperation: INTEGER; percentDone: Fixed; refcon: LONGINT; userRoutine: MovieProgressUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallMovieDrawingCompleteProc(theMovie: Movie; refCon: LONGINT; userRoutine: MovieDrawingCompleteUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallTrackTransferProc(t: Track; refCon: LONGINT; userRoutine: TrackTransferUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallGetMovieProc(offset: LONGINT; size: LONGINT; dataPtr: UNIV Ptr; refCon: UNIV Ptr; userRoutine: GetMovieUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}PROCEDURE CallQTCallBackProc(cb: QTCallBack; refCon: LONGINT; userRoutine: QTCallBackUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallMoviePreviewCallOutProc(refcon: LONGINT; userRoutine: MoviePreviewCallOutUPP): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}PROCEDURE CallMoviesErrorProc(theErr: OSErr; refcon: LONGINT; userRoutine: MoviesErrorUPP);	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallTextMediaProc(theText: Handle; theMovie: Movie; VAR displayFlag: INTEGER; refcon: LONGINT; userRoutine: TextMediaUPP): OSErr;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallMCActionFilterProc(mc: MovieController; VAR action: INTEGER; params: UNIV Ptr; userRoutine: MCActionFilterUPP): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}FUNCTION CallMCActionFilterWithRefConProc(mc: MovieController; action: INTEGER; params: UNIV Ptr; refCon: LONGINT; userRoutine: MCActionFilterWithRefConUPP): BOOLEAN;	{$IFC NOT GENERATINGCFM}	INLINE $205F, $4E90;	{$ENDC}{$ALIGN RESET}{$POP}{$SETC UsingIncludes := MoviesIncludes}{$ENDC} {__MOVIES__}{$IFC NOT UsingIncludes} END.{$ENDC}