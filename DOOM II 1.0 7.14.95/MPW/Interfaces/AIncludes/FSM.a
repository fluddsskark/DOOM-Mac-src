;;	File:		FSM.a;;	Copyright:	© 1984-1994 by Apple Computer, Inc.;				All rights reserved.;;	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994. ;;	Bugs?:		If you find a problem with this file, send the file and version;				information (from above) and the problem description to:;;					Internet:	apple.bugs@applelink.apple.com;					AppleLink:	APPLE.BUGS;;	IF &TYPE('__FSM__') = 'UNDEFINED' THEN__FSM__ SET 1	IF &TYPE('__FILES__') = 'UNDEFINED' THEN	include 'Files.a'	ENDIF;		include 'Types.a'											;;			include 'ConditionalMacros.a'							;;		include 'MixedMode.a'										;;		include 'OSUtils.a'										;;			include 'Memory.a'										;;	The new volume mount flags volMountInteractBit				EQU		15					; Input to VolumeMount: If set, it's OK for the file system volMountInteractMask			EQU		$8000				; to perform user interaction to mount the volume volMountChangedBit				EQU		14					; Output from VoumeMount: If set, the volume was mounted, but volMountChangedMask				EQU		$4000				; the volume mounting information record needs to be updated. volMountFSReservedMask			EQU		$00ff				; bits 0-7 are defined by each file system for its own use volMountSysReservedMask			EQU		$ff00				; bits 8-15 are reserved for Apple system use ;; * The new volume mount info record; VolumeMountInfoHeader 	RECORD	0length					 ds.w	1									; length of location data (including self) media					 ds.l	1									; type of media (must be registered with Apple) flags					 ds.w	1									; volume mount flags. Variable length data follows sizeof					 EQU	8						ENDRgestaltFSMVersion				EQU		'fsm ';; * Miscellaneous file system values not in Files.h; fsUsrCNID						EQU		16					; First assignable directory or file number ;	File system trap word attribute bits kHFSBit							EQU		9					; HFS call: bit 9 kHFSMask						EQU		$0200kAsyncBit						EQU		10					; Asynchronous call: bit 10 kAsyncMask						EQU		$0400;; * HFSCIProc selectCode values; * Note: The trap attribute bits (the HFS bit and the asynchronous bit); * may be set in these selectCode values.; kFSMOpen						EQU		$A000kFSMClose						EQU		$A001kFSMRead						EQU		$A002kFSMWrite						EQU		$A003kFSMGetVolInfo					EQU		$A007kFSMCreate						EQU		$A008kFSMDelete						EQU		$A009kFSMOpenRF						EQU		$A00AkFSMRename						EQU		$A00BkFSMGetFileInfo					EQU		$A00CkFSMSetFileInfo					EQU		$A00DkFSMUnmountVol					EQU		$A00EkFSMMountVol					EQU		$A00FkFSMAllocate					EQU		$A010kFSMGetEOF						EQU		$A011kFSMSetEOF						EQU		$A012kFSMFlushVol					EQU		$A013kFSMGetVol						EQU		$A014kFSMSetVol						EQU		$A015kFSMEject						EQU		$A017kFSMGetFPos						EQU		$A018kFSMOffline						EQU		$A035kFSMSetFilLock					EQU		$A041kFSMRstFilLock					EQU		$A042kFSMSetFilType					EQU		$A043kFSMSetFPos						EQU		$A044kFSMFlushFile					EQU		$A045;	The File System HFSDispatch selectCodes kFSMOpenWD						EQU		$0001kFSMCloseWD						EQU		$0002kFSMCatMove						EQU		$0005kFSMDirCreate					EQU		$0006kFSMGetWDInfo					EQU		$0007kFSMGetFCBInfo					EQU		$0008kFSMGetCatInfo					EQU		$0009kFSMSetCatInfo					EQU		$000AkFSMSetVolInfo					EQU		$000BkFSMLockRng						EQU		$0010kFSMUnlockRng					EQU		$0011kFSMCreateFileIDRef				EQU		$0014kFSMDeleteFileIDRef				EQU		$0015kFSMResolveFileIDRef			EQU		$0016kFSMExchangeFiles				EQU		$0017kFSMCatSearch					EQU		$0018kFSMOpenDF						EQU		$001AkFSMMakeFSSpec					EQU		$001B;	The Desktop Manager HFSDispatch selectCodes kFSMDTGetPath					EQU		$0020kFSMDTCloseDown					EQU		$0021kFSMDTAddIcon					EQU		$0022kFSMDTGetIcon					EQU		$0023kFSMDTGetIconInfo				EQU		$0024kFSMDTAddAPPL					EQU		$0025kFSMDTRemoveAPPL				EQU		$0026kFSMDTGetAPPL					EQU		$0027kFSMDTSetComment				EQU		$0028kFSMDTRemoveComment				EQU		$0029kFSMDTGetComment				EQU		$002AkFSMDTFlush						EQU		$002BkFSMDTReset						EQU		$002CkFSMDTGetInfo					EQU		$002DkFSMDTOpenInform				EQU		$002EkFSMDTDelete					EQU		$002F;	The AppleShare HFSDispatch selectCodes kFSMGetVolParms					EQU		$0030kFSMGetLogInInfo				EQU		$0031kFSMGetDirAccess				EQU		$0032kFSMSetDirAccess				EQU		$0033kFSMMapID						EQU		$0034kFSMMapName						EQU		$0035kFSMCopyFile					EQU		$0036kFSMMoveRename					EQU		$0037kFSMOpenDeny					EQU		$0038kFSMOpenRFDeny					EQU		$0039kFSMGetXCatInfo					EQU		$003AkFSMGetVolMountInfoSize			EQU		$003FkFSMGetVolMountInfo				EQU		$0040kFSMVolumeMount					EQU		$0041kFSMShare						EQU		$0042kFSMUnShare						EQU		$0043kFSMGetUGEntry					EQU		$0044kFSMGetForeignPrivs				EQU		$0060kFSMSetForeignPrivs				EQU		$0061;; * UTDetermineVol status values; dtmvError						EQU		0					; param error dtmvFullPathame					EQU		1					; determined by full pathname dtmvVRefNum						EQU		2					; determined by volume refNum dtmvWDRefNum					EQU		3					; determined by working directory refNum dtmvDriveNum					EQU		4					; determined by drive number dtmvDefault						EQU		5					; determined by default volume ;; * UTGetBlock options; gbDefault						EQU		0					; default value - read if not found ;	bits and masks gbReadBit						EQU		0					; read block from disk (forced read) gbReadMask						EQU		$0001gbExistBit						EQU		1					; get existing cache block gbExistMask						EQU		$0002gbNoReadBit						EQU		2					; don't read block from disk if not found in cache gbNoReadMask					EQU		$0004gbReleaseBit					EQU		3					; release block immediately after GetBlock gbReleaseMask					EQU		$0008;; * UTReleaseBlock options; rbDefault						EQU		0					; default value - just mark the buffer not in-use ;	bits and masks rbWriteBit						EQU		0					; force write buffer to disk rbWriteMask						EQU		$0001rbTrashBit						EQU		1					; trash buffer contents after release rbTrashMask						EQU		$0002rbDirtyBit						EQU		2					; mark buffer dirty rbDirtyMask						EQU		$0004rbFreeBit						EQU		3					; free the buffer (save in the hash) ;; *	rbFreeMask (rbFreeBit + rbTrashBit) works as rbTrash on < System 7.0 RamCache;; *	on >= System 7.0, rbfreeMask overrides rbTrash; rbFreeMask						EQU		$000A;; * UTFlushCache options; fcDefault						EQU		0					; default value - just flush any dirty buffers ;	bits and masks fcTrashBit						EQU		1					; trash buffers after flushing fcTrashMask						EQU		$0002fcFreeBit						EQU		3					; free buffers after flushing fcFreeMask						EQU		$0008				; fcFreeMask works as fcTrash on < System 7.0 RamCache ;; * UTCacheReadIP and UTCacheWriteIP cacheOption; noCacheBit						EQU		5					; don't cache this please noCacheMask						EQU		$0020rdVerifyBit						EQU		6					; read verify rdVerifyMask					EQU		$0040;; * Cache routine internal error codes; chNoBuf							EQU		1					; no free cache buffers (all in use) chInUse							EQU		2					; requested block in use chnotfound						EQU		3					; requested block not found chNotInUse						EQU		4					; block being released was not in use ;; * FCBRec.fcbFlags bits; fcbWriteBit						EQU		0					; Data can be written to this file fcbWriteMask					EQU		$01fcbResourceBit					EQU		1					; This file is a resource fork fcbResourceMask					EQU		$02fcbWriteLockedBit				EQU		2					; File has a locked byte range fcbWriteLockedMask				EQU		$04fcbSharedWriteBit				EQU		4					; File is open for shared write access fcbSharedWriteMask				EQU		$10fcbFileLockedBit				EQU		5					; File is locked (write-protected) fcbFileLockedMask				EQU		$20fcbOwnClumpBit					EQU		6					; File has clump size specified in FCB fcbOwnClumpMask					EQU		$40fcbModifiedBit					EQU		7					; File has changed since it was last flushed fcbModifiedMask					EQU		$80;; * ExtFileProc options; extendFileAllBit				EQU		0					; allocate all requested bytes or none extendFileAllMask				EQU		$0001extendFileContigBit				EQU		1					; force contiguous allocation extendFileContigMask			EQU		$0002;; *	HFS Component Interface constants; ;; * compInterfMask bits specific to HFS component; hfsCIDoesHFSBit					EQU		23					; set if file system supports HFS calls hfsCIDoesHFSMask				EQU		$00800000hfsCIDoesAppleShareBit			EQU		22					; set if AppleShare calls supported hfsCIDoesAppleShareMask			EQU		$00400000hfsCIDoesDeskTopBit				EQU		21					; set if Desktop Database calls supported hfsCIDoesDeskTopMask			EQU		$00200000hfsCIDoesDynamicLoadBit			EQU		20					; set if dynamically loading code resource hfsCIDoesDynamicLoadMask		EQU		$00100000			;		supported hfsCIResourceLoadedBit			EQU		19					; set if code resource already loaded hfsCIResourceLoadedMask			EQU		$00080000hfsCIHasHLL2PProcBit			EQU		18					; set if FFS' log2PhyProc and Extendfile proc hfsCIHasHLL2PProcMask			EQU		$00040000			; is written in a high level language. (i.e., uses Pascal calling convention) ;; *	Disk Initialization Component Interface constants; ;; * compInterfMask bits specific to Disk Initialization component; diCIHasExtFormatParamsBit		EQU		18					; set if file system needs extended format diCIHasExtFormatParamsMask		EQU		$00040000			;		parameters diCIHasMultiVolTypesBit			EQU		17					; set if file system supports more than one diCIHasMultiVolTypesMask		EQU		$00020000			;		volume type diCIDoesSparingBit				EQU		16					; set if file system supports disk sparing diCIDoesSparingMask				EQU		$00010000diCILiveBit						EQU		0					; set if file system is candidate for current diCILiveMask					EQU		$00000001			;		formatting operation (set by PACK2) ;; * Disk Initialization Component Function selectors; diCILoad						EQU		1					; Make initialization code memory resident diCIUnload						EQU		2					; Make initialization code purgeable diCIEvaluateSizeChoices			EQU		3					; Evaluate size choices diCIExtendedZero				EQU		4					; Write an empty volume directory diCIValidateVolName				EQU		5					; Validate volume name diCIGetVolTypeInfo				EQU		6					; get volume type info diCIGetFormatString				EQU		7					; get dialog format string diCIGetExtFormatParams			EQU		8					; get extended format parameters diCIGetDefectList				EQU		9					; return the defect list for the indicated disk - reserved for future use ;; * Constants used in the DICIEvaluateSizeRec and FormatListRec; diCIFmtListMax					EQU		8					; maximum number of format list entries in DICIEvaluateSizeRec.numSizeEntries ;	bits in FormatListRec.formatFlags: diCIFmtFlagsValidBit			EQU		7					; set if sec, side, tracks valid diCIFmtFlagsValidMask			EQU		$80diCIFmtFlagsCurrentBit			EQU		6					; set if current disk has this fmt diCIFmtFlagsCurrentMask			EQU		$40;	bits in FormatListRec.sizeListFlags: diCISizeListOKBit				EQU		15					; set if this disk size usable diCISizeListOKMask				EQU		$8000;; * DICIGetFormatStringRec.stringKind format strings; diCIAlternateFormatStr			EQU		1					; get alternate format  string (Balloon Help) diCISizePresentationStr			EQU		2					; get size presentation string (for dialog) ;; * Error codes returned by Disk Sparing; diCIUserCancelErr				EQU		1					; user cancelled the disk init diCICriticalSectorBadErr		EQU		20					; critical sectors are bad (hopeless)	diCISparingFailedErr			EQU		21					; disk cannot be spared diCITooManyBadSectorsErr		EQU		22					; too many bad sectors diCIUnknownVolTypeErr			EQU		23					; the volume type passed in diCIExtendedZero paramBlock is not supported diCIVolSizeMismatchErr			EQU		24					; specified volume size doesnÕt match with formatted disk size diCIUnknownDICallErr			EQU		25					; bogus DI function call selector diCINoSparingErr				EQU		26					; disk is bad but the target FS doesn't do disk sparing diCINoExtendInfoErr				EQU		27					; missing file system specific extra parameter in diCIExtendedZero call diCINoMessageTextErr			EQU		28					; missing message text in DIReformat call ;; *	File System Manager constants; ;; * Miscellaneous constants used by FSM; fsdVersion1						EQU		1					; current version of FSD record fsmIgnoreFSID					EQU		$fffe				; this FSID should be ignored by the driver fsmGenericFSID					EQU		$ffff				; unknown foreign file system ID ;; * compInterfMask bits common to all FSM components; fsmComponentEnableBit			EQU		31					; set if FSM component interface is enabled fsmComponentEnableMask			EQU		$80000000fsmComponentBusyBit				EQU		30					; set if FSM component interface is busy fsmComponentBusyMask			EQU		$40000000;; * Selectors for GetFSInfo; fsmGetFSInfoByIndex				EQU		-1					; get fs info by index fsmGetFSInfoByFSID				EQU		0					; get fs info by FSID fsmGetFSInfoByRefNum			EQU		1					; get fs info by file/vol refnum ;; * InformFSM messages; fsmNopMessage					EQU		0					; nop fsmDrvQElChangedMessage			EQU		1					; DQE has changed fsmGetFSIconMessage				EQU		2					; Get FFS's disk icon ;; * Messages passed to the fileSystemCommProc; ffsNopMessage					EQU		0					; nop, should always return noErr ffsGetIconMessage				EQU		1					; return disk icon and mask ffsIDDiskMessage				EQU		2					; identify the about-to-be-mounted volume ffsLoadMessage					EQU		3					; load in the FFS ffsUnloadMessage				EQU		4					; unload the FFS ffsIDVolMountMessage			EQU		5					; identify a VolMountInfo record ffsInformMessage				EQU		6					; FFS defined message ffsGetIconInfoMessage			EQU		7;; * Error codes from FSM functions; fsmFFSNotFoundErr				EQU		-431				; Foreign File system does not exist - new Pack2 could return this error too fsmBusyFFSErr					EQU		-432				; File system is busy, cannot be removed fsmBadFFSNameErr				EQU		-433				; Name length not 1 <= length <= 31 fsmBadFSDLenErr					EQU		-434				; FSD size incompatible with current FSM vers fsmDuplicateFSIDErr				EQU		-435				; FSID already exists on InstallFS fsmBadFSDVersionErr				EQU		-436				; FSM version incompatible with FSD fsmNoAlternateStackErr			EQU		-437				; no alternate stack for HFS CI fsmUnknownFSMMessageErr			EQU		-438				; unknown message passed to FSM ;; *	HFS Utility routine records; ;; * record used by UTGetPathComponentName; ParsePathRec 			RECORD	0namePtr					 ds.l	1									; pathname to parse startOffset				 ds.w	1									; where to start parsing componentLength			 ds.w	1									; the length of the pathname component parsed moreName				 ds.b	1									; non-zero if there are more components after this one foundDelimiter			 ds.b	1									; non-zero if parsing stopped because a colon (:) delimiter was found sizeof					 EQU	10						ENDRWDCBRec 				RECORD	0wdVCBPtr				 ds.l	1									; Pointer to VCB of this working directory wdDirID					 ds.l	1									; Directory ID number of this working directory wdCatHint				 ds.l	1									; Hint for finding this working directory wdProcID				 ds.l	1									; Process that created this working directory sizeof					 EQU	16						ENDRFCBRec 					RECORD	0fcbFlNm					 ds.l	1									; FCB file number. Non-zero marks FCB used fcbFlags				 ds.b	1									; FCB flags fcbTypByt				 ds.b	1									; File type byte fcbSBlk					 ds.w	1									; File start block (in alloc size blks) fcbEOF					 ds.l	1									; Logical length or EOF in bytes fcbPLen					 ds.l	1									; Physical file length in bytes fcbCrPs					 ds.l	1									; Current position within file fcbVPtr					 ds.l	1									; Pointer to the corresponding VCB fcbBfAdr				 ds.l	1									; File's buffer address fcbFlPos				 ds.w	1									; Directory block this file is in ; FCB Extensions for HFS fcbClmpSize				 ds.l	1									; Number of bytes per clump fcbBTCBPtr				 ds.l	1									; Pointer to B*-Tree control block for file fcbExtRec				 ds.l	3									; First 3 file extents fcbFType				 ds.l	1									; File's 4 Finder Type bytes fcbCatPos				 ds.l	1									; Catalog hint for use on Close fcbDirID				 ds.l	1									; Parent Directory ID fcbCName				 ds.l	8									; CName of open file sizeof					 EQU	94						ENDR;; *	HFS Component Interface records; HFSCIRec 				RECORD	0compInterfMask			 ds.l	1									; component flags compInterfProc			 ds.l	1									; pointer to file system call processing code log2PhyProc				 ds.l	1									; pointer to Lg2PhysProc() code stackTop				 ds.l	1									; file system stack top stackSize				 ds.l	1									; file system stack size stackPtr				 ds.l	1									; current file system stack pointer reserved3				 ds.l	1									; --reserved, must be zero-- idSector				 ds.l	1									; Sector you need to ID a local volume. For networked volumes, this must be -1 reserved2				 ds.l	1									; --reserved, must be zero-- reserved1				 ds.l	1									; --reserved, must be zero-- sizeof					 EQU	40						ENDR;; *	Disk Initialization Component Interface records; DICIRec 				RECORD	0compInterfMask			 ds.l	1									; component flags compInterfProc			 ds.l	1									; pointer to call processing code maxVolNameLength		 ds.w	1									; maximum length of your volume name blockSize				 ds.w	1									; your file system's block size reserved3				 ds.l	1									; --reserved, must be zero-- reserved2				 ds.l	1									; --reserved, must be zero-- reserved1				 ds.l	1									; --reserved, must be zero-- sizeof					 EQU	24						ENDR;; * FormatListRec as returned by the .Sony disk driver's; * Return Format List status call (csCode = 6).; * If the status call to get this list for a drive is not; * implemented by the driver, then a list with one entry; * is contructed from the drive queue element for the drive.; FormatListRec 			RECORD	0volSize					 ds.l	1									; disk capacity in SECTORs formatFlags				 ds.b	1									; flags sectorsPerTrack			 ds.b	1									; sectors per track side tracks					 ds.w	1									; number of tracks sizeof					 EQU	8						ENDR;; * SizeListRec built from FormatListRecs as described above.; SizeListRec 			RECORD	0sizeListFlags			 ds.w	1									; flags as set by external file system sizeEntry				 ds		FormatListRec						; disk driver format list record sizeof					 EQU	10						ENDR;; * paramBlock for the diCIEvaluateSize call; DICIEvaluateSizeRec 	RECORD	0defaultSizeIndex		 ds.w	1									; default size for this FS numSizeEntries			 ds.w	1									; number of size entries driveNumber				 ds.w	1									; drive number sizeListPtr				 ds.l	1									; ptr to size entry table sectorSize				 ds.w	1									; bytes per sector sizeof					 EQU	12						ENDR;; * paramBlock for the diCIExtendedZero call; DICIExtendedZeroRec 	RECORD	0driveNumber				 ds.w	1									; drive number volNamePtr				 ds.l	1									; ptr to volume name string fsid					 ds.w	1									; file system ID volTypeSelector			 ds.w	1									; volume type selector, if supports more than 1 type numDefectBlocks			 ds.w	1									; number of bad logical blocks defectListSize			 ds.w	1									; size of the defect list buffer in bytes defectListPtr			 ds.l	1									; pointer to defect list buffer volSize					 ds.l	1									; size of volume in SECTORs sectorSize				 ds.w	1									; bytes per sector extendedInfoPtr			 ds.l	1									; ptr to extended info sizeof					 EQU	28						ENDR;; * paramBlock for the diCIValidateVolName call; DICIValidateVolNameRec 	RECORD	0theChar					 ds.b	1									; the character to validate hasMessageBuffer		 ds.b	1									; false if no message charOffset				 ds.w	1									; position of the current character (first char = 1) messageBufferPtr		 ds.l	1									; pointer to message buffer or nil charByteType			 ds.w	1									; theChar's byte type (smSingleByte, smFirstByte, or smLastByte) sizeof					 EQU	10						ENDR;; * paramBlock for the diCIGetVolTypeInfo call; DICIGetVolTypeInfoRec 	RECORD	0volSize					 ds.l	1									; size of volume in SECTORs sectorSize				 ds.w	1									; bytes per sector numVolTypes				 ds.w	1									; number of volume types supported volTypesBuffer			 ds.b	132								; 4 string buffers sizeof					 EQU	140						ENDR;; * paramBlock for the diCIGetFormatString call; DICIGetFormatStringRec 	RECORD	0volSize					 ds.l	1									; volume size in SECTORs sectorSize				 ds.w	1									; sector size volTypeSelector			 ds.w	1									; volume type selector stringKind				 ds.w	1									; sub-function = type of string stringBuffer			 ds.l	64								; string buffer sizeof					 EQU	266						ENDR;; * paramBlock for the diCIGetExtendedFormatParams call; DICIGetExtendedFormatRec RECORD	0driveNumber				 ds.w	1									; drive number volTypeSelector			 ds.w	1									; volume type selector or 0 volSize					 ds.l	1									; size of volume in SECTORs sectorSize				 ds.w	1									; bytes per sector fileSystemSpecPtr		 ds.l	1									; pointer to the foreign file system's FSSpec extendedInfoPtr			 ds.l	1									; pointer to extended parameter structure sizeof					 EQU	18						ENDR;; *	File System Manager records; FSDRec 					RECORD	0fsdLink					 ds.l	1									; ptr to next fsdLength				 ds.w	1									; length of this FSD in BYTES fsdVersion				 ds.w	1									; version number fileSystemFSID			 ds.w	1									; file system id fileSystemName			 ds.l	8									; file system name fileSystemSpec			 ds		FSSpec								; foreign file system's FSSpec fileSystemGlobalsPtr	 ds.l	1									; ptr to file system globals fileSystemCommProc		 ds.l	1									; communication proc with the FFS reserved3				 ds.l	1									; --reserved, must be zero-- reserved2				 ds.l	1									; --reserved, must be zero-- reserved1				 ds.l	1									; --reserved, must be zero-- fsdHFSCI				 ds		HFSCIRec							; HFS component interface    fsdDICI					 ds		DICIRec							; Disk Initialization component interface sizeof					 EQU	196						ENDRFSMGetIconInfoRec 		RECORD	0theIcon					 ds.l	32								; The ICN# structure theMask					 ds.l	32								; The mask for the icon above whereStr				 ds.l	64sizeof					 EQU	512						ENDR;; * paramBlock for ffsGetIconMessage and fsmGetFSIconMessage; FSMGetIconRec 			RECORD	0refNum					 ds.w	1									; target drive num or volume refnum iconBufferPtr			 ds.l	1									; pointer to icon buffer requestSize				 ds.l	1									; requested size of the icon buffer actualSize				 ds.l	1									; actual size of the icon data returned iconType				 ds.b	1									; kind of icon isEjectable				 ds.b	1									; true if the device is ejectable driveQElemPtr			 ds.l	1									; pointer to DQE fileSystemSpecPtr		 ds.l	1									; pointer to foreign file system's FSSpec reserved1				 ds.l	1									; --reserved, must be zero-- sizeof					 EQU	28						ENDR;; *	HFS Utility routine prototypes; 	IF GENERATING68K THEN		Macro		_UTAllocateFCB			moveq	#0,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTAllocateFCB	ENDIF	IF GENERATING68K THEN		Macro		_UTReleaseFCB			moveq	#1,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTReleaseFCB	ENDIF	IF GENERATING68K THEN		Macro		_UTLocateFCB			moveq	#2,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTLocateFCB	ENDIF	IF GENERATING68K THEN		Macro		_UTLocateNextFCB			moveq	#3,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTLocateNextFCB	ENDIF	IF GENERATING68K THEN		Macro		_UTIndexFCB			moveq	#4,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTIndexFCB	ENDIF	IF GENERATING68K THEN		Macro		_UTResolveFCB			moveq	#5,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTResolveFCB	ENDIF	IF GENERATING68K THEN		Macro		_UTAllocateVCB			moveq	#6,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTAllocateVCB	ENDIF	IF GENERATING68K THEN		Macro		_UTAddNewVCB			moveq	#7,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTAddNewVCB	ENDIF	IF GENERATING68K THEN		Macro		_UTDisposeVCB			moveq	#8,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTDisposeVCB	ENDIF	IF GENERATING68K THEN		Macro		_UTLocateVCBByRefNum			moveq	#9,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTLocateVCBByRefNum	ENDIF	IF GENERATING68K THEN		Macro		_UTLocateVCBByName			moveq	#10,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTLocateVCBByName	ENDIF	IF GENERATING68K THEN		Macro		_UTLocateNextVCB			moveq	#11,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTLocateNextVCB	ENDIF	IF GENERATING68K THEN		Macro		_UTAllocateWDCB			moveq	#12,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTAllocateWDCB	ENDIF	IF GENERATING68K THEN		Macro		_UTReleaseWDCB			moveq	#13,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTReleaseWDCB	ENDIF	IF GENERATING68K THEN		Macro		_UTResolveWDCB			moveq	#14,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTResolveWDCB	ENDIF	IF GENERATING68K THEN		Macro		_UTFindDrive			moveq	#15,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTFindDrive	ENDIF	IF GENERATING68K THEN		Macro		_UTAdjustEOF			moveq	#16,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTAdjustEOF	ENDIF	IF GENERATING68K THEN		Macro		_UTSetDefaultVol			moveq	#17,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTSetDefaultVol	ENDIF	IF GENERATING68K THEN		Macro		_UTGetDefaultVol			moveq	#18,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTGetDefaultVol	ENDIF	IF GENERATING68K THEN		Macro		_UTEjectVol			moveq	#43,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTEjectVol	ENDIF	IF GENERATING68K THEN		Macro		_UTCheckWDRefNum			moveq	#19,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTCheckWDRefNum	ENDIF	IF GENERATING68K THEN		Macro		_UTCheckFileRefNum			moveq	#20,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTCheckFileRefNum	ENDIF	IF GENERATING68K THEN		Macro		_UTCheckVolRefNum			moveq	#21,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTCheckVolRefNum	ENDIF	IF GENERATING68K THEN		Macro		_UTCheckPermission			moveq	#22,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTCheckPermission	ENDIF	IF GENERATING68K THEN		Macro		_UTCheckVolOffline			moveq	#23,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTCheckVolOffline	ENDIF	IF GENERATING68K THEN		Macro		_UTCheckVolModifiable			moveq	#24,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTCheckVolModifiable	ENDIF	IF GENERATING68K THEN		Macro		_UTCheckFileModifiable			moveq	#25,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTCheckFileModifiable	ENDIF	IF GENERATING68K THEN		Macro		_UTCheckDirBusy			moveq	#26,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTCheckDirBusy	ENDIF	IF GENERATING68K THEN		Macro		_UTParsePathname			moveq	#27,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTParsePathname	ENDIF	IF GENERATING68K THEN		Macro		_UTGetPathComponentName			moveq	#28,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTGetPathComponentName	ENDIF	IF GENERATING68K THEN		Macro		_UTDetermineVol			moveq	#29,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTDetermineVol	ENDIF	IF GENERATING68K THEN		Macro		_UTGetBlock			moveq	#31,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTGetBlock	ENDIF	IF GENERATING68K THEN		Macro		_UTReleaseBlock			moveq	#32,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTReleaseBlock	ENDIF	IF GENERATING68K THEN		Macro		_UTFlushCache			moveq	#33,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTFlushCache	ENDIF	IF GENERATING68K THEN		Macro		_UTMarkDirty			moveq	#35,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTMarkDirty	ENDIF	IF GENERATING68K THEN		Macro		_UTTrashVolBlocks			moveq	#36,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTTrashVolBlocks	ENDIF	IF GENERATING68K THEN		Macro		_UTTrashFileBlocks			moveq	#37,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTTrashFileBlocks	ENDIF	IF GENERATING68K THEN		Macro		_UTTrashBlocks			moveq	#38,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTTrashBlocks	ENDIF	IF GENERATING68K THEN		Macro		_UTCacheReadIP			moveq	#39,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTCacheReadIP	ENDIF	IF GENERATING68K THEN		Macro		_UTCacheWriteIP			moveq	#40,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTCacheWriteIP	ENDIF	IF GENERATING68K THEN		Macro		_UTBlockInFQHashP			moveq	#44,d0			dc.w 	$A824		EndM	ELSE		IMPORT	UTBlockInFQHashP	ENDIF;; *	File System Manager call prototypes; 	ENDIF ; __FSM__