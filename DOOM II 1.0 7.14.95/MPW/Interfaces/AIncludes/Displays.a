;;	File:		Displays.a;;	Copyright:	© 1984-1994 by Apple Computer, Inc.;				All rights reserved.;;	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994. ;;	Bugs?:		If you find a problem with this file, send the file and version;				information (from above) and the problem description to:;;					Internet:	apple.bugs@applelink.apple.com;					AppleLink:	APPLE.BUGS;;	IF &TYPE('__DISPLAYS__') = 'UNDEFINED' THEN__DISPLAYS__ SET 1	__SKIP_DISPLAY_INCLUDES__: SET 1	IF &TYPE('__CONDITIONALMACROS__') = 'UNDEFINED' THEN	include 'ConditionalMacros.a'	ENDIF	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN	include 'Components.a'	ENDIF;		include 'Types.a'											;;		include 'MixedMode.a'										;	IF &TYPE('__SKIP_DISPLAY_INCLUDES__') = 'UNDEFINED' THEN	IF &TYPE('__APPLEEVENTS__') = 'UNDEFINED' THEN	include 'AppleEvents.a'	ENDIF;		include 'Errors.a'											;;		include 'Memory.a'											;;		include 'OSUtils.a'										;;		include 'Events.a'											;;			include 'Quickdraw.a'									;;				include 'QuickdrawText.a'							;;		include 'EPPC.a'											;;			include 'PPCToolbox.a'									;;				include 'AppleTalk.a'								;;			include 'Processes.a'									;;				include 'Files.a'									;;		include 'Notification.a'									;	IF &TYPE('__WINDOWS__') = 'UNDEFINED' THEN	include 'Windows.a'	ENDIF;		include 'Controls.a'										;;			include 'Menus.a'										;	ENDIF; AppleEvents Core Suite kAESystemConfigNotice			EQU		'cnfg'; Core Suite types kAEDisplayNotice				EQU		'dspl'kAEDisplaySummary				EQU		'dsum'keyDMConfigVersion				EQU		'dmcv'keyDMConfigFlags				EQU		'dmcf'keyDMConfigReserved				EQU		'dmcr'keyDisplayID					EQU		'dmid'keyDisplayComponent				EQU		'dmdc'keyDisplayDevice				EQU		'dmdd'keyDisplayFlags					EQU		'dmdf'keyDisplayMode					EQU		'dmdm'keyDisplayModeReserved			EQU		'dmmr'keyDisplayReserved				EQU		'dmdr'keyDisplayMirroredId			EQU		'dmmi'keyDeviceFlags					EQU		'dddf'keyDeviceDepthMode				EQU		'dddm'keyDeviceRect					EQU		'dddr'keyPixMapRect					EQU		'dpdr'keyPixMapHResolution			EQU		'dphr'keyPixMapVResolution			EQU		'dpvr'keyPixMapPixelType				EQU		'dppt'keyPixMapPixelSize				EQU		'dpps'keyPixMapCmpCount				EQU		'dpcc'keyPixMapCmpSize				EQU		'dpcs'keyPixMapAlignment				EQU		'dppa'keyPixMapResReserved			EQU		'dprr'keyPixMapReserved				EQU		'dppr'keyPixMapColorTableSeed			EQU		'dpct'keySummaryMenubar				EQU		'dsmb'keySummaryChanges				EQU		'dsch'keyDisplayOldConfig				EQU		'dold'keyDisplayNewConfig				EQU		'dnew'dmOnlyActiveDisplays			EQU		truedmAllDisplays					EQU		false; Switch Flags kNoSwitchConfirmBit				EQU		0					; Flag indicating that there is no need to confirm a switch to this mode kDepthNotAvailableBit			EQU		1					; Current depth not available in new mode kShowModeBit					EQU		3					; Show this mode even though it requires a confirm. kModeNotResizeBit				EQU		4					; Do not use this mode to resize display (for cards that mode drives a different connector). ;	Summary Change Flags (sticky bits indicating an operation was performed);	For example, moving a display then moving it back will still set the kMovedDisplayBit.;kBeginEndConfigureBit			EQU		0kMovedDisplayBit				EQU		1kSetMainDisplayBit				EQU		2kSetDisplayModeBit				EQU		3kAddDisplayBit					EQU		4kRemoveDisplayBit				EQU		5kNewDisplayBit					EQU		6kDisposeDisplayBit				EQU		7kEnabledDisplayBit				EQU		8kDisabledDisplayBit				EQU		9kMirrorDisplayBit				EQU		10kUnMirrorDisplayBit				EQU		11; Notification Messages for extended call back routines kDMNotifyInstalled				EQU		1					; At install time kDMNotifyEvent					EQU		2					; Post change time kDMNotifyRemoved				EQU		3					; At remove time kDMNotifyPrep					EQU		4					; Pre change time kDMNotifyExtendEvent			EQU		5					; Allow registrees to extend apple event before it is sent kDMNotifyDependents				EQU		6					; Minor notification check without full update ; Notification Flags kExtendedNotificationProc		EQU		(1 << 16); Selectors for tablecloths kTableclothInit					EQU		0kTableclothDraw					EQU		1kTableclothAnimate				EQU		2kTableclothAnimateContinue		EQU		3kTableclothClose				EQU		4; types for notifyType kFullNotify						EQU		0					; This is the appleevent whole nine yards notify kFullDependencyNotify			EQU		1					; Only sends to those who want to know about interrelated functionality (used for updating UI) ; DisplayID/DeviceID constants kDummyDeviceID					EQU		$0FF				; This is the ID of the dummy display, used when the last ÒrealÓ display is disabled.kInvalidDisplayID				EQU		$000				; This is the invalid IDkFirstDisplayID					EQU		$100; bits for panelListFlags kAllowDuplicatesBit				EQU		0; Constants for fidelity checks kNoFidelity						EQU		0kMinimumFidelity				EQU		1kDefaultFidelity				EQU		500					; I'm just picking a number for Apple default panels and engineskDefaultManufacturorFidelity	EQU		1000				; I'm just picking a number for Manufacturor's panels and engines (overrides apple defaults)kAnyPanelType					EQU		0					; Pass to DMNewEngineList for list of all panels (as opposed to specific types)kAnyEngineType					EQU		0					; Pass to DMNewEngineList for list of all engineskAnyDeviceType					EQU		0					; Pass to DMNewDeviceList for list of all deviceskAnyPortType					EQU		0					; Pass to DMNewDevicePortList for list of all devices; portListFlags for DM_NewDevicePortList ; Should offline devices be put into the port list (such as dummy display) kPLIncludeOfflineDevicesBit		EQU		0DMListEntryRec 			RECORD	0itemID					 ds.l	1									; DisplayID ManageritemComponent			 ds.l	1									; Component ManageritemDescription			 ds		ComponentDescription				; We can always construct this if we use something beyond the compontent mgr.itemClass				 ds.l	1									; Class of group to put this panel (eg geometry/color/etc for panels, brightness/contrast for engines, video out/sound/etc for devices)itemFidelity			 ds.l	1									; How good is this item for the specified search?itemFlags				 ds.l	1									; Set to 0 (future expansion)itemReserved			 ds.l	1									; What kind of code does the itemReference point to  (right now - kPanelEntryTypeComponentMgr only)itemFuture				 ds.l	1									; Set to 0 (future expansion - probably an alternate code style)sizeof					 EQU	48						ENDRDependentNotifyRec 		RECORD	0notifyType				 ds.l	1									; What type was the engine that made the change (may be zero)notifyClass				 ds.l	1									; What class was the change (eg geometry, color etc)displayID				 ds.l	1									; Which device was touched (kInvalidDisplayID -> all or none)notifyComponent			 ds.l	1									; What engine did it (may be 0)?notifyVersion			 ds.l	1									; Set to 0 (future expansion)notifyFlags				 ds.l	1									; Set to 0 (future expansion)notifyReserved			 ds.l	1									; Set to 0 (future expansion)notifyFuture			 ds.l	1									; Set to 0 (future expansion)sizeof					 EQU	32						ENDRTableclothInfoRec 		RECORD	0tableclothInstance		 ds.l	1nextAnimateTick			 ds.l	1refCon					 ds.l	1allDisplays				 ds.b	1filler					 ds.b	3sizeof					 EQU	16						ENDR; Trap interfaces 	IF GENERATING68K THEN		Macro		_DMGetFirstScreenDevice			moveq	#0,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetFirstScreenDevice	ENDIF	IF GENERATING68K THEN		Macro		_DMGetNextScreenDevice			moveq	#1,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetNextScreenDevice	ENDIF	IF GENERATING68K THEN		Macro		_DMDrawDesktopRect			moveq	#2,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMDrawDesktopRect	ENDIF	IF GENERATING68K THEN		Macro		_DMDrawDesktopRegion			moveq	#3,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMDrawDesktopRegion	ENDIF	IF GENERATING68K THEN		Macro		_DMGetGDeviceTablecloth			move.w	#$0404,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetGDeviceTablecloth	ENDIF	IF GENERATING68K THEN		Macro		_DMSetGDeviceTablecloth			move.w	#$0405,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMSetGDeviceTablecloth	ENDIF	IF GENERATING68K THEN		Macro		_DMBeginConfigureDisplays			move.w	#$0206,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMBeginConfigureDisplays	ENDIF	IF GENERATING68K THEN		Macro		_DMEndConfigureDisplays			move.w	#$0207,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMEndConfigureDisplays	ENDIF	IF GENERATING68K THEN		Macro		_DMAddDisplay			move.w	#$0D08,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMAddDisplay	ENDIF	IF GENERATING68K THEN		Macro		_DMMoveDisplay			move.w	#$0609,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMMoveDisplay	ENDIF	IF GENERATING68K THEN		Macro		_DMDisableDisplay			move.w	#$040A,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMDisableDisplay	ENDIF	IF GENERATING68K THEN		Macro		_DMEnableDisplay			move.w	#$040B,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMEnableDisplay	ENDIF	IF GENERATING68K THEN		Macro		_DMRemoveDisplay			move.w	#$040C,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMRemoveDisplay	ENDIF; OBSOLETE ******************;pascal OSErr DMGetComponentAnimateTicks(DMTableclothUPP animationComponent,unsigned long *goodDelay,unsigned long *maxDelay);    = {0x303C,0x060D,0xABEB}		{ ; fix pascal headers;;pascal OSErr DMSetComponentAnimateTicks(DMTableclothUPP animationComponent,unsigned long goodDelay,unsigned long maxDelay);    = {0x303C,0x060E,0xABEB}		{ ; fix pascal headers;;pascal OSErr DMGetNextAnimateTime(unsigned long *nextAnimateTime);    = {0x303C,0x020F,0xABEB}		{ ; fix pascal headers;************************** 	IF GENERATING68K THEN		Macro		_DMSetMainDisplay			move.w	#$0410,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMSetMainDisplay	ENDIF	IF GENERATING68K THEN		Macro		_DMSetDisplayMode			move.w	#$0A11,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMSetDisplayMode	ENDIF	IF GENERATING68K THEN		Macro		_DMCheckDisplayMode			move.w	#$0C12,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMCheckDisplayMode	ENDIF	IF GENERATING68K THEN		Macro		_DMGetDeskRegion			move.w	#$0213,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetDeskRegion	ENDIF	IF GENERATING68K THEN		Macro		_DMRegisterNotifyProc			move.w	#$0414,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMRegisterNotifyProc	ENDIF	IF GENERATING68K THEN		Macro		_DMRemoveNotifyProc			move.w	#$0415,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMRemoveNotifyProc	ENDIF	IF GENERATING68K THEN		Macro		_DMQDIsMirroringCapable			move.w	#$0216,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMQDIsMirroringCapable	ENDIF	IF GENERATING68K THEN		Macro		_DMCanMirrorNow			move.w	#$0217,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMCanMirrorNow	ENDIF	IF GENERATING68K THEN		Macro		_DMIsMirroringOn			move.w	#$0218,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMIsMirroringOn	ENDIF	IF GENERATING68K THEN		Macro		_DMMirrorDevices			move.w	#$0619,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMMirrorDevices	ENDIF	IF GENERATING68K THEN		Macro		_DMUnmirrorDevice			move.w	#$041A,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMUnmirrorDevice	ENDIF	IF GENERATING68K THEN		Macro		_DMGetNextMirroredDevice			move.w	#$041B,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetNextMirroredDevice	ENDIF	IF GENERATING68K THEN		Macro		_DMBlockMirroring			moveq	#28,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMBlockMirroring	ENDIF	IF GENERATING68K THEN		Macro		_DMUnblockMirroring			moveq	#29,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMUnblockMirroring	ENDIF	IF GENERATING68K THEN		Macro		_DMGetDisplayMgrA5World			move.w	#$021E,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetDisplayMgrA5World	ENDIF	IF GENERATING68K THEN		Macro		_DMGetDisplayIDByGDevice			move.w	#$051F,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetDisplayIDByGDevice	ENDIF	IF GENERATING68K THEN		Macro		_DMGetGDeviceByDisplayID			move.w	#$0520,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetGDeviceByDisplayID	ENDIF	IF GENERATING68K THEN		Macro		_DMSetDisplayComponent			move.w	#$0421,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMSetDisplayComponent	ENDIF	IF GENERATING68K THEN		Macro		_DMGetDisplayComponent			move.w	#$0422,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetDisplayComponent	ENDIF	IF GENERATING68K THEN		Macro		_DMNewDisplay			move.w	#$0D23,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMNewDisplay	ENDIF	IF GENERATING68K THEN		Macro		_DMDisposeDisplay			move.w	#$0424,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMDisposeDisplay	ENDIF	IF GENERATING68K THEN		Macro		_DMResolveDisplayComponents			moveq	#37,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMResolveDisplayComponents	ENDIF	IF GENERATING68K THEN		Macro		_DMRegisterExtendedNotifyProc			move.w	#$07EF,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMRegisterExtendedNotifyProc	ENDIF	IF GENERATING68K THEN		Macro		_DMRemoveExtendedNotifyProc			move.w	#$0026,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMRemoveExtendedNotifyProc	ENDIF	IF GENERATING68K THEN		Macro		_DMNewPanelList			move.w	#$0027,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMNewPanelList	ENDIF	IF GENERATING68K THEN		Macro		_DMNewEngineList			move.w	#$0028,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMNewEngineList	ENDIF	IF GENERATING68K THEN		Macro		_DMNewDeviceList			move.w	#$0029,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMNewDeviceList	ENDIF	IF GENERATING68K THEN		Macro		_DMNewDevicePortList			move.w	#$002A,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMNewDevicePortList	ENDIF	IF GENERATING68K THEN		Macro		_DMGetIndexedItemFromList			move.w	#$002B,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetIndexedItemFromList	ENDIF	IF GENERATING68K THEN		Macro		_DMDisposeList			move.w	#$002C,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMDisposeList	ENDIF	IF GENERATING68K THEN		Macro		_DMGetNameByDisplayID			move.w	#$042D,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetNameByDisplayID	ENDIF	IF GENERATING68K THEN		Macro		_DMNewDisplayIDByPortComponent			move.w	#$082E,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMNewDisplayIDByPortComponent	ENDIF	IF GENERATING68K THEN		Macro		_DMGetPortComponentByPortID			move.w	#$082F,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetPortComponentByPortID	ENDIF	IF GENERATING68K THEN		Macro		_DMSendDependentNotification			move.w	#$002D,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMSendDependentNotification	ENDIF	IF GENERATING68K THEN		Macro		_DMDisposePortComponent			move.w	#$0231,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMDisposePortComponent	ENDIF;pascal OSErr DMGetPortIDByDeviceComponent(Component deviceComponent, DisplayIDType* displayID);    = {0x303C,0x0032,0xABEB};	IF GENERATING68K THEN		Macro		_DMGetDisplayIDByDeviceComponent			move.w	#$002E,d0			dc.w 	$ABEB		EndM	ELSE		IMPORT	DMGetDisplayIDByDeviceComponent	ENDIF;;	Required calls in components:;	;;	GeneralDeviceCalls;		Return information specific to all devices;;	OSErr		CountDevicePorts(unsigned long portCount, ResType deviceType);;	OSErr		GetPortInfo(unsigned long portNumber,PortInfoRec* portInfo);;					PortInfo gives information for multiported devices (such as Telecaster).;	OSErr		CountPortEngineComponents(unsigned long portNumber,unsigned long* engineCount);;	OSErr		GetPortEngineComponentInfo(unsigned long portNumber,unsigned long engineCount, DevicePortInfoRec* componentInfo);;;;	Video Engine Components;		Return information specific to video devices;;	OSErr		CheckTiming;					Give the device a chance to okay or modify device settings;					especially useful for overridding the "needsConfirm" bit.;	OSErr		GetVideoInfo;					It would be nice to be able to get direct info about screen size;					dot pitch etc.  This obviously needs to be fleshed out.;	OSErr		SetWiggleDevice(Boolean wiggleDevice);;	OSErr		GetWiggleDevice(Boolean* isWiggling);;					Returns an error if device is not capable of wiggling;;	Sound Engine Components;	;	OSErr		SetWiggleDevice(Boolean wiggleDevice);;	OSErr		GetWiggleDevice(Boolean* isWiggling);;					Returns an error if device is not capable of wiggling;;	HI Component Calls;	;	OSErr		TargetDevice(DisplayID displayID);;	We could also define a standard notify message and call that when we had an update issue (saving on components having to register for notifies);			That would by us not having to handle an extended remove notification that handles "you data" specific removes.;	ENDIF ; __DISPLAYS__