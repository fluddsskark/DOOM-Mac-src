;;	File:		MixedMode.a;;	Copyright:	© 1984-1994 by Apple Computer, Inc.;				All rights reserved.;;	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994. ;;	Bugs?:		If you find a problem with this file, send the file and version;				information (from above) and the problem description to:;;					Internet:	apple.bugs@applelink.apple.com;					AppleLink:	APPLE.BUGS;;	IF &TYPE('__MIXEDMODE__') = 'UNDEFINED' THEN__MIXEDMODE__ SET 1	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN	include 'Types.a'	ENDIF;		include 'ConditionalMacros.a'								;kRoutineDescriptorVersion		EQU		7; MixedModeMagic Magic Cookie/Trap number _MixedModeMagic					EQU		$AAFE; Calling Conventions kPascalStackBased				EQU		0kCStackBased					EQU		1kRegisterBased					EQU		2kD0DispatchedPascalStackBased	EQU		8kD1DispatchedPascalStackBased	EQU		12kD0DispatchedCStackBased		EQU		9kStackDispatchedPascalStackBased EQU		14kThinkCStackBased				EQU		5; ISA Types kM68kISA						EQU		0kPowerPCISA						EQU		1; RTA Types kOld68kRTA						EQU		(0 << 4)kPowerPCRTA						EQU		(0 << 4)kCFM68kRTA						EQU		(1 << 4)kRegisterD0						EQU		0kRegisterD1						EQU		1kRegisterD2						EQU		2kRegisterD3						EQU		3kRegisterD4						EQU		8kRegisterD5						EQU		9kRegisterD6						EQU		10kRegisterD7						EQU		11kRegisterA0						EQU		4kRegisterA1						EQU		5kRegisterA2						EQU		6kRegisterA3						EQU		7kRegisterA4						EQU		12kRegisterA5						EQU		13kRegisterA6						EQU		14; A7 is the same as the PowerPC SP kCCRegisterCBit					EQU		16kCCRegisterVBit					EQU		17kCCRegisterZBit					EQU		18kCCRegisterNBit					EQU		19kCCRegisterXBit					EQU		20; SizeCodes we use everywhere kNoByteCode						EQU		0kOneByteCode					EQU		1kTwoByteCode					EQU		2kFourByteCode					EQU		3; Mixed Mode Routine Records ; Routine Flag Bits kProcDescriptorIsAbsolute		EQU		$00kProcDescriptorIsRelative		EQU		$01kFragmentIsPrepared				EQU		$00kFragmentNeedsPreparing			EQU		$02kUseCurrentISA					EQU		$00kUseNativeISA					EQU		$04kPassSelector					EQU		$0kDontPassSelector				EQU		$08kRoutineIsNotDispatchedDefaultRoutine EQU		$0kRoutineIsDispatchedDefaultRoutine EQU		$10RoutineRecord 			RECORD	0procInfo				 ds.l	1									; calling conventions reserved1				 ds.b	1									; Must be 0 ISA						 ds.b	1									; Instruction Set Architecture routineFlags			 ds.w	1									; Flags for each routine procDescriptor			 ds.l	1									; Where is the thing weÕre calling? reserved2				 ds.l	1									; Must be 0 selector				 ds.l	1									; For dispatched routines, the selector sizeof					 EQU	20						ENDR; Mixed Mode Routine Descriptors ; Definitions of the Routine Descriptor Flag Bits kSelectorsAreNotIndexable		EQU		$00kSelectorsAreIndexable			EQU		$01; Routine Descriptor Structure RoutineDescriptor 		RECORD	0goMixedModeTrap			 ds.w	1									; Our A-Trap version					 ds.b	1									; Current Routine Descriptor version routineDescriptorFlags	 ds.b	1									; Routine Descriptor Flags reserved1				 ds.l	1									; Unused, must be zero reserved2				 ds.b	1									; Unused, must be zero selectorInfo			 ds.b	1									; If a dispatched routine, calling convention, else 0 routineCount			 ds.w	1									; Number of routines in this RD routineRecords			 ds		RoutineRecord						; The individual routines sizeof					 EQU	32						ENDR; Calling Convention Offsets kCallingConventionWidth			EQU		4kCallingConventionPhase			EQU		0kCallingConventionMask			EQU		$F; Result Offsets kResultSizeWidth				EQU		2kResultSizePhase				EQU		kCallingConventionWidthkResultSizeMask					EQU		$30; Parameter offsets & widths kStackParameterWidth			EQU		2kStackParameterPhase			EQU		(kCallingConventionWidth + kResultSizeWidth)kStackParameterMask				EQU		$FFFFFFC0; Register Result Location offsets & widths kRegisterResultLocationWidth	EQU		5kRegisterResultLocationPhase	EQU		(kCallingConventionWidth + kResultSizeWidth); Register Parameter offsets & widths kRegisterParameterWidth			EQU		5kRegisterParameterPhase			EQU		(kCallingConventionWidth + kResultSizeWidth + kRegisterResultLocationWidth)kRegisterParameterSizePhase		EQU		0kRegisterParameterSizeWidth		EQU		2kRegisterParameterWhichPhase	EQU		kRegisterParameterSizeWidthkRegisterParameterWhichWidth	EQU		3; Dispatched Stack Routine Selector offsets & widths kDispatchedSelectorSizeWidth	EQU		2kDispatchedSelectorSizePhase	EQU		(kCallingConventionWidth + kResultSizeWidth); Dispatched Stack Routine Parameter offsets kDispatchedParameterPhase		EQU		(kCallingConventionWidth + kResultSizeWidth + kDispatchedSelectorSizeWidth); Special Case offsets & widths kSpecialCaseSelectorWidth		EQU		6kSpecialCaseSelectorPhase		EQU		kCallingConventionWidthkSpecialCaseSelectorMask		EQU		$3F0; Component Manager Special Case offsets & widths kComponentMgrResultSizeWidth	EQU		2kComponentMgrResultSizePhase	EQU		kCallingConventionWidth + kSpecialCaseSelectorWidth ; 4 + 6 = 10 kComponentMgrParameterWidth		EQU		2kComponentMgrParameterPhase		EQU		kComponentMgrResultSizePhase + kComponentMgrResultSizeWidth ; 10 + 2 = 12 kSpecialCase					EQU		$0000000F; all of the special cases enumerated.  The selector field is 6 bits wide kSpecialCaseHighHook			EQU		0kSpecialCaseCaretHook			EQU		0					; same as kSpecialCaseHighHook kSpecialCaseEOLHook				EQU		1kSpecialCaseWidthHook			EQU		2kSpecialCaseTextWidthHook		EQU		2					; same as kSpecialCaseWidthHook kSpecialCaseNWidthHook			EQU		3kSpecialCaseDrawHook			EQU		4kSpecialCaseHitTestHook			EQU		5kSpecialCaseTEFindWord			EQU		6kSpecialCaseProtocolHandler		EQU		7kSpecialCaseSocketListener		EQU		8kSpecialCaseTERecalc			EQU		9kSpecialCaseTEDoText			EQU		10kSpecialCaseGNEFilterProc		EQU		11kSpecialCaseMBarHook			EQU		12kSpecialCaseComponentMgr		EQU		13	IF GENERATINGCFM  THEN	IF GENERATING68K THEN		Macro		_NewRoutineDescriptor			moveq	#0,d0			dc.w 	$AA59		EndM	ELSE		IMPORT	NewRoutineDescriptor	ENDIF	IF GENERATING68K THEN		Macro		_DisposeRoutineDescriptor			moveq	#1,d0			dc.w 	$AA59		EndM	ELSE		IMPORT	DisposeRoutineDescriptor	ENDIF	IF GENERATING68K THEN		Macro		_NewFatRoutineDescriptor			moveq	#2,d0			dc.w 	$AA59		EndM	ELSE		IMPORT	NewFatRoutineDescriptor	ENDIF	ELSE	ENDIF	IF CFMSYSTEMCALLS  THEN	ENDIF	ENDIF ; __MIXEDMODE__