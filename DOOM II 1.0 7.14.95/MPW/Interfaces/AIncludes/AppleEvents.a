;;	File:		AppleEvents.a;;	Copyright:	© 1984-1994 by Apple Computer, Inc.;				All rights reserved.;;	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994. ;;	Bugs?:		If you find a problem with this file, send the file and version;				information (from above) and the problem description to:;;					Internet:	apple.bugs@applelink.apple.com;					AppleLink:	APPLE.BUGS;;	IF &TYPE('__APPLEEVENTS__') = 'UNDEFINED' THEN__APPLEEVENTS__ SET 1	IF &TYPE('__ERRORS__') = 'UNDEFINED' THEN	include 'Errors.a'	ENDIF;		include 'ConditionalMacros.a'								;	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN	include 'Types.a'	ENDIF	IF &TYPE('__MEMORY__') = 'UNDEFINED' THEN	include 'Memory.a'	ENDIF;		include 'MixedMode.a'										;	IF &TYPE('__OSUTILS__') = 'UNDEFINED' THEN	include 'OSUtils.a'	ENDIF	IF &TYPE('__EVENTS__') = 'UNDEFINED' THEN	include 'Events.a'	ENDIF;		include 'Quickdraw.a'										;;			include 'QuickdrawText.a'								;	IF &TYPE('__EPPC__') = 'UNDEFINED' THEN	include 'EPPC.a'	ENDIF;		include 'PPCToolbox.a'										;;			include 'AppleTalk.a'									;;		include 'Processes.a'										;;			include 'Files.a'										;	IF &TYPE('__NOTIFICATION__') = 'UNDEFINED' THEN	include 'Notification.a'	ENDIF; Apple event descriptor types typeBoolean						EQU		'bool'typeChar						EQU		'TEXT'typeSMInt						EQU		'shor'typeInteger						EQU		'long'typeSMFloat						EQU		'sing'typeFloat						EQU		'doub'typeLongInteger					EQU		'long'typeShortInteger				EQU		'shor'typeLongFloat					EQU		'doub'typeShortFloat					EQU		'sing'typeExtended					EQU		'exte'typeComp						EQU		'comp'typeMagnitude					EQU		'magn'typeAEList						EQU		'list'typeAERecord					EQU		'reco'typeAppleEvent					EQU		'aevt'typeTrue						EQU		'true'typeFalse						EQU		'fals'typeAlias						EQU		'alis'typeEnumerated					EQU		'enum'typeType						EQU		'type'typeAppParameters				EQU		'appa'typeProperty					EQU		'prop'typeFSS							EQU		'fss 'typeKeyword						EQU		'keyw'typeSectionH					EQU		'sect'typeWildCard					EQU		'****'typeApplSignature				EQU		'sign'typeQDRectangle					EQU		'qdrt'typeFixed						EQU		'fixd'typeSessionID					EQU		'ssid'typeTargetID					EQU		'targ'typeProcessSerialNumber			EQU		'psn 'typeNull						EQU		'null'				; null or nonexistent data ; Keywords for Apple event parameters keyDirectObject					EQU		'----'keyErrorNumber					EQU		'errn'keyErrorString					EQU		'errs'keyProcessSerialNumber			EQU		'psn '; Keywords for Apple event attributes keyTransactionIDAttr			EQU		'tran'keyReturnIDAttr					EQU		'rtid'keyEventClassAttr				EQU		'evcl'keyEventIDAttr					EQU		'evid'keyAddressAttr					EQU		'addr'keyOptionalKeywordAttr			EQU		'optk'keyTimeoutAttr					EQU		'timo'keyInteractLevelAttr			EQU		'inte'				; this attribute is read only - will be set in AESend keyEventSourceAttr				EQU		'esrc'				; this attribute is read only keyMissedKeywordAttr			EQU		'miss'				; this attribute is read only keyOriginalAddressAttr			EQU		'from'				; new in 1.0.1 ; Keywords for special handlers keyPreDispatch					EQU		'phac'				; preHandler accessor call keySelectProc					EQU		'selh'				; more selector call ; Keyword for recording keyAERecorderCount				EQU		'recr'				; available only in vers 1.0.1 and greater ; Keyword for version information keyAEVersion					EQU		'vers'				; available only in vers 1.0.1 and greater ; Event Class kCoreEventClass					EQU		'aevt'; Event IDÕs kAEOpenApplication				EQU		'oapp'kAEOpenDocuments				EQU		'odoc'kAEPrintDocuments				EQU		'pdoc'kAEQuitApplication				EQU		'quit'kAEAnswer						EQU		'ansr'kAEApplicationDied				EQU		'obit'; Constants for use in AESend mode kAENoReply						EQU		$00000001			; sender doesn't want a reply to event kAEQueueReply					EQU		$00000002			; sender wants a reply but won't wait kAEWaitReply					EQU		$00000003			; sender wants a reply and will wait kAENeverInteract				EQU		$00000010			; server should not interact with user kAECanInteract					EQU		$00000020			; server may try to interact with user kAEAlwaysInteract				EQU		$00000030			; server should always interact with user where appropriate kAECanSwitchLayer				EQU		$00000040			; interaction may switch layer kAEDontReconnect				EQU		$00000080			; don't reconnect if there is a sessClosedErr from PPCToolbox kAEWantReceipt					EQU		nReturnReceipt		; sender wants a receipt of message kAEDontRecord					EQU		$00001000			; don't record this event - available only in vers 1.0.1 and greater kAEDontExecute					EQU		$00002000			; don't send the event for recording - available only in vers 1.0.1 and greater ; Constants for the send priority in AESend kAENormalPriority				EQU		$00000000			; post message at the end of the event queue kAEHighPriority					EQU		nAttnMsg			; post message at the front of the event queue ; Constants for recording kAEStartRecording				EQU		'reca'				; available only in vers 1.0.1 and greater kAEStopRecording				EQU		'recc'				; available only in vers 1.0.1 and greater kAENotifyStartRecording			EQU		'rec1'				; available only in vers 1.0.1 and greater kAENotifyStopRecording			EQU		'rec0'				; available only in vers 1.0.1 and greater kAENotifyRecording				EQU		'recr'; Constant for the returnID param of AECreateAppleEvent kAutoGenerateReturnID			EQU		-1					; AECreateAppleEvent will generate a session-unique ID ; Constant for transaction IDÕs kAnyTransactionID				EQU		0					; no transaction is in use ; Constants for timeout durations kAEDefaultTimeout				EQU		-1					; timeout value determined by AEM kNoTimeOut						EQU		-2					; wait until reply comes back, however long it takes ; Constants for AEResumeTheCurrentEvent kAENoDispatch					EQU		0					; dispatch parameter to AEResumeTheCurrentEvent takes a pointer to a dispatch kAEUseStandardDispatch			EQU		$FFFFFFFF			; table, or one of these two constants ; Constants for Refcon in AEResumeTheCurrentEvent with kAEUseStandardDispatch kAEDoNotIgnoreHandler			EQU		$00000000kAEIgnoreAppPhacHandler			EQU		$00000001			; available only in vers 1.0.1 and greater kAEIgnoreAppEventHandler		EQU		$00000002			; available only in vers 1.0.1 and greater kAEIgnoreSysPhacHandler			EQU		$00000004			; available only in vers 1.0.1 and greater kAEIgnoreSysEventHandler		EQU		$00000008			; available only in vers 1.0.1 and greater kAEIngoreBuiltInEventHandler	EQU		$00000010			; available only in vers 1.0.1 and greater kAEDontDisposeOnResume			EQU		$80000000			; available only in vers 1.0.1 and greater ; Apple event manager data types AEDesc 					RECORD	0descriptorType			 ds.l	1dataHandle				 ds.l	1sizeof					 EQU	8						ENDRAEKeyDesc 				RECORD	0descKey					 ds.l	1descContent				 ds		AEDescsizeof					 EQU	12						ENDR; an AEDesc which contains address data ; a list of AEDesc's is a special kind of AEDesc ; AERecord is a list of keyworded AEDesc's ; an AERecord that contains an AppleEvent ; parameter to AESend ; priority param of AESend kAEInteractWithSelf				EQU		0kAEInteractWithLocal			EQU		1kAEInteractWithAll				EQU		2kAEUnknownSource				EQU		0kAEDirectCall					EQU		1kAESameProcess					EQU		2kAELocalProcess					EQU		3kAERemoteProcess				EQU		4kAEDataArray					EQU		0kAEPackedArray					EQU		1kAEHandleArray					EQU		2kAEDescArray					EQU		3kAEKeyDescArray					EQU		4AEArrayData 			RECORD	0VariantLevel0Begin		EQU	*kAEDataArray			 ds.w	1						ORG		VariantLevel0BeginkAEPackedArray			 ds.b	1						ORG		VariantLevel0BeginkAEHandleArray			 ds.l	1						ORG		VariantLevel0BeginkAEDescArray			 ds		AEDesc						ORG		VariantLevel0BeginkAEKeyDescArray			 ds		AEKeyDescsizeof					 EQU	12						ENDR;*************************************************************************; The following calls apply to any AEDesc. Every 'result' descriptor is; created for you, so you will be responsible for memory management; (including disposing) of the descriptors so created. Note: purgeable; descriptor data is not supported - the AEM does not call LoadResource.  ;*************************************************************************	IF GENERATING68K THEN		Macro		_AECreateDesc			move.w	#$0825,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AECreateDesc	ENDIF	IF GENERATING68K THEN		Macro		_AECoercePtr			move.w	#$0A02,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AECoercePtr	ENDIF	IF GENERATING68K THEN		Macro		_AECoerceDesc			move.w	#$0603,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AECoerceDesc	ENDIF	IF GENERATING68K THEN		Macro		_AEDisposeDesc			move.w	#$0204,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEDisposeDesc	ENDIF	IF GENERATING68K THEN		Macro		_AEDuplicateDesc			move.w	#$0405,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEDuplicateDesc	ENDIF;*************************************************************************;  The following calls apply to AEDescList. Since AEDescList is a subtype of;  AEDesc, the calls in the previous section can also be used for AEDescList.;  All list and array indices are 1-based. If the data was greater than;  maximumSize in the routines below, then actualSize will be greater than;  maximumSize, but only maximumSize bytes will actually be retrieved.;*************************************************************************	IF GENERATING68K THEN		Macro		_AECreateList			move.w	#$0706,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AECreateList	ENDIF	IF GENERATING68K THEN		Macro		_AECountItems			move.w	#$0407,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AECountItems	ENDIF	IF GENERATING68K THEN		Macro		_AEPutPtr			move.w	#$0A08,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEPutPtr	ENDIF	IF GENERATING68K THEN		Macro		_AEPutDesc			move.w	#$0609,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEPutDesc	ENDIF	IF GENERATING68K THEN		Macro		_AEGetNthPtr			move.w	#$100A,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetNthPtr	ENDIF	IF GENERATING68K THEN		Macro		_AEGetNthDesc			move.w	#$0A0B,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetNthDesc	ENDIF	IF GENERATING68K THEN		Macro		_AESizeOfNthItem			move.w	#$082A,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AESizeOfNthItem	ENDIF	IF GENERATING68K THEN		Macro		_AEGetArray			move.w	#$0D0C,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetArray	ENDIF	IF GENERATING68K THEN		Macro		_AEPutArray			move.w	#$0B0D,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEPutArray	ENDIF	IF GENERATING68K THEN		Macro		_AEDeleteItem			move.w	#$040E,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEDeleteItem	ENDIF;*************************************************************************; The following calls apply to AERecord. Since AERecord is a subtype of; AEDescList, the calls in the previous sections can also be used for; AERecord an AERecord can be created by using AECreateList with isRecord; set to true. ;*************************************************************************	IF GENERATING68K THEN		Macro		_AEPutParamPtr			move.w	#$0A0F,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEPutParamPtr	ENDIF	IF GENERATING68K THEN		Macro		_AEPutParamDesc			move.w	#$0610,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEPutParamDesc	ENDIF	IF GENERATING68K THEN		Macro		_AEGetParamPtr			move.w	#$0E11,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetParamPtr	ENDIF	IF GENERATING68K THEN		Macro		_AEGetParamDesc			move.w	#$0812,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetParamDesc	ENDIF	IF GENERATING68K THEN		Macro		_AESizeOfParam			move.w	#$0829,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AESizeOfParam	ENDIF	IF GENERATING68K THEN		Macro		_AEDeleteParam			move.w	#$0413,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEDeleteParam	ENDIF;*************************************************************************; The following calls also apply to type AppleEvent. Message attributes are; far more restricted, and can only be accessed through the following 5; calls. The various list and record routines cannot be used to access the; attributes of an event. ;*************************************************************************	IF GENERATING68K THEN		Macro		_AEGetAttributePtr			move.w	#$0E15,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetAttributePtr	ENDIF	IF GENERATING68K THEN		Macro		_AEGetAttributeDesc			move.w	#$0826,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetAttributeDesc	ENDIF	IF GENERATING68K THEN		Macro		_AESizeOfAttribute			move.w	#$0828,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AESizeOfAttribute	ENDIF	IF GENERATING68K THEN		Macro		_AEPutAttributePtr			move.w	#$0A16,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEPutAttributePtr	ENDIF	IF GENERATING68K THEN		Macro		_AEPutAttributeDesc			move.w	#$0627,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEPutAttributeDesc	ENDIF;*************************************************************************;  The next couple of calls are basic routines used to create, send,;  and process AppleEvents. ;*************************************************************************	IF GENERATING68K THEN		Macro		_AECreateAppleEvent			move.w	#$0B14,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AECreateAppleEvent	ENDIF	IF GENERATING68K THEN		Macro		_AESend			move.w	#$0D17,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AESend	ENDIF	IF GENERATING68K THEN		Macro		_AEProcessAppleEvent			move.w	#$021B,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEProcessAppleEvent	ENDIF; ; Note: during event processing, an event handler may realize that it is likely; to exceed the client's timeout limit. Passing the reply to this; routine causes a wait event to be generated that asks the client; for more time. ;	IF GENERATING68K THEN		Macro		_AEResetTimer			move.w	#$0219,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEResetTimer	ENDIF;*************************************************************************; The following four calls are available for applications which need more; sophisticated control over when and how events are processed. Applications; which implement multi-session servers or which implement their own; internal event queueing will probably be the major clients of these; routines. They can be called from within a handler to prevent the AEM from; disposing of the AppleEvent when the handler returns. They can be used to; asynchronously process the event (as MacApp does).;*************************************************************************	IF GENERATING68K THEN		Macro		_AESuspendTheCurrentEvent			move.w	#$022B,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AESuspendTheCurrentEvent	ENDIF; ; Note: The following routine tells the AppleEvent manager that processing; is either about to resume or has been completed on a previously suspended; event. The procPtr passed in as the dispatcher parameter will be called to; attempt to redispatch the event. Several constants for the dispatcher; parameter allow special behavior. They are:;  	- kAEUseStandardDispatch means redispatch as if the event was just;	  received, using the standard AppleEvent dispatch mechanism.;  	- kAENoDispatch means ignore the parameter.;   	  Use this in the case where the event has been handled and no;	  redispatch is needed.;  	- non nil means call the routine which the dispatcher points to.;	IF GENERATING68K THEN		Macro		_AEResumeTheCurrentEvent			move.w	#$0818,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEResumeTheCurrentEvent	ENDIF	IF GENERATING68K THEN		Macro		_AEGetTheCurrentEvent			move.w	#$021A,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetTheCurrentEvent	ENDIF	IF GENERATING68K THEN		Macro		_AESetTheCurrentEvent			move.w	#$022C,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AESetTheCurrentEvent	ENDIF;*************************************************************************;  The following three calls are used to allow applications to behave;  courteously when a user interaction such as a dialog box is needed. ;*************************************************************************	IF GENERATING68K THEN		Macro		_AEGetInteractionAllowed			move.w	#$021D,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetInteractionAllowed	ENDIF	IF GENERATING68K THEN		Macro		_AESetInteractionAllowed			move.w	#$011E,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AESetInteractionAllowed	ENDIF	IF GENERATING68K THEN		Macro		_AEInteractWithUser			move.w	#$061C,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEInteractWithUser	ENDIF;*************************************************************************;  These calls are used to set up and modify the event dispatch table.;*************************************************************************	IF GENERATING68K THEN		Macro		_AEInstallEventHandler			move.w	#$091F,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEInstallEventHandler	ENDIF	IF GENERATING68K THEN		Macro		_AERemoveEventHandler			move.w	#$0720,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AERemoveEventHandler	ENDIF	IF GENERATING68K THEN		Macro		_AEGetEventHandler			move.w	#$0921,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetEventHandler	ENDIF;*************************************************************************;  These calls are used to set up and modify the coercion dispatch table.;*************************************************************************	IF GENERATING68K THEN		Macro		_AEInstallCoercionHandler			move.w	#$0A22,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEInstallCoercionHandler	ENDIF	IF GENERATING68K THEN		Macro		_AERemoveCoercionHandler			move.w	#$0723,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AERemoveCoercionHandler	ENDIF	IF GENERATING68K THEN		Macro		_AEGetCoercionHandler			move.w	#$0B24,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetCoercionHandler	ENDIF;*************************************************************************;  These calls are used to set up and modify special hooks into the;  AppleEvent manager.;*************************************************************************	IF GENERATING68K THEN		Macro		_AEInstallSpecialHandler			move.w	#$0500,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEInstallSpecialHandler	ENDIF	IF GENERATING68K THEN		Macro		_AERemoveSpecialHandler			move.w	#$0501,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AERemoveSpecialHandler	ENDIF	IF GENERATING68K THEN		Macro		_AEGetSpecialHandler			move.w	#$052D,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEGetSpecialHandler	ENDIF;*************************************************************************;  This call was added in version 1.0.1. If called with the keyword;  keyAERecorderCount ('recr'), the number of recorders that are;  currently active is returned in 'result'.;*************************************************************************; available only in vers 1.0.1 and greater 	IF GENERATING68K THEN		Macro		_AEManagerInfo			move.w	#$0441,d0			dc.w 	$A816		EndM	ELSE		IMPORT	AEManagerInfo	ENDIF	ENDIF ; __APPLEEVENTS__