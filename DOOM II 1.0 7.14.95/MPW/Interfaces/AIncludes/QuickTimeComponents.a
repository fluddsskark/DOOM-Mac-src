;;	File:		QuickTimeComponents.a;;	Copyright:	© 1984-1994 by Apple Computer, Inc.;				All rights reserved.;;	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994. ;;	Bugs?:		If you find a problem with this file, send the file and version;				information (from above) and the problem description to:;;					Internet:	apple.bugs@applelink.apple.com;					AppleLink:	APPLE.BUGS;;	IF &TYPE('__QUICKTIMECOMPONENTS__') = 'UNDEFINED' THEN__QUICKTIMECOMPONENTS__ SET 1	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN	include 'Components.a'	ENDIF;		include 'Types.a'											;;			include 'ConditionalMacros.a'							;;		include 'MixedMode.a'										;	IF &TYPE('__IMAGECOMPRESSION__') = 'UNDEFINED' THEN	include 'ImageCompression.a'	ENDIF;		include 'Quickdraw.a'										;;			include 'QuickdrawText.a'								;;		include 'QDOffscreen.a'									;;			include 'Errors.a'										;;		include 'Windows.a'										;;			include 'Memory.a'										;;			include 'Events.a'										;;				include 'OSUtils.a'								;;			include 'Controls.a'									;;				include 'Menus.a'									;;		include 'StandardFile.a'									;;			include 'Dialogs.a'									;;				include 'TextEdit.a'								;;			include 'Files.a'										;	IF &TYPE('__MOVIES__') = 'UNDEFINED' THEN	include 'Movies.a'	ENDIF;		include 'Aliases.a'										;;			include 'AppleTalk.a'									;	IF &TYPE('__VIDEO__') = 'UNDEFINED' THEN	include 'Video.a'	ENDIFclockComponentType				EQU		'clok'systemTickClock					EQU		'tick'				; subtype: 60ths since boot		systemSecondClock				EQU		'seco'				; subtype: seconds since 1904		systemMillisecondClock			EQU		'mill'				; subtype: 1000ths since boot		systemMicrosecondClock			EQU		'micr'kClockRateIsLinear				EQU		1kClockImplementsCallBacks		EQU		2;* These are Clock procedures *	IF GENERATING68K THEN		Macro		_ClockGetTime			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0001			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	ClockGetTime	ENDIF	IF GENERATING68K THEN		Macro		_ClockNewCallBack			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$0002			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	ClockNewCallBack	ENDIF	IF GENERATING68K THEN		Macro		_ClockDisposeCallBack			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0003			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	ClockDisposeCallBack	ENDIF	IF GENERATING68K THEN		Macro		_ClockCallMeWhen			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	ClockCallMeWhen	ENDIF	IF GENERATING68K THEN		Macro		_ClockCancelCallBack			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0005			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	ClockCancelCallBack	ENDIF	IF GENERATING68K THEN		Macro		_ClockRateChanged			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0006			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	ClockRateChanged	ENDIF	IF GENERATING68K THEN		Macro		_ClockTimeChanged			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0007			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	ClockTimeChanged	ENDIF	IF GENERATING68K THEN		Macro		_ClockSetTimeBase			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0008			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	ClockSetTimeBase	ENDIF	IF GENERATING68K THEN		Macro		_ClockStartStopChanged			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0009			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	ClockStartStopChanged	ENDIF	IF GENERATING68K THEN		Macro		_ClockGetRate			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	ClockGetRate	ENDIFkClockGetTimeSelect				EQU		$1kClockNewCallBackSelect			EQU		$2kClockDisposeCallBackSelect		EQU		$3kClockCallMeWhenSelect			EQU		$4kClockCancelCallBackSelect		EQU		$5kClockRateChangedSelect			EQU		$6kClockTimeChangedSelect			EQU		$7kClockSetTimeBaseSelect			EQU		$8kClockStartStopChangedSelect	EQU		$9kClockGetRateSelect				EQU		$A;;	General Sequence Grab stuff;SeqGrabComponentType			EQU		'barg'SeqGrabChannelType				EQU		'sgch'SeqGrabPanelType				EQU		'sgpn'SeqGrabCompressionPanelType		EQU		'comp'SeqGrabSourcePanelType			EQU		'sour'seqGrabToDisk					EQU		1seqGrabToMemory					EQU		2seqGrabDontUseTempMemory		EQU		4seqGrabAppendToFile				EQU		8seqGrabDontAddMovieResource		EQU		16seqGrabDontMakeMovie			EQU		32seqGrabPreExtendFile			EQU		64seqGrabDataProcIsInterruptSafe	EQU		128seqGrabDataProcDoesOverlappingReads EQU		256seqGrabRecord					EQU		1seqGrabPreview					EQU		2seqGrabPlayDuringRecord			EQU		4seqGrabHasBounds				EQU		1seqGrabHasVolume				EQU		2seqGrabHasDiscreteSamples		EQU		4SeqGrabFrameInfo 		RECORD	0frameOffset				 ds.l	1frameTime				 ds.l	1frameSize				 ds.l	1frameChannel			 ds.l	1frameRefCon				 ds.l	1sizeof					 EQU	20						ENDRgrabPictOffScreen				EQU		1grabPictIgnoreClip				EQU		2grabPictCurrentImage			EQU		4sgFlagControlledGrab			EQU		(1 << 0)SGDeviceName 			RECORD	0name					 ds.l	16icon					 ds.l	1flags					 ds.l	1refCon					 ds.l	1reserved				 ds.l	1									; zerosizeof					 EQU	80						ENDRsgDeviceNameFlagDeviceUnavailable EQU		(1 << 0)SGDeviceListRecord 		RECORD	0count					 ds.w	1selectedIndex			 ds.w	1reserved				 ds.l	1									; zeroentry					 ds		SGDeviceNamesizeof					 EQU	88						ENDRsgDeviceListWithIcons			EQU		(1 << 0)sgDeviceListDontCheckAvailability EQU		(1 << 1)seqGrabWriteAppend				EQU		0seqGrabWriteReserve				EQU		1seqGrabWriteFill				EQU		2seqGrabUnpause					EQU		0seqGrabPause					EQU		1seqGrabPauseForMenu				EQU		3channelFlagDontOpenResFile		EQU		2channelFlagHasDependency		EQU		4sgPanelFlagForPanel				EQU		1SGOutputRecord 			RECORD	0data					 ds.l	1sizeof					 EQU	4						ENDRchannelPlayNormal				EQU		0channelPlayFast					EQU		1channelPlayHighQuality			EQU		2channelPlayAllData				EQU		4	IF GENERATING68K THEN		Macro		_SGInitialize			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0001			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGInitialize	ENDIF	IF GENERATING68K THEN		Macro		_SGSetDataOutput			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0002			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetDataOutput	ENDIF	IF GENERATING68K THEN		Macro		_SGGetDataOutput			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0003			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetDataOutput	ENDIF	IF GENERATING68K THEN		Macro		_SGSetGWorld			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetGWorld	ENDIF	IF GENERATING68K THEN		Macro		_SGGetGWorld			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0005			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetGWorld	ENDIF	IF GENERATING68K THEN		Macro		_SGNewChannel			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0006			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGNewChannel	ENDIF	IF GENERATING68K THEN		Macro		_SGDisposeChannel			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0007			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGDisposeChannel	ENDIF	IF GENERATING68K THEN		Macro		_SGStartPreview			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0010			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGStartPreview	ENDIF	IF GENERATING68K THEN		Macro		_SGStartRecord			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0011			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGStartRecord	ENDIF	IF GENERATING68K THEN		Macro		_SGIdle			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0012			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGIdle	ENDIF	IF GENERATING68K THEN		Macro		_SGStop			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0013			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGStop	ENDIF	IF GENERATING68K THEN		Macro		_SGPause			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0014			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPause	ENDIF	IF GENERATING68K THEN		Macro		_SGPrepare			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0015			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPrepare	ENDIF	IF GENERATING68K THEN		Macro		_SGRelease			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0016			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGRelease	ENDIF	IF GENERATING68K THEN		Macro		_SGGetMovie			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0017			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetMovie	ENDIF	IF GENERATING68K THEN		Macro		_SGSetMaximumRecordTime			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0018			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetMaximumRecordTime	ENDIF	IF GENERATING68K THEN		Macro		_SGGetMaximumRecordTime			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0019			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetMaximumRecordTime	ENDIF	IF GENERATING68K THEN		Macro		_SGGetStorageSpaceRemaining			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetStorageSpaceRemaining	ENDIF	IF GENERATING68K THEN		Macro		_SGGetTimeRemaining			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetTimeRemaining	ENDIF	IF GENERATING68K THEN		Macro		_SGGrabPict			dc.w 	$2F3C			dc.w 	$000E			dc.w 	$001C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGrabPict	ENDIF	IF GENERATING68K THEN		Macro		_SGGetLastMovieResID			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetLastMovieResID	ENDIF	IF GENERATING68K THEN		Macro		_SGSetFlags			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetFlags	ENDIF	IF GENERATING68K THEN		Macro		_SGGetFlags			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetFlags	ENDIF	IF GENERATING68K THEN		Macro		_SGSetDataProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0020			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetDataProc	ENDIF	IF GENERATING68K THEN		Macro		_SGNewChannelFromComponent			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0021			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGNewChannelFromComponent	ENDIF	IF GENERATING68K THEN		Macro		_SGDisposeDeviceList			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0022			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGDisposeDeviceList	ENDIF	IF GENERATING68K THEN		Macro		_SGAppendDeviceListToMenu			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0023			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGAppendDeviceListToMenu	ENDIF	IF GENERATING68K THEN		Macro		_SGSetSettings			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0024			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetSettings	ENDIF	IF GENERATING68K THEN		Macro		_SGGetSettings			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0025			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetSettings	ENDIF	IF GENERATING68K THEN		Macro		_SGGetIndChannel			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$0026			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetIndChannel	ENDIF	IF GENERATING68K THEN		Macro		_SGUpdate			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0027			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGUpdate	ENDIF	IF GENERATING68K THEN		Macro		_SGGetPause			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0028			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetPause	ENDIF	IF GENERATING68K THEN		Macro		_SGSettingsDialog			dc.w 	$2F3C			dc.w 	$0016			dc.w 	$0029			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSettingsDialog	ENDIF	IF GENERATING68K THEN		Macro		_SGGetAlignmentProc			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$002A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetAlignmentProc	ENDIF	IF GENERATING68K THEN		Macro		_SGSetChannelSettings			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$002B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelSettings	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelSettings			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$002C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelSettings	ENDIF	IF GENERATING68K THEN		Macro		_SGGetMode			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$002D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetMode	ENDIF	IF GENERATING68K THEN		Macro		_SGSetDataRef			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$002E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetDataRef	ENDIF	IF GENERATING68K THEN		Macro		_SGGetDataRef			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$002F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetDataRef	ENDIF	IF GENERATING68K THEN		Macro		_SGNewOutput			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0030			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGNewOutput	ENDIF	IF GENERATING68K THEN		Macro		_SGDisposeOutput			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0031			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGDisposeOutput	ENDIF	IF GENERATING68K THEN		Macro		_SGSetOutputFlags			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0032			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetOutputFlags	ENDIF	IF GENERATING68K THEN		Macro		_SGSetChannelOutput			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0033			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelOutput	ENDIF	IF GENERATING68K THEN		Macro		_SGGetDataOutputStorageSpaceRemaining			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0034			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetDataOutputStorageSpaceRemaining	ENDIF;;	calls from Channel to seqGrab;	IF GENERATING68K THEN		Macro		_SGWriteMovieData			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0100			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGWriteMovieData	ENDIF	IF GENERATING68K THEN		Macro		_SGAddFrameReference			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0101			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGAddFrameReference	ENDIF	IF GENERATING68K THEN		Macro		_SGGetNextFrameReference			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0102			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetNextFrameReference	ENDIF	IF GENERATING68K THEN		Macro		_SGGetTimeBase			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0103			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetTimeBase	ENDIF	IF GENERATING68K THEN		Macro		_SGSortDeviceList			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0104			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSortDeviceList	ENDIF	IF GENERATING68K THEN		Macro		_SGAddMovieData			dc.w 	$2F3C			dc.w 	$001A			dc.w 	$0105			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGAddMovieData	ENDIF	IF GENERATING68K THEN		Macro		_SGChangedSource			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0106			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGChangedSource	ENDIF;** Sequence Grab CHANNEL Component Stuff **	IF GENERATING68K THEN		Macro		_SGSetChannelUsage			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0080			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelUsage	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelUsage			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0081			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelUsage	ENDIF	IF GENERATING68K THEN		Macro		_SGSetChannelBounds			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0082			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelBounds	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelBounds			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0083			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelBounds	ENDIF	IF GENERATING68K THEN		Macro		_SGSetChannelVolume			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0084			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelVolume	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelVolume			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0085			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelVolume	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelInfo			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0086			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelInfo	ENDIF	IF GENERATING68K THEN		Macro		_SGSetChannelPlayFlags			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0087			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelPlayFlags	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelPlayFlags			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0088			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelPlayFlags	ENDIF	IF GENERATING68K THEN		Macro		_SGSetChannelMaxFrames			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0089			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelMaxFrames	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelMaxFrames			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$008A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelMaxFrames	ENDIF	IF GENERATING68K THEN		Macro		_SGSetChannelRefCon			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$008B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelRefCon	ENDIF	IF GENERATING68K THEN		Macro		_SGSetChannelClip			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$008C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelClip	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelClip			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$008D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelClip	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelSampleDescription			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$008E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelSampleDescription	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelDeviceList			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$008F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelDeviceList	ENDIF	IF GENERATING68K THEN		Macro		_SGSetChannelDevice			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0090			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelDevice	ENDIF	IF GENERATING68K THEN		Macro		_SGSetChannelMatrix			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0091			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetChannelMatrix	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelMatrix			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0092			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelMatrix	ENDIF	IF GENERATING68K THEN		Macro		_SGGetChannelTimeScale			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0093			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetChannelTimeScale	ENDIF	IF GENERATING68K THEN		Macro		_SGChannelPutPicture			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0094			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGChannelPutPicture	ENDIF	IF GENERATING68K THEN		Macro		_SGChannelSetRequestedDataRate			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0095			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGChannelSetRequestedDataRate	ENDIF	IF GENERATING68K THEN		Macro		_SGChannelGetRequestedDataRate			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0096			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGChannelGetRequestedDataRate	ENDIF	IF GENERATING68K THEN		Macro		_SGChannelSetDataSourceName			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$0097			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGChannelSetDataSourceName	ENDIF	IF GENERATING68K THEN		Macro		_SGChannelGetDataSourceName			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0098			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGChannelGetDataSourceName	ENDIF;;	calls from seqGrab to Channel;	IF GENERATING68K THEN		Macro		_SGInitChannel			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0180			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGInitChannel	ENDIF	IF GENERATING68K THEN		Macro		_SGWriteSamples			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0181			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGWriteSamples	ENDIF	IF GENERATING68K THEN		Macro		_SGGetDataRate			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0182			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetDataRate	ENDIF	IF GENERATING68K THEN		Macro		_SGAlignChannelRect			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0183			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGAlignChannelRect	ENDIF;;	Dorky dialog panel calls;	IF GENERATING68K THEN		Macro		_SGPanelGetDitl			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0200			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelGetDitl	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelGetTitle			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0201			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelGetTitle	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelCanRun			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0202			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelCanRun	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelInstall			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$0203			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelInstall	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelEvent			dc.w 	$2F3C			dc.w 	$0016			dc.w 	$0204			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelEvent	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelItem			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0205			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelItem	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelRemove			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$0206			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelRemove	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelSetGrabber			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0207			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelSetGrabber	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelSetResFile			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0208			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelSetResFile	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelGetSettings			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0209			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelGetSettings	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelSetSettings			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$020A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelSetSettings	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelValidateInput			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$020B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelValidateInput	ENDIF	IF GENERATING68K THEN		Macro		_SGPanelSetEventFilter			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$020C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGPanelSetEventFilter	ENDIF;** Sequence Grab VIDEO CHANNEL Component Stuff **;;	Video stuff;SGCompressInfo 			RECORD	0buffer					 ds.l	1bufferSize				 ds.l	1similarity				 ds.b	1reserved				 ds.b	1sizeof					 EQU	10						ENDRVideoBottles 			RECORD	0procCount				 ds.w	1grabProc				 ds.l	1grabCompleteProc		 ds.l	1displayProc				 ds.l	1compressProc			 ds.l	1compressCompleteProc	 ds.l	1addFrameProc			 ds.l	1transferFrameProc		 ds.l	1grabCompressCompleteProc ds.l	1displayCompressProc		 ds.l	1sizeof					 EQU	38						ENDR	IF GENERATING68K THEN		Macro		_SGGetSrcVideoBounds			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0100			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetSrcVideoBounds	ENDIF	IF GENERATING68K THEN		Macro		_SGSetVideoRect			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0101			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetVideoRect	ENDIF	IF GENERATING68K THEN		Macro		_SGGetVideoRect			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0102			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetVideoRect	ENDIF	IF GENERATING68K THEN		Macro		_SGGetVideoCompressorType			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0103			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetVideoCompressorType	ENDIF	IF GENERATING68K THEN		Macro		_SGSetVideoCompressorType			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0104			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetVideoCompressorType	ENDIF	IF GENERATING68K THEN		Macro		_SGSetVideoCompressor			dc.w 	$2F3C			dc.w 	$0012			dc.w 	$0105			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetVideoCompressor	ENDIF	IF GENERATING68K THEN		Macro		_SGGetVideoCompressor			dc.w 	$2F3C			dc.w 	$0014			dc.w 	$0106			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetVideoCompressor	ENDIF	IF GENERATING68K THEN		Macro		_SGGetVideoDigitizerComponent			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0107			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetVideoDigitizerComponent	ENDIF	IF GENERATING68K THEN		Macro		_SGSetVideoDigitizerComponent			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0108			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetVideoDigitizerComponent	ENDIF	IF GENERATING68K THEN		Macro		_SGVideoDigitizerChanged			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0109			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGVideoDigitizerChanged	ENDIF	IF GENERATING68K THEN		Macro		_SGSetVideoBottlenecks			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$010A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetVideoBottlenecks	ENDIF	IF GENERATING68K THEN		Macro		_SGGetVideoBottlenecks			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$010B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetVideoBottlenecks	ENDIF	IF GENERATING68K THEN		Macro		_SGGrabFrame			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$010C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGrabFrame	ENDIF	IF GENERATING68K THEN		Macro		_SGGrabFrameComplete			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$010D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGrabFrameComplete	ENDIF	IF GENERATING68K THEN		Macro		_SGDisplayFrame			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$010E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGDisplayFrame	ENDIF	IF GENERATING68K THEN		Macro		_SGCompressFrame			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$010F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGCompressFrame	ENDIF	IF GENERATING68K THEN		Macro		_SGCompressFrameComplete			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$0110			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGCompressFrameComplete	ENDIF	IF GENERATING68K THEN		Macro		_SGAddFrame			dc.w 	$2F3C			dc.w 	$000E			dc.w 	$0111			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGAddFrame	ENDIF	IF GENERATING68K THEN		Macro		_SGTransferFrameForCompress			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$0112			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGTransferFrameForCompress	ENDIF	IF GENERATING68K THEN		Macro		_SGSetCompressBuffer			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$0113			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetCompressBuffer	ENDIF	IF GENERATING68K THEN		Macro		_SGGetCompressBuffer			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0114			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetCompressBuffer	ENDIF	IF GENERATING68K THEN		Macro		_SGGetBufferInfo			dc.w 	$2F3C			dc.w 	$0012			dc.w 	$0115			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetBufferInfo	ENDIF	IF GENERATING68K THEN		Macro		_SGSetUseScreenBuffer			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0116			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetUseScreenBuffer	ENDIF	IF GENERATING68K THEN		Macro		_SGGetUseScreenBuffer			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0117			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetUseScreenBuffer	ENDIF	IF GENERATING68K THEN		Macro		_SGGrabCompressComplete			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0118			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGrabCompressComplete	ENDIF	IF GENERATING68K THEN		Macro		_SGDisplayCompress			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0119			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGDisplayCompress	ENDIF	IF GENERATING68K THEN		Macro		_SGSetFrameRate			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$011A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetFrameRate	ENDIF	IF GENERATING68K THEN		Macro		_SGGetFrameRate			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$011B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetFrameRate	ENDIF;** Sequence Grab SOUND CHANNEL Component Stuff **;;	Sound stuff;	IF GENERATING68K THEN		Macro		_SGSetSoundInputDriver			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0100			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetSoundInputDriver	ENDIF	IF GENERATING68K THEN		Macro		_SGGetSoundInputDriver			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0101			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetSoundInputDriver	ENDIF	IF GENERATING68K THEN		Macro		_SGSoundInputDriverChanged			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0102			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSoundInputDriverChanged	ENDIF	IF GENERATING68K THEN		Macro		_SGSetSoundRecordChunkSize			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0103			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetSoundRecordChunkSize	ENDIF	IF GENERATING68K THEN		Macro		_SGGetSoundRecordChunkSize			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0104			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetSoundRecordChunkSize	ENDIF	IF GENERATING68K THEN		Macro		_SGSetSoundInputRate			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0105			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetSoundInputRate	ENDIF	IF GENERATING68K THEN		Macro		_SGGetSoundInputRate			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0106			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetSoundInputRate	ENDIF	IF GENERATING68K THEN		Macro		_SGSetSoundInputParameters			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0107			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGSetSoundInputParameters	ENDIF	IF GENERATING68K THEN		Macro		_SGGetSoundInputParameters			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0108			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SGGetSoundInputParameters	ENDIFsgChannelAtom					EQU		'chan'sgChannelSettingsAtom			EQU		'ctom'sgChannelDescription			EQU		'cdsc'sgChannelSettings				EQU		'cset'sgDeviceNameType				EQU		'name'sgUsageType						EQU		'use 'sgPlayFlagsType					EQU		'plyf'sgClipType						EQU		'clip'sgMatrixType					EQU		'mtrx'sgVolumeType					EQU		'volu'sgPanelSettingsAtom				EQU		'ptom'sgPanelDescription				EQU		'pdsc'sgPanelSettings					EQU		'pset'sgcSoundCompressionType			EQU		'scmp'sgcSoundSampleRateType			EQU		'srat'sgcSoundChannelCountType		EQU		'schn'sgcSoundSampleSizeType			EQU		'ssiz'sgcSoundInputType				EQU		'sinp'sgcSoundGainType				EQU		'gain'sgcVideoHueType					EQU		'hue 'sgcVideoSaturationType			EQU		'satr'sgcVideoContrastType			EQU		'trst'sgcVideoSharpnessType			EQU		'shrp'sgcVideoBrigtnessType			EQU		'brit'sgcVideoBlackLevelType			EQU		'blkl'sgcVideoWhiteLevelType			EQU		'whtl'sgcVideoInputType				EQU		'vinp'sgcVideoFormatType				EQU		'vstd'sgcVideoFilterType				EQU		'vflt'sgcVideoRectType				EQU		'vrct'sgVideoDigitizerType			EQU		'vdig'kSGInitializeSelect				EQU		$1kSGSetDataOutputSelect			EQU		$2kSGGetDataOutputSelect			EQU		$3kSGSetGWorldSelect				EQU		$4kSGGetGWorldSelect				EQU		$5kSGNewChannelSelect				EQU		$6kSGDisposeChannelSelect			EQU		$7kSGStartPreviewSelect			EQU		$10kSGStartRecordSelect			EQU		$11kSGIdleSelect					EQU		$12kSGStopSelect					EQU		$13kSGPauseSelect					EQU		$14kSGPrepareSelect				EQU		$15kSGReleaseSelect				EQU		$16kSGGetMovieSelect				EQU		$17kSGSetMaximumRecordTimeSelect	EQU		$18kSGGetMaximumRecordTimeSelect	EQU		$19kSGGetStorageSpaceRemainingSelect EQU		$1AkSGGetTimeRemainingSelect		EQU		$1BkSGGrabPictSelect				EQU		$1CkSGGetLastMovieResIDSelect		EQU		$1DkSGSetFlagsSelect				EQU		$1EkSGGetFlagsSelect				EQU		$1FkSGSetDataProcSelect			EQU		$20kSGNewChannelFromComponentSelect EQU		$21kSGDisposeDeviceListSelect		EQU		$22kSGAppendDeviceListToMenuSelect	EQU		$23kSGSetSettingsSelect			EQU		$24kSGGetSettingsSelect			EQU		$25kSGGetIndChannelSelect			EQU		$26kSGUpdateSelect					EQU		$27kSGGetPauseSelect				EQU		$28kSGSettingsDialogSelect			EQU		$29kSGGetAlignmentProcSelect		EQU		$2AkSGSetChannelSettingsSelect		EQU		$2BkSGGetChannelSettingsSelect		EQU		$2CkSGGetModeSelect				EQU		$2DkSGSetDataRefSelect				EQU		$2EkSGGetDataRefSelect				EQU		$2FkSGNewOutputSelect				EQU		$30kSGDisposeOutputSelect			EQU		$31kSGSetOutputFlagsSelect			EQU		$32kSGSetChannelOutputSelect		EQU		$33kSGGetDataOutputStorageSpaceRemainingSelect EQU		$34kSGWriteMovieDataSelect			EQU		$100kSGAddFrameReferenceSelect		EQU		$101kSGGetNextFrameReferenceSelect	EQU		$102kSGGetTimeBaseSelect			EQU		$103kSGSortDeviceListSelect			EQU		$104kSGAddMovieDataSelect			EQU		$105kSGChangedSourceSelect			EQU		$106kSGCSetChannelUsageSelect		EQU		$80kSGCGetChannelUsageSelect		EQU		$81kSGCSetChannelBoundsSelect		EQU		$82kSGCGetChannelBoundsSelect		EQU		$83kSGCSetChannelVolumeSelect		EQU		$84kSGCGetChannelVolumeSelect		EQU		$85kSGCGetChannelInfoSelect		EQU		$86kSGCSetChannelPlayFlagsSelect	EQU		$87kSGCGetChannelPlayFlagsSelect	EQU		$88kSGCSetChannelMaxFramesSelect	EQU		$89kSGCGetChannelMaxFramesSelect	EQU		$8AkSGCSetChannelRefConSelect		EQU		$8BkSGCSetChannelClipSelect		EQU		$8CkSGCGetChannelClipSelect		EQU		$8DkSGCGetChannelSampleDescriptionSelect EQU		$8EkSGCGetChannelDeviceListSelect	EQU		$8FkSGCSetChannelDeviceSelect		EQU		$90kSGCSetChannelMatrixSelect		EQU		$91kSGCGetChannelMatrixSelect		EQU		$92kSGCGetChannelTimeScaleSelect	EQU		$93kSGCChannelPutPictureSelect		EQU		$94kSGCChannelSetRequestedDataRateSelect EQU		$95kSGCChannelGetRequestedDataRateSelect EQU		$96kSGCChannelSetDataSourceNameSelect EQU		$97kSGCChannelGetDataSourceNameSelect EQU		$98kSGCInitChannelSelect			EQU		$180kSGCWriteSamplesSelect			EQU		$181kSGCGetDataRateSelect			EQU		$182kSGCAlignChannelRectSelect		EQU		$183kSGCPanelGetDitlSelect			EQU		$200kSGCPanelGetTitleSelect			EQU		$201kSGCPanelCanRunSelect			EQU		$202kSGCPanelInstallSelect			EQU		$203kSGCPanelEventSelect			EQU		$204kSGCPanelItemSelect				EQU		$205kSGCPanelRemoveSelect			EQU		$206kSGCPanelSetGrabberSelect		EQU		$207kSGCPanelSetResFileSelect		EQU		$208kSGCPanelGetSettingsSelect		EQU		$209kSGCPanelSetSettingsSelect		EQU		$20AkSGCPanelValidateInputSelect	EQU		$20BkSGCPanelSetEventFilterSelect	EQU		$20CkSGCGetSrcVideoBoundsSelect		EQU		$100kSGCSetVideoRectSelect			EQU		$101kSGCGetVideoRectSelect			EQU		$102kSGCGetVideoCompressorTypeSelect EQU		$103kSGCSetVideoCompressorTypeSelect EQU		$104kSGCSetVideoCompressorSelect	EQU		$105kSGCGetVideoCompressorSelect	EQU		$106kSGCGetVideoDigitizerComponentSelect EQU		$107kSGCSetVideoDigitizerComponentSelect EQU		$108kSGCVideoDigitizerChangedSelect	EQU		$109kSGCSetVideoBottlenecksSelect	EQU		$10AkSGCGetVideoBottlenecksSelect	EQU		$10BkSGCGrabFrameSelect				EQU		$10CkSGCGrabFrameCompleteSelect		EQU		$10DkSGCDisplayFrameSelect			EQU		$10EkSGCCompressFrameSelect			EQU		$10FkSGCCompressFrameCompleteSelect	EQU		$110kSGCAddFrameSelect				EQU		$111kSGCTransferFrameForCompressSelect EQU		$112kSGCSetCompressBufferSelect		EQU		$113kSGCGetCompressBufferSelect		EQU		$114kSGCGetBufferInfoSelect			EQU		$115kSGCSetUseScreenBufferSelect	EQU		$116kSGCGetUseScreenBufferSelect	EQU		$117kSGCGrabCompressCompleteSelect	EQU		$118kSGCDisplayCompressSelect		EQU		$119kSGCSetFrameRateSelect			EQU		$11AkSGCGetFrameRateSelect			EQU		$11BkSGCSetSoundInputDriverSelect	EQU		$100kSGCGetSoundInputDriverSelect	EQU		$101kSGCSoundInputDriverChangedSelect EQU		$102kSGCSetSoundRecordChunkSizeSelect EQU		$103kSGCGetSoundRecordChunkSizeSelect EQU		$104kSGCSetSoundInputRateSelect		EQU		$105kSGCGetSoundInputRateSelect		EQU		$106kSGCSetSoundInputParametersSelect EQU		$107kSGCGetSoundInputParametersSelect EQU		$108; Standard type for video digitizers videoDigitizerComponentType		EQU		'vdig'vdigInterfaceRev				EQU		2; Input Format Standards ntscIn							EQU		0					; current input format currentIn						EQU		0					; ntsc input format palIn							EQU		1					; pal input format secamIn							EQU		2					; secam input format ntscReallyIn					EQU		3					; ntsc input format ; Input Formats compositeIn						EQU		0					; input is composite format sVideoIn						EQU		1					; input is sVideo format rgbComponentIn					EQU		2					; input is rgb component format rgbComponentSyncIn				EQU		3					; input is rgb component format (sync on green?)yuvComponentIn					EQU		4					; input is yuv component format yuvComponentSyncIn				EQU		5					; input is yuv component format (sync on green?) ; Video Digitizer PlayThru States vdPlayThruOff					EQU		0vdPlayThruOn					EQU		1; Input Color Space Modes vdDigitizerBW					EQU		0					; black and white vdDigitizerRGB					EQU		1					; rgb color ; Phase Lock Loop Modes vdBroadcastMode					EQU		0					; Broadcast / Laser Disk video mode vdVTRMode						EQU		1					; VCR / Magnetic media mode ; Field Select Options vdUseAnyField					EQU		0					; Digitizers choice on field use vdUseOddField					EQU		1					; Use odd field for half size vert and smaller vdUseEvenField					EQU		2					; Use even field for half size vert and smaller ; vdig types vdTypeBasic						EQU		0					; basic, no clipping vdTypeAlpha						EQU		1					; supports clipping with alpha channel vdTypeMask						EQU		2					; supports clipping with mask plane vdTypeKey						EQU		3					; supports clipping with key color(s) ; Digitizer Input Capability/Current Flags	digiInDoesNTSC					EQU		1 << 0				; digitizer supports NTSC input format digiInDoesPAL					EQU		1 << 1				; digitizer supports PAL input format digiInDoesSECAM					EQU		1 << 2				; digitizer supports SECAM input format digiInDoesGenLock				EQU		1 << 7				; digitizer does genlock digiInDoesComposite				EQU		1 << 8				; digitizer supports composite input type digiInDoesSVideo				EQU		1 << 9				; digitizer supports S-Video input type digiInDoesComponent				EQU		1 << 10				; digitizer supports component = rgb, input type digiInVTR_Broadcast				EQU		1 << 11				; digitizer can differentiate between the two digiInDoesColor					EQU		1 << 12				; digitizer supports color digiInDoesBW					EQU		1 << 13				; digitizer supports black & white ; Digitizer Input Current Flags = these are valid only during active operating conditions,	digiInSignalLock				EQU		1 << 31				; digitizer detects input signal is locked, this bit = horiz lock || vertical lock ; Digitizer Output Capability/Current Flags digiOutDoes1					EQU		1 << 0				; digitizer supports 1 bit pixels digiOutDoes2					EQU		1 << 1				; digitizer supports 2 bit pixels digiOutDoes4					EQU		1 << 2				; digitizer supports 4 bit pixels digiOutDoes8					EQU		1 << 3				; digitizer supports 8 bit pixels digiOutDoes16					EQU		1 << 4				; digitizer supports 16 bit pixels digiOutDoes32					EQU		1 << 5				; digitizer supports 32 bit pixels digiOutDoesDither				EQU		1 << 6				; digitizer dithers in indexed modes digiOutDoesStretch				EQU		1 << 7				; digitizer can arbitrarily stretch digiOutDoesShrink				EQU		1 << 8				; digitizer can arbitrarily shrink digiOutDoesMask					EQU		1 << 9				; digitizer can mask to clipping regions digiOutDoesDouble				EQU		1 << 11				; digitizer can stretch to exactly double size digiOutDoesQuad					EQU		1 << 12				; digitizer can stretch exactly quadruple size digiOutDoesQuarter				EQU		1 << 13				; digitizer can shrink to exactly quarter size digiOutDoesSixteenth			EQU		1 << 14				; digitizer can shrink to exactly sixteenth size digiOutDoesRotate				EQU		1 << 15				; digitizer supports rotate transformations digiOutDoesHorizFlip			EQU		1 << 16				; digitizer supports horizontal flips Sx < 0 digiOutDoesVertFlip				EQU		1 << 17				; digitizer supports vertical flips Sy < 0 digiOutDoesSkew					EQU		1 << 18				; digitizer supports skew = shear,twist, digiOutDoesBlend				EQU		1 << 19digiOutDoesWarp					EQU		1 << 20digiOutDoesHW_DMA				EQU		1 << 21				; digitizer not constrained to local device digiOutDoesHWPlayThru			EQU		1 << 22				; digitizer doesn't need time to play thru digiOutDoesILUT					EQU		1 << 23				; digitizer does inverse LUT for index modes digiOutDoesKeyColor				EQU		1 << 24				; digitizer does key color functions too digiOutDoesAsyncGrabs			EQU		1 << 25				; digitizer supports async grabs digiOutDoesUnreadableScreenBits	EQU		1 << 26				; playthru doesn't generate readable bits on screendigiOutDoesCompress				EQU		1 << 27				; supports alternate output data types digiOutDoesCompressOnly			EQU		1 << 28				; can't provide raw frames anywhere digiOutDoesPlayThruDuringCompress EQU		1 << 29			; digi can do playthru while providing compressed data ; Types DigitizerInfo 			RECORD	0vdigType				 ds.w	1inputCapabilityFlags	 ds.l	1outputCapabilityFlags	 ds.l	1inputCurrentFlags		 ds.l	1outputCurrentFlags		 ds.l	1slot					 ds.w	1									; temporary for connection purposes gdh						 ds.l	1									; temporary for digitizers that have preferred screen maskgdh					 ds.l	1									; temporary for digitizers that have mask planes minDestHeight			 ds.w	1									; Smallest resizable height minDestWidth			 ds.w	1									; Smallest resizable width maxDestHeight			 ds.w	1									; Largest resizable height maxDestWidth			 ds.w	1									; Largest resizable height blendLevels				 ds.w	1									; Number of blend levels supported (2 if 1 bit mask) reserved				 ds.l	1									; reserved sizeof					 EQU	42						ENDRVdigType 				RECORD	0digType					 ds.l	1reserved				 ds.l	1sizeof					 EQU	8						ENDRVdigTypeList 			RECORD	0count					 ds.w	1list					 ds		VdigTypesizeof					 EQU	10						ENDRVdigBufferRec 			RECORD	0dest					 ds.l	1location				 ds		Pointreserved				 ds.l	1sizeof					 EQU	12						ENDRVdigBufferRecList 		RECORD	0count					 ds.w	1matrix					 ds.l	1mask					 ds.l	1list					 ds		VdigBufferRecsizeof					 EQU	22						ENDRVDCompressionList 		RECORD	0codec					 ds.l	1cType					 ds.l	1typeName				 ds.l	16name					 ds.l	16formatFlags				 ds.l	1compressFlags			 ds.l	1reserved				 ds.l	1sizeof					 EQU	148						ENDRdmaDepth1						EQU		1dmaDepth2						EQU		2dmaDepth4						EQU		4dmaDepth8						EQU		8dmaDepth16						EQU		16dmaDepth32						EQU		32dmaDepth2Gray					EQU		64dmaDepth4Gray					EQU		128dmaDepth8Gray					EQU		256kVDIGControlledFrameRate		EQU		-1; number of vdig callskvdigSelectors					EQU		86	IF GENERATING68K THEN		Macro		_VDGetMaxSrcRect			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$0001			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetMaxSrcRect	ENDIF	IF GENERATING68K THEN		Macro		_VDGetActiveSrcRect			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$0002			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetActiveSrcRect	ENDIF	IF GENERATING68K THEN		Macro		_VDSetDigitizerRect			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0003			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetDigitizerRect	ENDIF	IF GENERATING68K THEN		Macro		_VDGetDigitizerRect			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetDigitizerRect	ENDIF	IF GENERATING68K THEN		Macro		_VDGetVBlankRect			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$0005			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetVBlankRect	ENDIF	IF GENERATING68K THEN		Macro		_VDGetMaskPixMap			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0006			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetMaskPixMap	ENDIF	IF GENERATING68K THEN		Macro		_VDGetPlayThruDestination			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0008			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetPlayThruDestination	ENDIF	IF GENERATING68K THEN		Macro		_VDUseThisCLUT			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0009			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDUseThisCLUT	ENDIF	IF GENERATING68K THEN		Macro		_VDSetInputGammaValue			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$000A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetInputGammaValue	ENDIF	IF GENERATING68K THEN		Macro		_VDGetInputGammaValue			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$000B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetInputGammaValue	ENDIF	IF GENERATING68K THEN		Macro		_VDSetBrightness			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetBrightness	ENDIF	IF GENERATING68K THEN		Macro		_VDGetBrightness			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetBrightness	ENDIF	IF GENERATING68K THEN		Macro		_VDSetContrast			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetContrast	ENDIF	IF GENERATING68K THEN		Macro		_VDSetHue			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetHue	ENDIF	IF GENERATING68K THEN		Macro		_VDSetSharpness			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0010			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetSharpness	ENDIF	IF GENERATING68K THEN		Macro		_VDSetSaturation			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0011			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetSaturation	ENDIF	IF GENERATING68K THEN		Macro		_VDGetContrast			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0012			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetContrast	ENDIF	IF GENERATING68K THEN		Macro		_VDGetHue			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0013			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetHue	ENDIF	IF GENERATING68K THEN		Macro		_VDGetSharpness			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0014			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetSharpness	ENDIF	IF GENERATING68K THEN		Macro		_VDGetSaturation			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0015			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetSaturation	ENDIF	IF GENERATING68K THEN		Macro		_VDGrabOneFrame			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0016			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGrabOneFrame	ENDIF	IF GENERATING68K THEN		Macro		_VDGetMaxAuxBuffer			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0017			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetMaxAuxBuffer	ENDIF	IF GENERATING68K THEN		Macro		_VDGetDigitizerInfo			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0019			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetDigitizerInfo	ENDIF	IF GENERATING68K THEN		Macro		_VDGetCurrentFlags			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$001A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetCurrentFlags	ENDIF	IF GENERATING68K THEN		Macro		_VDSetKeyColor			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetKeyColor	ENDIF	IF GENERATING68K THEN		Macro		_VDGetKeyColor			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetKeyColor	ENDIF	IF GENERATING68K THEN		Macro		_VDAddKeyColor			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDAddKeyColor	ENDIF	IF GENERATING68K THEN		Macro		_VDGetNextKeyColor			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetNextKeyColor	ENDIF	IF GENERATING68K THEN		Macro		_VDSetKeyColorRange			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$001F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetKeyColorRange	ENDIF	IF GENERATING68K THEN		Macro		_VDGetKeyColorRange			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0020			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetKeyColorRange	ENDIF	IF GENERATING68K THEN		Macro		_VDSetDigitizerUserInterrupt			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0021			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetDigitizerUserInterrupt	ENDIF	IF GENERATING68K THEN		Macro		_VDSetInputColorSpaceMode			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0022			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetInputColorSpaceMode	ENDIF	IF GENERATING68K THEN		Macro		_VDGetInputColorSpaceMode			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0023			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetInputColorSpaceMode	ENDIF	IF GENERATING68K THEN		Macro		_VDSetClipState			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0024			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetClipState	ENDIF	IF GENERATING68K THEN		Macro		_VDGetClipState			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0025			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetClipState	ENDIF	IF GENERATING68K THEN		Macro		_VDSetClipRgn			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0026			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetClipRgn	ENDIF	IF GENERATING68K THEN		Macro		_VDClearClipRgn			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0027			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDClearClipRgn	ENDIF	IF GENERATING68K THEN		Macro		_VDGetCLUTInUse			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0028			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetCLUTInUse	ENDIF	IF GENERATING68K THEN		Macro		_VDSetPLLFilterType			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0029			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetPLLFilterType	ENDIF	IF GENERATING68K THEN		Macro		_VDGetPLLFilterType			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$002A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetPLLFilterType	ENDIF	IF GENERATING68K THEN		Macro		_VDGetMaskandValue			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$002B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetMaskandValue	ENDIF	IF GENERATING68K THEN		Macro		_VDSetMasterBlendLevel			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$002C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetMasterBlendLevel	ENDIF	IF GENERATING68K THEN		Macro		_VDSetPlayThruDestination			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$002D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetPlayThruDestination	ENDIF	IF GENERATING68K THEN		Macro		_VDSetPlayThruOnOff			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$002E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetPlayThruOnOff	ENDIF	IF GENERATING68K THEN		Macro		_VDSetFieldPreference			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$002F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetFieldPreference	ENDIF	IF GENERATING68K THEN		Macro		_VDGetFieldPreference			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0030			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetFieldPreference	ENDIF	IF GENERATING68K THEN		Macro		_VDPreflightDestination			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0032			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDPreflightDestination	ENDIF	IF GENERATING68K THEN		Macro		_VDPreflightGlobalRect			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0033			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDPreflightGlobalRect	ENDIF	IF GENERATING68K THEN		Macro		_VDSetPlayThruGlobalRect			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0034			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetPlayThruGlobalRect	ENDIF	IF GENERATING68K THEN		Macro		_VDSetInputGammaRecord			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0035			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetInputGammaRecord	ENDIF	IF GENERATING68K THEN		Macro		_VDGetInputGammaRecord			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0036			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetInputGammaRecord	ENDIF	IF GENERATING68K THEN		Macro		_VDSetBlackLevelValue			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0037			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetBlackLevelValue	ENDIF	IF GENERATING68K THEN		Macro		_VDGetBlackLevelValue			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0038			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetBlackLevelValue	ENDIF	IF GENERATING68K THEN		Macro		_VDSetWhiteLevelValue			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0039			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetWhiteLevelValue	ENDIF	IF GENERATING68K THEN		Macro		_VDGetWhiteLevelValue			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$003A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetWhiteLevelValue	ENDIF	IF GENERATING68K THEN		Macro		_VDGetVideoDefaults			dc.w 	$2F3C			dc.w 	$001C			dc.w 	$003B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetVideoDefaults	ENDIF	IF GENERATING68K THEN		Macro		_VDGetNumberOfInputs			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$003C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetNumberOfInputs	ENDIF	IF GENERATING68K THEN		Macro		_VDGetInputFormat			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$003D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetInputFormat	ENDIF	IF GENERATING68K THEN		Macro		_VDSetInput			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$003E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetInput	ENDIF	IF GENERATING68K THEN		Macro		_VDGetInput			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$003F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetInput	ENDIF	IF GENERATING68K THEN		Macro		_VDSetInputStandard			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0040			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetInputStandard	ENDIF	IF GENERATING68K THEN		Macro		_VDSetupBuffers			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0041			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetupBuffers	ENDIF	IF GENERATING68K THEN		Macro		_VDGrabOneFrameAsync			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0042			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGrabOneFrameAsync	ENDIF	IF GENERATING68K THEN		Macro		_VDDone			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0043			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDDone	ENDIF	IF GENERATING68K THEN		Macro		_VDSetCompression			dc.w 	$2F3C			dc.w 	$0016			dc.w 	$0044			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetCompression	ENDIF	IF GENERATING68K THEN		Macro		_VDCompressOneFrameAsync			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0045			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDCompressOneFrameAsync	ENDIF	IF GENERATING68K THEN		Macro		_VDCompressDone			dc.w 	$2F3C			dc.w 	$0014			dc.w 	$0046			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDCompressDone	ENDIF	IF GENERATING68K THEN		Macro		_VDReleaseCompressBuffer			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0047			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDReleaseCompressBuffer	ENDIF	IF GENERATING68K THEN		Macro		_VDGetImageDescription			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0048			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetImageDescription	ENDIF	IF GENERATING68K THEN		Macro		_VDResetCompressSequence			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0049			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDResetCompressSequence	ENDIF	IF GENERATING68K THEN		Macro		_VDSetCompressionOnOff			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$004A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetCompressionOnOff	ENDIF	IF GENERATING68K THEN		Macro		_VDGetCompressionTypes			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$004B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetCompressionTypes	ENDIF	IF GENERATING68K THEN		Macro		_VDSetTimeBase			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$004C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetTimeBase	ENDIF	IF GENERATING68K THEN		Macro		_VDSetFrameRate			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$004D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetFrameRate	ENDIF	IF GENERATING68K THEN		Macro		_VDGetDataRate			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$004E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetDataRate	ENDIF	IF GENERATING68K THEN		Macro		_VDGetSoundInputDriver			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$004F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetSoundInputDriver	ENDIF	IF GENERATING68K THEN		Macro		_VDGetDMADepths			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0050			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetDMADepths	ENDIF	IF GENERATING68K THEN		Macro		_VDGetPreferredTimeScale			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0051			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetPreferredTimeScale	ENDIF	IF GENERATING68K THEN		Macro		_VDReleaseAsyncBuffers			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0052			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDReleaseAsyncBuffers	ENDIF; 83 is reserved for compatibility reasons 	IF GENERATING68K THEN		Macro		_VDSetDataRate			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0054			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDSetDataRate	ENDIF	IF GENERATING68K THEN		Macro		_VDGetTimeCode			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0055			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDGetTimeCode	ENDIF	IF GENERATING68K THEN		Macro		_VDUseSafeBuffers			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0056			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	VDUseSafeBuffers	ENDIFkSelectVDGetMaxSrcRect			EQU		$1kSelectVDGetActiveSrcRect		EQU		$2kSelectVDSetDigitizerRect		EQU		$3kSelectVDGetDigitizerRect		EQU		$4kSelectVDGetVBlankRect			EQU		$5kSelectVDGetMaskPixMap			EQU		$6kSelectVDGetPlayThruDestination	EQU		$8kSelectVDUseThisCLUT			EQU		$9kSelectVDSetInputGammaValue		EQU		$AkSelectVDGetInputGammaValue		EQU		$BkSelectVDSetBrightness			EQU		$CkSelectVDGetBrightness			EQU		$DkSelectVDSetContrast			EQU		$EkSelectVDSetHue					EQU		$FkSelectVDSetSharpness			EQU		$10kSelectVDSetSaturation			EQU		$11kSelectVDGetContrast			EQU		$12kSelectVDGetHue					EQU		$13kSelectVDGetSharpness			EQU		$14kSelectVDGetSaturation			EQU		$15kSelectVDGrabOneFrame			EQU		$16kSelectVDGetMaxAuxBuffer		EQU		$17kSelectVDGetDigitizerInfo		EQU		$19kSelectVDGetCurrentFlags		EQU		$1AkSelectVDSetKeyColor			EQU		$1BkSelectVDGetKeyColor			EQU		$1CkSelectVDAddKeyColor			EQU		$1DkSelectVDGetNextKeyColor		EQU		$1EkSelectVDSetKeyColorRange		EQU		$1FkSelectVDGetKeyColorRange		EQU		$20kSelectVDSetDigitizerUserInterrupt EQU		$21kSelectVDSetInputColorSpaceMode	EQU		$22kSelectVDGetInputColorSpaceMode	EQU		$23kSelectVDSetClipState			EQU		$24kSelectVDGetClipState			EQU		$25kSelectVDSetClipRgn				EQU		$26kSelectVDClearClipRgn			EQU		$27kSelectVDGetCLUTInUse			EQU		$28kSelectVDSetPLLFilterType		EQU		$29kSelectVDGetPLLFilterType		EQU		$2AkSelectVDGetMaskandValue		EQU		$2BkSelectVDSetMasterBlendLevel	EQU		$2CkSelectVDSetPlayThruDestination	EQU		$2DkSelectVDSetPlayThruOnOff		EQU		$2EkSelectVDSetFieldPreference		EQU		$2FkSelectVDGetFieldPreference		EQU		$30kSelectVDPreflightDestination	EQU		$32kSelectVDPreflightGlobalRect	EQU		$33kSelectVDSetPlayThruGlobalRect	EQU		$34kSelectVDSetInputGammaRecord	EQU		$35kSelectVDGetInputGammaRecord	EQU		$36kSelectVDSetBlackLevelValue		EQU		$37kSelectVDGetBlackLevelValue		EQU		$38kSelectVDSetWhiteLevelValue		EQU		$39kSelectVDGetWhiteLevelValue		EQU		$3AkSelectVDGetVideoDefaults		EQU		$3BkSelectVDGetNumberOfInputs		EQU		$3CkSelectVDGetInputFormat			EQU		$3DkSelectVDSetInput				EQU		$3EkSelectVDGetInput				EQU		$3FkSelectVDSetInputStandard		EQU		$40kSelectVDSetupBuffers			EQU		$41kSelectVDGrabOneFrameAsync		EQU		$42kSelectVDDone					EQU		$43kSelectVDSetCompression			EQU		$44kSelectVDCompressOneFrameAsync	EQU		$45kSelectVDCompressDone			EQU		$46kSelectVDReleaseCompressBuffer	EQU		$47kSelectVDGetImageDescription	EQU		$48kSelectVDResetCompressSequence	EQU		$49kSelectVDSetCompressionOnOff	EQU		$4AkSelectVDGetCompressionTypes	EQU		$4BkSelectVDSetTimeBase			EQU		$4CkSelectVDSetFrameRate			EQU		$4DkSelectVDGetDataRate			EQU		$4EkSelectVDGetSoundInputDriver	EQU		$4FkSelectVDGetDMADepths			EQU		$50kSelectVDGetPreferredTimeScale	EQU		$51kSelectVDReleaseAsyncBuffers	EQU		$52kSelectVDSetDataRate			EQU		$54kSelectVDGetTimeCode			EQU		$55kSelectVDUseSafeBuffers			EQU		$56StandardCompressionType			EQU		'scdi'StandardCompressionSubType		EQU		'imag'scListEveryCodec				EQU		1 << 1scAllowZeroFrameRate			EQU		1 << 2scAllowZeroKeyFrameRate			EQU		1 << 3scShowBestDepth					EQU		1 << 4scUseMovableModal				EQU		1 << 5;	Possible test flags for setting test image.scPreferCropping				EQU		1 << 0scPreferScaling					EQU		1 << 1scPreferScalingAndCropping		EQU		scPreferScaling | scPreferCropping;	Dimensions of the image preview box.scTestImageWidth				EQU		80scTestImageHeight				EQU		80;	Possible items returned by hookProc.scOKItem						EQU		1scCancelItem					EQU		2scCustomItem					EQU		3;	Result returned when user cancelled.scUserCancelled					EQU		1SCSpatialSettings 		RECORD	0codecType				 ds.l	1codec					 ds.l	1depth					 ds.w	1spatialQuality			 ds.l	1sizeof					 EQU	14						ENDRSCTemporalSettings 		RECORD	0temporalQuality			 ds.l	1frameRate				 ds.l	1keyFrameRate			 ds.l	1sizeof					 EQU	12						ENDRSCDataRateSettings 		RECORD	0dataRate				 ds.l	1frameDuration			 ds.l	1minSpatialQuality		 ds.l	1minTemporalQuality		 ds.l	1sizeof					 EQU	16						ENDRSCExtendedProcs 		RECORD	0filterProc				 ds.l	1hookProc				 ds.l	1refcon					 ds.l	1customName				 ds.l	8sizeof					 EQU	44						ENDR;	Get/SetInfo selectorsscSpatialSettingsType			EQU		'sptl'				; pointer to SCSpatialSettings structscTemporalSettingsType			EQU		'tprl'				; pointer to SCTemporalSettings structscDataRateSettingsType			EQU		'drat'				; pointer to SCDataRateSettings structscColorTableType				EQU		'clut'				; pointer to CTabHandlescProgressProcType				EQU		'prog'				; pointer to ProgressRecord structscExtendedProcsType				EQU		'xprc'				; pointer to SCExtendedProcs structscPreferenceFlagsType			EQU		'pref'				; pointer to longscSettingsStateType				EQU		'ssta'				; pointer to HandlescSequenceIDType				EQU		'sequ'				; pointer to ImageSequencescWindowPositionType			EQU		'wndw'				; pointer to PointscCodecFlagsType				EQU		'cflg'				; pointer to CodecFlagsscCodecSettingsType				EQU		'cdec'				; pointer to HandlescForceKeyValueType				EQU		'ksim';	scTypeNotFoundErr returned by Get/SetInfo when type cannot be found.;* These are Progress procedures *	IF GENERATING68K THEN		Macro		_SCPositionRect			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0002			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCPositionRect	ENDIF	IF GENERATING68K THEN		Macro		_SCPositionDialog			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$0003			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCPositionDialog	ENDIF	IF GENERATING68K THEN		Macro		_SCSetTestImagePictHandle			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCSetTestImagePictHandle	ENDIF	IF GENERATING68K THEN		Macro		_SCSetTestImagePictFile			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0005			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCSetTestImagePictFile	ENDIF	IF GENERATING68K THEN		Macro		_SCSetTestImagePixMap			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$0006			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCSetTestImagePixMap	ENDIF	IF GENERATING68K THEN		Macro		_SCGetBestDeviceRect			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0007			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCGetBestDeviceRect	ENDIF	IF GENERATING68K THEN		Macro		_SCRequestImageSettings			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$000A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCRequestImageSettings	ENDIF	IF GENERATING68K THEN		Macro		_SCCompressImage			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$000B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCCompressImage	ENDIF	IF GENERATING68K THEN		Macro		_SCCompressPicture			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$000C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCCompressPicture	ENDIF	IF GENERATING68K THEN		Macro		_SCCompressPictureFile			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCCompressPictureFile	ENDIF	IF GENERATING68K THEN		Macro		_SCRequestSequenceSettings			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$000E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCRequestSequenceSettings	ENDIF	IF GENERATING68K THEN		Macro		_SCCompressSequenceBegin			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$000F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCCompressSequenceBegin	ENDIF	IF GENERATING68K THEN		Macro		_SCCompressSequenceFrame			dc.w 	$2F3C			dc.w 	$0014			dc.w 	$0010			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCCompressSequenceFrame	ENDIF	IF GENERATING68K THEN		Macro		_SCCompressSequenceEnd			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0011			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCCompressSequenceEnd	ENDIF	IF GENERATING68K THEN		Macro		_SCDefaultPictHandleSettings			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$0012			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCDefaultPictHandleSettings	ENDIF	IF GENERATING68K THEN		Macro		_SCDefaultPictFileSettings			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0013			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCDefaultPictFileSettings	ENDIF	IF GENERATING68K THEN		Macro		_SCDefaultPixMapSettings			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$0014			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCDefaultPixMapSettings	ENDIF	IF GENERATING68K THEN		Macro		_SCGetInfo			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0015			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCGetInfo	ENDIF	IF GENERATING68K THEN		Macro		_SCSetInfo			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0016			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCSetInfo	ENDIF	IF GENERATING68K THEN		Macro		_SCNewGWorld			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0017			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCNewGWorld	ENDIF	IF GENERATING68K THEN		Macro		_SCSetCompressFlags			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0018			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCSetCompressFlags	ENDIF	IF GENERATING68K THEN		Macro		_SCGetCompressFlags			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0019			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCGetCompressFlags	ENDIFSCParams 				RECORD	0flags					 ds.l	1theCodecType			 ds.l	1theCodec				 ds.l	1spatialQuality			 ds.l	1temporalQuality			 ds.l	1depth					 ds.w	1frameRate				 ds.l	1keyFrameRate			 ds.l	1reserved1				 ds.l	1reserved2				 ds.l	1sizeof					 EQU	38						ENDRscGetCompression				EQU		1scShowMotionSettings			EQU		1 << 0scSettingsChangedItem			EQU		-1scCompressFlagIgnoreIdenticalFrames EQU		1	IF GENERATING68K THEN		Macro		_SCGetCompressionExtended			dc.w 	$2F3C			dc.w 	$0018			dc.w 	$0001			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	SCGetCompressionExtended	ENDIFkSCPositionRectSelect			EQU		$2kSCPositionDialogSelect			EQU		$3kSCSetTestImagePictHandleSelect	EQU		$4kSCSetTestImagePictFileSelect	EQU		$5kSCSetTestImagePixMapSelect		EQU		$6kSCGetBestDeviceRectSelect		EQU		$7kSCRequestImageSettingsSelect	EQU		$AkSCCompressImageSelect			EQU		$BkSCCompressPictureSelect		EQU		$CkSCCompressPictureFileSelect	EQU		$DkSCRequestSequenceSettingsSelect EQU		$EkSCCompressSequenceBeginSelect	EQU		$FkSCCompressSequenceFrameSelect	EQU		$10kSCCompressSequenceEndSelect	EQU		$11kSCDefaultPictHandleSettingsSelect EQU		$12kSCDefaultPictFileSettingsSelect EQU		$13kSCDefaultPixMapSettingsSelect	EQU		$14kSCGetInfoSelect				EQU		$15kSCSetInfoSelect				EQU		$16kSCNewGWorldSelect				EQU		$17kSCSetCompressFlagsSelect		EQU		$18kSCGetCompressFlagsSelect		EQU		$19kSCGetCompressionExtendedSelect	EQU		$1MovieImportType					EQU		'eat 'MovieExportType					EQU		'spit'canMovieImportHandles			EQU		1 << 0canMovieImportFiles				EQU		1 << 1hasMovieImportUserInterface		EQU		1 << 2canMovieExportHandles			EQU		1 << 3canMovieExportFiles				EQU		1 << 4hasMovieExportUserInterface		EQU		1 << 5dontAutoFileMovieImport			EQU		1 << 6canMovieExportAuxDataHandle		EQU		1 << 7canMovieImportValidateHandles	EQU		1 << 8canMovieImportValidateFile		EQU		1 << 9dontRegisterWithEasyOpen		EQU		1 << 10canMovieImportInPlace			EQU		1 << 11movieImportSubTypeIsFileExtension EQU		1 << 12kMovieImportExportOpenSelect	EQU		kComponentOpenSelectkMovieImportExportCloseSelect	EQU		kComponentCloseSelectkMovieImportExportCanDoSelect	EQU		kComponentCanDoSelectkMovieImportExportVersionSelect	EQU		kComponentVersionSelectkMovieImportHandleSelect		EQU		1kMovieImportFileSelect			EQU		2kMovieImportSetSampleDurationSelect EQU		3kMovieImportSetSampleDescriptionSelect EQU		4kMovieImportSetMediaFileSelect	EQU		5kMovieImportSetDimensionsSelect	EQU		6kMovieImportSetChunkSizeSelect	EQU		7kMovieImportSetProgressProcSelect EQU		8kMovieImportSetAuxiliaryDataSelect EQU		9kMovieImportSetFromScrapSelect	EQU		10kMovieImportDoUserDialogSelect	EQU		11kMovieImportSetDurationSelect	EQU		12kMovieImportGetAuxiliaryDataTypeSelect EQU		13kMovieImportValidateSelect		EQU		14kMovieImportGetFileTypeSelect	EQU		15kMovieExportToHandleSelect		EQU		128kMovieExportToFileSelect		EQU		129kMovieExportDoUserDialogSelectOBSOLETE EQU		130kMovieExportGetAuxiliaryDataSelect EQU		131kMovieExportSetProgressProcSelect EQU		132kMovieExportSetSampleDescriptionSelect EQU		133kMovieExportDoUserDialogSelect	EQU		134kMovieExportGetCreatorTypeSelect EQU		135movieImportCreateTrack			EQU		1movieImportInParallel			EQU		2movieImportMustUseTrack			EQU		4movieImportResultUsedMultipleTracks EQU		8	IF GENERATING68K THEN		Macro		_MovieImportHandle			dc.w 	$2F3C			dc.w 	$0020			dc.w 	$0001			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportHandle	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportFile			dc.w 	$2F3C			dc.w 	$0020			dc.w 	$0002			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportFile	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportSetSampleDuration			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0003			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportSetSampleDuration	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportSetSampleDescription			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportSetSampleDescription	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportSetMediaFile			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0005			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportSetMediaFile	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportSetDimensions			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0006			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportSetDimensions	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportSetChunkSize			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0007			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportSetChunkSize	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportSetProgressProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0008			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportSetProgressProc	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportSetAuxiliaryData			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0009			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportSetAuxiliaryData	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportSetFromScrap			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$000A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportSetFromScrap	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportDoUserDialog			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$000B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportDoUserDialog	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportSetDuration			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportSetDuration	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportGetAuxiliaryDataType			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportGetAuxiliaryDataType	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportValidate			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$000E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportValidate	ENDIF	IF GENERATING68K THEN		Macro		_MovieImportGetFileType			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieImportGetFileType	ENDIF	IF GENERATING68K THEN		Macro		_MovieExportToHandle			dc.w 	$2F3C			dc.w 	$0014			dc.w 	$0080			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieExportToHandle	ENDIF	IF GENERATING68K THEN		Macro		_MovieExportToFile			dc.w 	$2F3C			dc.w 	$0014			dc.w 	$0081			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieExportToFile	ENDIF	IF GENERATING68K THEN		Macro		_MovieExportGetAuxiliaryData			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0083			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieExportGetAuxiliaryData	ENDIF	IF GENERATING68K THEN		Macro		_MovieExportSetProgressProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0084			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieExportSetProgressProc	ENDIF	IF GENERATING68K THEN		Macro		_MovieExportSetSampleDescription			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0085			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieExportSetSampleDescription	ENDIF	IF GENERATING68K THEN		Macro		_MovieExportDoUserDialog			dc.w 	$2F3C			dc.w 	$0014			dc.w 	$0086			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieExportDoUserDialog	ENDIF	IF GENERATING68K THEN		Macro		_MovieExportGetCreatorType			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0087			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MovieExportGetCreatorType	ENDIF	 IF Â GENERATINGPOWERPC THEN ; Text Export Display Info data structureTextDisplayData 		RECORD	0displayFlags			 ds.l	1textJustification		 ds.l	1bgColor					 ds		RGBColortextBox					 ds		RectbeginHilite				 ds.w	1endHilite				 ds.w	1hiliteColor				 ds		RGBColordoHiliteColor			 ds.b	1filler					 ds.b	1scrollDelayDur			 ds.l	1dropShadowOffset		 ds		PointdropShadowTransparency	 ds.w	1sizeof					 EQU	44						ENDR	ENDIF	IF GENERATING68K THEN		Macro		_TextExportGetDisplayData			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0100			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TextExportGetDisplayData	ENDIF;**************;;	File Preview Components;;**************pnotComponentWantsEvents		EQU		1pnotComponentNeedsNoCache		EQU		2kPreviewOpenSelector			EQU		0kPreviewCloseSelector			EQU		-1kPreviewCanDoSelector			EQU		-2kPreviewVersionSelector			EQU		-3kPreviewShowDataSelector		EQU		1kPreviewMakePreviewSelector		EQU		2kPreviewMakePreviewReferenceSelector EQU		3kPreviewEventSelector			EQU		4ShowFilePreviewComponentType	EQU		'pnot'CreateFilePreviewComponentType	EQU		'pmak'	IF GENERATING68K THEN		Macro		_PreviewShowData			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0001			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	PreviewShowData	ENDIF	IF GENERATING68K THEN		Macro		_PreviewMakePreview			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0002			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	PreviewMakePreview	ENDIF	IF GENERATING68K THEN		Macro		_PreviewMakePreviewReference			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0003			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	PreviewMakePreviewReference	ENDIF	IF GENERATING68K THEN		Macro		_PreviewEvent			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	PreviewEvent	ENDIFkDataHCanRead					EQU		1 << 0kDataHSpecialRead				EQU		1 << 1kDataHSpecialReadFile			EQU		1 << 2kDataHCanWrite					EQU		1 << 3kDataHSpecialWrite				EQU		1 << 4kDataHSpecialWriteFile			EQU		1 << 5kDataHCanStreamingWrite			EQU		1 << 6kDataHMustCheckDataRef			EQU		1 << 7DataHVolumeListRecord 	RECORD	0vRefNum					 ds.w	1flags					 ds.l	1sizeof					 EQU	6						ENDRkDataHExtendedSchedule			EQU		'xtnd'DataHScheduleRecord 	RECORD	0timeNeededBy			 ds		TimeRecordextendedID				 ds.l	1									; always is kDataHExtendedScheduleextendedVers			 ds.l	1									; always set to 0priority				 ds.l	1									; 100.0 or more means must have. lower numbersÉsizeof					 EQU	28						ENDR	IF GENERATING68K THEN		Macro		_DataHGetData			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0002			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHGetData	ENDIF	IF GENERATING68K THEN		Macro		_DataHPutData			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0003			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHPutData	ENDIF	IF GENERATING68K THEN		Macro		_DataHFlushData			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHFlushData	ENDIF	IF GENERATING68K THEN		Macro		_DataHOpenForWrite			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0005			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHOpenForWrite	ENDIF	IF GENERATING68K THEN		Macro		_DataHCloseForWrite			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0006			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHCloseForWrite	ENDIF	IF GENERATING68K THEN		Macro		_DataHOpenForRead			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0008			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHOpenForRead	ENDIF	IF GENERATING68K THEN		Macro		_DataHCloseForRead			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0009			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHCloseForRead	ENDIF	IF GENERATING68K THEN		Macro		_DataHSetDataRef			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHSetDataRef	ENDIF	IF GENERATING68K THEN		Macro		_DataHGetDataRef			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHGetDataRef	ENDIF	IF GENERATING68K THEN		Macro		_DataHCompareDataRef			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$000C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHCompareDataRef	ENDIF	IF GENERATING68K THEN		Macro		_DataHTask			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$000D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHTask	ENDIF	IF GENERATING68K THEN		Macro		_DataHScheduleData			dc.w 	$2F3C			dc.w 	$0018			dc.w 	$000E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHScheduleData	ENDIF	IF GENERATING68K THEN		Macro		_DataHFinishData			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$000F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHFinishData	ENDIF	IF GENERATING68K THEN		Macro		_DataHFlushCache			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0010			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHFlushCache	ENDIF	IF GENERATING68K THEN		Macro		_DataHResolveDataRef			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$0011			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHResolveDataRef	ENDIF	IF GENERATING68K THEN		Macro		_DataHGetFileSize			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0012			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHGetFileSize	ENDIF	IF GENERATING68K THEN		Macro		_DataHCanUseDataRef			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0013			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHCanUseDataRef	ENDIF	IF GENERATING68K THEN		Macro		_DataHGetVolumeList			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0014			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHGetVolumeList	ENDIF	IF GENERATING68K THEN		Macro		_DataHWrite			dc.w 	$2F3C			dc.w 	$0014			dc.w 	$0015			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHWrite	ENDIF	IF GENERATING68K THEN		Macro		_DataHPreextend			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0016			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHPreextend	ENDIF	IF GENERATING68K THEN		Macro		_DataHSetFileSize			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0017			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHSetFileSize	ENDIF	IF GENERATING68K THEN		Macro		_DataHGetFreeSpace			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0018			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHGetFreeSpace	ENDIF	IF GENERATING68K THEN		Macro		_DataHCreateFile			dc.w 	$2F3C			dc.w 	$0006			dc.w 	$0019			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHCreateFile	ENDIF	IF GENERATING68K THEN		Macro		_DataHGetPreferredBlockSize			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHGetPreferredBlockSize	ENDIF	IF GENERATING68K THEN		Macro		_DataHGetDeviceIndex			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHGetDeviceIndex	ENDIF	IF GENERATING68K THEN		Macro		_DataHIsStreamingDataHandler			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHIsStreamingDataHandler	ENDIF	IF GENERATING68K THEN		Macro		_DataHGetDataInBuffer			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$001D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHGetDataInBuffer	ENDIF	IF GENERATING68K THEN		Macro		_DataHGetScheduleAheadTime			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHGetScheduleAheadTime	ENDIF	IF GENERATING68K THEN		Macro		_DataHSetCacheSizeLimit			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$001F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHSetCacheSizeLimit	ENDIF	IF GENERATING68K THEN		Macro		_DataHGetCacheSizeLimit			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0020			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHGetCacheSizeLimit	ENDIF	IF GENERATING68K THEN		Macro		_DataHPlaybackHints			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0103			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	DataHPlaybackHints	ENDIFkDataHGetDataSelect				EQU		$2kDataHPutDataSelect				EQU		$3kDataHFlushDataSelect			EQU		$4kDataHOpenForWriteSelect		EQU		$5kDataHCloseForWriteSelect		EQU		$6kDataHOpenForReadSelect			EQU		$8kDataHCloseForReadSelect		EQU		$9kDataHSetDataRefSelect			EQU		$AkDataHGetDataRefSelect			EQU		$BkDataHCompareDataRefSelect		EQU		$CkDataHTaskSelect				EQU		$DkDataHScheduleDataSelect		EQU		$EkDataHFinishDataSelect			EQU		$FkDataHFlushCacheSelect			EQU		$10kDataHResolveDataRefSelect		EQU		$11kDataHGetFileSizeSelect			EQU		$12kDataHCanUseDataRefSelect		EQU		$13kDataHGetVolumeListSelect		EQU		$14kDataHWriteSelect				EQU		$15kDataHPreextendSelect			EQU		$16kDataHSetFileSizeSelect			EQU		$17kDataHGetFreeSpaceSelect		EQU		$18kDataHCreateFileSelect			EQU		$19kDataHGetPreferredBlockSizeSelect EQU		$1AkDataHGetDeviceIndexSelect		EQU		$1BkDataHIsStreamingDataHandlerSelect EQU		$1CkDataHGetDataInBufferSelect		EQU		$1DkDataHGetScheduleAheadTimeSelect EQU		$1EkDataHSetCacheSizeLimitSelect	EQU		$1FkDataHGetCacheSizeLimitSelect	EQU		$20kDataHPlaybackHintsSelect		EQU		$103kMusicComponentType				EQU		'musi'; MusicSynthesizerFlagskSynthesizerDynamicVoice		EQU		1					; can reassign voices/channels (else, hogs all channels in mask kSynthesizerUsesMIDIPort		EQU		2					; must be patched through MIDI Manager kSynthesizerMicrotone			EQU		4					; can play microtonal scales kSynthesizerLimitedMicrotone	EQU		8					; can play microtones, but only on 1-voice parts kSynthesizerMixedDrums			EQU		16					; any part can play drum parts, total = instrument parts kSynthesizerSoftware			EQU		32					; implemented in main CPU software == uses cpu cycles kSynthesizerGMSuperset			EQU		8192kSynthesizerGM					EQU		16384				; synth is a GM device ;; * Note that these controller numbers; * are _not_ identical to the MIDI controller numbers.; * These are _signed_ 8.8 values, and the LSB's are; * always sent to a MIDI device. Controllers 32-63 are; * reserved (for MIDI, they are LSB's for 0-31, but we; * always send both).; *; * The full range, therefore, is -128.00 to 127.7f.; *; * _Excepting_ _volume_, all controls default to zero.; *; * Pitch bend is specified in fractional semitones! No; * more "pitch bend range" nonsense. You can bend as far; * as you want, any time you want.; kControllerModulationWheel		EQU		1kControllerBreath				EQU		2kControllerFoot					EQU		4kControllerPortamentoTime		EQU		5kControllerVolume				EQU		7kControllerBalance				EQU		8kControllerPan					EQU		10					; 0 - "default", 1 - n: positioned in output 1-n (incl fractions) kControllerExpression			EQU		11kControllerPitchBend			EQU		32					; positive & negative semitones, with 7 bits fraction kControllerAfterTouch			EQU		33kControllerSustain				EQU		64					; boolean - positive for on, 0 or negative off kControllerPortamento			EQU		65					; boolean kControllerSostenuto			EQU		66					; boolean kControllerSoftPedal			EQU		67					; boolean kControllerReverb				EQU		91kControllerTremolo				EQU		92kControllerChorus				EQU		93kControllerCeleste				EQU		94kControllerPhaser				EQU		95kControllerMaximum				EQU		$7FFF				; +01111111.11111111 kControllerMinimum				EQU		$8000				; -10000000.00000000 SynthesizerDescription 	RECORD	0synthesizerType			 ds.l	1									; synthesizer type (must be same as component subtype) name					 ds.l	8									; text name of synthesizer type flags					 ds.l	1									; from the above enum voiceCount				 ds.l	1									; maximum polyphony partCount				 ds.l	1									; maximum multi-timbrality (and midi channels) instrumentCount			 ds.l	1									; non gm, built in (rom) instruments only modifiableInstrumentCount ds.l	1									; plus n-more are user modifiable channelMask				 ds.l	1									; (midi device only) which channels device always uses drumPartCount			 ds.l	1									; maximum multi-timbrality of drum parts drumCount				 ds.l	1									; non gm, built in (rom) drumkits only modifiableDrumCount		 ds.l	1									; plus n-more are user modifiable drumChannelMask			 ds.l	1									; (midi device only) which channels device always uses outputCount				 ds.l	1									; number of audio outputs (usually two) latency					 ds.l	1									; response time in µSec controllers				 ds.l	4									; array of 128 bits gmInstruments			 ds.l	4									; array of 128 bits gmDrums					 ds.l	4									; array of 128 bits sizeof					 EQU	132						ENDRkVoiceCountDynamic				EQU		-1					; constant to use to specify dynamic voicing ToneDescription 		RECORD	0synthesizerType			 ds.l	1									; synthesizer type synthesizerName			 ds.l	8									; name of instantiation of synth instrumentName			 ds.l	8									; preferred name for human use instrumentNumber		 ds.l	1									; inst-number used if synth-name matches gmNumber				 ds.l	1									; Best matching general MIDI number sizeof					 EQU	76						ENDRkFirstDrumkit					EQU		16384				; (first value is "no drum". instrument numbers from 16384->16384+128 are drumkits, and for GM they are _defined_ drumkits! kLastDrumkit					EQU		(kFirstDrumkit + 128); InstrumentMatchkInstrumentMatchSynthesizerType	EQU		1kInstrumentMatchSynthesizerName	EQU		2kInstrumentMatchName			EQU		4kInstrumentMatchNumber			EQU		8kInstrumentMatchGMNumber		EQU		16; KnobFlagskKnobRealtime					EQU		1					; Knob can be changed interactively as part of a sequence (ie knob can be changed at interrupt time) kKnobNextNote					EQU		2					; Knob only takes effect on the next note played kKnobAction						EQU		4					; setting the knob does something immediate kKnobNotInstrument				EQU		8					; indicates that the knob isn't in the instrument handle kKnobAffectsOthers				EQU		16					; other knobs will change value from this one kKnobMinorGroupStart			EQU		64					; knob is first in some logical subgroup of knobs kKnobGroupStart					EQU		128					; knob is first in some logical group of knobs ; One of these may be used at a time. kKnobTypeNumber					EQU		0 << 12kKnobTypeBoolean				EQU		1 << 12kKnobTypeNote					EQU		2 << 12kKnobTypePan					EQU		3 << 12kKnobTypeInstrument				EQU		4 << 12				; knob value = reference to another instrument number kKnobTypeSetting				EQU		5 << 12				; knob value is 1 of n different things (eg, fm algorithms) kUnknownKnobValue				EQU		$7FFFFFFF			; a knob with this value means, we don't know it. KnobDescription 		RECORD	0name					 ds.l	8lowValue				 ds.l	1highValue				 ds.l	1defaultValue			 ds.l	1									; a default instrument is made of all default values flags					 ds.l	1sizeof					 EQU	48						ENDRInstrumentData 			RECORD	0tone					 ds		ToneDescriptionknobCount				 ds.l	1knob					 ds.l	1sizeof					 EQU	84						ENDRFlatInstrument 			RECORD	0tone					 ds		ToneDescriptionsize					 ds.l	1									; size in bytes of the following data, including size field (excluding tonedescription) data					 ds.b	4sizeof					 EQU	84						ENDRInstrumentAboutInfo 	RECORD	0p						 ds.l	1author					 ds.l	64copyright				 ds.l	64other					 ds.l	64sizeof					 EQU	772						ENDRMusicMIDIPacket 		RECORD	0length					 ds.w	1reserved				 ds.l	1data					 ds.b	249sizeof					 EQU	256						ENDRkMusicFirstSelect				EQU		0kMusicGetDescriptionSelect		EQU		1kMusicGetPartSelect				EQU		2kMusicSetPartSelect				EQU		3kMusicSetInstrumentNumberSelect	EQU		4kMusicGetInstrumentNumberSelect	EQU		5kMusicStoreInstrumentSelect		EQU		6kMusicGetInstrumentSelect		EQU		7kMusicSetInstrumentSelect		EQU		8kMusicDummyOne					EQU		9kMusicDummyTwo					EQU		10kMusicDummyThree				EQU		11kMusicDummyFour					EQU		12kMusicGetInstrumentKnobDescriptionSelect EQU		13kMusicGetDrumKnobDescriptionSelect EQU		14kMusicGetKnobDescriptionSelect	EQU		15kMusicGetPartKnobSelect			EQU		16kMusicSetPartKnobSelect			EQU		17kMusicGetKnobSelect				EQU		18kMusicSetKnobSelect				EQU		19kMusicGetPartNameSelect			EQU		20kMusicSetPartNameSelect			EQU		21kMusicFindToneSelect			EQU		22kMusicPlayNoteSelect			EQU		23kMusicResetPartSelect			EQU		24kMusicSetControllerSelect		EQU		25kMusicGetControllerSelect		EQU		26kMusicGetMIDIProcSelect			EQU		27kMusicSetMIDIProcSelect			EQU		28kMusicGetInstrumentNamesSelect	EQU		29kMusicGetDrumNamesSelect		EQU		30kMusicGetMasterTuneSelect		EQU		31kMusicSetMasterTuneSelect		EQU		32kMusicSetFlatInstrumentSelect	EQU		33kMusicGetInstrumentAboutInfoSelect EQU		34notImplementedMusicErr			EQU		($80000000 | ((-2100 - 1)))cantSendToSynthesizerErr		EQU		($80000000 | ((-2100 - 2)))cantReceiveFromSynthesizerErr	EQU		($80000000 | ((-2100 - 3)))illegalVoiceAllocationErr		EQU		($80000000 | ((-2100 - 4)))illegalPartErr					EQU		($80000000 | ((-2100 - 5)))illegalChannelErr				EQU		($80000000 | ((-2100 - 6)))illegalKnobErr					EQU		($80000000 | ((-2100 - 7)))illegalKnobValueErr				EQU		($80000000 | ((-2100 - 8)))illegalInstrumentErr			EQU		($80000000 | ((-2100 - 9)))illegalControllerErr			EQU		($80000000 | ((-2100 - 10)))midiManagerAbsentErr			EQU		($80000000 | ((-2100 - 11)))synthesizerNotRespondingErr		EQU		($80000000 | ((-2100 - 12)))synthesizerErr					EQU		($80000000 | ((-2100 - 13)))illegalNoteChannelErr			EQU		($80000000 | ((-2100 - 14)))noteChannelNotAllocatedErr		EQU		($80000000 | ((-2100 - 15)))tunePlayerFullErr				EQU		($80000000 | ((-2100 - 16)))tuneParseErr					EQU		($80000000 | ((-2100 - 17)))kGMType							EQU		'gm  ';-----------------------------------------;	Capabilities and Voice Allocation;-----------------------------------------	IF GENERATING68K THEN		Macro		_MusicGetPart			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0002			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetPart	ENDIF	IF GENERATING68K THEN		Macro		_MusicSetPart			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0003			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicSetPart	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetDescription			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0001			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetDescription	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetInstrumentAboutInfo			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0022			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetInstrumentAboutInfo	ENDIF;-----------------------------------------;	Instrument Loading and Storing;-----------------------------------------	IF GENERATING68K THEN		Macro		_MusicSetInstrumentNumber			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicSetInstrumentNumber	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetInstrumentNumber			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0005			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetInstrumentNumber	ENDIF	IF GENERATING68K THEN		Macro		_MusicStoreInstrument			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0006			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicStoreInstrument	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetInstrument			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0007			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetInstrument	ENDIF	IF GENERATING68K THEN		Macro		_MusicSetInstrument			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0008			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicSetInstrument	ENDIF	IF GENERATING68K THEN		Macro		_MusicSetFlatInstrument			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0021			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicSetFlatInstrument	ENDIF;-----------------------------------------;	Instrument Knobs;-----------------------------------------	IF GENERATING68K THEN		Macro		_MusicGetInstrumentKnobDescription			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$000D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetInstrumentKnobDescription	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetDrumKnobDescription			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$000E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetDrumKnobDescription	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetPartKnob			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0010			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetPartKnob	ENDIF	IF GENERATING68K THEN		Macro		_MusicSetPartKnob			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0011			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicSetPartKnob	ENDIF;-----------------------------------------;	Synthesizer Knobs;-----------------------------------------	IF GENERATING68K THEN		Macro		_MusicGetKnobDescription			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$000F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetKnobDescription	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetKnob			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0012			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetKnob	ENDIF	IF GENERATING68K THEN		Macro		_MusicSetKnob			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0013			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicSetKnob	ENDIF	IF GENERATING68K THEN		Macro		_MusicSetMasterTune			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0020			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicSetMasterTune	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetMasterTune			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$001F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetMasterTune	ENDIF;-----------------------------------------;	Names of Instruments;-----------------------------------------	IF GENERATING68K THEN		Macro		_MusicGetPartName			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0014			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetPartName	ENDIF	IF GENERATING68K THEN		Macro		_MusicSetPartName			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0015			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicSetPartName	ENDIF	IF GENERATING68K THEN		Macro		_MusicFindTone			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0016			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicFindTone	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetInstrumentNames			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$001D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetInstrumentNames	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetDrumNames			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$001E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetDrumNames	ENDIF;-----------------------------------------;	Realtime Actions;-----------------------------------------	IF GENERATING68K THEN		Macro		_MusicPlayNote			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0017			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicPlayNote	ENDIF	IF GENERATING68K THEN		Macro		_MusicResetPart			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0018			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicResetPart	ENDIF	IF GENERATING68K THEN		Macro		_MusicSetController			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0019			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicSetController	ENDIF	IF GENERATING68K THEN		Macro		_MusicGetController			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$001A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetController	ENDIF;-----------------------------------------;	Finding the Hardware;-----------------------------------------	IF GENERATING68K THEN		Macro		_MusicGetMIDIProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$001B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicGetMIDIProc	ENDIF	IF GENERATING68K THEN		Macro		_MusicSetMIDIProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$001C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	MusicSetMIDIProc	ENDIF;--------------------------;	Types;--------------------------SynthesizerConnections 	RECORD	0clientID				 ds.l	1inputPortID				 ds.l	1outputPortID			 ds.l	1midiChannel				 ds.l	1									; The system channel; others are configurable (or the nubus slot number) flags					 ds.l	1reserved				 ds.l	3									; should be zero sizeof					 EQU	32						ENDRNoteRequest 			RECORD	0polyphony				 ds.l	1									; Maximum number of voices typicalPolyphony		 ds.l	1									; Hint for level mixing tone					 ds		ToneDescriptionsizeof					 EQU	84						ENDRkNAFirstSelector				EQU		-7kNATargetSelect					EQU		-6kNARegisterSelect				EQU		-5kNAVersionSelect				EQU		-4kNACanDoSelect					EQU		-3kNACloseSelect					EQU		-2kNAOpenSelect					EQU		-1kNARegisterMusicDeviceSelect	EQU		0kNAUnregisterMusicDeviceSelect	EQU		1kNAGetRegisteredMusicDeviceSelect EQU		2kNASaveMusicConfigurationSelect	EQU		3kNANewNoteChannelSelect			EQU		4kNADisposeNoteChannelSelect		EQU		5kNAGetNoteChannelInfoSelect		EQU		6kNAPrerollNoteChannelSelect		EQU		7kNAUnrollNoteChannelSelect		EQU		8kNAEngageNoteChannelSelect		EQU		9kNADisengageNoteChannelSelect	EQU		10kNASetNoteChannelVolumeSelect	EQU		11kNAResetNoteChannelSelect		EQU		12kNAPlayNoteSelect				EQU		13kNASetControllerSelect			EQU		14kNASetKnobSelect				EQU		15kNAFindNoteChannelToneSelect	EQU		16kNASetNoteChannelInstrumentSelect EQU		17kNAPickInstrumentSelect			EQU		18kNAPickArrangementSelect		EQU		19kNAGetStatusBlockSelect			EQU		20kNASetDefaultMIDIInputSelect	EQU		21kNAGetDefaultMIDIInputSelect	EQU		22kNAGetNoteChannelStateSelect	EQU		23kNASetNoteChannelStateSelect	EQU		24kNAUseDefaultMIDIInputSelect	EQU		25kNALoseDefaultMIDIInputSelect	EQU		26kNAStuffToneDescriptionSelect	EQU		27kNACopyrightDialogSelect		EQU		28kNASetFlatInstrumentSelect		EQU		29kNASetInstrumentSelect			EQU		30kNALastSelector					EQU		31kPickDontMix					EQU		1					; dont mix instruments with drum sounds kPickSameSynth					EQU		2					; only allow the same device that went in, to come out kNoteAllocatorType				EQU		'nota';--------------------------------;	Note Allocator Prototypes;--------------------------------;; * System Configuration; 	IF GENERATING68K THEN		Macro		_NARegisterMusicDevice			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0000			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NARegisterMusicDevice	ENDIF	IF GENERATING68K THEN		Macro		_NAUnregisterMusicDevice			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0001			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAUnregisterMusicDevice	ENDIF	IF GENERATING68K THEN		Macro		_NAGetRegisteredMusicDevice			dc.w 	$2F3C			dc.w 	$0014			dc.w 	$0002			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAGetRegisteredMusicDevice	ENDIF	IF GENERATING68K THEN		Macro		_NASetDefaultMIDIInput			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0015			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NASetDefaultMIDIInput	ENDIF	IF GENERATING68K THEN		Macro		_NAGetDefaultMIDIInput			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0016			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAGetDefaultMIDIInput	ENDIF	IF GENERATING68K THEN		Macro		_NASaveMusicConfiguration			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0003			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NASaveMusicConfiguration	ENDIF;; * Allocation; 	IF GENERATING68K THEN		Macro		_NANewNoteChannel			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NANewNoteChannel	ENDIF	IF GENERATING68K THEN		Macro		_NADisposeNoteChannel			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0005			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NADisposeNoteChannel	ENDIF	IF GENERATING68K THEN		Macro		_NAGetNoteChannelInfo			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0006			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAGetNoteChannelInfo	ENDIF	IF GENERATING68K THEN		Macro		_NAUseDefaultMIDIInput			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0019			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAUseDefaultMIDIInput	ENDIF	IF GENERATING68K THEN		Macro		_NALoseDefaultMIDIInput			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$001A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NALoseDefaultMIDIInput	ENDIF;; * Setup; 	IF GENERATING68K THEN		Macro		_NAPrerollNoteChannel			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0007			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAPrerollNoteChannel	ENDIF	IF GENERATING68K THEN		Macro		_NAUnrollNoteChannel			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0008			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAUnrollNoteChannel	ENDIF	IF GENERATING68K THEN		Macro		_NAEngageNoteChannel			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0009			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAEngageNoteChannel	ENDIF	IF GENERATING68K THEN		Macro		_NADisengageNoteChannel			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$000A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NADisengageNoteChannel	ENDIF	IF GENERATING68K THEN		Macro		_NAGetNoteChannelState			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0017			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAGetNoteChannelState	ENDIF	IF GENERATING68K THEN		Macro		_NASetNoteChannelState			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0018			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NASetNoteChannelState	ENDIF	IF GENERATING68K THEN		Macro		_NAResetNoteChannel			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAResetNoteChannel	ENDIF	IF GENERATING68K THEN		Macro		_NASetNoteChannelVolume			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$000B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NASetNoteChannelVolume	ENDIF	IF GENERATING68K THEN		Macro		_NASetInstrument			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$001E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NASetInstrument	ENDIF	IF GENERATING68K THEN		Macro		_NASetFlatInstrument			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$001D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NASetFlatInstrument	ENDIF;; * Control; 	IF GENERATING68K THEN		Macro		_NAPlayNote			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$000D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAPlayNote	ENDIF	IF GENERATING68K THEN		Macro		_NASetController			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$000E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NASetController	ENDIF	IF GENERATING68K THEN		Macro		_NASetKnob			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$000F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NASetKnob	ENDIF	IF GENERATING68K THEN		Macro		_NAFindNoteChannelTone			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0010			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAFindNoteChannelTone	ENDIF	IF GENERATING68K THEN		Macro		_NASetNoteChannelInstrument			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0011			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NASetNoteChannelInstrument	ENDIF;; * User Interface; 	IF GENERATING68K THEN		Macro		_NAPickInstrument			dc.w 	$2F3C			dc.w 	$001C			dc.w 	$0012			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAPickInstrument	ENDIF	IF GENERATING68K THEN		Macro		_NAStuffToneDescription			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$001B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAStuffToneDescription	ENDIF	IF GENERATING68K THEN		Macro		_NAPickArrangement			dc.w 	$2F3C			dc.w 	$0018			dc.w 	$0013			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAPickArrangement	ENDIF	IF GENERATING68K THEN		Macro		_NACopyrightDialog			dc.w 	$2F3C			dc.w 	$001C			dc.w 	$001C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NACopyrightDialog	ENDIF;; * Note Allocator interior views; NAStatPiece 			RECORD	0clientName				 ds.l	8synthesizerName			 ds.l	8part					 ds.l	1midiChannel				 ds.l	1polyphony				 ds.l	1valid					 ds.l	1sizeof					 EQU	80						ENDRNAStat 					RECORD	0pieceCount				 ds.l	1piece					 ds.b	64 * NAStatPiecesizeof					 EQU	5124						ENDR	IF GENERATING68K THEN		Macro		_NAGetStatusBlock			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0014			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	NAGetStatusBlock	ENDIF;--------------------------;	Types;--------------------------kTuneQueueDepth					EQU		8					; Deepest you can queue tune segments TuneStatus 				RECORD	0tune					 ds.l	1									; currently playing tune tunePtr					 ds.l	1									; position within currently playing piece time					 ds.l	1									; current tune time queueCount				 ds.w	1									; how many pieces queued up? queueSpots				 ds.w	1									; How many more tunepieces can be queued queueTime				 ds.l	1									; How much time is queued up? (can be very inaccurate) reserved				 ds.l	3sizeof					 EQU	32						ENDRkStopTuneFade					EQU		1					; do a quick, synchronous fadeout kStopTuneSustain				EQU		2					; don't silece notes kStopTuneInstant				EQU		4					; silence notes fast (else, decay them) kStopTuneReleaseChannels		EQU		8					; afterwards, let the channels go kTuneSelect						EQU		3kTuneSetHeaderSelect			EQU		4kTuneGetTimeBaseSelect			EQU		5kTuneSetTimeScaleSelect			EQU		6kTuneGetTimeScaleSelect			EQU		7kTuneGetIndexedNoteChannelSelect EQU		8kTuneDummy						EQU		9kTuneQueueSelect				EQU		10kTuneInstantSelect				EQU		11kTuneGetStatusSelect			EQU		12kTuneStopSelect					EQU		13kTuneResumeSelect				EQU		14kTuneFlushSelect				EQU		15kTuneSetVolumeSelect			EQU		16kTuneGetVolumeSelect			EQU		17kTunePrerollSelect				EQU		18kTuneUnrollSelect				EQU		19kTuneLastSelector				EQU		20kMaxTunePlayerParts				EQU		32kTunePlayerType					EQU		'tune';--------------------------;	Prototypes;--------------------------	IF GENERATING68K THEN		Macro		_TuneSetHeader			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneSetHeader	ENDIF	IF GENERATING68K THEN		Macro		_TuneGetTimeBase			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0005			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneGetTimeBase	ENDIF	IF GENERATING68K THEN		Macro		_TuneSetTimeScale			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0006			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneSetTimeScale	ENDIF	IF GENERATING68K THEN		Macro		_TuneGetTimeScale			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0007			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneGetTimeScale	ENDIF	IF GENERATING68K THEN		Macro		_TuneGetIndexedNoteChannel			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0008			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneGetIndexedNoteChannel	ENDIF; Values for when to start. kTuneStartNow					EQU		1					; start after buffer is implied kTuneDontClipNotes				EQU		2					; allow notes to finish their durations outside sample kTuneExcludeEdgeNotes			EQU		4					; dont play notes that start at end of tune kTuneStartNewMaster				EQU		16384	IF GENERATING68K THEN		Macro		_TuneQueue			dc.w 	$2F3C			dc.w 	$001C			dc.w 	$000A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneQueue	ENDIF	IF GENERATING68K THEN		Macro		_TuneInstant			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$000B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneInstant	ENDIF	IF GENERATING68K THEN		Macro		_TuneGetStatus			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000C			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneGetStatus	ENDIF; Values for when to start. kStopSustain					EQU		1					; Leaves notes playing, not silent kStopFadeout					EQU		2					; Does a synchronous fade-out 	IF GENERATING68K THEN		Macro		_TuneStop			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$000D			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneStop	ENDIF	IF GENERATING68K THEN		Macro		_TuneResume			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$000E			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneResume	ENDIF	IF GENERATING68K THEN		Macro		_TuneFlush			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$000F			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneFlush	ENDIF	IF GENERATING68K THEN		Macro		_TuneSetVolume			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0010			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneSetVolume	ENDIF	IF GENERATING68K THEN		Macro		_TuneGetVolume			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0011			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneGetVolume	ENDIF	IF GENERATING68K THEN		Macro		_TunePreroll			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0012			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TunePreroll	ENDIF	IF GENERATING68K THEN		Macro		_TuneUnroll			dc.w 	$2F3C			dc.w 	$0000			dc.w 	$0013			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TuneUnroll	ENDIF; 	QuickTime Music Track Event Formats:;;	At this time, QuickTime music tracks support 5 different event types -- REST events,;	short NOTE events, short CONTROL events, short GENERAL events, Long NOTE events, ;	long CONTROL events, and variable GENERAL events.; ;		¥ REST Event (4 bytes/event):;	;			(0 0 0) (5-bit UNUSED) (24-bit Rest Duration);		;		¥ÊShort NOTE Events (4 bytes/event):;	;			(0 0 1) (5-bit Instrument) (6-bit Pitch) (7-bit Volume) (11-bit Duration);		;			where:	Pitch is offset by 32 (Actual pitch = pitch field + 32);;		¥ÊShort CONTROL Events (4 bytes/event):;	;			(0 1 0) (5-bit Instrument) (8-bit Controller) (1-bit UNUSED) (1-bit Sign) (7-bit MSB) (7-bit LSB);																		 ( or 15-bit Signed Value);		¥ Short GENERAL Event (4 bytes/event):;	;			(0 1 1) (1-bit UNUSED) (12-bit Sub-Type) (16-bit Value);	;		¥ Long NOTE Events (8 bytes/event):;	;			(1 0 0 1) (12-bit Instrument) (1-bit UNUSED) (7-bit Pitch) (1-bit UNUSED) (7-bit Volume);			(1 0) (8-bit UNUSED) (22-bit Duration);		;		¥ÊLong CONTROL Event (8 bytes/event):;		;			(1 0 1 0) (12-bit Instrument) (16-bit Value MSB) ;			(1 0) (14-bit Controller) (16-bit Value LSB);	;		¥ÊLong KNOB Event (8 bytes/event):;	;			(1 0 1 1) (12-bit Sub-Type) (16-bit Value MSB);			(1 0) (14-bit KNOB) (16-bit Value LSB);	;		¥ÊVariable GENERAL Length Events (N bytes/event):;	;			(1 1 1 1) (12-bit Sub-Type) (16-bit Length);				:;			(32-bit Data values);				:;			(1 1) (14-bit UNUSED) (16-bit Length);	;			where:	Length field is the number of LONG words in the record.;					Lengths include the first and last long words (Minimum length = 2);				;	The following event type values have not been used yet and are reserved for ;	future expansion:;		;		¥ (1 0 0 0)		(8 bytes/event);		¥ (1 1 0 0)		(N bytes/event);		¥ (1 1 0 1)		(N bytes/event);		¥ (1 1 1 0)		(N bytes/event);		;	For all events, the following generalizations apply:;	;		-	All duration values are specified in Millisecond units.;		- 	Pitch values are intended to map directly to the MIDI key numbers.;		-	Controllers from 0 to 127 correspond to the standard MIDI controllers.;			Controllers greater than 127 correspond to other controls (i.e., Pitch Bend, ;			Key Pressure, and Channel Pressure).	;; Defines for the implemented music event data fieldskRestEventType					EQU		$0					; lower 3-bits kNoteEventType					EQU		$1					; lower 3-bits kControlEventType				EQU		$2					; lower 3-bits kMarkerEventType				EQU		$3					; lower 3-bits kUndefined1EventType			EQU		$8					; 4-bits kXNoteEventType					EQU		$9					; 4-bits kXControlEventType				EQU		$A					; 4-bits kKnobEventType					EQU		$B					; 4-bits kUndefined2EventType			EQU		$C					; 4-bits kUndefined3EventType			EQU		$D					; 4-bits kUndefined4EventType			EQU		$E					; 4-bits kGeneralEventType				EQU		$F					; 4-bits kXEventLengthBits				EQU		$2					; 2 bits: indicates 8-byte event record kGeneralEventLengthBits			EQU		$3					; 2 bits: indicates variable length event record kEventLen						EQU		1					; length of events in long words kXEventLen						EQU		2kRestEventLen					EQU		kEventLen			; length of events in long words kNoteEventLen					EQU		kEventLenkControlEventLen				EQU		kEventLenkMarkerEventLen					EQU		kEventLenkXNoteEventLen					EQU		kXEventLenkXControlEventLen				EQU		kXEventLenkGeneralEventLen				EQU		kXEventLen			; 2 or more, however ; Universal Event DefineskEventLengthFieldPos			EQU		30					; by looking at these two bits of the 1st or last word 			 kEventLengthFieldWidth			EQU		2					; of an event you can determine the event length 					 ; length field: 0 & 1 => 1 long; 2 => 2 longs; 3 => variable length kEventTypeFieldPos				EQU		29					; event type field for short events kEventTypeFieldWidth			EQU		3					; short type is 3 bits kXEventTypeFieldPos				EQU		28					; event type field for extended events kXEventTypeFieldWidth			EQU		4					; extended type is 4 bits kEventInstrumentFieldPos		EQU		24kEventInstrumentFieldWidth		EQU		5kXEventInstrumentFieldPos		EQU		16					; in the 1st long word kXEventInstrumentFieldWidth		EQU		12; Rest EventskRestEventDurationFieldPos		EQU		0kRestEventDurationFieldWidth	EQU		24kRestEventDurationMax			EQU		((1 << kRestEventDurationFieldWidth) - 1); Note EventskNoteEventPitchFieldPos			EQU		18kNoteEventPitchFieldWidth		EQU		6kNoteEventPitchOffset			EQU		32					; add to value in pitch field to get actual pitch kNoteEventVolumeFieldPos		EQU		11kNoteEventVolumeFieldWidth		EQU		7kNoteEventVolumeOffset			EQU		0					; add to value in volume field to get actual volume kNoteEventDurationFieldPos		EQU		0kNoteEventDurationFieldWidth	EQU		11kNoteEventDurationMax			EQU		((1 << kNoteEventDurationFieldWidth) - 1)kXNoteEventPitchFieldPos		EQU		0					; in the 1st long word kXNoteEventPitchFieldWidth		EQU		16kXNoteEventDurationFieldPos		EQU		0					; in the 2nd long word kXNoteEventDurationFieldWidth	EQU		22kXNoteEventDurationMax			EQU		((1 << kXNoteEventDurationFieldWidth) - 1)kXNoteEventVolumeFieldPos		EQU		22					; in the 2nd long word kXNoteEventVolumeFieldWidth		EQU		7; Control EventskControlEventControllerFieldPos	EQU		16kControlEventControllerFieldWidth EQU		8kControlEventValueFieldPos		EQU		0kControlEventValueFieldWidth	EQU		16kXControlEventControllerFieldPos EQU		0					; in the 2nd long word kXControlEventControllerFieldWidth EQU		16kXControlEventValueFieldPos		EQU		0					; in the 1st long word kXControlEventValueFieldWidth	EQU		16; Knob EventskKnobEventValueHighFieldPos		EQU		0					; 1st long word kKnobEventValueHighFieldWidth	EQU		16kKnobEventKnobFieldPos			EQU		16					; 2nd long word kKnobEventKnobFieldWidth		EQU		14kKnobEventValueLowFieldPos		EQU		0					; 2nd long word kKnobEventValueLowFieldWidth	EQU		16; Marker EventskMarkerEventSubtypeFieldPos		EQU		16kMarkerEventSubtypeFieldWidth	EQU		8kMarkerEventValueFieldPos		EQU		0kMarkerEventValueFieldWidth		EQU		16; General EventskGeneralEventSubtypeFieldPos	EQU		16					; in the last long word kGeneralEventSubtypeFieldWidth	EQU		14kGeneralEventLengthFieldPos		EQU		0					; in the 1st & last long words kGeneralEventLengthFieldWidth	EQU		16kGeneralEventNoteRequest		EQU		1					; Encapsulates NoteRequest data structure kGeneralEventInstrument			EQU		2					; Encapsulates poly, typical poly, followed by InstrumentData record kGeneralEventFlatInstrument		EQU		3					; Encapsulates poly, typical poly, followed by FlatInstrument record kGeneralEventPartName			EQU		4					; Brackets 2 longs follwed by a pascal string (padded to long alignment) kGeneralEventPartKey			EQU		5					; Brackets 2 longs TCSourceRefNameType				EQU		'name'tcDropFrame						EQU		1 << 0tc24HourMax						EQU		1 << 1tcNegTimesOK					EQU		1 << 2tcCounter						EQU		1 << 3TimeCodeDef 			RECORD	0flags					 ds.l	1									; drop-frame, etc.fTimeScale				 ds.l	1									; time scale of frameDuration (eg. 2997)frameDuration			 ds.l	1									; duration of each frame (eg. 100)numFrames				 ds.b	1									; number of frames per second for timecode (eg. 30); number of frames per tick for counter modepadding					 ds.b	1									; unused padding byte sizeof					 EQU	14						ENDRtctNegFlag						EQU		$80					; negative bit is in minutesTimeCodeTime 			RECORD	0hours					 ds.b	1minutes					 ds.b	1seconds					 ds.b	1frames					 ds.b	1sizeof					 EQU	4						ENDRTimeCodeCounter 		RECORD	0counter					 ds.l	1sizeof					 EQU	4						ENDRTimeCodeDescription 	RECORD	0; standard sample description headerdescSize				 ds.l	1dataFormat				 ds.l	1resvd1					 ds.l	1resvd2					 ds.w	1dataRefIndex			 ds.w	1; timecode specific stuffflags					 ds.l	1timeCodeDef				 ds		TimeCodeDefsrcRef					 ds.l	1sizeof					 EQU	38						ENDRtcdfShowTimeCode				EQU		1 << 0kTCGetCurrentTimeCodeSelect		EQU		257kTCGetTimeCodeAtTimeSelect		EQU		258kTCTimeCodeToStringSelect		EQU		259kTCTimeCodeToFrameNumberSelect	EQU		260kTCFrameNumberToTimeCodeSelect	EQU		261kTCGetSourceRefSelect			EQU		262kTCSetSourceRefSelect			EQU		263kTCSetTimeCodeFlagsSelect		EQU		264kTCGetTimeCodeFlagsSelect		EQU		265kTCSetDisplayOptionsSelect		EQU		266kTCGetDisplayOptionsSelect		EQU		267	IF GENERATING68K THEN		Macro		_TCGetCurrentTimeCode			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0101			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCGetCurrentTimeCode	ENDIF	IF GENERATING68K THEN		Macro		_TCGetTimeCodeAtTime			dc.w 	$2F3C			dc.w 	$0014			dc.w 	$0102			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCGetTimeCodeAtTime	ENDIF	IF GENERATING68K THEN		Macro		_TCTimeCodeToFrameNumber			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0104			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCTimeCodeToFrameNumber	ENDIF	IF GENERATING68K THEN		Macro		_TCFrameNumberToTimeCode			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0105			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCFrameNumberToTimeCode	ENDIF	IF GENERATING68K THEN		Macro		_TCTimeCodeToString			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0103			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCTimeCodeToString	ENDIF	IF GENERATING68K THEN		Macro		_TCGetSourceRef			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0106			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCGetSourceRef	ENDIF	IF GENERATING68K THEN		Macro		_TCSetSourceRef			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0107			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCSetSourceRef	ENDIF	IF GENERATING68K THEN		Macro		_TCSetTimeCodeFlags			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0108			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCSetTimeCodeFlags	ENDIF	IF GENERATING68K THEN		Macro		_TCGetTimeCodeFlags			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0109			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCGetTimeCodeFlags	ENDIF	IF GENERATING68K THEN		Macro		_TCSetDisplayOptions			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$010A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCSetDisplayOptions	ENDIF	IF GENERATING68K THEN		Macro		_TCGetDisplayOptions			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$010B			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	TCGetDisplayOptions	ENDIF; UPP call backs 	ENDIF ; __QUICKTIMECOMPONENTS__