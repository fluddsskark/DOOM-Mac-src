;;	File:		Translation.a;;	Copyright:	© 1984-1994 by Apple Computer, Inc.;				All rights reserved.;;	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994. ;;	Bugs?:		If you find a problem with this file, send the file and version;				information (from above) and the problem description to:;;					Internet:	apple.bugs@applelink.apple.com;					AppleLink:	APPLE.BUGS;;	IF &TYPE('__TRANSLATION__') = 'UNDEFINED' THEN__TRANSLATION__ SET 1	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN	include 'Types.a'	ENDIF;		include 'ConditionalMacros.a'								;	IF &TYPE('__FILES__') = 'UNDEFINED' THEN	include 'Files.a'	ENDIF;		include 'MixedMode.a'										;;		include 'OSUtils.a'										;;			include 'Memory.a'										;	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN	include 'Components.a'	ENDIF	IF &TYPE('__TRANSLATIONEXTENSIONS__') = 'UNDEFINED' THEN	include 'TranslationExtensions.a'	ENDIF;		include 'Quickdraw.a'										;;			include 'QuickdrawText.a'								;domCannot						EQU		0domNative						EQU		1domTranslateFirst				EQU		2domWildcard						EQU		3; 0L terminated array of OSTypes, or FileTypes; Progress dialog resource IDkTranslationScrapProgressDialogID EQU		-16555; block of data that describes how to translateFileTranslationSpec 	RECORD	0componentSignature		 ds.l	1translationSystemInfo	 ds.l	1src						 ds		FileTypeSpecdst						 ds		FileTypeSpecsizeof					 EQU	48						ENDR;****************************************************************************************;* ;*   GetFileTypesThatAppCanNativelyOpen;* ;*  This routine returns a list of all FileTypes that an application can open by itself;* ;*  Enter:	appVRefNumHint		volume where application resides (can be wrong, and if is, will be used as a starting point);* 			appSignature		signature (creator) of application;* 			nativeTypes			pointer to a buffer to be filled with up to 64 FileTypes;* ;*  Exit:	nativeTypes			zero terminated array of FileTypes that can be opened by app;	IF GENERATING68K THEN		Macro		_GetFileTypesThatAppCanNativelyOpen			moveq	#28,d0			dc.w 	$ABFC		EndM	ELSE		IMPORT	GetFileTypesThatAppCanNativelyOpen	ENDIF;****************************************************************************************;* ;*  ExtendFileTypeList;* ;*  This routine makes a new list of file types that can be translated into a type in the given list;*  Used by StandardFile;* ;*  Enter:	originalTypeList		pointer to list of file types that can be opened;* 			numberOriginalTypes		number of file types in orgTypeList;*  			extendedTypeList		pointer to a buffer to be filled with file types;* 			numberExtendedTypes		max number of file types that can be put in extendedTypeList;* ;*  Exit:	extendedTypeList		buffer filled in with file types that can be translated;* 			numberExtendedTypes		number of file types put in extendedTypeList;	IF GENERATING68K THEN		Macro		_ExtendFileTypeList			moveq	#9,d0			dc.w 	$ABFC		EndM	ELSE		IMPORT	ExtendFileTypeList	ENDIF;****************************************************************************************;* ;* ;*  This routine checks if a file can be opened by a particular application.;*  If so, it returns if it needs to be translated first, and if so then how.;*  The FileTypes that the app can open are specified by nativelyOpenableTypes,;*  or if it is NULL, GetFileTypesThatAppCanNativelyOpen is called.;* ;*  Enter:	targetDocument		document to check if it can be opened;* 			appVRefNumHint		vRefNum of application to open doc ( can be wrong, and if is, will be used as a starting point);* 			appSignature		signature (creator) of application to open doc;* 			nativeTypes			zero terminated list of FileTypes app can open natively, or NULL to use default list;* 			onlyNative			whether to consider if document can be translated before opening;* 			howToOpen			pointer to buffer in which to put how the document can be opened;* 			howToTranslate		pointer to buffer in which to put a FileTranslationSpec record;* ;*  Exit:	howToOpen			whether file needs to be translated to be read;* 			howToTranslate		if file can be translated, buffer filled in with how to translate;* 			returns				noErr, noPrefAppErr;	IF GENERATING68K THEN		Macro		_CanDocBeOpened			moveq	#30,d0			dc.w 	$ABFC		EndM	ELSE		IMPORT	CanDocBeOpened	ENDIF;****************************************************************************************;* ;*  GetFileTranslationPaths;* ;*  This routine returns a list of all ways a translation can occure to or from a FileType.;*  The app is checked to exist.  The hint for each app is the VRefNum and DTRefNum;* ;*  Enter:	srcDoc			source file or NULL for all matches;* 			dstDoc			destination FileType or NULL for all matches;* 			maxResultCount;* 			resultBuffer;*  Exit:	number of paths;	IF GENERATING68K THEN		Macro		_GetFileTranslationPaths			moveq	#56,d0			dc.w 	$ABFC		EndM	ELSE		IMPORT	GetFileTranslationPaths	ENDIF;****************************************************************************************;* ;*  GetPathFromTranslationDialog;* ;*  This routine, with a given document, application, and a passed typelist will display the;*  Macintosh Easy Open translation dialog allowing the user to make a choice.  The choice;*  made will be written as a preference (so the next call to CanDocBeOpened() will work).;*  The routine returns the translation path information.;* ;*  Enter:	theDocument			FSSpec to document to open;* 			theApplication		FSSpec to application to open document;* 			typeList			Nil terminated list of FileType's (e.g. SFTypeList-like) of types;* 								you would like the documented translated to.  Order most perferred;* 								to least.;* ;*  Exit:	howToOpen			Translation method needed to open document;* 			howToTranslate		Translation specification;* 			returns				Any errors that might occur.;	IF GENERATING68K THEN		Macro		_GetPathFromTranslationDialog			moveq	#55,d0			dc.w 	$ABFC		EndM	ELSE		IMPORT	GetPathFromTranslationDialog	ENDIF;****************************************************************************************;* ;*   TranslateFile;* ;*  This routine reads a file of one format and writes it to another file in another format. ;*  The information on how to translated is generated by the routine CanDocBeOpened.;*  TranslateFile calls through to the TranslateFile Extension's DoTranslateFile routine.  ;*  The destination file must not exist.  It is created by this routine.  ;* ;*  Enter:	sourceDocument			input file to translate;* 			destinationDocument		output file of translation;* 			howToTranslate			pointer to info on how to translate;*  Exit:	returns					noErr, badTranslationSpecErr ;	IF GENERATING68K THEN		Macro		_TranslateFile			moveq	#12,d0			dc.w 	$ABFC		EndM	ELSE		IMPORT	TranslateFile	ENDIF;****************************************************************************************;* ;*   GetDocumentKindString;* ;*  This routine returns the string the Finder should show for the "kind" of a document;*  in the GetInfo window and in the kind column of a list view.  ;* ;*  Enter:	docVRefNum		The volume containing the document;* 			docType			The catInfo.fdType of the document;* 			docCreator		The catInfo.fdCreator of the document;* 			kindString		pointer to where to return the string;* ;*  Exit:	kindString		pascal string.  Ex: "\pSurfCalc spreadsheet";* 			returns			noErr, or afpItemNoFound if kind could not be determined;	IF GENERATING68K THEN		Macro		_GetDocumentKindString			moveq	#22,d0			dc.w 	$ABFC		EndM	ELSE		IMPORT	GetDocumentKindString	ENDIF;****************************************************************************************;* ;*  GetTranslationExtensionName;* ;*  This routine returns the translation system name from a specified TranslationSpec;* ;*  Enter:	translationMethod	The translation path to get the translation name from;* ;*  Exit:	extensionName		The name of the translation system;* 			returns				Any errors that might occur;	IF GENERATING68K THEN		Macro		_GetTranslationExtensionName			moveq	#54,d0			dc.w 	$ABFC		EndM	ELSE		IMPORT	GetTranslationExtensionName	ENDIF;****************************************************************************************;* ;*  GetScrapDataProcPtr;* ;*  This is a prototype for the function you must supply to TranslateScrap. It is called to ;*  get the data to be translated.  The first call TranslateScrap will make to this is to;*  ask for the 'fmts' data.  That is a special.   You should resize and fill in the handle;*  with a list all the formats that you have available to be translated, and the length of each.;*  (See I.M. VI 4-23 for details of 'fmts').  It will then be called again asking for one of  ;*  the formats that 'fmts' list said was available.;* ;*  Enter:	requestedFormat			Format of data that TranslateScrap needs.;* 			dataH					Handle in which to put the requested data;* 			srcDataGetterRefCon		Extra parameter for you passed to TranslateScrap;* 			;*  Exit:	dataH					Handle is resized and filled with data in requested format;;****************************************************************************************;* ;*  TranslateScrap;* ;*  This routine resizes the destination handle and fills it with data of the requested format.;*  The data is generated by translated one or more source formats of data supplied by;*  the procedure srcDataGetter.  ;*  This routine is automatically called by GetScrap and ReadEdition.  You only need to call;*  this if you need to translated scrap style data, but are not using the ScrapMgr or EditionMgr.;* ;*  Enter:	sourceDataGetter			Pointer to routine that can get src data;* 			sourceDataGetterRefCon		Extra parameter for dataGetter;* 			destinationFormat			Format of data desired;* 			destinationData				Handle in which to store translated data;* 			;*  Exit:	dstData						Handle is resized and filled with data in requested format;	IF GENERATING68K THEN		Macro		_TranslateScrap			moveq	#14,d0			dc.w 	$ABFC		EndM	ELSE		IMPORT	TranslateScrap	ENDIF	ENDIF ; __TRANSLATION__