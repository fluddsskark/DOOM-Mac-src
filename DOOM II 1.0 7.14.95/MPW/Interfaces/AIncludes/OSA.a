;;	File:		OSA.a;;	Copyright:	© 1984-1994 by Apple Computer, Inc.;				All rights reserved.;;	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994. ;;	Bugs?:		If you find a problem with this file, send the file and version;				information (from above) and the problem description to:;;					Internet:	apple.bugs@applelink.apple.com;					AppleLink:	APPLE.BUGS;;	IF &TYPE('__OSA__') = 'UNDEFINED' THEN__OSA__ SET 1	IF &TYPE('__ERRORS__') = 'UNDEFINED' THEN	include 'Errors.a'	ENDIF;		include 'ConditionalMacros.a'								;	IF &TYPE('__APPLEEVENTS__') = 'UNDEFINED' THEN	include 'AppleEvents.a'	ENDIF;		include 'Types.a'											;;		include 'Memory.a'											;;			include 'MixedMode.a'									;;		include 'OSUtils.a'										;;		include 'Events.a'											;;			include 'Quickdraw.a'									;;				include 'QuickdrawText.a'							;;		include 'EPPC.a'											;;			include 'PPCToolbox.a'									;;				include 'AppleTalk.a'								;;			include 'Processes.a'									;;				include 'Files.a'									;;		include 'Notification.a'									;	IF &TYPE('__AEOBJECTS__') = 'UNDEFINED' THEN	include 'AEObjects.a'	ENDIF	IF &TYPE('__COMPONENTS__') = 'UNDEFINED' THEN	include 'Components.a'	ENDIFkOSAComponentType				EQU		'osa '; 0x73637074 kOSAGenericScriptingComponentSubtype EQU		'scpt';	Type of script document files.	; 0x6f736173 kOSAFileType					EQU		'osas';;		Suite and event code of the RecordedText event. ;		(See OSAStartRecording, below.);	; 0x61736372 kOSASuite						EQU		'ascr'; 0x72656364 kOSARecordedText				EQU		'recd'; Selector returns boolean ; 0x6d6f6469 kOSAScriptIsModified			EQU		'modi'; Selector returns boolean ; 0x63736372 kOSAScriptIsTypeCompiledScript	EQU		'cscr'; Selector returns boolean ; 0x76616c75 kOSAScriptIsTypeScriptValue		EQU		'valu'; Selector returns boolean ; 0x636e7478 kOSAScriptIsTypeScriptContext	EQU		'cntx'; Selector returns a DescType which may be passed to OSACoerceToDesc ; 0x62657374 kOSAScriptBestType				EQU		'best';;		This selector is used to determine whether a script has source ;		associated with it that when given to OSAGetSource, the call will not;		fail.  The selector returns a boolean.;	; 0x67737263 kOSACanGetSource				EQU		'gsrc'typeOSADialectInfo				EQU		'difo'				;  0x6469666f   keyOSADialectName				EQU		'dnam'				;  0x646e616d   keyOSADialectCode				EQU		'dcod'				;  0x64636f64   keyOSADialectLangCode			EQU		'dlcd'				;  0x646c6364   keyOSADialectScriptCode			EQU		'dscd'; Under the Open Scripting Architecture all error results are longs ;;		OSAIDs allow transparent manipulation of scripts associated with;	 	various scripting systems.;	kOSANullScript					EQU		0; No -script constant. kOSANullMode					EQU		0					; sounds better kOSAModeNull					EQU		0					; tastes consistent ;;		Some routines take flags that control their execution.  This constant;		declares default mode settings are used.;	;*************************************************************************;	Standard Script Errors;**************************************************************************;	It is recommended that scripting components use the following set of error;	codes to signal failure when applicable.  This enables applications that;	use the OSA API to deal with some class of script errors in a less than ;	ad hoc manner.  Scripting components are of course encouraged to return;	component-specific errors when these don't apply.;*************************************************************************;		Dynamic errors:;;	These errors result from data-dependent conditions and are typically;	signaled at runtime.;;;		Signaled when a value can't be coerced to the desired type. Similar;	  	to errOSATypeError except results from coercion.;	errOSACantCoerce				EQU		errAECoercionFail; Signaled when an object is not found in a container errOSACantAccess				EQU		errAENoSuchObject;;		Signaled when an object cannot be set in a container.  Same as ;	  	AERegistry error errAEWriteDenied.;	errOSACantAssign				EQU		-10006;;		Signaled by user scripts or applications when no actual error code;	  	is to be returned.  Simply means "an error has occurred".  Most useful;	  	in conjunction with an error message from the application.;	errOSAGeneralError				EQU		-2700; Signaled when there is an attempt to divide by zero errOSADivideByZero				EQU		-2701; Signaled when integer or real value is too large to be represented errOSANumericOverflow			EQU		-2702;;		Signaled when application can't be launched or when it is remote and;	  	program linking is not enabled.;	errOSACantLaunch				EQU		-2703; Signaled when an application can't respond to AppleEvents errOSAAppNotHighLevelEventAware	EQU		-2704; Signaled when an application's terminology resource is not readable errOSACorruptTerminology		EQU		-2705; Signaled when the runtime stack overflows errOSAStackOverflow				EQU		-2706; Signaled when a runtime internal data structure overflows errOSAInternalTableOverflow		EQU		-2707;;		Signaled when an intrinsic limitation is exceeded for the size of ;	  	a value or data structure.;	errOSADataBlockTooLarge			EQU		-2708errOSACantGetTerminology		EQU		-2709errOSACantCreate				EQU		-2710;		Component-specific dynamic script errors:;;	The range -2720 thru -2739 is reserved for component-specific runtime errors.;	(Note that error codes from different scripting components in this range will;	overlap.);;		Static errors:;;	These errors comprise what are commonly thought of as parse and compile-;	time errors.  However, in a dynamic system (e.g. AppleScript) any or all;	of these may also occur at runtime.;; Signaled when data was not the right type and coercion is not allowed errOSATypeError					EQU		errAEWrongDataType; Signaled when a message was sent to an object that didn't handle it OSAMessageNotUnderstood			EQU		errAEEventNotHandled;;		Signaled when a function to be returned doesn't exist.  (Probably only;	  	useful in languages with first-class functions that distinguish between;	  	functions and other values (two name spaces). This is different from;	  	errOSAMessageNotUnderstood, which may be signaled when the method is;	  	invoked.;	OSAUndefinedHandler				EQU		errAEHandlerNotFound; Signaled when a container can never have the requested object OSAIllegalAccess				EQU		errAEAccessorNotFound; Signaled when index was out of range. Specialization of errOSACantAccess. OSAIllegalIndex					EQU		errAEIllegalIndex; Signaled when a range is screwy. Specialization of errOSACantAccess. OSAIllegalRange					EQU		errAEImpossibleRange;;		Signaled when an object can never be set in a container.  Same as ;	  	AERegistry error errAENotModifiable.;	OSAIllegalAssign				EQU		-10003;;		Signaled when a syntax error occurs. (e.g. "Syntax error" or;	 	"<this> can't go after <that>").;	OSASyntaxError					EQU		-2740;;		Signaled when another form of syntax was expected. (e.g. "expected;	  	a <type> but found <this>").;	OSASyntaxTypeError				EQU		-2741; Signaled when a name or number is too long to be parsed OSATokenTooLong					EQU		-2742;;		Signaled when a parameter is missing for a function invocation.  Note;	  	that in some languages, this error may occur at runtime.;	OSAMissingParameter				EQU		errAEDescNotFound;;		Signaled when function is called with the wrong number of parameters,;	  	or a parameter pattern cannot be matched.;	OSAParameterMismatch			EQU		errAEWrongNumberArgs;;		Signaled when a formal parameter, local variable, or instance variable;	  	is specified more than once.;	OSADuplicateParameter			EQU		-2750;;		Signaled when a formal parameter, local variable, or instance variable;	  	is specified more than once.;	OSADuplicateProperty			EQU		-2751;;		Signaled when more than one handler is defined with the same name in ;	  	a scope where the language doesn't allow it.;	OSADuplicateHandler				EQU		-2752; Signaled when a variable is accessed that has no value OSAUndefinedVariable			EQU		-2753;;		Signaled when a variable is declared inconsistently in the same scope,;	  	such as both local and global.;	OSAInconsistentDeclarations		EQU		-2754;;		Signaled when illegal control flow occurs in an application (no catcher;	  	for throw, non-lexical loop exit, etc.).;	OSAControlFlowError				EQU		-2755;		Component-specific static script errors:;;	The range -2760 thru -2779 is reserved for component-specific parsing and;	compile-time errors. (Note that error codes from different scripting;	components in this range will overlap.);;		Dialect-specific script errors:;;	The range -2780 thru -2799 is reserved for dialect specific error codes for;	scripting components that support dialects. (Note that error codes from;	different scripting components in this range will overlap, as well as error;	codes from different dialects in the same scripting component.);;*************************************************************************;	OSA Interface Descriptions;**************************************************************************;	The OSA Interface is broken down into a required interface, and several;	optional interfaces to support additional functionality.  A given scripting;	component may choose to support only some of the optional interfaces in;	addition to the basic interface.  The OSA Component Flags may be used to ;	query the Component Manager to find a scripting component with a particular;	capability, or determine if a particular scripting component supports a ;	particular capability.;*************************************************************************; OSA Component Flags: kOSASupportsCompiling			EQU		$0002kOSASupportsGetSource			EQU		$0004kOSASupportsAECoercion			EQU		$0008kOSASupportsAESending			EQU		$0010kOSASupportsRecording			EQU		$0020kOSASupportsConvenience			EQU		$0040kOSASupportsDialects			EQU		$0080kOSASupportsEventHandling		EQU		$0100; Component Selectors: kOSASelectLoad					EQU		$0001kOSASelectStore					EQU		$0002kOSASelectExecute				EQU		$0003kOSASelectDisplay				EQU		$0004kOSASelectScriptError			EQU		$0005kOSASelectDispose				EQU		$0006kOSASelectSetScriptInfo			EQU		$0007kOSASelectGetScriptInfo			EQU		$0008kOSASelectSetActiveProc			EQU		$0009kOSASelectGetActiveProc			EQU		$000A; Compiling: kOSASelectScriptingComponentName EQU		$0102kOSASelectCompile				EQU		$0103kOSASelectCopyID				EQU		$0104; GetSource: kOSASelectGetSource				EQU		$0201; AECoercion: kOSASelectCoerceFromDesc		EQU		$0301kOSASelectCoerceToDesc			EQU		$0302; AESending: kOSASelectSetSendProc			EQU		$0401kOSASelectGetSendProc			EQU		$0402kOSASelectSetCreateProc			EQU		$0403kOSASelectGetCreateProc			EQU		$0404kOSASelectSetDefaultTarget		EQU		$0405; Recording: kOSASelectStartRecording		EQU		$0501kOSASelectStopRecording			EQU		$0502; Convenience: kOSASelectLoadExecute			EQU		$0601kOSASelectCompileExecute		EQU		$0602kOSASelectDoScript				EQU		$0603; Dialects: kOSASelectSetCurrentDialect		EQU		$0701kOSASelectGetCurrentDialect		EQU		$0702kOSASelectAvailableDialects		EQU		$0703kOSASelectGetDialectInfo		EQU		$0704kOSASelectAvailableDialectCodeList EQU		$0705; Event Handling: kOSASelectSetResumeDispatchProc	EQU		$0801kOSASelectGetResumeDispatchProc	EQU		$0802kOSASelectExecuteEvent			EQU		$0803kOSASelectDoEvent				EQU		$0804kOSASelectMakeContext			EQU		$0805; scripting component specific selectors are added beginning with this value  kOSASelectComponentSpecificStart EQU		$1001;		Mode Flags:;;	Warning: These should not conflict with the AESend mode flags in;	AppleEvents.h, because we may want to use them as OSA mode flags too.;;;		This mode flag may be passed to OSALoad, OSAStore or OSACompile to;	  	instruct the scripting component to not retain the "source" of an;	  	expression.  This will cause the OSAGetSource call to return the error;	  	errOSASourceNotAvailable if used.  However, some scripting components;	  	may not retain the source anyway.  This is mainly used when either space;	  	efficiency is desired, or a script is to be "locked" so that its;	  	implementation may not be viewed.;	kOSAModePreventGetSource		EQU		$00000001;;		These mode flags may be passed to OSACompile, OSAExecute, OSALoadExecute;	  	OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to;	  	indicate whether or not the script may interact with the user, switch;	  	layer or reconnect if necessary.  Any AppleEvents will be sent with the;	  	corresponding AESend mode supplied.;	kOSAModeNeverInteract			EQU		kAENeverInteractkOSAModeCanInteract				EQU		kAECanInteractkOSAModeAlwaysInteract			EQU		kAEAlwaysInteractkOSAModeDontReconnect			EQU		kAEDontReconnect;;		This mode flag may be passed to OSACompile, OSAExecute, OSALoadExecute;	  	OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to;	  	indicate whether or not AppleEvents should be sent with the;	  	kAECanSwitchLayer mode flag sent or not. NOTE: This flag is exactly the;	  	opposite sense of the AppleEvent flag kAECanSwitchLayer.  This is to;	  	provide a more convenient default, i.e. not supplying any mode;	  	(kOSAModeNull) means to send events with kAECanSwitchLayer.  Supplying;	  	the kOSAModeCantSwitchLayer mode flag will cause AESend to be called;	  	without kAECanSwitchLayer.;	kOSAModeCantSwitchLayer			EQU		$00000040;;		This mode flag may be passed to OSACompile, OSAExecute, OSALoadExecute;	  	OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to;	  	indicate whether or not AppleEvents should be sent with the kAEDontRecord;	  	mode flag sent or not. NOTE: This flag is exactly the opposite sense of;	  	the AppleEvent flag kAEDontRecord.  This is to provide a more convenient;	  	default, i.e. not supplying any mode (kOSAModeNull) means to send events;	  	with kAEDontRecord.  Supplying the kOSAModeDoRecord mode flag will ;	  	cause AESend to be called without kAEDontRecord.;	kOSAModeDoRecord				EQU		$00001000;;		This is a mode flag for OSACompile that indicates that a context should;	  	be created as the result of compilation. All handler definitions are;	  	inserted into the new context, and variables are initialized by;	  	evaluating their initial values in a null context (i.e. they must be;	  	constant expressions).;	kOSAModeCompileIntoContext		EQU		$00000002;;		This is a mode flag for OSACompile that indicates that the previous;	  	script ID (input to OSACompile) should be augmented with any new;	  	definitions in the sourceData rather than replaced with a new script.;	  	This means that the previous script ID must designate a context.;	  	The presence of this flag causes the kOSAModeCompileIntoContext flag;	  	to be implicitly used, causing any new definitions to be initialized;	  	in a null context.;	kOSAModeAugmentContext			EQU		$00000004;;		This mode flag may be passed to OSADisplay or OSADoScript to indicate;	  	that output only need be human-readable, not re-compilable by OSACompile.;	  	If used, output may be arbitrarily "beautified", e.g. quotes may be left;	  	off of string values, long lists may have elipses, etc.;	kOSAModeDisplayForHumans		EQU		$00000008;;		This mode flag may be passed to OSAStore in the case where the scriptID;	  	is a context.  This causes the context to be saved, but not the context's;	  	parent context.  When the stored context is loaded back in, the parent;	  	will be kOSANullScript.;	kOSAModeDontStoreParent			EQU		$00010000;;		This mode flag may be passed to OSAExecuteEvent to cause the event to;	  	be dispatched to the direct object of the event. The direct object (or;	  	subject attribute if the direct object is a non-object specifier) will;	  	be resolved, and the resulting script object will be the recipient of;	  	the message. The context argument to OSAExecuteEvent will serve as the;	  	root of the lookup/resolution process.;	kOSAModeDispatchToDirectObject	EQU		$00020000;;		This mode flag may be passed to OSAExecuteEvent to indicate that;	  	components do not have to get the data of object specifier arguments.;	kOSAModeDontGetDataForArguments	EQU		$00040000;*************************************************************************;	OSA Basic Scripting Interface;**************************************************************************;	Scripting components must at least support the Basic Scripting interface.;*************************************************************************;		Loading and Storing Scripts:;;	These routines allow scripts to be loaded and stored in their internal;	(possibly compiled, non-text) representation.;; Resource type for scripts kOSAScriptResourceType			EQU		kOSAGenericScriptingComponentSubtype;;		Default type given to OSAStore which creates "generic" loadable script;	  	data descriptors.;	typeOSAGenericStorage			EQU		kOSAScriptResourceType	IF GENERATING68K THEN		Macro		_OSALoad			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0001			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSALoad	ENDIF;;		OSAComponentFunctionInline(kOSASelectLoad, 12);;	;		Errors:;			badComponentInstance		invalid scripting component instance;			errOSASystemError;			errOSABadStorageType:		scriptData not for this scripting component;			errOSACorruptData:			data seems to be corrupt;			errOSADataFormatObsolete	script data format is no longer supported;			errOSADataFormatTooNew		script data format is from a newer version;		;		ModeFlags:;			kOSAModePreventGetSource;		IF GENERATING68K THEN		Macro		_OSAStore			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0002			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAStore	ENDIF;;		OSAComponentFunctionInline(kOSASelectStore, 16);;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;			errOSABadStorageType:	desiredType not for this scripting component;		;		ModeFlags:;			kOSAModePreventGetSource;			kOSAModeDontStoreParent;	; Executing Scripts: 	IF GENERATING68K THEN		Macro		_OSAExecute			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0003			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAExecute	ENDIF;;		OSAComponentFunctionInline(kOSASelectExecute, 16);;		This call runs a script.  The contextID represents the environment;		with which global variables in the script are resolved.  The constant;		kOSANullScript may be used for the contextID if the application wishes;		to not deal with context directly (a default one is associated with each;		scripting component instance).  The resultingScriptValueID is the ;		result of evaluation, and contains a value which may be displayed using;		the OSAGetSource call.  The modeFlags convey scripting component;		specific information.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;			errOSAScriptError:		the executing script got an error;	;		ModeFlags:;			kOSAModeNeverInteract;			kOSAModeCanInteract;			kOSAModeAlwaysInteract;			kOSAModeCantSwitchLayer;			kOSAModeDontReconnect;			kOSAModeDoRecord;	; Displaying results: 	IF GENERATING68K THEN		Macro		_OSADisplay			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0004			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSADisplay	ENDIF;;		OSAComponentFunctionInline(kOSASelectDisplay, 16);;		This call is used to convert results (script value IDs) into displayable;		text. The desiredType should be at least typeChar, and modeFlags are;		scripting system specific flags to control the formatting of the;		resulting text. This call differs from OSAGetSource in that (1) it;		always produces at least typeChar, (2) is only works on script values,;		(3) it may display it's output in non-compilable form (e.g. without;		string quotes, elipses inserted in long and/or circular lists, etc.) and;		(4) it is required by the basic scripting interface.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;			errAECoercionFail:		desiredType not supported by scripting component;	;		ModeFlags:;			kOSAModeDisplayForHumans;	; Getting Error Information: 	IF GENERATING68K THEN		Macro		_OSAScriptError			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0005			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAScriptError	ENDIF;;		OSAComponentFunctionInline(kOSASelectScriptError, 12);;		Whenever script execution returns errOSAExecutionError, this routine;		may be used to get information about that error.  The selector describes;		the type of information desired about the error (various selectors are;		listed below).  The desiredType indicates the data type of the result;		desired for that selector.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSABadSelector:		selector not supported by scripting component;			errAECoercionFail:		desiredType not supported by scripting component;	; OSAScriptError selectors: ;;		This selector is used to determine the error number of a script error.;		These error numbers may be either system error numbers, or error numbers;		that are scripting component specific.;		Required desiredTypes:	;	  		typeShortInteger;	kOSAErrorNumber					EQU		keyErrorNumber;;		This selector is used to determine the full error message associated;		with the error number.  It should include the name of the application;		which caused the error, as well as the specific error that occurred.;		This selector is sufficient for simple error reporting (but see;		kOSAErrorBriefMessage, below).;		Required desiredTypes:;			typeChar					error message string;	kOSAErrorMessage				EQU		keyErrorString;;		This selector is used to determine a brief error message associated with;		the error number.  This message and should not mention the name of the;		application which caused the error, any partial results or offending;		object (see kOSAErrorApp, kOSAErrorPartialResult and;		kOSAErrorOffendingObject, below).;		Required desiredTypes:;	  		typeChar					brief error message string;	;  0x65727262  kOSAErrorBriefMessage			EQU		'errb';;		This selector is used to determine which application actually got the;		error (if it was the result of an AESend), or the current application;		if ....;		Required desiredTypes:;	  		typeProcessSerialNumber		PSN of the errant application;	  		typeChar					name of the errant application;	;  0x65726170  kOSAErrorApp					EQU		'erap';;		This selector is used to determine any partial result returned by an ;		operation. If an AESend call failed, but a partial result was returned,;		then the partial result may be returned as an AEDesc.;		Required desiredTypes:;	  		typeBest					AEDesc of any partial result;	;  0x70746c72   kOSAErrorPartialResult			EQU		'ptlr';;		This selector is used to determine any object which caused the error;		that may have been indicated by an application.  The result is an ;		AEDesc.;		Required desiredTypes:;	  		typeBest					AEDesc of any offending object;	;  0x65726f62   kOSAErrorOffendingObject		EQU		'erob';;		This selector is used to determine the type expected by a coercion ;		operation if a type error occurred.;	;  0x65727274   kOSAErrorExpectedType			EQU		'errt';;		This selector is used to determine the source text range (start and ;		end positions) of where the error occurred.;		Required desiredTypes:;	  		typeOSAErrorRange;	;  0x65726e67  kOSAErrorRange					EQU		'erng';;		An AERecord type containing keyOSASourceStart and keyOSASourceEnd fields;	    of type short.;	;  0x65726e67   typeOSAErrorRange				EQU		'erng'; Field of a typeOSAErrorRange record of typeShortInteger ;  0x73726373    keyOSASourceStart				EQU		'srcs'; Field of a typeOSAErrorRange record of typeShortInteger ;  0x73726365   keyOSASourceEnd					EQU		'srce'; Disposing Script IDs: 	IF GENERATING68K THEN		Macro		_OSADispose			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0006			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSADispose	ENDIF;;		OSAComponentFunctionInline(kOSASelectDispose, 4);;		Disposes a script or context.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;	; Getting and Setting Script Information: 	IF GENERATING68K THEN		Macro		_OSASetScriptInfo			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0007			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSASetScriptInfo	ENDIF;;		OSAComponentFunctionInline(kOSASelectSetScriptInfo, 12);;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;			errOSABadSelector:		selector not supported by scripting component;									or selector not for this scriptID;		IF GENERATING68K THEN		Macro		_OSAGetScriptInfo			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0008			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAGetScriptInfo	ENDIF;;		OSAComponentFunctionInline(kOSASelectGetScriptInfo, 12);;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;			errOSABadSelector:		selector not supported by scripting component;									or selector not for this scriptID;	; Manipulating the ActiveProc:;;	Scripting systems will supply default values for these procedures if they;	are not set by the client:;	IF GENERATING68K THEN		Macro		_OSASetActiveProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0009			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSASetActiveProc	ENDIF;;		OSAComponentFunctionInline(kOSASelectSetActiveProc, 8);;		If activeProc is nil, the default activeProc is used.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;		IF GENERATING68K THEN		Macro		_OSAGetActiveProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$000A			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAGetActiveProc	ENDIF;;		OSAComponentFunctionInline(kOSASelectGetActiveProc, 8);;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;	;*************************************************************************;	OSA Optional Compiling Interface;**************************************************************************;	Scripting components that support the Compiling interface have the ;	kOSASupportsCompiling bit set in it's ComponentDescription.;*************************************************************************	IF GENERATING68K THEN		Macro		_OSAScriptingComponentName			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0102			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAScriptingComponentName	ENDIF;;		OSAComponentFunctionInline(kOSASelectScriptingComponentName, 4);;		Given a scripting component, this routine returns the name of that;		scripting component in a type that is coercable to text (typeChar).;		The generic scripting component returns the name of the default;		scripting component.  This name should be sufficient to convey to the;		user the kind of script (syntax) he is expected to write.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;		IF GENERATING68K THEN		Macro		_OSACompile			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0602			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSACompile	ENDIF;;		OSAComponentFunctionInline(kOSASelectCompile, 12);;		Coerces input desc (possibly text) into a script's internal format.;		Once compiled, the script is ready to run.  The modeFlags convey;		scripting component specific information.  The previous script ID;		(result parameter) is made to refer to the newly compiled script,;		unless it was originally kOSANullScript.  In this case a new script;		ID is created and used.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errAECoercionFail:		sourceData is not compilable;			errOSAScriptError:		sourceData was a bad script (syntax error);			errOSAInvalidID:		previousAndResultingCompiledScriptID was not;									valid on input;	;		ModeFlags:;			kOSAModePreventGetSource;			kOSAModeCompileIntoContext;			kOSAModeAugmentContext;			kOSAModeNeverInteract;			kOSAModeCanInteract;			kOSAModeAlwaysInteract;			kOSAModeCantSwitchLayer;			kOSAModeDontReconnect;			kOSAModeDoRecord;		IF GENERATING68K THEN		Macro		_OSACopyID			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0104			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSACopyID	ENDIF;;		OSAComponentFunctionInline(kOSASelectCopyID, 8);;		If toID is a reference to kOSANullScript then it is updated to have a;		new scriptID value.  This call can be used to perform undo or revert;		operations on scripts. ;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;	;*************************************************************************;	OSA Optional GetSource Interface;**************************************************************************;	Scripting components that support the GetSource interface have the ;	kOSASupportsGetSource bit set in it's ComponentDescription.;*************************************************************************	IF GENERATING68K THEN		Macro		_OSAGetSource			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0201			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAGetSource	ENDIF;;		OSAComponentFunctionInline(kOSASelectGetSource, 12);;		This routine causes a compiled script to be output in a form (possibly;		text) such that it is suitable to be passed back to OSACompile.;;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;			errOSASourceNotAvailable	can't get source for this scriptID;	;*************************************************************************;	OSA Optional AECoercion Interface;**************************************************************************;	Scripting components that support the AECoercion interface have the ;	kOSASupportsAECoercion bit set in it's ComponentDescription.;*************************************************************************	IF GENERATING68K THEN		Macro		_OSACoerceFromDesc			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0301			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSACoerceFromDesc	ENDIF;;		OSAComponentFunctionInline(kOSASelectCoerceFromDesc, 12);;		This routine causes script data to be coerced into a script value.;		If the scriptData is an AppleEvent, then the resultingScriptID is a;		compiled script ID (mode flags for OSACompile may be used in this case).;		Other scriptData descriptors create script value IDs.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;	;		ModeFlags:;			kOSAModePreventGetSource;			kOSAModeCompileIntoContext;			kOSAModeNeverInteract;			kOSAModeCanInteract;			kOSAModeAlwaysInteract;			kOSAModeCantSwitchLayer;			kOSAModeDontReconnect;			kOSAModeDoRecord;		IF GENERATING68K THEN		Macro		_OSACoerceToDesc			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0302			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSACoerceToDesc	ENDIF;;		OSAComponentFunctionInline(kOSASelectCoerceToDesc, 16);;		This routine causes a script value to be coerced into any desired form.;		If the scriptID denotes a compiled script, then it may be coerced to ;		typeAppleEvent.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;	;*************************************************************************;	OSA Optional AESending Interface;**************************************************************************;	Scripting components that support the AESending interface have the ;	kOSASupportsAESending bit set in it's ComponentDescription.;*************************************************************************;;	Scripting systems will supply default values for these procedures if they;	are not set by the client:;	IF GENERATING68K THEN		Macro		_OSASetSendProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0401			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSASetSendProc	ENDIF;;		OSAComponentFunctionInline(kOSASelectSetSendProc, 8);;		If sendProc is nil, the default sendProc is used.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;		IF GENERATING68K THEN		Macro		_OSAGetSendProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0402			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAGetSendProc	ENDIF;;		OSAComponentFunctionInline(kOSASelectGetSendProc, 8);;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;		IF GENERATING68K THEN		Macro		_OSASetCreateProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0403			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSASetCreateProc	ENDIF;;		OSAComponentFunctionInline(kOSASelectSetCreateProc, 8);;		If createProc is nil, the default createProc is used.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;		IF GENERATING68K THEN		Macro		_OSAGetCreateProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0404			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAGetCreateProc	ENDIF;;		OSAComponentFunctionInline(kOSASelectGetCreateProc, 8);;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;		IF GENERATING68K THEN		Macro		_OSASetDefaultTarget			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0405			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSASetDefaultTarget	ENDIF;;		OSAComponentFunctionInline(kOSASelectSetDefaultTarget, 4);;		This routine sets the default target application for AE sending.;		It also establishes the default target from which terminologies come.;		It is effectively like having an AppleScript "tell" statement around;		the entire program.  If this routine is not called, or if the target ;		is a null AEDesc, then the current application is the default target.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;	;*************************************************************************;	OSA Optional Recording Interface;**************************************************************************;	Scripting components that support the Recording interface have the ;	kOSASupportsRecording bit set in it's ComponentDescription.;*************************************************************************	IF GENERATING68K THEN		Macro		_OSAStartRecording			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0501			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAStartRecording	ENDIF;;		OSAComponentFunctionInline(kOSASelectStartRecording, 4);;		Starts recording.  If compiledScriptToModifyID is kOSANullScript, a;		new script ID is created and returned.  If the current application has;		a handler for the kOSARecordedText event, then kOSARecordedText events;		are sent to the application containing the text of each AppleEvent ;		recorded.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;			errOSARecordingIsAlreadyOn;		IF GENERATING68K THEN		Macro		_OSAStopRecording			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0502			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAStopRecording	ENDIF;;		OSAComponentFunctionInline(kOSASelectStopRecording, 4);;		If compiledScriptID is not being recorded into or recording is not;		currently on, no error is returned.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;	;*************************************************************************;	OSA Optional Convenience Interface;**************************************************************************;	Scripting components that support the Convenience interface have the ;	kOSASupportsConvenience bit set in it's ComponentDescription.;*************************************************************************	IF GENERATING68K THEN		Macro		_OSALoadExecute			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0601			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSALoadExecute	ENDIF;;		OSAComponentFunctionInline(kOSASelectLoadExecute, 16);;		This routine is effectively equivalent to calling OSALoad followed by;		OSAExecute.  After execution, the compiled source is disposed.  Only the;		resulting value ID is retained.;	;		Errors:;			badComponentInstance		invalid scripting component instance;			errOSASystemError;			errOSABadStorageType:		scriptData not for this scripting component;			errOSACorruptData:			data seems to be corrupt;			errOSADataFormatObsolete	script data format is no longer supported;			errOSADataFormatTooNew		script data format is from a newer version;			errOSAInvalidID;			errOSAScriptError:			the executing script got an error;	;		ModeFlags:;			kOSAModeNeverInteract;			kOSAModeCanInteract;			kOSAModeAlwaysInteract;			kOSAModeCantSwitchLayer;			kOSAModeDontReconnect;			kOSAModeDoRecord;		IF GENERATING68K THEN		Macro		_OSACompileExecute			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0602			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSACompileExecute	ENDIF;;		OSAComponentFunctionInline(kOSASelectCompileExecute, 16);;		This routine is effectively equivalent to calling OSACompile followed by;		OSAExecute.  After execution, the compiled source is disposed.  Only the;		resulting value ID is retained.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errAECoercionFail:		sourceData is not compilable;			errOSAScriptError:		sourceData was a bad script (syntax error);			errOSAInvalidID:		previousAndResultingCompiledScriptID was not;									valid on input;			errOSAScriptError:		the executing script got an error;	;		ModeFlags:;			kOSAModeNeverInteract;			kOSAModeCanInteract;			kOSAModeAlwaysInteract;			kOSAModeCantSwitchLayer;			kOSAModeDontReconnect;			kOSAModeDoRecord;		IF GENERATING68K THEN		Macro		_OSADoScript			dc.w 	$2F3C			dc.w 	$0014			dc.w 	$0603			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSADoScript	ENDIF;;		OSAComponentFunctionInline(kOSASelectDoScript, 20);;		This routine is effectively equivalent to calling OSACompile followed by;		OSAExecute and then OSADisplay.  After execution, the compiled source;		and the resulting value are is disposed.  Only the resultingText;		descriptor is retained.  If a script error occur during processing, the ;		resultingText gets the error message of the error, and errOSAScriptError;		is returned.  OSAScriptError may still be used to extract more ;		information about the particular error.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errAECoercionFail:		sourceData is not compilable or ;									desiredType not supported by scripting component;			errOSAScriptError:		sourceData was a bad script (syntax error);			errOSAInvalidID:		previousAndResultingCompiledScriptID was not;									valid on input;			errOSAScriptError:		the executing script got an error;	;		ModeFlags:;			kOSAModeNeverInteract;			kOSAModeCanInteract;			kOSAModeAlwaysInteract;			kOSAModeCantSwitchLayer;			kOSAModeDontReconnect;			kOSAModeDoRecord;			kOSAModeDisplayForHumans;	;*************************************************************************;	OSA Optional Dialects Interface;**************************************************************************;	Scripting components that support the Dialects interface have the ;	kOSASupportsDialects bit set in it's ComponentDescription.;*************************************************************************;;	These calls allows an scripting component that supports different dialects;	to dynamically switch between those dialects.  Although this interface is;	specified, the particular dialect codes are scripting component dependent.;	IF GENERATING68K THEN		Macro		_OSASetCurrentDialect			dc.w 	$2F3C			dc.w 	$0002			dc.w 	$0701			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSASetCurrentDialect	ENDIF;;		OSAComponentFunctionInline(kOSASelectSetCurrentDialect, 2);;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSANoSuchDialect:	invalid dialectCode;		IF GENERATING68K THEN		Macro		_OSAGetCurrentDialect			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0702			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAGetCurrentDialect	ENDIF;;		OSAComponentFunctionInline(kOSASelectGetCurrentDialect, 4);;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;		IF GENERATING68K THEN		Macro		_OSAAvailableDialects			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0703			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAAvailableDialects	ENDIF;;		OSAComponentFunctionInline(kOSASelectAvailableDialects, 4);;		This call return an AEList containing information about each of the;		currently available dialects of a scripting component.  Each item;		is an AERecord of typeOSADialectInfo that contains at least the fields;		keyOSADialectName, keyOSADialectCode, KeyOSADialectLangCode and ;		keyOSADialectScriptCode.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;		IF GENERATING68K THEN		Macro		_OSAGetDialectInfo			dc.w 	$2F3C			dc.w 	$000A			dc.w 	$0704			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAGetDialectInfo	ENDIF;;		OSAComponentFunctionInline(kOSASelectGetDialectInfo, 10);;		This call gives information about the specified dialect of a scripting;		component. It returns an AEDesc whose type depends on the selector ;		specified. Available selectors are the same as the field keys for a;		dialect info record. The type of AEDesc returned is the same as the ;		type of the field that has same key as the selector.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;		 	errOSABadSelector;			errOSANoSuchDialect:	invalid dialectCode;		IF GENERATING68K THEN		Macro		_OSAAvailableDialectCodeList			dc.w 	$2F3C			dc.w 	$0004			dc.w 	$0705			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAAvailableDialectCodeList	ENDIF;;		OSAComponentFunctionInline(kOSASelectAvailableDialectCodeList, 4);;		This is alternative to OSAGetAvailableDialectCodeList. Use this call;		and  OSAGetDialectInfo to get information on dialects.;		This call return an AEList containing dialect code for each of the;		currently available dialects of a scripting component. Each dialect;		code is a short integer of type typeShortInteger.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;;		Type of a dialect info record containing at least keyOSADialectName;		and keyOSADialectCode fields.;;		keys for dialect info record, also used as selectors to OSAGetDialectInfo.;;		Field of a typeOSADialectInfo record of typeChar.;		Field of a typeOSADialectInfo record of typeShortInteger.;		Field of a typeOSADialectInfo record of typeShortInteger.;		Field of a typeOSADialectInfo record of typeShortInteger.;	;*************************************************************************;	OSA Optional Event Handling Interface;**************************************************************************;	Scripting components that support the Event Handling interface have the ;	kOSASupportsEventHandling bit set in it's ComponentDescription.;*************************************************************************	IF GENERATING68K THEN		Macro		_OSASetResumeDispatchProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0801			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSASetResumeDispatchProc	ENDIF;;		OSAComponentFunctionInline(kOSASelectSetResumeDispatchProc, 8);;		This function is used to set the ResumeDispatchProc that will be used;		by OSAExecuteEvent and OSADoEvent if either no event handler can be;		found in the context, or the context event hander "continues" control;		onward. The two constants kOSAUseStandardDispatch and kOSANoDispatch;		may also be passed to this routine indicating that the handler registered;		in the application with AEInstallEventHandler should be used, or no;		dispatch should occur, respectively.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;	kOSAUseStandardDispatch			EQU		kAEUseStandardDispatch;;		Special ResumeDispatchProc constant which may be passed to ;		OSASetResumeDispatchProc indicating that the handler registered;		in the application with AEInstallEventHandler should be used.;		;		NOTE:	Had to remove the cast (AEEventHandlerUPP).  The C compiler;				doesn't allow pointer types to be assigned to an enum.  All;				constants must be assigned as enums to translate properly to;				Pascal.;	kOSANoDispatch					EQU		kAENoDispatch;;		Special ResumeDispatchProc constant which may be passed to ;		OSASetResumeDispatchProc indicating that no dispatch should occur.;		;		NOTE:	Had to remove the cast (AEEventHandlerUPP).  The C compiler;				doesn't allow pointer types to be assigned to an enum.  All;				constants must be assigned as enums to translate properly to;				Pascal.;	kOSADontUsePhac					EQU		$0001;;		Special refCon constant that may be given to OSASetResumeDispatchProc;		only when kOSAUseStandardDispatch is used as the ResumeDispatchProc.;		This causes the standard dispatch to be performed, except the phac;		handler is not called.  This is useful during tinkerability, when;		the phac handler is used to lookup a context associated with an event's ;		direct parameter, and call OSAExecuteEvent or OSADoEvent.  Failure to;		bypass the phac handler would result in an infinite loop.;		IF GENERATING68K THEN		Macro		_OSAGetResumeDispatchProc			dc.w 	$2F3C			dc.w 	$0008			dc.w 	$0802			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAGetResumeDispatchProc	ENDIF;;		OSAComponentFunctionInline(kOSASelectGetResumeDispatchProc, 8);;		Returns the registered ResumeDispatchProc.  If no ResumeDispatchProc has;		been registered, then kOSAUseStandardDispatch (the default) is returned.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;		IF GENERATING68K THEN		Macro		_OSAExecuteEvent			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0803			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAExecuteEvent	ENDIF;;		OSAComponentFunctionInline(kOSASelectExecuteEvent, 16);;		This call is similar to OSAExecute except the initial command to;		execute comes in the form of an AppleEvent.  If the contextID;		defines any event handlers for that event, they are used to process;		the event.  If no event handler can be found in the context;		errAEEventNotHandled is returned.  If an event handler is found and;		the hander "continues" control onward, the ResumeDispatchProc;		(registered with OSASetResumeDispatchProc, above) is called given the;		AppleEvent.  The result is returned as a scriptValueID.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;			errOSAScriptError:		the executing script got an error;			errAEEventNotHandled:	no handler for event in contextID;	;		ModeFlags:;			kOSAModeNeverInteract;			kOSAModeCanInteract;			kOSAModeAlwaysInteract;			kOSAModeCantSwitchLayer;			kOSAModeDontReconnect;			kOSAModeDoRecord;		IF GENERATING68K THEN		Macro		_OSADoEvent			dc.w 	$2F3C			dc.w 	$0010			dc.w 	$0804			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSADoEvent	ENDIF;;		OSAComponentFunctionInline(kOSASelectDoEvent, 16);;		This call is similar to OSADoScript except the initial command to;		execute comes in the form of an AppleEvent, and the result is an ;		AppleEvent reply record.  If the contextID defines any event handlers;		for that event, they are used to process the event.  If no event handler;		can be found in the context errAEEventNotHandled is returned.  If an;		event handler is found and the hander "continues" control onward, the;		ResumeDispatchProc (registered with OSASetResumeDispatchProc, above) is;		called given the AppleEvent.  The result is returned in the form of an;		AppleEvent reply descriptor. If at any time the script gets an error, or;		if the ResumeDispatchProc returns a reply event indicating an error,;		then the OSADoEvent call itself returns an error reply (i.e. OSADoEvent;		should never return errOSAScriptError).  Any error result returned by;		the ResumeDispatchProc will be returned by OSADoEvent.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;			errAEEventNotHandled:	no handler for event in contextID;	;		ModeFlags:;			kOSAModeNeverInteract;			kOSAModeCanInteract;			kOSAModeAlwaysInteract;			kOSAModeCantSwitchLayer;			kOSAModeDontReconnect;			kOSAModeDoRecord;		IF GENERATING68K THEN		Macro		_OSAMakeContext			dc.w 	$2F3C			dc.w 	$000C			dc.w 	$0805			moveq	#0,d0			dc.w 	$A82A		EndM	ELSE		IMPORT	OSAMakeContext	ENDIF;;		OSAComponentFunctionInline(kOSASelectMakeContext, 12);;		Makes a new empty context which may be passed to OSAExecute or ;		OSAExecuteEvent.  If contextName is typeNull, an unnamed context is;		created. If parentContext is kOSANullScript then the resulting context;		does not inherit bindings from any other context.;	;		Errors:;			badComponentInstance	invalid scripting component instance;			errOSASystemError;			errOSAInvalidID;			errAECoercionFail:		contextName is invalid;		ENDIF ; __OSA__