;;	File:		CodeFragments.a;;	Copyright:	© 1984-1994 by Apple Computer, Inc.;				All rights reserved.;;	Version:	Universal Interfaces 2.0a3  ETO #16, MPW prerelease.  Friday, November 11, 1994. ;;	Bugs?:		If you find a problem with this file, send the file and version;				information (from above) and the problem description to:;;					Internet:	apple.bugs@applelink.apple.com;					AppleLink:	APPLE.BUGS;;	IF &TYPE('__CODEFRAGMENTS__') = 'UNDEFINED' THEN__CODEFRAGMENTS__ SET 1	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN	include 'Types.a'	ENDIF;		include 'ConditionalMacros.a'								;	IF &TYPE('__FILES__') = 'UNDEFINED' THEN	include 'Files.a'	ENDIF;		include 'MixedMode.a'										;;		include 'OSUtils.a'										;;			include 'Memory.a'										;kCFragResourceType				EQU		'cfrg'kCFragResourceID				EQU		0kCFragLibraryFileType			EQU		'shlb'kPowerPCCFragArch				EQU		'pwpc'kMotorola68KCFragArch			EQU		'm68k'kAnyCFragArch					EQU		$3F3F3F3FkLoadCFrag						EQU		$01					; Try to use existing copy, load if not found.kFindCFrag						EQU		$02					; Try find an existing copy, don't load if not found.kNewCFragCopy					EQU		$05					; Load a new copy whether one already exists or not.kInplaceCFrag					EQU		$80					; Use data sections directly in the container.kUnresolvedCFragSymbolAddress	EQU		0kCodeCFragSymbol				EQU		0kDataCFragSymbol				EQU		1kTVectorCFragSymbol				EQU		2kTOCCFragSymbol					EQU		3kGlueCFragSymbol				EQU		4kImportLibraryCFrag				EQU		0					; Standard CFM import library.kApplicationCFrag				EQU		1					; Macintosh application.kDropInAdditionCFrag			EQU		2					; Private extension to an application or library.kIsCompleteCFrag				EQU		0					; A "base" fragment, not an update.kFirstCFragUpdate				EQU		1					; The first update, others are numbered 2, 3, ...kMemoryCFragLocator				EQU		0					; Container is already addressable.kDataForkCFragLocator			EQU		1					; Container is in a file's data fork.kResourceCFragLocator			EQU		2					; Container is in a file's resource fork.kCFragGoesToEOF					EQU		0CFragOldMemoryLocator 	RECORD	0address					 ds.l	1length					 ds.l	1inPlace					 ds.b	1reserved3a				 ds.b	3									; ! Do not use this!sizeof					 EQU	12						ENDRCFragHFSDiskFlatLocator RECORD	0fileSpec				 ds.l	1offset					 ds.l	1length					 ds.l	1sizeof					 EQU	12						ENDR; ! This must have a file specification at the same offset as a data fork locator!CFragHFSSegmentedLocator RECORD	0fileSpec				 ds.l	1rsrcType				 ds.l	1rsrcID					 ds.w	1reserved2a				 ds.w	1									; ! Do not use this!sizeof					 EQU	12						ENDRCFragHFSLocator 		RECORD	0where					 ds.l	1									; Really of type CFragLocatorKind.VariantLevel0Begin		EQU	*onDisk					 ds		CFragHFSDiskFlatLocator			; First so debugger shows this form.						ORG		VariantLevel0BegininMem					 ds.l	3						ORG		VariantLevel0BegininSegs					 ds.l	3sizeof					 EQU	16						ENDR; -------------------------------------------------------------------------------------------; The parameter block passed to fragment initialization functions.  The locator and name; pointers are valid only for the duration of the initialization routine.  I.e. if you want; to save the locator or name, save the contents, not the pointers.  Initialization routines; take one parameter, a pointer to the parameter block, and return a success/failure result.; ! Note that the initialization function returns an OSErr.  Any result other than noErr will; ! cause the entire load to be aborted at that point.CFragInitBlock 			RECORD	0contextID				 ds.l	1closureID				 ds.l	1connectionID			 ds.l	1fragLocator				 ds.l	4libName					 ds.l	1reserved4a				 ds.l	1									; ! Do not use this!reserved4b				 ds.l	1									; ! Do not use this!reserved4c				 ds.l	1									; ! Do not use this!reserved4d				 ds.l	1									; ! Do not use this!sizeof					 EQU	48						ENDR; ¤; ===========================================================================================; Routines; ========	IF GENERATING68K THEN		Macro		_GetSharedLibrary			move.w	#$0001,-(sp)			dc.w 	$AA5A		EndM	ELSE		IMPORT	GetSharedLibrary	ENDIF	IF GENERATING68K THEN		Macro		_GetDiskFragment			move.w	#$0002,-(sp)			dc.w 	$AA5A		EndM	ELSE		IMPORT	GetDiskFragment	ENDIF	IF GENERATING68K THEN		Macro		_GetMemFragment			move.w	#$0003,-(sp)			dc.w 	$AA5A		EndM	ELSE		IMPORT	GetMemFragment	ENDIF	IF GENERATING68K THEN		Macro		_CloseConnection			move.w	#$0004,-(sp)			dc.w 	$AA5A		EndM	ELSE		IMPORT	CloseConnection	ENDIF	IF GENERATING68K THEN		Macro		_FindSymbol			move.w	#$0005,-(sp)			dc.w 	$AA5A		EndM	ELSE		IMPORT	FindSymbol	ENDIF	IF GENERATING68K THEN		Macro		_CountSymbols			move.w	#$0006,-(sp)			dc.w 	$AA5A		EndM	ELSE		IMPORT	CountSymbols	ENDIF	IF GENERATING68K THEN		Macro		_GetIndSymbol			move.w	#$0007,-(sp)			dc.w 	$AA5A		EndM	ELSE		IMPORT	GetIndSymbol	ENDIF	IF OLDROUTINENAMES  THENkPowerPCArch					EQU		kPowerPCCFragArchkMotorola68KArch				EQU		kMotorola68KCFragArchkAnyArchType					EQU		kAnyCFragArchkNoLibName						EQU		0kNoConnectionID					EQU		0kLoadLib						EQU		kLoadCFragkFindLib						EQU		kFindCFragkLoadNewCopy					EQU		kNewCFragCopykUseInPlace						EQU		kInplaceCFragkCodeSym						EQU		kCodeCFragSymbolkDataSym						EQU		kDataCFragSymbolkTVectSym						EQU		kTVectorCFragSymbolkTOCSym							EQU		kTOCCFragSymbolkGlueSym						EQU		kGlueCFragSymbolkInMem							EQU		kMemoryCFragLocatorkOnDiskFlat						EQU		kDataForkCFragLocatorkOnDiskSegmented				EQU		kResourceCFragLocatorkIsLib							EQU		kImportLibraryCFragkIsApp							EQU		kApplicationCFragkIsDropIn						EQU		kDropInAdditionCFragkFullLib						EQU		kIsCompleteCFragkUpdateLib						EQU		kFirstCFragUpdatekCFMRsrcType					EQU		kCFragResourceTypekCFMRsrcID						EQU		kCFragResourceIDkSHLBFileType					EQU		kCFragLibraryFileTypekUnresolvedSymbolAddress		EQU		kUnresolvedCFragSymbolAddresskPowerPC						EQU		kPowerPCCFragArchkMotorola68K					EQU		kMotorola68KCFragArch	ENDIF	ENDIF ; __CODEFRAGMENTS__