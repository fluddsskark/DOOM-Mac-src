Welcome to Kibitz for PowerPC.January 10, 1994For those of you familiar with earlier ports for PowerPC, this is an entirely new port.There were two main reasons for doing a new port:1) Take advantage of all the features of the latest version of Kibitz, such as textto speech.2) Make best advantage of the Universal Interfaces so that there is a single commoncode base for both 68K and PowerPC.The makefiles allow you to build a 68K only version, a PowerPC only version or a"fat" version containing both 68K and PowerPC so it will run natively on either platform.A good first step for preparing to port to PowerPC is to compile for 68K using theUniversal Interfaces, so this version of Kibitz should be instructive even if youdon't have immediate access to PowerPC.Detailed build instructions are below, but first a note on makefiles - the MPW makefacility doesn't lend itself that well to building multiple targets from the sameset of sources.  A variety of approaches are possible and different approaches maybe better for different situations.  This sample takes a couple of different approaches,but some common hints are useful:Default build rules.  Without default build rules, you need to specify exactly how tocompile your source files.  MPW has built-in default build rules for MPW C which specifythat files ending in .c.o are built from files ending in .c.  That's great for MPW C, butwhat about PPCC, the PowerPC compiler.  These makefiles add additional build rules whichspecify that files ending in .o are built from .c using PPCC.  This simplifies makefiles a lot.  See the individual makefiles for more information.Directory dependency rules - These are particularly useful for keeping your buildsorganized.  These samples use separate build directories for 68K and PowerPC to keepthings organized and to minimize clutter in the source directories.  Directory dependencyrules let Make handle that for you.Abstract targets - An abstract target has no build rules, just dependencies.  So anabstract target doesn't build anything itself, but is implicitly built as a resultof the dependencies.  It's useful for helping organize makefiles and to create makefilesthat are easily retargetable.  For example, the Kibitz makefile has the following abstractrule:AppPPC				Ä	{AppName}.pefAppPPC is not a real target and is never actually built because there are no rules to build it.  But Kibitz depends on it, so building Kibitz means "building" AppPPC, whichmeans building {AppName}.pef (i.e. Kibitz.pef), which has its own build rule.Approaches to makefiles-----------------------This code is organized into two separate directories:DTS.Lib - A collection of functions useful for multiple purposes.  Some, but not all, of          this code is required to build Kibitz. Note that there is a sub-folder CDEFs.		  This comes pre-built.Kibitz  - The source code for Kibitz itself.Two different approaches were used in these makefiles.  DTS.Lib doesn't generate an application, just object code collected into libraries.  Rather than creatingmultiple makefiles for multiple targets, multiple targets are included in the makefile.The desired build target is selected by specifying the target on the Make command line.The makefiles support building: 68K, PowerPC, or "fat" versions.  MPW scripts simplifythe build process by calling Make with the right command line options. The DTS.Lib codeis broken up into a series of small code libraries.  Not all of these libraries are requiredby Kibitz, but the DTS.Lib make scripts build them all anyway.  If all you want to do isbuild Kibitz, you may want to simplify the scripts to only build the libraries you need.That's left as an exercise for the reader.  [Look for future PowerPC samples based on DTSsample code that does use the remaining parts of DTS.Lib on a future developer CD or SDK.]The Kibitz makefile builds the actual Kibitz application.  This presented a problem because what is really needed is a makefile that can build the same target (Kibitz)three different ways, 68K only, PowerPC only and "fat".  That's impossible to do, sothis makefile builds the "fat" version by default.  But changing a single dependencyrule lets you build either of the other versions.  See the makefile for more information.Build instructions.-------------------Kibitz depends upon QuickTime and Speech libraries and headers.  Before building Kibitz,you must install these into your MPW environment.  Refer to the document:"More SystemInterfaces:More Interfaces - Read Me First".  You will need to install headersand libraries into {CIncludes} and {PPCLibraries} as well as add extensions to yourPowerPC.The libraries in the DTS.Lib folder must be built first.  The folder DTS.Lib contains three separate build scripts:DTS.Lib_all.makeDTS.Lib_all.PPC.makeDTS.Lib_all.fat.makeThese aren't really makefiles, just build scripts that build the 68K, PowerPC and "fat"version respectively.They invoke the following makefiles to build the individual libraries:DTS.Lib_controls.makeDTS.Lib_ctlhandler.makeDTS.Lib_framework.makeDTS.Lib_strings.makeDTS.Lib_treeobj.makeDTS.Lib_utils.makeThe following subfolders of DTS.Lib must exist before you try to build these libraries:OBJECT -- This contains the 68K object filesOBJECTPPC - This contains the PowerPC object filesAfter building the DTS.Lib files, set the directory to the Kibitz folder and makeKibitz.  By default, this makes a "fat" application.  Follow the directions in themakefile if you wish to build a 68K only or PowerPC only version.The following subfolders of Kibitz must exist before you try to build these libraries:OBJECT -- This contains the 68K object filesOBJECTPPC - This contains the PowerPC object filesEnjoy!-----Known bugs (bugs specific to the PowerPC version):Optimized builds using PPCC do not work.Aggregate initialization - In some cases, static initialization of aggregate data structures is not handled correctly by PPCC.  Kibitz has a very large structure,newDocData, and this structure must be initialized at runtime, rather than atcompile time.  So this isn't really a bug, but a workaround for the compiler.There is currently no way to detect the presence of a native PowerPC speech library.The right way will be with Gestalt.  Kibitz is "weak" linked to the speech library, soit will work in the absence of the speech library.  But if you happen to have a versionof the Speech Manager and don't have the native library and try to use speech features,Kibitz will check and find out that the Speech Manager is present and just assume thatthe native speech library is also present and crash.  A future version will have thecorrect test for the speech library.