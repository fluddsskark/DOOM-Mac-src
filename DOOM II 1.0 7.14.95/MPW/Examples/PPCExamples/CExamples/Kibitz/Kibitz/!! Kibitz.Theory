The area that needs most explaining in Kibitz is the AppleEvents stuff.  Thisturned out to be trickier than I had thought it would be.  It wasn't creatingor sending the AppleEvents that was difficult.  This turned out to be rathereasy.  The problem was the hand-shaking necessary to keep the game(s) in syncon each machine.The first version sent the entire game when a two-player session wasestablished.  Moves were then sent from that point.  The first version alsohad undo/redo capability so that a user could back up the game a bit, and thenafter reviewing a previous position, redo forward to the current position.  Isent these undo/redo events to the other player, as well as regular moves.The reason that these undo/redo events were sent is so that the two gameswould always be in sync.  The problem was that, just as one player was movinga piece, the other player could undo a move.  These messages would cross eachother in transmission, and when recieved, would be processed.  This could (anddid) cause the two board positions to not be in sync.  Obviously, some form ofhand-shaking was necessary.What I chose to do was to always transmit the entire game.  In sending a newgame, I could then use a scrollbar to view previous positions.  By sendingthe entire game, I gained random access to any position in the game.Of course, once I added the slider (custom scrollbar), then there was theproblem that both players could be scrolling at the same time.  Each machinewould be sending lots of AppleEvents, and neither one would be payingattention to them.  They would just queue up, and when the scrollbars werefinally released, the board position events would be processed.  Thisprocessing of lots of queued events would cause the board to jump from oneposition to another, and then finally settle down when all the events werereceived and handled.This simultaneous scrolling also caused the board positions to be out of sync.That's when I decided that I needed a creator of the game.  (The creatormachine is the machine that initiated the game.)  The creator echos changesback to the other player.  This would guarantee that if the two boardpositions got out of sync, that they would get synced up again.  There is noway to prevent them from getting out of sync, since the users can be scrollingat each end at the same time.This echoing by the creator solved a lot of problems.  For example:  There isa resign button that you can push if you wish to throw in the towel.  It ispossible that both users could do this at the same time.  A resign message issent to the other machine.  Both players get the message that the opponentresigned.  So, who won?  The creator machine echos what it received, whichmay change the state of the other machine.  This echoing of resignationmessages guarantees that only one player can resign.This should help you understand why I am sending the kind of events that Iam, and some of the decisions that I made as to how to do stuff.  The restof the application is rather straightforward application stuff, althoughthere is a lot of code.  I think (hope) that there are enough comments inthe code to explain everything.Eric Soldan