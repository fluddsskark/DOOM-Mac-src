Changed the framework and the AppsToGo editor to use the min/max fields for TextEditcontrols.  The min field is used for selStart, and the max field is used for selEnd.This allows you to determine if a TextEdit control should initially have its textselected or not, without having to write code to do it.__________Fixed double-dispose of a handle problem when saving 'WIND' size to a non-existant'WIND' resource.  This only occured when using the AppsToGo editor.__________Added feature in File2.c where if the first character of the enumerated window titleis a space, then it uses the 'WIND' window title instead.  This allows commentingof document definitions when using the AppsToGo editor.__________Extensively changes ListControl.c to support variable-size cells.  If you want a Listcontrol with variable-size cells, then you need to call CLVInitialize() at some pointprior to creating a variable-size cell list.  You can convert an existing list controlto a variable-size cell list control by calling CLVVariableSizeCells(), which callsCLVInitialize().Various improvements have been made in the operation of the regular list control.Changed Window2.c to pay attention to bit 14 of the List control mode field.  If thisis set, then it creates the control, and then converts it to a variable-size cell list.__________Where and when DoOpenApplication() is called has changed.  It is now called by theapplication in Start.c, and also when AppsToGo tells it to apply changes and restartthe application.  It no longer calls it on an 'oapp' event.__________The Kibitz feature of a document remembering what remote application is was connected toand launching that remote application when the document is opened has been added toDTS.Lib.  The calls to manage this that have been added are:void			GetFullPathAndAppName(StringPtr path, StringPtr app);void			AllowAutoReconnect(FileRecHndl frHndl);pascal Boolean	AEPortFilter(LocationNamePtr locationName, PortInfoPtr thePortInfo);OSErr			LaunchRemoteApp(FileRecHndl frHndl);Descriptions of the functions can be found in the header file DTS.Lib.protos.h.The sample application DTS.StyleChat uses this functionality.  Refer to it for how touse the new calls.__________BAD BUG FIXED!!TreeObj.c could try to fetch a long from an odd address, which causes address errorson 68000-based machines.  This has been fixed.The odds of this happening weren't too good, and therefore it wasn't caught.  Sorry.DTS.Draw, which is the sample that uses TreeObj the most, has objects whose dataSizeis always even, since it is based on sizeof(theStruct).  Structs are padded to beeven in size.  If the data size is even, then all is well.  If it is odd, then thechild handle table immediately following the data area of the objects is alignedto odd addresses.  When the handle (long) was fetched, an address error occured.BlockMove is now used to get the long values, so no address errors occur anymore.__________UnmapMenuItem() has been changed to return an invalid menu item number (32767) if there isa remapping table, but the remapping table has no entry for the given menu item number.This prevents accidental overlaping of menu item values.If you either have no table for a particular menu, or if all entries are in the table,then there is no functional difference.  The only possible difference is if you call itfor a menu item that doesn't exist.  It used to simply return the value that was passedin, and that value could be used as a valid value.__________The TextEdit control has been revised to support the TSMTE init.  If the TSMTE initis available, then the TextEdit control can support inline-input of double-byte text.HOWEVER:  You must make a call to the TextEdit control to inform it that you want it		  to use TSMTE, or else you will not get this benefit.  Also, you must register		  and unregister your application with the TextServoces Manager if you want		  to use TSMTE, or else you will crash.Start.c now calls InitTSMAwareApplication() and CloseTSMAwareApplication().  This is doneconditionally -- only if the TSMTE init is available.  As part of the startup code, youneed the following to initialize TSM:	if(CTEUseTSMTE())		InitTSMAwareApplication();And as part of the shutdown code, you need the following:	if(CTEUseTSMTE())		CloseTSMAwareApplication();CTEUseTSMTE checks to see if TSMTE is available.  If it is, it returns true.(It is only available if TSM is available.)  If TSMTE is available, then youneed to register and unregister your application with the TextServices Manager.This is all you need to do to your application to support double-byte inline-input.__________The popup CDEF can't handle negative coordinates.  This meant that popups couldn't beput in sidebars, as AppsToGo distinguishes location of controls by their coordinates.(Sidebar controls are offset -16384 horizontally.)CtlHandler.c, Utilities.c, and Window2.c were modified to handle popup controls specially.The control must first be created to be a problem, and therefore Window2.c keeps trackof the ctlDefProc of popup controls for comparison purposes.  The ctlDefProc is storedin the global gPopupProc.  CtlHandler.c and Utilities.c look at this golbal and compareit to the ctlDefProc of the control to be drawn or tracked.  If it matches, the port'sorigin is set to 0,0, and the control is offset to that location.  When the drawing ortracking is completed, everything is restored.This allows the popup control to be positioned in negative coordinate space, but stilloperate.__________Two procs (plus 4 fields) have been added to the control style (extension) record.These procs are for the purpose of custom tracking of the control.  The prototypes are:typedef Boolean (*TrackControlProcPtr)(ControlHandle ctl, short part, EventRecord *event);typedef Boolean (*ScrollProcPtr)(ControlHandle ctl, short part, short oldVal, short newVal);The TrackControlProcPtr is set to nil, except if the control is a scrollbar.  If it is ascrollbar, then it is set to the static function (in Window2.c) DefaultScroll().  Thisfunction handles the scrolling in a generic way.  The page and line areas of the scrollbarscroll by 10 pixels and 1 pixel, respectively.  If you wish, you can set the values tosomething else.  The values are stored in the ControlStyleInfo record of the styled control.typedef struct ControlStyleInfo {	short				ctlID;	TrackControlProcPtr	trackProc;	ScrollProcPtr		scrollProc;	short				hArrowVal;	short				vArrowVal;	short				hPageVal;	short				vPageVal;	short				fontSize;	Style				fontStyle;	Str32				font;	Str63				keyEquivs;	Str255				balloonHelp;} ControlStyleInfo;The initial values are set to 0, and if they are 0, the defaults of 10 and 1 are used.For scrollbars, the trackProc field is initialized to DefaultScroll().  The scrollProcfield is set to nil.  If you want an opportunity to do something while the scrollbaris tracking, set the scrollProc field to non-nil.  Your function will be called withthe control, part # (thumb, or whatever), the old control value, and the new controlvalue.  This should be enough information to determine what you want to do.To set the trackProc, scrollProc, hArrowVal, vArrowVal, hPageVal, or vPageVal fields, youwould add some code to the InitContent() proc for the document.  It would be something like:OSErr	InitContent(FileRecHndl frHndl, WindowPtr window){	OSErr				err;	ControlHandle		ctl;	ControlStyleInfo	cinfo;	err = AddControlSet(window, (*frHndl)->fileState.sfType, kwStandardVis, 0, 0, nil);		/* First, add the controls for this document as defined with AppsToGo. */	if (!err) {										/* If all is well... */		CNum2Ctl(window, kScrollbarID, &ctl);		/* Get the scrollbar handle. */		if (ctl) {			if (GetControlStyle(ctl, &cinfo)) {		/* Get the scrollbar info record. */				cinfo.scrollProc = YourScrollProc;	/* Set the fields you want. */				cinfo.hArrowVal = 2;				cinfo.hPageVal  = 20;				err = SetControlStyle(ctl, &cinfo);	/* Save the modified record in the control. */			}		}	}	return(err);}__________The maxTextLen field of the CTENewInfo structure has an additional meaning.  If thevalue is less than 1, then the negative of the value is used, and the destRct, viewRct,and brdrRct fields are deltas from the control rect, instead of absolute rects.  Thisedits better in the AppsToGo editor.  Before, if a TextEdit control's size was changed,the destRct, viewRct, and brdrRct fields had to be adjusted accordingly.  However, thiswas done only if the object was resized with the mouse.  If values were typed in forthe control rect, then it was assumed that these were to be edited individually.  Also,the rect could be sized with the mouse such that when the other rects were adjusted, theycould end up being empty rects.  This caused incorrect rect values from then on.AppsToGo has been modified to handle both positive and negative values for the maxTextLenfield.  Also, the new method of delta rects is the primary method, and therefore the signof the maxTextLen field is actually displayed and interpreted backwards.  For the most part,this can be ignored.  Here are the rules:If the maxTextLen value in the AppsToGo application editor is greater than 0, then thedestRct, viewRct, and brdrRct values are added to the control rect, and the result isthen used.If the maxTextLen value in the AppsToGo application editor is less than 1, then thecontrol's destRct, viewRct, and brdrRct fields are absolute rects, and will be used asthey are displayed.  Note that when the framework creates a TextEdit control based onthis definition, it will use the absolute value of the maxTextLen field.__________GetNextWindow (and therefore GetNextDocument) have been modified to returninvisible windows (or documents with invisible windows).  This change was madeto allow kHideOnClose windows to not have to be saved in a global.  You canaccess the window or document by calling one of the above functions now, evenif the window is curently hidden.__________The document procs for reading and writing the default document header are nolonger initialized in File2.c.  They are left nil.  This means that you will nolonger get reading and writing the default document header information as adefault behavior.HOWEVER:If you call DefaultInitDocument, they are set as they were before.  This means thatif you still want this behavior and you use the hierarchical document package, thenyou will still get the benefit of reading and writing the default document header.If you want to use the default document header facilities without the hierarchicaldocument package, simply initialize the procs for reading and writing the headeryourself in your own document initialization code.  You would add the followingtwo lines (assuming that the document variable is called frHndl):	(*frHndl)->fileState.readDocumentHeaderProc  = DefaultReadDocumentHeader;	(*frHndl)->fileState.writeDocumentHeaderProc = DefaultWriteDocumentHeader;This will give you the behavior you want.The reason for the change is that some documents want the standard header and some don't.By explicitly setting them within the framework meant that the code got linked in, evenif you then later set the procs to nil (because you didn't want the header).  This causeddead code to get linked in.  By assuming that the header isn't going to be used, and byhaving the application stating that they will indeed be used, we can prevent this deadcode from getting linked in.Again, if you call DefaultInitDocument, you do indeed get the header information.  This isdone because it isn't a bad assumption to make.  If you are calling DefaultInitDocument,you want things handled for you, and this would include the header information.  If you aredoing something custom, then you want more control.__________