Introduction------------ModApp is a "modular" application written by Richard Clark of Apple'sDeveloper University. ModApp serves as a demonstration and test bedfor loading external code modules into an application. ModApp can loadPowerPC modules from the data fork of a file or from a resource,and can load 68K code from a resource.(Note: The terms "tool" and "module" are used interchangably throughoutthis document.)Some of the things that ModApp demonstrates are:	¥ÊUsing CFM for conventional shared libraries (GWorldTools)	¥ Using CFM for custom additions (PowerPC modules)	¥ Calling 68K code directly	¥ Using MixedMode for Toolbox callbacks (Apple events support)The code is portable between the PowerPC compilers, THINK C, and CodeWarrior from Metrowerks. ModApp can be built in a 68K version, a PowerPCor as a "fat binary" which incorporates both. The few instances wherethe PowerPC code deviates from the 68K code (declaring the "qd" global,creating a UniversalProcPtr for callbacks) are surrounded by "#ifdef powerc".(which is declared for all PowerPC compilers for the Macintosh.)Building ModApp---------------ModApp has an MPW make file to build it and all tools. The default makefile builds "fat" versions of the application and all tools.	¥ÊBuilding "all" will build a "fat" version of the app and all tools	¥ Building "ModApp" creates a "fat" version of the app, while 	  building "ModApp.68K" makes a 68K-only version and building	  "ModApp.PowerPC" creates a PowerPC-only version.	¥ Building ":Modules"Clock" builds only the clock module, or 	  you can substitute another module name.	  NOTE: The makefile requires 3 subfolders in the ModApp folder:Modules, PowerPC, and 68K. Running the "MakeFolders" script willcreate these for you if they don't exist already.If you construct your own makefile, or move this to another developmentsystem, note that the "Koch" and "Clock" modules depend on the "GWorldTools"library.The default build has symbols turned *off* and optimization set for *size*. Editing the "SYM" variable at the start of the makefile turns symbolicdebugging on and off, editing "OPT" controls the optimization level (for PowerPC.)These options also can be set from the command line	make ModApp -d SYM=on -d OPT=offbuilds a debugging version. (Note that SYM=on implies OPT=off)Theory of Operation-------------------ModApp is a fairly standard Macintosh application, though it doesn't print or scroll.The interesting part has to do with how modules are loaded and executed. The reallycrucial information is contained in ToolLoader.c, ToolAPI.h, and the tool filesthemselves.Since ModApp has to support both 68K and PowerPC modules, almost all calls to a moduleare done through Universal Procedure Pointers. When the module's initialization routineis called, it creates a UPP for each entry point and places these in the "ToolInfoBlock"data structure. (See the ToolStartup routine in Button.c for an example of this.) ModAppthen uses these UniversalProcedurePointers to call the module.(Currently, modules do not call back to the main application, though if they did I wouldprobably implement these callbacks using a similar table mechanism.)The only exception to the "modules are called via Universal Procedure Pointers" rule is the module's "ToolStartup" routine. This routine may be called directly, or througha UniversalProcPtr -- see "InitializeTool" in ToolLoader.c for details.The structure of a tool-----------------------A 68K module is implemented as a single 'TOOL' (0) resource, and has all of thelimitations of 68K stand-alone code.A PowerPC module may be implemented as either a PEF container in the data fork of themodule's file, or as a 'TOOL' (1) resource containing a PEF container. (NOTE: In ModApp,the PowerPC resource should not have a routine descriptor at the front, as it will beloaded and called as a native code fragment -- see LoadViaCFM in ToolLoader.c) PowerPCmodules also have to contain a 'cfrg' resource to designate them as native; the typeshould be set to "kIsDropIn" and the location set to either kOnDiskFlat (for the datafork) or kInMem (for a resource)."Fat" modules contain both kinds of code in the appropriate places. Don't forget the'cfrg' resource!The sample modules------------------ModApp ships with several sample modules, ranging from simple frameworks to a fancyfractal drawing demonstration:	¥ Simple Ñ a basic do-nothing module, that just draws a black rectangle in the window.	¥ Button - displays a single push button and beeps when the button is pressed. This	  module demonstrates how a module should handle getting its own resources.	¥ Clock - A basic analog clock with a sweep-second hand. This demonstrates how a 	  module can install and remove menus and get idle time. Clock uses the "GWorldTools"	  library for off-screen drawing. (supplied)	¥ Koch - Draws the von Koch "snowflake" fractal over and over, rotating and colorizing	  the result. This is a nice demonstration of Quickdraw's performance.	and finally...	¥ PowerResource - A really trivial module, but one that shows how to build and load	  PowerPC code resources (without going through Mixed Mode.)For more information...-----------------------If you have any questions or comments about ModApp, please send them to theAppleLink address RDCLARK, or on the internet to "rdclark@apple.com"