#ifndef __MPW_VERSION__	#if defined(powerc) || defined(__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#else	#include <Resources.h>	#include <SegLoad.h>#endif#include "LionDoom.h"#include <Lion.h>#include "DoomResources.h"#include "AppleTalkNet.h"#include "SerialNet.h"#include "CTBNet.h"#include "doomdef.h"#include "MacPCSwitches.h"#include "NetDialogs.h"#include <MixedMode.h>#include "ipxcalls.h"extern void IPXSetup (void);extern Boolean					gPlayAlone;extern WindowPtr				gDoomWindow;extern unsigned short 	gIPXSocket;extern void RestoreScreenDepth (void);void GetPlayMode (void);extern DialogPtr			gStatusDialog;extern void StatusDialog (tLong total, tLong current);extern void DrawStatusDialog (Boolean forUpdate);extern void StatusParamText(char *one, char *two, char *three, char *four);extern void SpinCursor (void);extern void BlackScreen(void);extern pascal Boolean NetOptionsDialogFilter (DialogPtr dlg, EventRecord *evt, tWord *itm);extern void Connect (void);extern void HideMenuBar ( void );extern RedrawScreen();enum{	iGameOptionsOK						= 1,	iGameOptionsCancel				= 2,	iGameOptionsApple					= 3,	iGameOptionsSerial				= 4,	iGameOptionsCTB						= 5,	iGameOptionsIPX						= 6,	iGameOptionsInit					= 7,	iGameOptionsCoop					= 8,	iGameOptionsDeath					= 9,	iGameOptionsRespawn				= 10,	iGameOptionsTitle					= 11,	iGameOptionsLine					= 12,	iGameOptionsNumPlayTitle	= 13,	iGameOptionsNumPlay				= 14,	iGameOptionsSocketTitle		= 15,	iGameOptionsSocket				= 16,	iGameOptionsSerPort				= 17};/*=============== ReadPacket==============*/int  inescape;int  newpacket = 1;char packet[MAXPACKET];int  packetlen;boolean ReadPacket (void){	char 		c;	Size		length;	Boolean	got;		if (newpacket)	{		packetlen = 0;		newpacket = 0;	}	do 	{ 		length = 1;		switch (gNetType)		{			case kSerialNet:				got = SerReadString((Ptr) &c, &length);			break;			case kCTBNet:				got = CTBReadString((Ptr) &c, &length);			break;		}		if (!got)		{			return(false);		}/*		if (c < 0 )		{			return false;  // haven't read a complete packet		}*/	//printf ("%c",c);		if (inescape)		{			inescape = false;			if (c!=FRAMECHAR1)			{				newpacket = 1;	    		return true; // got a good packet	   		}	  	}		else if (c==FRAMECHAR1)		{			inescape = true;			continue;   // don't know  yet if it is a terminator		}      // or  a literal FRAMECHAR			if (packetlen >= MAXPACKET)		{			continue;   // oversize packet		}		packet[packetlen] = c;		packetlen++;	} while (1);}/*=============== WritePacket==============*/void WritePacket (char *buffer, int len){	int  b;	char static localbuffer[MAXPACKET*2+2];	b = 0;	if (len > MAXPACKET)	{		return;	}	while (len--)	{		if (*buffer == FRAMECHAR1)		{			localbuffer[b++] = FRAMECHAR1; // escape it for literal		}  		localbuffer[b++] = *buffer++;	}	localbuffer[b++] = FRAMECHAR1;	localbuffer[b++] = FRAMECHAR2;		switch (gNetType)	{		case kSerialNet:			SerSendString (1, localbuffer, b);		break;		case kCTBNet:			CTBSendString (1, localbuffer, b);		break;	}}/*=================== Connect== Figures out who is player 0 and 1=================*/void Connect (void){	long	time;	int		oldsec;	int		localstage, remotestage;	char	str[20];	char	idstr[7];	char	remoteidstr[7];	unsigned long  idnum;	int   i; 	//	// build a (hopefully) unique id string by hashing up the current milliseconds	// and the interrupt table	//	/* if (CheckParm ("-player1"))		idnum = 0;		else if (CheckParm ("-player2"))		idnum = 999999;		Otherwise do the following	*/	time = TickCount();	idnum = time;	for (i=0 ; i<512 ; i++)	{		idnum += ((unsigned far *)0)[i];	}  	idnum %= 1000000; 	idstr[0] = '0' + idnum/ 100000l;	idnum -= (idstr[0]-'0')*100000l;	idstr[1] = '0' + idnum/ 10000l;	idnum -= (idstr[1]-'0')*10000l;	idstr[2] = '0' + idnum/ 1000l;	idnum -= (idstr[2]-'0')*1000l;	idstr[3] = '0' + idnum/ 100l;	idnum -= (idstr[3]-'0')*100l;	idstr[4] = '0' + idnum/ 10l;	idnum -= (idstr[4]-'0')*10l;	idstr[5] = '0' + idnum;	idstr[6] = 0; //// sit in a loop until things are worked out//// the packet is:  ID000000_0// the first field is the idnum, the second is the acknowledge stage// ack stage starts out 0, is bumped to 1 after the other computer's id// is known, and is bumped to 2 after the other computer has raised to 1// oldsec = -1; localstage = remotestage = 0;	do	{		if (CheckForTermination())		{			I_Exit();		}				SpinCursor();		if (ReadPacket())		{			SpinCursor();			packet[packetlen] = 0;	//		printf ("read : %s\n",packet);			if (packetlen != 10)			{				continue;			}			if (strncmp(packet,"ID",2) )			{				continue;			}			if (!strncmp (packet+2,idstr,6))			{				//I_Error ("STR_DUPLICATE");			}			strncpy (remoteidstr,packet+2,6);		    			remotestage = packet[9] - '0';			localstage = remotestage+1;			oldsec = -1;		}			time = TickCount();		if (time != oldsec)		{			oldsec = time;			sprintf (str,"ID%s_%i",idstr,localstage);			WritePacket (str,strlen(str));//			printf ("wrote: %s\n",str);		}		} while (localstage < 2);		SpinCursor();	//	// decide who is who	//	if (strcmp(remoteidstr,idstr) < 0)	{		gKeyPlayer = false;	}	else	{		gKeyPlayer = true; 	}	// ConsolePlayer is determined by option menu gKeyPlayer value	if (gKeyPlayer)							// ¥¥Warning only works for two players	{		doomcom->consoleplayer = 0;	}	else	{		doomcom->consoleplayer = 1;	}		//// flush out any extras//	switch (gNetType)	{		case kSerialNet:			SerFlushData();		break;		case kCTBNet:			CTBFlushData();		break;	}	}/******************************************************** *	GetPlayMode.																				* *																											* *	Gets some very important information from the user	* *	prior to just randomly launching some network				* *	protocol.																						* ********************************************************/void GetPlayMode (void){	DialogPtr					dPointer;	Boolean						death 			= false;	Boolean						altdeathflag 		= false;	OSErr							status;	Boolean						redo = false;		// I_InitNetwork sets doomcom and netgame	I_InitNetwork ();		/*	SetPort(gDoomWindow);	PaintRect(&gDoomWindow->portRect);	// Clear the dialog area	ValidRect(&gDoomWindow->portRect);*/	StatusParamText("\pStarting Doom II...", "\p", "\p", "\p");	StatusDialog(80, 1);	DrawStatusDialog(TRUE);	SpinCursor();		switch(gNetType)	{		case kAppleTalkNet:			// Check if we have valid AppleTalk			if ((status = CheckAppleTalkState()) != noErr)			{				I_Error("Error %d in initializing AppleTalk\n", status);			}			SpinCursor();			status = InitializeNet();			if (status)			{				I_Error("Unable to initialize AppleTalk");			}						SpinCursor();			AppleTalkConnect();		break;		case kSerialNet:					gPCCommunication = true;						StatusDialog(80, 1);			StatusParamText("\pInitializing Connection...", "\p", "\p", "\p");			DrawStatusDialog(TRUE);			status		= SerInitializeNet();			if (status)			{				I_Error("Serial initialization %d",status);			}			Connect();		break;		case kCTBNet:			gPCCommunication = true;						CTBInitializeNet();			if (gKeyPlayer)			{				if (!CTBOpenConnection())				{					BlackScreen();					RedrawScreen();					I_Error("Unable to reach the other player");				}				else				{						BlackScreen();						RedrawScreen();						StatusParamText("\pInitializing Connection...", "\p", "\p", "\p");						Connect();						BlackScreen();						RedrawScreen();						StatusParamText("\pInitializing Connection...", "\p", "\p", "\p");				}			}			else			{				status = CTBWaitForConnection();				if (status != noErr)				{					if (status == cmNotSupported)					{						if (!CTBOpenConnection())						{							BlackScreen();							RedrawScreen();							I_Error("Sorry, unable to reach the other player");						}						else						{							BlackScreen();							RedrawScreen();							StatusParamText("\pInitializing Connection...", "\p", "\p", "\p");							Connect();							BlackScreen();							RedrawScreen();							StatusParamText("\pInitializing Connection...", "\p", "\p", "\p");						}					}					else					{						I_Error("Sorry, did not hear from the other player");					}				}				else				{					BlackScreen();					RedrawScreen();					StatusParamText("\pInitializing Connection...", "\p", "\p", "\p");					Connect();					BlackScreen();					RedrawScreen();					StatusParamText("\pInitializing Connection...", "\p", "\p", "\p");				}			}		break;		case kIPXNet:			gPCCommunication = true;			IPXSetup ();		break;	}		ReleaseResource(GetResource('DLOG', rDialogGameOptions));	ReleaseResource(GetResource('DITL', 506));}