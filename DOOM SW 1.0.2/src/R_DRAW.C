#include "LionDoom.h"// R_draw.c#include "doomdef.h"#include "r_local.h"/* * *	External globals * */extern byte				remapMac[256];/*All drawing to the view buffer is accomplished in this file.  The other refreshfiles only know about ccordinates, not the architecture of the frame buffer.*/byte					*viewimage = NULL;int						viewwidth = 0, 							scaledviewwidth = 0, 							viewheight = 0, 							viewwindowx = 0, 							viewwindowy = 0;byte					*ylookup[MAXHEIGHT];int						columnofs[MAXWIDTH];int						gViewOffset;					// For Medium resolution y offset basebyte					translations[3][256];	// color tables for different playersbyte					*translationtables;/* * *	DrawColumn variables * */ byte					*dc_translation;lighttable_t	*dc_colormap = NULL;int						dc_x = 0;int						dc_yl = 0;int						dc_yh = 0;fixed_t				dc_iscale = 0;fixed_t				dc_texturemid = 0;byte					*dc_source = NULL;		// first pixel in a column (possibly virtual)/* * *	Local Prototypes * */void R_VideoErase (unsigned ofs, int count);/****************************************************** *	R_DrawColumnMedRes.																* *																										* *	The R_DrawColumnMedRes draws a column in medium		* *	resolution, or 640x200. See R_DrawColumn for low	* *	and high resolution.															* ******************************************************/void R_DrawColumnMedRes (void){	register byte							*source, *dest, *colormap;	register unsigned long		frac, fracstep, fracstep2, fracstepTotal;	register long							count;		count = (dc_yh - dc_yl) + 1;	if (count <= 0)		return;		source = dc_source;	colormap = dc_colormap;	dest = ylookup[ (dc_yl + 1) >> 1 ] + columnofs[dc_x] - gViewOffset;		fracstep = dc_iscale << 9;	frac = (dc_texturemid + (dc_yl - centery) * dc_iscale) << 9;		fracstep2 = fracstep << 1;				// 2 * fracstep	fracstepTotal = fracstep << 2;		// 4 * fracstep		if (dc_yl & 0x01)					// Odd Destination Y Coordinate	{		count &= 0xFFFFFFFEL;		// Make sure it is even		frac += fracstep;				// Don't draw "odd" source pixels. Go to next.	}#if defined(powerc) || defined (__powerc)// PowerPC Version Begins	while (count >= 4)	{		unsigned long	tempA, tempB;		unsigned long	indexA, indexB;				indexA = source[ (frac >> 25) ];		indexB = source[ ((frac + fracstep2) >> 25) ];		frac += fracstepTotal;				tempA = colormap[indexA];		tempB = colormap[indexB];				dest[kHiResRowBytes * 0] = tempA;		count -= 4;		dest[kHiResRowBytes * 1] = tempB;				dest += kHiResRowBytes * 2;	}		while (count > 0)	{		unsigned long	indexA;		unsigned long	tempA;				indexA = source[ (frac >> 25) ];		count -= 2;		tempA = colormap[ indexA ];		frac += fracstep2;		dest[0] = tempA;		dest += kHiResRowBytes;	}// PowerPC Version Ends#else// 680x0 Version Begins	while (count >= 8)	{		dest[kHiResRowBytes * 0] = colormap[source[ (short)(frac >> 25) ]];		dest[kHiResRowBytes * 1] = colormap[source[ (short)((frac + fracstep2) >> 25) ]];		frac += fracstepTotal;		dest[kHiResRowBytes * 2] = colormap[source[ (short) (frac >> 25) ]];		dest[kHiResRowBytes * 3] = colormap[source[ (short) ((frac + fracstep2) >> 25) ]];		frac += fracstepTotal;		dest += kHiResRowBytes * 4;		count -= 8;	}		while (count > 0)	{		*dest = colormap[source[ (short) (frac >> 25) ]];		dest += kHiResRowBytes;		frac += fracstep2;		count -= 2;	}// 680x0 Version Ends#endif}/****************************************************** *	R_DrawColumn.																			* *																										* *	The function R_DrawColumn draws a vertical column	* *	of pixels, one at a time. This function has been	* *	optimized for PowerPC-based Macs, and has the C		* *	version for 68K Macs as well.											* ******************************************************/void R_DrawColumn (void){	register byte							*source, *dest, *colormap;	register unsigned long		frac, fracstep, fracstep2, fracstep3, fracstep4;		register long							count;		count = (dc_yh - dc_yl) + 1;	if (count <= 0)		return;		source = dc_source;	colormap = dc_colormap;	dest = ylookup[dc_yl] + columnofs[dc_x];		fracstep = dc_iscale << 9;	frac = (dc_texturemid + (dc_yl - centery) * dc_iscale) << 9;		fracstep2 = fracstep + fracstep;	fracstep3 = fracstep2 + fracstep;	fracstep4 = fracstep3 + fracstep;#if defined(powerc) || defined (__powerc)	if (gHiRes)	{		while (count >= 4)		{			unsigned long	tempA, tempB, tempC, tempD;			unsigned long	indexA, indexB, indexC, indexD;					indexA = source[ (frac>>25) ];			indexB = source[ ((frac+fracstep) >> 25) ];			indexC = source[ ((frac+fracstep2) >> 25) ];			indexD = source[ ((frac+fracstep3) >> 25) ];			frac += fracstep4;						tempA = colormap[indexA];			tempB = colormap[indexB];			tempC = colormap[indexC];			tempD = colormap[indexD];			count -= 4;			dest[kHiResRowBytes*0] = tempA;			dest[kHiResRowBytes*1] = tempB;			dest[kHiResRowBytes*2] = tempC;			dest[kHiResRowBytes*3] = tempD;			dest += kHiResRowBytes * 4;		}				while (count > 0)		{			*dest = colormap[source[ (frac >> 25) ]];			dest += kHiResRowBytes;			frac += fracstep;			count--;		}	}	else	{		while (count >= 4)		{			unsigned long	tempA, tempB, tempC, tempD;			unsigned long	indexA, indexB, indexC, indexD;					indexA = source[ (frac>>25) ];			indexB = source[ ((frac+fracstep) >> 25) ];			indexC = source[ ((frac+fracstep2) >> 25) ];			indexD = source[ ((frac+fracstep3) >> 25) ];			frac += fracstep4;						tempA = colormap[indexA];			tempB = colormap[indexB];			tempC = colormap[indexC];			tempD = colormap[indexD];			count -= 4;			dest[kScreenWidth*0] = tempA;			dest[kScreenWidth*1] = tempB;			dest[kScreenWidth*2] = tempC;			dest[kScreenWidth*3] = tempD;			dest += kScreenWidth * 4;		}				while (count > 0)		{			*dest = colormap[source[ (frac >> 25) ]];			dest += kScreenWidth;			frac += fracstep;			count--;		}	}#else	if (gHiRes)	{		while (count >= 8)		{			dest[0] = colormap[source[ (short)(frac>>25) ]];			dest[kHiResRowBytes] = colormap[source[ (short) ((frac+fracstep) >> 25) ]];			dest[kHiResRowBytes*2] = colormap[source[ (short)((frac+fracstep2) >> 25) ]];			dest[kHiResRowBytes*3] = colormap[source[ (short)((frac+fracstep3) >> 25) ]];			frac += fracstep4;			dest[kHiResRowBytes*4] = colormap[source[ (short) (frac >> 25) ]];			dest[kHiResRowBytes*5] = colormap[source[ (short) ((frac+fracstep) >> 25) ]];			dest[kHiResRowBytes*6] = colormap[source[ (short) ((frac+fracstep2) >> 25) ]];			dest[kHiResRowBytes*7] = colormap[source[ (short) ((frac+fracstep3) >> 25) ]];			frac += fracstep4;			dest += kHiResRowBytes * 8;			count -= 8;		}				while (count > 0)		{			*dest = colormap[source[ (short) (frac >> 25) ]];			dest += kHiResRowBytes;			frac += fracstep;			count--;		}	}	else	{		while (count >= 8)		{			dest[0] = colormap[source[ (short)(frac>>25) ]];			dest[kScreenWidth] = colormap[source[ (short) ((frac+fracstep) >> 25) ]];			dest[kScreenWidth*2] = colormap[source[ (short)((frac+fracstep2) >> 25) ]];			dest[kScreenWidth*3] = colormap[source[ (short)((frac+fracstep3) >> 25) ]];			frac += fracstep4;			dest[kScreenWidth*4] = colormap[source[ (short) (frac >> 25) ]];			dest[kScreenWidth*5] = colormap[source[ (short) ((frac+fracstep) >> 25) ]];			dest[kScreenWidth*6] = colormap[source[ (short) ((frac+fracstep2) >> 25) ]];			dest[kScreenWidth*7] = colormap[source[ (short) ((frac+fracstep3) >> 25) ]];			frac += fracstep4;			dest += kScreenWidth * 8;			count -= 8;		}				while (count > 0)		{			*dest = colormap[source[ (short) (frac >> 25) ]];			dest += kScreenWidth;			frac += fracstep;			count--;		}	}	#endif}/****************************************************** *	R_DrawMultiColumn.																* *																										* *	R_DrawMultiColumn draws 2 columns at one time if	* *	possible. This prevents the cache from being			* *	thrashed on the PowerPC. If a problem with either	* *	column occurs, it draws the other one using 			* *	R_DrawColumn().																		* ******************************************************/void R_DrawMultiColumn (tMultiDrawColumnRec *colsRec){	register byte									*destA, *destB, *cmapA, *cmapB;	register byte									*srcA, *srcB, *dest;	register fixed_t							fracA, fracB, fracstepA, fracstepB;	register int									count, sourceBytes;	register tMultiColumnRecord		*recA, *recB;	register int									bailCode;		recA = &colsRec->rec[0];	recB = &colsRec->rec[1];		if (TRUE)	{		register int		countA, countB;		countA = (recA->fYh - recA->fYl);		countB = (recB->fYh - recB->fYl);				if (countA < 0)		{			dc_source = recB->fSource;			dc_colormap = recB->fColormap;			dc_x = recB->fX;			dc_yl = recB->fYl;			dc_yh = recB->fYh;			dc_iscale = recB->fiScale;			dc_texturemid = recB->fTextureMid;			R_DrawColumn();		}				if (countB < 0)		{			dc_source = recA->fSource;			dc_colormap = recA->fColormap;			dc_x = recA->fX;			dc_yl = recA->fYl;			dc_yh = recA->fYh;			dc_iscale = recA->fiScale;			dc_texturemid = recA->fTextureMid;			R_DrawColumn();		}				if ((countA < 0) || (countB < 0))			return;	}	#ifdef RANGECHECK	if (gHiRes)	{		if ((unsigned)recA->fX >= kHiResScreenWidth || 			recA->fYl < 0 || recA->fYh >= kHiResScreenHeight)			I_Error ("R_DrawColumn: %i to %i at %i", recA->fYl, recA->fYh, recA->fX);		if ((unsigned)recB->fX >= kHiResScreenWidth || 			recB->fYl < 0 || recB->fYh >= kHiResScreenHeight)			I_Error ("R_DrawColumn: %i to %i at %i", recB->fYl, recB->fYh, recB->fX);	}	else	{		if ((unsigned)recA->fX >= kScreenWidth || 			recA->fYl < 0 || recA->fYh >= kScreenHeight)			I_Error ("R_DrawColumn: %i to %i at %i", recA->fYl, recA->fYh, recA->fX);		if ((unsigned)recB->fX >= kScreenWidth || 			recB->fYl < 0 || recB->fYh >= kScreenHeight)			I_Error ("R_DrawColumn: %i to %i at %i", recB->fYl, recB->fYh, recB->fX);	}#endif		fracstepA = recA->fiScale;	fracstepB = recB->fiScale;	destA = ylookup[ recA->fYl ] + columnofs[ recA->fX ];	destB = ylookup[ recB->fYl ] + columnofs[ recB->fX ];		srcA = recA->fSource;	srcB = recB->fSource;		fracA = recA->fTextureMid + ((recA->fYl - centery) * fracstepA);	fracB = recB->fTextureMid + ((recB->fYl - centery) * fracstepB);		cmapA = recA->fColormap;	cmapB = recB->fColormap;		if (gHiRes)		sourceBytes = kHiResRowBytes;	else		sourceBytes = kScreenWidth;	// Process areas of leading Y difference to get the two columns in sync.	if ( recA->fYl > recB->fYl )	{		unsigned long		temp;		unsigned long		temp2;				count = recA->fYl - recB->fYl;		recB->fYl += count;				while (count--)		{			temp = srcB[ (fracB >> FRACBITS) & 127 ];			fracB += fracstepB;			temp2 = cmapB[ temp ];			*destB = temp2;			destB += sourceBytes;		}	}	else if (recB->fYl > recA->fYl)	{		unsigned long		temp;		unsigned long		temp2;				count = recB->fYl - recA->fYl;		recA->fYl += count;				while (count--)		{			temp = srcA[ (fracA >> FRACBITS) & 127 ];			fracA += fracstepA;			temp2 = cmapA[ temp ];			*destA = temp2;			destA += sourceBytes;		}	}		dest = (byte *) destA;#ifdef RANGECHECK	if ( recA->fYl != recB->fYl )		I_Error("R_DrawMultiColumn: top of columns not synced!");#endif// rec[0].fYl should equal rec[1].fYl ! (both columns synced on "y" values.	if ( recA->fYh < recB->fYh )	{		count = (recA->fYh - recA->fYl) + 1;		bailCode = -1;		recB->fYl += count;	}	else if ( recA->fYh > recB->fYh )	{		count = (recB->fYh - recB->fYl) + 1;		bailCode = 1;		recA->fYl += count;	}	else	{		count = (recB->fYh - recB->fYl) + 1;		bailCode = 0;	}		if (count)	{		while (count)		{			unsigned long	tempA;			unsigned long	tempB;			unsigned long	tempC;			unsigned long	tempD;						tempA = srcA[ (fracA >> FRACBITS) & 127 ];			fracA += fracstepA;			tempB = srcB[ (fracB >> FRACBITS) & 127 ];			fracB += fracstepB;						count--;						tempC = cmapA[ tempA ];			tempD = cmapB[ tempB ];						dest[0] = tempC;			dest[1] = tempD;						dest += sourceBytes;		}	}		if (!bailCode)		return;	// Finish up		if (bailCode < 0)	{		count = (recB->fYh - recB->fYl) + 1;				while (count)		{			unsigned long	temp1;						temp1 = srcB[ (fracB >> FRACBITS) & 127 ];			fracB += fracstepB;			dest[0] = cmapB[ temp1 ];			count--;			dest += sourceBytes;		}	}	else if (bailCode > 0)	{		count = (recA->fYh - recA->fYl) + 1;				while (count)		{			unsigned long	temp1;						temp1 = srcA[ (fracA >> FRACBITS) & 127 ];			fracA += fracstepA;			dest[0] = cmapA[ temp1 ];			count--;			dest += sourceBytes;		}	}}#define FUZZTABLE	50#define FUZZOFF	(kScreenWidth)#define FUZZOFFHI (kHiResRowBytes)int		fuzzoffset[FUZZTABLE] = {FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF};int		fuzzoffsetHi[FUZZTABLE] = {FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,-FUZZOFFHI,-FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,-FUZZOFFHI,-FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI,FUZZOFFHI,-FUZZOFFHI,FUZZOFFHI};int		fuzzpos = 0;/****************************************************** *	R_DrawFuzzColumnMedRes.														* *																										* *	Draws the "fuzzy", transparent monsters by using	* *	a distortion algorithm that uses a neighboring		* *	pixel (either the one above or the one below).		* ******************************************************/void R_DrawFuzzColumnMedRes (void){	register int		count, regFuzzPos;	register byte		*dest, *regCMaps;	register int		*regFuzzOff;		if (!dc_yl)		dc_yl = 1;	if (dc_yh >= viewheight - 2)		dc_yh = viewheight - 3;		count = (dc_yh - dc_yl) + 1;	if (count <= 0)		return;	#ifdef RANGECHECK	if ((unsigned)dc_x >= kHiResScreenWidth || dc_yl < 0 || dc_yh >= kHiResScreenHeight)		I_Error ("R_DrawFuzzColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);#endif		dest = ylookup[ (dc_yl + 1) >> 1 ] + columnofs[dc_x] - gViewOffset;		if (dc_yl & 0x01)		count &= 0xFFFFFFFEL;	regCMaps = &colormaps[6 * 256];	regFuzzOff = fuzzoffsetHi;	regFuzzPos = fuzzpos;	#if defined(powerc) || defined (__powerc)// PowerPC Version Begins	while (count >= 4)	{		unsigned long	tempA, tempB;		unsigned long	indexA, indexB;				indexA = regFuzzOff[ regFuzzPos++ ];		count -= 4;		tempA = dest[ indexA ];		if (regFuzzPos == FUZZTABLE)			regFuzzPos = 0;		dest[kHiResRowBytes * 0] = regCMaps[ tempA ];				indexB = regFuzzOff[ regFuzzPos++ ];		tempB = dest[ indexB ];		if (regFuzzPos == FUZZTABLE)			regFuzzPos = 0;		dest[kHiResRowBytes * 1] = regCMaps[ tempB ];				dest += kHiResRowBytes * 2;	}		while (count > 0)	{		unsigned long	tempA;		unsigned long	indexA;				indexA = regFuzzOff[ regFuzzPos++ ];		count -= 2;		tempA = dest[ indexA ];		if (regFuzzPos == FUZZTABLE)			regFuzzPos = 0;		dest[kHiResRowBytes * 0] = regCMaps[ tempA ];		dest += kHiResRowBytes;	}// PowerPC Version Ends#else// 68K Version Begins	while (count >= 4)	{		dest[kHiResRowBytes * 0] = regCMaps[ dest[ regFuzzOff[ regFuzzPos++ ]]];		if (regFuzzPos == FUZZTABLE)			regFuzzPos = 0;				dest[kHiResRowBytes * 1] = regCMaps[ dest[ regFuzzOff[ regFuzzPos++ ]]];		if (regFuzzPos == FUZZTABLE)			regFuzzPos = 0;				count -= 4;		dest += kHiResRowBytes * 2;	}		while (count > 0)	{		dest[kHiResRowBytes*0] = regCMaps[ dest[ regFuzzOff[ regFuzzPos++ ]]];		if (regFuzzPos == FUZZTABLE)			regFuzzPos = 0;		count -= 2;		dest += kHiResRowBytes;	}// 68K Version Ends#endif		fuzzpos = regFuzzPos;}/****************************************************** *	R_DrawFuzzColumn.																	* *																										* *	Draws the "fuzzy", transparent monsters by using	* *	a distortion algorithm that uses a neighboring		* *	pixel (either the one above or the one below).		* *	Function works for High resolution or for low			* *	resolution.																				* ******************************************************/void R_DrawFuzzColumn (void){	register int		count, regFuzzPos;	register byte		*dest, *regCMaps;	register int		*regFuzzOff;		if (!dc_yl)		dc_yl = 1;	if (dc_yh == viewheight-1)		dc_yh = viewheight - 2;		count = dc_yh - dc_yl;	if (count < 0)		return;	#ifdef RANGECHECK	if (gHiRes)	{		if ((unsigned)dc_x >= kHiResScreenWidth || dc_yl < 0 || dc_yh >= kHiResScreenHeight)			I_Error ("R_DrawFuzzColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);	}	else	{		if ((unsigned)dc_x >= kScreenWidth || dc_yl < 0 || dc_yh >= kScreenHeight)			I_Error ("R_DrawFuzzColumn: %i to %i at %i", dc_yl, dc_yh, dc_x);	}#endif		dest = ylookup[dc_yl] + columnofs[dc_x];		regCMaps = &colormaps[6 * 256];		if (gHiRes)		regFuzzOff = fuzzoffsetHi;	else		regFuzzOff = fuzzoffset;		regFuzzPos = fuzzpos;		if (gHiRes)	{		do		{			*dest = regCMaps[ dest[ regFuzzOff[ regFuzzPos ] ] ];			if (++regFuzzPos == FUZZTABLE)				regFuzzPos = 0;			dest += kHiResRowBytes;		} while (count--);	}	else	{		do		{			*dest = regCMaps[ dest[ regFuzzOff[ regFuzzPos ] ] ];			if (++regFuzzPos == FUZZTABLE)				regFuzzPos = 0;			dest += kScreenWidth;		} while (count--);	}		fuzzpos = regFuzzPos;}/****************************************************** *	R_DrawTranslatedColumnMedRes.											* *																										* *	Translates the column of pixels by remapping			* *	them through the "dc_translation" array.					* *	For medium resolution only.												* ******************************************************/void R_DrawTranslatedColumnMedRes (void){	register byte							*source, *dest, *colormap, *trans;	register unsigned long		frac, fracstep, fracstep2, fracstep3, fracstep4;		register long							count;		count = (dc_yh - dc_yl) + 1;	if (count <= 0)		return;		dest = ylookup[ (dc_yl + 1) >> 1 ] + columnofs[dc_x] - gViewOffset;		fracstep = dc_iscale;	frac = dc_texturemid + (dc_yl - centery) * fracstep;		// Step twice as fast because of medium resolution.		fracstep <<= 1;		colormap = dc_colormap;	trans = dc_translation;	source = dc_source;		if (dc_yl & 0x01)					// Odd Destination Y Coordinate	{		count &= 0xFFFFFFFEL;		// Make sure it is even		frac += fracstep;				// Don't draw "odd" source pixels. Go to next.	}		fracstep2 = fracstep + fracstep;	fracstep3 = fracstep2 + fracstep;	fracstep4 = fracstep3 + fracstep;#if defined(powerc) || defined (__powerc)// PowerPC Version Begins	while (count >= 8)	{		unsigned long	tempA, tempB, tempC, tempD;		unsigned long	indexA, indexB, indexC, indexD;			indexA = source[ (frac >> FRACBITS) ];		indexB = source[ ((frac+fracstep) >> FRACBITS) ];		indexC = source[ ((frac+fracstep2) >> FRACBITS) ];		indexD = source[ ((frac+fracstep3) >> FRACBITS) ];		frac += fracstep4;				tempA = trans[indexA];		tempB = trans[indexB];		tempC = trans[indexC];		tempD = trans[indexD];		indexA = colormap[tempA];		indexB = colormap[tempB];		indexC = colormap[tempC];		indexD = colormap[tempD];		count -= 8;		dest[kHiResRowBytes*0] = indexA;		dest[kHiResRowBytes*1] = indexB;		dest[kHiResRowBytes*2] = indexC;		dest[kHiResRowBytes*3] = indexD;				dest += kHiResRowBytes * 4;	}		while (count > 0)	{		*dest = colormap[trans[source[ (frac >> FRACBITS) ]]];		count -= 2;		dest += kHiResRowBytes;		frac += fracstep;	}	// PowerPC Version Ends#else// 68K Version Begins	while (count >= 16)	{		dest[kHiResRowBytes*0] = colormap[trans[source[ (short)(frac >> FRACBITS) ]]];		dest[kHiResRowBytes*1] = colormap[trans[source[ (short)((frac+fracstep) >> FRACBITS) ]]];		dest[kHiResRowBytes*2] = colormap[trans[source[ (short)((frac+fracstep2) >> FRACBITS) ]]];		dest[kHiResRowBytes*3] = colormap[trans[source[ (short)((frac+fracstep3) >> FRACBITS) ]]];		frac += fracstep4;		dest[kHiResRowBytes*4] = colormap[trans[source[ (short) (frac >> FRACBITS) ]]];		dest[kHiResRowBytes*5] = colormap[trans[source[ (short) ((frac+fracstep) >> FRACBITS) ]]];		dest[kHiResRowBytes*6] = colormap[trans[source[ (short) ((frac+fracstep2) >> FRACBITS) ]]];		dest[kHiResRowBytes*7] = colormap[trans[source[ (short) ((frac+fracstep3) >> FRACBITS) ]]];		frac += fracstep4;		count -= 16;		dest += kHiResRowBytes * 8;	}		while (count > 0)	{		dest[kHiResRowBytes*0] = colormap[trans[source[ (short)(frac >> FRACBITS) ]]];		dest += kHiResRowBytes;		count -= 2;		frac += fracstep;	}	// 68K Version Ends#endif}/****************************************************** *	R_DrawTranslatedColumn.														* *																										* *	Translates the column of pixels by remapping			* *	them through the "dc_translation" array.					* *	This function is for high and low resolution			* *	only. See "R_DrawTranslatedColumn" for the				* *	medium resolution version.												* ******************************************************/void R_DrawTranslatedColumn (void){	register byte							*source, *dest, *colormap, *trans;	register unsigned long		frac, fracstep, fracstep2, fracstep3, fracstep4;		register long							count;		count = (dc_yh - dc_yl) + 1;	if (count <= 0)		return;		dest = ylookup[dc_yl] + columnofs[dc_x];		fracstep = dc_iscale;	frac = dc_texturemid + (dc_yl - centery) * fracstep;	colormap = dc_colormap;	trans = dc_translation;	source = dc_source;		fracstep2 = fracstep + fracstep;	fracstep3 = fracstep2 + fracstep;	fracstep4 = fracstep3 + fracstep;#if defined(powerc) || defined (__powerc)// PowerPC Version Begins	if (gHiRes)	{		while (count >= 4)		{			unsigned long	tempA, tempB, tempC, tempD;			unsigned long	indexA, indexB, indexC, indexD;					indexA = source[ (frac >> FRACBITS) ];			indexB = source[ ((frac+fracstep) >> FRACBITS) ];			indexC = source[ ((frac+fracstep2) >> FRACBITS) ];			indexD = source[ ((frac+fracstep3) >> FRACBITS) ];			frac += fracstep4;						tempA = trans[indexA];			tempB = trans[indexB];			tempC = trans[indexC];			tempD = trans[indexD];			indexA = colormap[tempA];			indexB = colormap[tempB];			indexC = colormap[tempC];			indexD = colormap[tempD];			count -= 4;			dest[kHiResRowBytes*0] = indexA;			dest[kHiResRowBytes*1] = indexB;			dest[kHiResRowBytes*2] = indexC;			dest[kHiResRowBytes*3] = indexD;						dest += kHiResRowBytes * 4;		}				while (count > 0)		{			*dest = colormap[trans[source[ (frac >> FRACBITS) ]]];			dest += kHiResRowBytes;			frac += fracstep;			count--;		}	}	else	{		while (count >= 4)		{			unsigned long	tempA, tempB, tempC, tempD;			unsigned long	indexA, indexB, indexC, indexD;					indexA = source[ (frac >> FRACBITS) ];			indexB = source[ ((frac+fracstep) >> FRACBITS) ];			indexC = source[ ((frac+fracstep2) >> FRACBITS) ];			indexD = source[ ((frac+fracstep3) >> FRACBITS) ];			frac += fracstep4;						tempA = trans[indexA];			tempB = trans[indexB];			tempC = trans[indexC];			tempD = trans[indexD];			indexA = colormap[tempA];			indexB = colormap[tempB];			indexC = colormap[tempC];			indexD = colormap[tempD];			count -= 4;			dest[kScreenWidth*0] = indexA;			dest[kScreenWidth*1] = indexB;			dest[kScreenWidth*2] = indexC;			dest[kScreenWidth*3] = indexD;			dest += kScreenWidth * 4;		}				while (count > 0)		{			*dest = colormap[trans[source[ (frac >> FRACBITS) ]]];			dest += kScreenWidth;			frac += fracstep;			count--;		}	}	// PowerPC Version Ends#else// 68K Version Begins	if (gHiRes)	{		while (count >= 8)		{			dest[kHiResRowBytes*0] = colormap[trans[source[ (short)(frac >> FRACBITS) ]]];			dest[kHiResRowBytes*1] = colormap[trans[source[ (short)((frac+fracstep) >> FRACBITS) ]]];			dest[kHiResRowBytes*2] = colormap[trans[source[ (short)((frac+fracstep2) >> FRACBITS) ]]];			dest[kHiResRowBytes*3] = colormap[trans[source[ (short)((frac+fracstep3) >> FRACBITS) ]]];			frac += fracstep4;			dest[kHiResRowBytes*4] = colormap[trans[source[ (short) (frac >> FRACBITS) ]]];			dest[kHiResRowBytes*5] = colormap[trans[source[ (short) ((frac+fracstep) >> FRACBITS) ]]];			dest[kHiResRowBytes*6] = colormap[trans[source[ (short) ((frac+fracstep2) >> FRACBITS) ]]];			dest[kHiResRowBytes*7] = colormap[trans[source[ (short) ((frac+fracstep3) >> FRACBITS) ]]];			frac += fracstep4;			count -= 8;			dest += kHiResRowBytes * 8;		}				while (count > 0)		{			dest[kHiResRowBytes*0] = colormap[trans[source[ (short)(frac >> FRACBITS) ]]];			dest += kHiResRowBytes;			count--;			frac += fracstep;		}	}	else	{		while (count >= 8)		{			dest[kScreenWidth*0] = colormap[trans[source[ (short)(frac >> FRACBITS) ]]];			dest[kScreenWidth*1] = colormap[trans[source[ (short)((frac+fracstep) >> FRACBITS) ]]];			dest[kScreenWidth*2] = colormap[trans[source[ (short)((frac+fracstep2) >> FRACBITS) ]]];			dest[kScreenWidth*3] = colormap[trans[source[ (short)((frac+fracstep3) >> FRACBITS) ]]];			frac += fracstep4;			dest[kScreenWidth*4] = colormap[trans[source[ (short) (frac >> FRACBITS) ]]];			dest[kScreenWidth*5] = colormap[trans[source[ (short) ((frac+fracstep) >> FRACBITS) ]]];			dest[kScreenWidth*6] = colormap[trans[source[ (short) ((frac+fracstep2) >> FRACBITS) ]]];			dest[kScreenWidth*7] = colormap[trans[source[ (short) ((frac+fracstep3) >> FRACBITS) ]]];			frac += fracstep4;			count -= 8;			dest += kScreenWidth * 8;		}				while (count > 0)		{			dest[kScreenWidth*0] = colormap[trans[source[ (short)(frac >> FRACBITS) ]]];			dest += kScreenWidth;			frac += fracstep;			count--;		}	}	// 68K Version Ends#endif}/****************************************************** *	R_InitTranslationTables.													* *																										* *	Initializes the translation tables. Why does it		* *	do this?																					* ******************************************************/void R_InitTranslationTables (void){	int		i;		translationtables = Z_Malloc ((256 * 3) + 255, PU_STATIC, 0);	translationtables = (byte *)(( (int)translationtables + 255 ) & ~255);	//// translate just the 16 green colors//	for (i = 0; i < 256; i++)	{		if (i >= 0x70L && i <= 0x7fL)		{	// green, gray, brown, red			translationtables[i] = 0x60 + (i & 0xf);			translationtables[i + 256] = 0x40 + (i & 0xf);			translationtables[i + 512] = 0x20 + (i & 0xf);		}		else			translationtables[i] = translationtables[i + 256]				= translationtables[i + 512] = i;	}}/*================== R_DrawSpan=================*/int						ds_y;int						ds_x1;int						ds_x2;lighttable_t	*ds_colormap;fixed_t				ds_xfrac;fixed_t				ds_yfrac;fixed_t				ds_xstep;fixed_t				ds_ystep;byte					*ds_source;		// start of a 64*64 tile imageint						dscount;			// just for profilingvoid R_DrawSpan (void){	register fixed_t		xfrac, yfrac;	register byte				*dest;	register int				count;	register int				spot;	register byte				*remapArray;	register byte				*regDSColor;	register byte				*regDSSrc;	register fixed_t		regDSXStep = ds_xstep;	register fixed_t		regDSYStep = ds_ystep;		if (gHiRes == 1)		ds_y >>= 1;	#ifdef RANGECHECK	if (gHiRes)	{		if (ds_x2 < ds_x1 || ds_x1 < 0 || ds_x2 >= kHiResScreenWidth		|| (unsigned)ds_y > kHiResScreenHeight)			I_Error ("R_DrawSpan: %i to %i at %i", ds_x1, ds_x2, ds_y);	}	else	{		if (ds_x2 < ds_x1 || ds_x1 < 0 || ds_x2 >= kScreenWidth		|| (unsigned)ds_y > kScreenHeight)			I_Error ("R_DrawSpan: %i to %i at %i", ds_x1, ds_x2, ds_y);	}#endif		xfrac = ds_xfrac;	yfrac = ds_yfrac;		if (gHiRes == 1)		dest = ylookup[ds_y] + columnofs[ds_x1] - gViewOffset;	else		dest = ylookup[ds_y] + columnofs[ds_x1];		count = ds_x2 - ds_x1;	remapArray = remapMac;	regDSColor = ds_colormap;	regDSSrc = ds_source;	#if defined(powerc) || defined (__powerc)// PowerPC Version Begins	while (count >= 4)	{		byte	tempA;		byte	tempB;		byte	tempC;		byte	tempD;				spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		tempA = regDSSrc[spot];		xfrac += regDSXStep;		dest[0] = regDSColor[tempA];		yfrac += regDSYStep;				spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		tempB = regDSSrc[spot];		xfrac += regDSXStep;		dest[1] = regDSColor[tempB];		yfrac += regDSYStep;				count -= 4;		spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		tempC = regDSSrc[spot];		xfrac += regDSXStep;		dest[2] = regDSColor[tempC];		yfrac += regDSYStep;		spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		tempD = regDSSrc[spot];		xfrac += regDSXStep;		dest[3] = regDSColor[tempD];		yfrac += regDSYStep;				dest += 4;	}		while (count >= 0)	{		byte	tempA;				spot = ((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63);		tempA = regDSSrc[spot];		xfrac += regDSXStep;		count--;		*dest++ = regDSColor[tempA];		yfrac += regDSYStep;	}// PowerPC Version Ends#else// 68K Version Begins - not really used. See: Draw68K.asm (R_DrawSpanAsm)	while (count >= 4)	{		dest[0] = regDSColor[ regDSSrc[ (short)((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63) ]];		xfrac += regDSXStep;		yfrac += regDSYStep;		dest[1] = regDSColor[ regDSSrc[ (short)((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63) ]];		xfrac += regDSXStep;		yfrac += regDSYStep;		dest[2] = regDSColor[ regDSSrc[ (short)((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63) ]];		xfrac += regDSXStep;		yfrac += regDSYStep;		count -= 4;		dest[3] = regDSColor[ regDSSrc[ (short)((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63) ]];		xfrac += regDSXStep;		yfrac += regDSYStep;				dest += 4;	}		while (count >= 0)	{		*dest++ = regDSColor[ regDSSrc[ (short)((yfrac >> (16 - 6)) & (63 * 64)) + ((xfrac >> 16) & 63) ]];		xfrac += regDSXStep;		yfrac += regDSYStep;		count--;	}// 68K Version Ends#endif}/*================== R_InitBuffer==================*/void R_InitBuffer (int width, int height){	register int	i;		if (gHiRes)	{		viewwindowx = (kHiResScreenWidth - width) >> 1;		for (i = 0; i < width; i++)			columnofs[i] = viewwindowx + i;				if (width == kHiResScreenWidth)			viewwindowy = 0;		else			viewwindowy = (kHiResScreenHeight - (SBARHEIGHT * 2) - height) >> 1;				if (gHiRes == 1)			gViewOffset = (viewwindowy / 2) * kHiResRowBytes;				for (i = 0; i < height; i++)			ylookup[i] = screens[0] + (i + viewwindowy) * kHiResRowBytes;	}	else	{		viewwindowx = (kScreenWidth - width) >> 1;		for (i = 0; i < width; i++)			columnofs[i] = viewwindowx + i;		if (width == kScreenWidth)			viewwindowy = 0;		else			viewwindowy = (kScreenHeight - SBARHEIGHT - height) >> 1;				for (i = 0; i < height; i++)			ylookup[i] = screens[0] + (i + viewwindowy) * kScreenWidth;	}}/*==================== R_FillBackScreen== Fills the back screen with a pattern for variable screen sizes= Also draws a beveled edge==================*/int				gBackscreenFilled = 0;void R_FillBackScreen (void){	register byte			*src, *dest, *remapArray;	register short		x, y;	register short		i, temp;	patch_t						*patch;	char							name1[] = "FLOOR7_2";	// DOOM	char							name2[] = "GRNROCK";	// DOOM II	char							*name;		gBackscreenFilled = 1;		if ((gHiRes == 0) && (scaledviewwidth == kScreenWidth))		return;	if ((gHiRes > 0) && (scaledviewwidth == kHiResScreenWidth))		return;		if (commercial)		name = name2;	else		name = name1;		src = W_CacheLumpName (name, PU_CACHE);	dest = screens[1];	remapArray = remapMac;		// Draw the rock, but remap into Macintosh colors.		for (y = 0; y < kScreenHeight - SBARHEIGHT; y++)	{		for (x = 0; x < kScreenWidth / 64; x++)		{			temp = ((y & 63) << 6);			for (i = 0; i < 64; i++)				dest[i] = remapArray[ src[ temp++ ]];						dest += 64;		}	}		if (TRUE)	{		int		svw = scaledviewwidth;		int		vwx = viewwindowx;		int		vwy = viewwindowy;		int		vh = viewheight;				// scaledviewwidth, viewwindowx, etc. are based on coordinates		// for screen[0], not screen[1], which is low resolution. Divide by 2.				if (gHiRes)		{			svw >>= 1;			vwx >>= 1;			vwy >>= 1;			vh >>= 1;		}				patch = W_CacheLumpName ("brdr_t", PU_CACHE);		for (x = 0; x < svw ; x += 8)			V_DrawPatch (vwx + x, vwy - 8, 1, patch);				patch = W_CacheLumpName ("brdr_b", PU_CACHE);		for (x = 0; x < svw; x += 8)			V_DrawPatch (vwx + x, vwy + vh, 1, patch);				patch = W_CacheLumpName ("brdr_l",PU_CACHE);		for (y = 0; y < vh; y += 8)			V_DrawPatch (vwx - 8, vwy + y, 1, patch);				patch = W_CacheLumpName ("brdr_r",PU_CACHE);		for (y = 0; y < vh; y += 8)			V_DrawPatch (vwx + svw, vwy + y, 1, patch);		V_DrawPatch (vwx - 8, vwy - 8, 1, W_CacheLumpName ("brdr_tl",PU_CACHE));		V_DrawPatch (vwx + svw, vwy - 8, 1, W_CacheLumpName ("brdr_tr",PU_CACHE));		V_DrawPatch (vwx - 8, vwy + vh, 1, W_CacheLumpName ("brdr_bl",PU_CACHE));		V_DrawPatch (vwx + svw, vwy + vh, 1, W_CacheLumpName ("brdr_br",PU_CACHE));	}}void R_VideoErase (unsigned ofs, int count){	if (gHiRes)		I_Error("R_VideoErase called in Hi res mode!");	else		BlockMoveData (screens[1] + ofs, screens[0] + ofs, count);}/*==================== R_DrawViewBorder== Draws the border around the view for different size windows==================*/void R_DrawViewBorder (void){	int			top, top2, side, ofs, i;	if ((!gHiRes) && (scaledviewwidth == kScreenWidth))		return;	if ((gHiRes) && (scaledviewwidth == kHiResScreenWidth))		return; 	 	if (gHiRes) 	{ 	// V_CopyRect: src coordinates are low resolution, dst coordinates 	// are high resolution. width and height are src-coordinate based. 			top = ((kScreenHeight - SBARHEIGHT) - (viewheight >> 1)) >> 1;		side = (kScreenWidth - (scaledviewwidth >> 1)) >> 1;				//          x, y, srcScreen, width, height, dstX, dstY, dstScreen		 	// top 		V_CopyRect (0, 0, 1, kScreenWidth, top, 0, 0, 0); 	// left: to bottom.		V_CopyRect (0, top, 1, side, (kScreenHeight - SBARHEIGHT) - top, 0, top * 2, 0);	// right: to bottom.		V_CopyRect (kScreenWidth - side, top, 1, side, (kScreenHeight - SBARHEIGHT) - top, 			(kScreenWidth - side) * 2, top * 2, 0);	// bottom		V_CopyRect (side, top + (viewheight >> 1), 1, (scaledviewwidth >> 1),			(kScreenHeight - SBARHEIGHT) - (top + (viewheight >> 1)),			side * 2, (top + (viewheight >> 1)) * 2, 0); 	} 	else 	{		top = ((kScreenHeight - SBARHEIGHT) - viewheight) >> 1;		side = (kScreenWidth - scaledviewwidth) >> 1;				top2 = top * kScreenWidth;				// copy top and one line of left side		R_VideoErase (0, top2 + side);				// copy one line of right side and bottom		ofs = (viewheight + top) * kScreenWidth - side;		R_VideoErase (ofs, top2 + side);				// copy sides using wraparound		ofs = top2 + kScreenWidth - side;		side <<= 1;				for (i = 1; i < viewheight; i++)		{			R_VideoErase (ofs, side);			ofs += kScreenWidth;		}	}}