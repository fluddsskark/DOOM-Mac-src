#ifndef __MPW_VERSION__	#if defined(powerc) || defined(__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#else	#include <Files.h>	#include <Fonts.h>	#include <Strings.h>#endif#include "LionDoom.h"// M_menu.c #include "doomdef.h"#include "hu_stuff.h"#include <Movies.h>#include <stdlib.h>#include <ctype.h>#include <DoomResources.h>extern void HelpScreen (void);extern void G_DoLoadGame (FSSpec *fSpec);extern void G_DoSaveGame (FSSpec *fSpec);extern patch_t			*hu_font[HU_FONTSIZE]; extern boolean			message_dontfuckwithme;extern short			gAppVRefNum;extern long				gAppDirId;extern int				gOneTimeFullUpdate;extern int				automapactive;extern int				gDoSaveAs;extern short			gCursID;extern boolean			sendsave;extern int				gBackscreenFilled;extern FSSpec			gQuickSave;extern boolean			chat_on;        // in heads-up code extern int				usejoystick;extern int				useMouse;extern boolean			sendpause; extern boolean			gGameLoaded;extern Boolean			gQuickTimeInstalled;//// defaulted values // int		mouseSensitivity = 0;		// has default int		showMessages = 0;			// has default 0 = off, 1 = on int		sfxVolume = 0;				// has default 0 - 15 int		musicVolume = 0;			// has default 0 - 15 int		detailLevel = 0;			// has default, 1 = high, 0 = normal int		screenblocks = 0;			// has default int		screenSize = 0;				// temp for screenblocks (0-9)  int		messageToPrint = 0;			// 1 = message to be printed char    *messageString = NULL;		// ...and here's the message string! int		messx = 0;					// message x & y int		messy = 0; int		messageLastMenuActive = 0; boolean messageNeedsInput = 0;      // timed message = no input from user void    (*messageRoutine)(int response) = NULL;#define SAVESTRINGSIZE  24  char    gammamsg[5][26] ={	GAMMALVL0,	GAMMALVL1,	GAMMALVL2,	GAMMALVL3,	GAMMALVL4 }; int		saveStringEnter = 0;				// we're going to be entering a savegame string int		saveSlot = 0;						// which slot to save in int		saveCharIndex = 0;					// which char we're editing char    saveOldString[SAVESTRINGSIZE];		// old save description before edit  boolean inhelpscreens = 0;boolean menuactive = 0;#define SKULLXOFF       -32 #define LINEHEIGHT      16  char    savegamestrings[10][SAVESTRINGSIZE];////      QuitDOOM messages // char	*endmsg[8] ={	QUITMSG,	"Please donÕt leave, thereÕs more demons to toast!",	"LetÕs beat it -- this is turning into a bloodbath!",	//"i wouldn't leave if i were you.\ndos is much worse.",	"Well, go click on your icons then. IÕll be waiting.",	// "you're trying to say you like dos\nbetter than me, right?",	"YouÕre saying you like the desktop pattern better than me, right?",	"DonÕt leave yet -- thereÕs a demon around that corner!",	"Ya know, next time you come in here IÕm gonna toast ya.",	"Go ahead and leave. See if I care."};////      QuitDOOM II messages //#if 1char endmsg2[8][80]={	QUITMSG,	"you want to quit?\nthen, thou hast lost an eighth!",	// "don't go now, there's a \ndimensional shambler waiting\nat the dos prompt!",	"don't go now, there's a \ndimensional shambler waiting\nin your system folder!",	"get outta here and go back\nto your boring programs.",	"if i were your boss, i'd \n deathmatch ya in a minute!",	"look, bud. you leave now\nand you forfeit your body count!",	"just leave. when you come\nback, i'll be waiting with a bat.",	"you're lucky i don't smack\nyou for thinking about leaving."};#elsechar endmsg2[8][80]={	QUITMSG,	"fuck you, pussy!\nget the fuck out!",	"you quit and i'll jizz\nin your cystholes!",	"if you leave, i'll make\nthe lord drink my jizz.",	"hey, ron! can we say\n'fuck' in the game?",	"i'd leave: this is just\nmore monsters and levels.\nwhat a load.",	"suck it down, asshole!\nyou're a fucking wimp!",	"don't quit now! we're \nstill spending your money!"};#endifchar    endstring[160];//// MENU TYPEDEFS // typedef struct {	short   status;					// 0 = no cursor here, 1 = ok,2 = arrows ok 	char    name[10];	void    (*routine)(int choice); // choice = menu item #. if status = 2,									// ...choice=0:leftarrow,1:rightarrow 	char    alphaKey;				// hotkey in menu } menuitem_t; typedef struct menu_s {	short	numitems;               // # of menu items 	struct menu_s   *prevMenu;		// previous menu 	menuitem_t      *menuitems;     // menu items 	void    (*routine)();			// draw routine 	short   x,y;					// x,y of menu 	short   lastOn;					// last item user was on in menu } menu_t; short   itemOn = 0;					// menu item skull is on short   skullAnimCounter = 0;		// skull animation counter short   whichSkull = 0;				// which skull to draw char    *skullName[2] =				// graphic name of skulls 		{"M_SKULL1","M_SKULL2"}; menu_t  *currentMenu = NULL;		// current menudef #include "M_MENU.PROTO.H"//=============================================//// DOOM MENU ////============================================= enum {	newgame = 0,	options,	loadgame,	savegame,/*#ifdef SPECIAL	readthis,#endif*/	// quitdoom,	main_end} main_e; menuitem_t MainMenu[]={	{1,"M_NGAME",M_NewGame,'n'},	{1,"M_OPTION",M_Options,'o'},	{1,"M_LOADG",M_LoadGame,'l'},	{1,"M_SAVEG",M_SaveGame,'s'},/*#ifdef SPECIAL	{1,"M_RDTHIS",M_ReadThis2,'r'}, #endif*/	// {1,"M_RDTHIS",M_ReadThis,'r'},	// {1,"M_QUITG",M_QuitDOOM,'q'}}; menu_t  MainDef ={	main_end,	NULL,	MainMenu,	M_DrawMainMenu,	97, 64 + 24, // 97,64,	0 };//=============================================//// EPISODE SELECT ////============================================= enum {	ep1,	ep2,	ep3,#ifdef SPECIAL	ep4,#endif	ep_end } episodes_e; menuitem_t EpisodeMenu[]={	{1,"M_EPI1",M_Episode,'k'},	{1,"M_EPI2", M_Episode,'t'},	{1,"M_EPI3", M_Episode,'i'}#ifdef SPECIAL	,{1,"M_EPI4",M_Episode,'t'}#endif}; menu_t  EpiDef ={	ep_end,                         // # of menu items 	&MainDef,                               // previous menu 	EpisodeMenu,            // menuitem_t ->	M_DrawEpisode,                  // drawing routine ->	48,63,              // x,y 	ep1                             // lastOn };//=============================================//// NEW GAME ////============================================= enum {	killthings,	toorough,	hurtme,	violence,	nightmare,	newg_end } newgame_e; menuitem_t NewGameMenu[]={	{1,"M_JKILL",M_ChooseSkill,'i'},	{1,"M_ROUGH", M_ChooseSkill,'h'},	{1,"M_HURT", M_ChooseSkill,'h'},	{1,"M_ULTRA", M_ChooseSkill,'u'},	{1,"M_NMARE", M_ChooseSkill,'n'}}; menu_t  NewDef ={	newg_end,           // # of menu items 	&EpiDef,            // previous menu 	NewGameMenu,            // menuitem_t ->	M_DrawNewGame,                  // drawing routine ->	48,63,              // x,y 	hurtme                  // lastOn };//=============================================//// OPTIONS MENU ////============================================= enum {	endgame,	messages,//	detail,	scrnsize,	option_empty1,	mousesens,	option_empty2,	soundvol,	opt_end } options_e; menuitem_t OptionsMenu[]={	{1,"M_ENDGAM",M_EndGame,'e'},	{1,"M_MESSG",M_ChangeMessages,'m'},/*	{1,"M_DETAIL",M_ChangeDetail,'g'}, */	{2,"M_SCRNSZ",M_SizeDisplay,'s'},	{-1,"",0},	{2,"M_MSENS",M_ChangeSensitivity,'m'},	{-1,"",0},	{1,"M_SVOL",M_Sound,'s'}}; menu_t  OptionsDef ={	opt_end,	&MainDef,	OptionsMenu,	M_DrawOptions,	60,37,	0 };//=============================================//// Read This! MENU 1 & 2 ////============================================= enum {	rdthsempty1,	read1_end } read_e; menuitem_t ReadMenu1[]={	{1,"",M_ReadThis2,0}}; menu_t  ReadDef1 ={	read1_end,	&MainDef,	ReadMenu1,	M_DrawReadThis1,	280,185,	0 }; enum {	rdthsempty2,	read2_end } read_e2; menuitem_t ReadMenu2[]={	{1,"",M_FinishReadThis,0}}; menu_t  ReadDef2 = { 	read2_end, #ifdef SPECIAL	NULL,#else	&ReadDef1, #endif	ReadMenu2, 	M_DrawReadThis2, 	330,175, 	0 }; //=============================================//// SOUND VOLUME MENU ////============================================= enum {	sfx_vol,	sfx_empty1,	music_vol,	sfx_empty2,	sound_end } sound_e; menuitem_t SoundMenu[]={	{2,"M_SFXVOL",M_SfxVol,'s'},	{-1,"",0},	{2,"M_MUSVOL",M_MusicVol,'m'},	{-1,"",0}}; menu_t  SoundDef ={	sound_end,	&OptionsDef,	SoundMenu,	M_DrawSound,	80,64,	0 };//=============================================//// LOAD GAME MENU ////============================================= enum {	load1,	load2,	load3,	load4,	load5,	load6,	load_end } load_e; menuitem_t LoadMenu[]={	{1,"", M_LoadSelect,'1'},	{1,"", M_LoadSelect,'2'},	{1,"", M_LoadSelect,'3'},	{1,"", M_LoadSelect,'4'},	{1,"", M_LoadSelect,'5'},	{1,"", M_LoadSelect,'6'}}; menu_t  LoadDef ={	load_end,	&MainDef,	LoadMenu,	M_DrawLoad,	80,54,	0 };//=============================================//// SAVE GAME MENU ////============================================= menuitem_t SaveMenu[]={	{1,"", M_SaveSelect,'1'},	{1,"", M_SaveSelect,'2'},	{1,"", M_SaveSelect,'3'},	{1,"", M_SaveSelect,'4'},	{1,"", M_SaveSelect,'5'},	{1,"", M_SaveSelect,'6'}}; menu_t  SaveDef ={	load_end,	&MainDef,	SaveMenu,	M_DrawSave,	80,54,	0 };//=============================================////      M_ReadSaveStrings - read the strings from the //      savegame files ////============================================= /*void M_ReadSaveStrings (void){	int			i;	Str255		name;	FSSpec		fileSpec;	short		err, fileRefNum;	long		count;		for (i = 0; i < load_end; i++)	{		// if (M_CheckParm("-cdrom"))		// 	sprintf((char *)name,"c:\\doomdata\\"SAVEGAMENAME"%d.dsg",i);		// else				sprintf((char *)name, SAVEGAMENAME"%d.dsg", i);				c2pstr((char *)name);				err = FSMakeFSSpec(gAppVRefNum, gAppDirId, name, &fileSpec);		if (err != noErr)		{		CantLoadSaveGames :			strcpy(&savegamestrings[i][0], EMPTYSTRING);			LoadMenu[i].status = 0;			continue;		}				err = FSpOpenDF(&fileSpec, fsRdWrPerm, &fileRefNum);		if (err != noErr)			goto CantLoadSaveGames;				count = SAVESTRINGSIZE;		err = FSRead(fileRefNum, &count, &savegamestrings[i]);		if (err != noErr)			goto CantLoadSaveGames;				err = FSClose(fileRefNum);				LoadMenu[i].status = 1;	}}*///=============================================////      M_LoadGame ////============================================= void M_DrawLoad (void){	int             i;	V_DrawPatchLRes (72, 28, 0, W_CacheLumpName("M_LOADG", PU_CACHE));	for (i = 0; i < load_end; i++)	{		M_DrawSaveLoadBorder(LoadDef.x, LoadDef.y + LINEHEIGHT * i);		M_WriteText(LoadDef.x, LoadDef.y + LINEHEIGHT * i, savegamestrings[i]);	}}////      Draw border for the savegame description // void M_DrawSaveLoadBorder (int x,int y){	int             i;	V_DrawPatchLRes (x-8, y+7, 0, W_CacheLumpName("M_LSLEFT",PU_CACHE));		for (i = 0;i < 24;i++)	{		V_DrawPatchLRes (x, y+7, 0, W_CacheLumpName("M_LSCNTR",PU_CACHE));		x += 8;	}	V_DrawPatchLRes (x, y+7, 0, W_CacheLumpName("M_LSRGHT",PU_CACHE));}////      User wants to load this game // void M_LoadSelect (int choice){	/*	if (M_CheckParm("-cdrom"))		sprintf(name, "c:\\doomdata\\"SAVEGAMENAME"%d.dsg", choice);	else	*/		/*	sprintf(name, SAVEGAMENAME"%d.dsg", choice);	G_LoadGame (name);	M_ClearMenus ();	*/}////      Selected from DOOM menu // void M_LoadGame (int choice){	if (netgame)	{		M_StartMessage(LOADNET,NULL,false);		return;	}		gameaction = ga_loadgame;	gGameLoaded = false;			// Prompt user	M_ClearMenus();}//=============================================////      M_SaveGame ////============================================= void M_DrawSave(void){	int             i;		V_DrawPatchLRes (72,28,0,W_CacheLumpName("M_SAVEG",PU_CACHE));	for (i = 0;i < load_end; i++)	{		M_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+LINEHEIGHT*i);		M_WriteText(LoadDef.x,LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);	}		if (saveStringEnter)	{		i = M_StringWidth(savegamestrings[saveSlot]);		M_WriteText(LoadDef.x + i,LoadDef.y+LINEHEIGHT*saveSlot,"_");	}}////      M_Responder calls this when user is finished // void M_DoSave(int slot){/*	G_SaveGame (slot,savegamestrings[slot]);	M_ClearMenus ();	//      PICK QUICKSAVE SLOT YET?	if (quickSaveSlot == -2)		quickSaveSlot = slot;*/}////      User wants to save. Start string input for M_Responder // void M_SaveSelect(int choice){	saveStringEnter = 1;            // we're going to be intercepting all chars 	saveSlot = choice;	strcpy(saveOldString,savegamestrings[choice]);	if (!strcmp(savegamestrings[choice],EMPTYSTRING))		savegamestrings[choice][0] = 0;	saveCharIndex = strlen(savegamestrings[choice]);}////      Selected from DOOM menu // void M_SaveGame (int choice){	if (!usergame)	{		M_StartMessage(SAVEDEAD,NULL,false);		return;	}		if (gamestate != GS_LEVEL)		return;		gameaction = ga_savegame;	gGameLoaded = false;			// Prompt user	sendsave = true;	M_ClearMenus();}//=============================================////      M_QuickSave ////============================================= char    tempstring[80]; void M_QuickSaveResponse(int ch){/*	if (ch == 'y')	{		M_DoSave(quickSaveSlot);		S_StartSound(NULL,sfx_swtchx);	}*/} void M_QuickSave(void){	if (!usergame)	{		S_StartSound(NULL,sfx_oof);		return;	}	if (gamestate != GS_LEVEL)		return;	gameaction = ga_savegame;	M_ClearMenus();}//=============================================////      M_QuickLoad ////============================================= void M_QuickLoadResponse(int ch){/*	if (ch == 'y')	{		M_LoadSelect(quickSaveSlot);		S_StartSound(NULL,sfx_swtchx);	}*/} void M_QuickLoad (void){	if (netgame)	{		M_StartMessage(QLOADNET,NULL,false);		return;	}		if (gGameLoaded == false)	{		M_StartMessage(QSAVESPOT,NULL,false);		return;	}		gameaction = ga_loadgame;	M_ClearMenus();}//=============================================//// Read This Menus ////============================================= void M_DrawReadThis1(void){	inhelpscreens = true;	V_DrawPatchLRes (0,0,0,W_CacheLumpName("HELP2",PU_CACHE)); // HR1} void M_DrawReadThis2(void){	inhelpscreens = true;	V_DrawPatchLRes (0,0,0,W_CacheLumpName("HELP1",PU_CACHE)); // HR1}void M_DrawReadThisRetail(void){	inhelpscreens = true;	V_DrawPatchLRes (0,0,0,W_CacheLumpName("HELP",PU_CACHE)); // HR1}//=============================================//// Change Sfx & Music volumes ////============================================= void M_DrawSound(void){	V_DrawPatchLRes (60,38,0,W_CacheLumpName("M_SVOL",PU_CACHE));	M_DrawThermo(SoundDef.x,SoundDef.y+LINEHEIGHT*(sfx_vol+1),				16,sfxVolume);	M_DrawThermo(SoundDef.x,SoundDef.y+LINEHEIGHT*(music_vol+1),				16,musicVolume);} void M_Sound(int choice){	M_SetupNextMenu(&SoundDef);} void M_SfxVol(int choice){	switch(choice)	{		case 0:			if (sfxVolume)				sfxVolume--;			break;		case 1:			if (sfxVolume < 15)				sfxVolume++;			break;	}		S_SetSfxVolume(sfxVolume * 8);}extern Boolean		gMusicOff;extern Boolean		gQuickTimeLoaded;extern int			gLastSongStarted;extern int			gLastSongLooping; void M_MusicVol(int choice){	switch(choice)	{		case 0:			if (musicVolume)			{				musicVolume--;				if ((musicVolume == 0) && gQuickTimeInstalled)				{					MenuHandle	theMenu;										theMenu = GetMHandle(mOptionsMenu);					SetItemMark(theMenu, 11, noMark);					gMusicOff = TRUE;					S_StopMusic();										if (gQuickTimeLoaded)					{						gQuickTimeLoaded = FALSE;						ExitMovies();					}				}			}			break;					case 1:			if ((musicVolume < 15) && gQuickTimeInstalled)			{				musicVolume++;				if (musicVolume && gMusicOff)				{					MenuHandle	theMenu;										// Turn it on										theMenu = GetMHandle(mOptionsMenu);					SetItemMark(theMenu, 11, checkMark);										gMusicOff = FALSE;										if (!gQuickTimeLoaded)					{						EnterMovies();						gQuickTimeLoaded = TRUE;					}										S_ChangeMusic(gLastSongStarted, gLastSongLooping);				}			}			break;	}		S_SetMusicVolume(musicVolume * 8);}//=============================================//// M_DrawMainMenu ////============================================= void M_DrawMainMenu(void){	V_DrawPatchLRes (94,2,0,W_CacheLumpName("M_DOOM",PU_CACHE));}//=============================================//// M_NewGame ////============================================= void M_DrawNewGame(void){	V_DrawPatchLRes (96,14,0,W_CacheLumpName("M_NEWG",PU_CACHE));	V_DrawPatchLRes (54,38,0,W_CacheLumpName("M_SKILL",PU_CACHE));} void M_NewGame(int choice){	if (netgame && !demoplayback)	{		M_StartMessage(NEWGAME,NULL,false);		return;	}		if (commercial)	{		NewDef.lastOn = startskill;		M_SetupNextMenu(&NewDef);	}	else		M_SetupNextMenu(&EpiDef);}//=============================================////      M_Episode ////============================================= int     epi; void M_DrawEpisode(void){	V_DrawPatchLRes (54,38,0,W_CacheLumpName("M_EPISOD",PU_CACHE));} void M_VerifyNightmare(int ch){	if (ch != 'y')		return;			G_DeferedInitNew(nightmare,epi+1,1);	M_ClearMenus ();} void M_ChooseSkill(int choice){	if (choice == nightmare)	{		M_StartMessage(NIGHTMARE, (void *)M_VerifyNightmare,true);		return;	}		G_DeferedInitNew(choice,epi+1,1);	startskill = choice;	M_ClearMenus ();} void M_Episode(int choice){	if (shareware && choice)	{		M_StartMessage(SWSTRING,NULL,false);		M_SetupNextMenu(&ReadDef1);		return;	}	epi = choice;	M_SetupNextMenu(&NewDef);}//=============================================//// M_Options ////============================================= char    detailNames[2][9] = {"M_GDHIGH","M_GDLOW"}; char    msgNames[2][9] = {"M_MSGOFF","M_MSGON"}; void M_DrawOptions(void){	V_DrawPatchLRes (108,15,0,W_CacheLumpName("M_OPTTTL",PU_CACHE));		/*	V_DrawPatchLRes (OptionsDef.x + 175,OptionsDef.y+LINEHEIGHT*detail,0,		W_CacheLumpName(detailNames[gHiRes & 0x01], PU_CACHE));	*/		V_DrawPatchLRes (OptionsDef.x + 120,OptionsDef.y+LINEHEIGHT*messages,0,		W_CacheLumpName(msgNames[showMessages],PU_CACHE));	M_DrawThermo(OptionsDef.x,OptionsDef.y+LINEHEIGHT*(mousesens+1),				10,mouseSensitivity);		M_DrawThermo(OptionsDef.x,OptionsDef.y+LINEHEIGHT*(scrnsize+1),				9,screenSize);} void M_Options(int choice){	M_SetupNextMenu(&OptionsDef);}//=============================================////      Toggle messages on/off ////============================================= void M_ChangeMessages(int choice){	showMessages = 1 - showMessages;		if (!showMessages)		players[consoleplayer].message = MSGOFF;	else 		players[consoleplayer].message = MSGON ;	message_dontfuckwithme = true;}//=============================================//// M_EndGame ////============================================= void M_EndGameResponse(int ch){	if (ch != 'y')	{		gOneTimeFullUpdate = 1;		return;	}			currentMenu->lastOn = itemOn;	M_ClearMenus ();	D_StartTitle ();} void M_EndGame(int choice){	if (!usergame)	{		S_StartSound(NULL,sfx_oof);		return;	}		if (netgame)	{		M_StartMessage(NETEND,NULL,false);		return;	}		M_StartMessage(ENDGAME, (void *)M_EndGameResponse,true);}//=============================================//// M_ReadThis ////============================================= void M_ReadThis(int choice){	M_SetupNextMenu(&ReadDef1);} void M_ReadThis2(int choice){	M_SetupNextMenu(&ReadDef2);} void M_FinishReadThis(int choice){	M_SetupNextMenu(&MainDef);}//=============================================//// M_QuitDOOM ////============================================= int     quitsounds[8] ={	sfx_pldeth,	sfx_dmpain,	sfx_popain,	sfx_slop,	sfx_telept,	sfx_posit1,	sfx_posit3,	sfx_sgtatk }; int     quitsounds2[8] ={	sfx_vilact,	sfx_getpow,	sfx_boscub,	sfx_slop,	sfx_skeswg,	sfx_kntdth,	sfx_bspact,	sfx_sgtatk }; void M_QuitResponse (int ch){	long dummy;		if (ch != 'y')		return;		if (!netgame)	{		if (commercial)			S_StartSound(NULL,quitsounds2[(gametic>>2)&7]);		else			S_StartSound(NULL,quitsounds[(gametic>>2)&7]);				// I_WaitVBL(105);				Delay(80,  &dummy);	}		I_Quit ();} void M_QuitDOOM(int choice){/*	if (commercial)		#ifdef FRENCH		sprintf(endstring,"%s\n\n"DOSY, endmsg2[0]);		#else		sprintf(endstring,"%s\n\n"DOSY, endmsg2[(gametic>>2)&7]);		#endif	else		sprintf(endstring,"%s\n\n"DOSY, endmsg[(gametic>>2)&7]);	M_StartMessage(endstring, (void *)M_QuitResponse,true);*/	sprintf(endstring, "%s", endmsg[ (gametic >> 2) & 0x07 ]);	c2pstr(endstring);	ParamText((unsigned char *)endstring, "\p", "\p", "\p");		InitCursor();	gCursID = -2;		if (Alert(601, NULL) == 1)	{		DisposePtr( (Ptr)screens[0] );	// Tons o memory freed up!			screens[0] = screens[1] = screens[2] = screens[3] = NULL;		I_Quit ();	}		if (useMouse || usejoystick)		HideCursor();} void M_ChangeSensitivity(int choice){	switch(choice)	{		case 0:			if (mouseSensitivity)				mouseSensitivity--;			break;		case 1:			if (mouseSensitivity < 9)				mouseSensitivity++;			break;	}} void M_ChangeDetail(int choice){	if (!automapactive)	{		detailLevel++;		if (detailLevel > 2)			detailLevel = 0;		R_SetViewSize (screenblocks, detailLevel);				if (detailLevel == 2)			players[consoleplayer].message = DETAILHI;		else if (detailLevel == 1)			players[consoleplayer].message = DETAILMED;		else 			players[consoleplayer].message = DETAILLO;				gOneTimeFullUpdate = 1;	}}void M_SizeDisplay (int choice){	switch(choice)	{		case 0:			if (screenSize > 0)			{				screenblocks--;				screenSize--;			}			break;		case 1:			if (screenSize < 8)			{				screenblocks++;				screenSize++;			}			break;	}		R_SetViewSize (screenblocks, detailLevel);}//=============================================//=============================================////      Menu Functions ////=============================================//============================================= void M_DrawThermo(int x,int y,int thermWidth,int thermDot){	int     xx,i;	xx = x;	V_DrawPatchLRes (xx,y,0,W_CacheLumpName("M_THERML",PU_CACHE));	xx += 8;	for (i=0;i<thermWidth;i++)	{		V_DrawPatchLRes (xx,y,0,W_CacheLumpName("M_THERMM",PU_CACHE));		xx += 8;	}	V_DrawPatchLRes (xx,y,0,W_CacheLumpName("M_THERMR",PU_CACHE));	V_DrawPatchLRes ((x+8) + thermDot*8,y,		0,W_CacheLumpName("M_THERMO",PU_CACHE));} void M_DrawEmptyCell(menu_t *menu,int item){	V_DrawPatchLRes (menu->x - 10,        menu->y+item*LINEHEIGHT - 1, 0,		W_CacheLumpName("M_CELL1",PU_CACHE));} void M_DrawSelCell(menu_t *menu,int item){	V_DrawPatchLRes (menu->x - 10,        menu->y+item*LINEHEIGHT - 1, 0,		W_CacheLumpName("M_CELL2",PU_CACHE));} void M_StartMessage(char *string,void *routine,boolean input){		messageLastMenuActive = menuactive;//		menuactive = 0;		messageToPrint = 1;		messageString = string;		messageRoutine = routine;		messageNeedsInput = input;		menuactive = true;		return;} void M_StopMessage(void){	menuactive = messageLastMenuActive;	messageToPrint = 0;		gOneTimeFullUpdate = 1;}//=========================================================================////      Find string width from hu_font chars ////========================================================================= int M_StringWidth(char *string){	int             i;	int             w = 0;	int             c;		for (i = 0;i < strlen(string);i++)	{		c = toupper(string[i]) - HU_FONTSTART;		if (c < 0 || c >= HU_FONTSIZE)			w += 4;		else 			w += SHORT (hu_font[c]->width);	}			return w;}//=========================================================================////      Find string height from hu_font chars ////========================================================================= int M_StringHeight(char *string){	int             i;	int             h;	int             height = SHORT(hu_font[0]->height);		h = height;	for (i = 0;i < strlen(string);i++)		if (string[i] == '\n')			h += height;			return h;}//=========================================================================////      Write a string using the hu_font ////========================================================================= void M_WriteText(int x, int y, char *string){	int             w;	char    *ch;	int             c;	int             cx;	int             cy;			ch = string;	cx = x;	cy = y;		while(1)	{		c = *ch++;		if (!c)			break;		if (c == '\n')		{			cx = x;			cy += 12;			continue;		}				c = toupper(c) - HU_FONTSTART;		if (c < 0 || c>= HU_FONTSIZE)		{			cx += 4;			continue;		}				w = SHORT (hu_font[c]->width);		if (cx+w > kScreenWidth)			break;			V_DrawPatchLRes(cx, cy, 0, hu_font[c]);		cx+=w;	}}/*===============================================================================							CONTROL PANEL ===============================================================================*//*======================= M_Responder =======================*/ boolean M_Responder (event_t *ev){	int             ch;	int             i;	static  int     joywait = 0;	static  int     mousewait = 0;	static  int     mousey = 0;	static  int     lasty = 0;	static  int     mousex = 0;	static  int     lastx = 0;		ch = -1;		if (ev->type == ev_joystick && joywait < I_GetTime())	{		if (ev->data3 == -1)		{			ch = KEY_UPARROW;			joywait = I_GetTime() + 5;		}		else if (ev->data3 == 1)		{			ch = KEY_DOWNARROW;			joywait = I_GetTime() + 5;		}				if (ev->data2 == -1)		{			ch = KEY_LEFTARROW;			joywait = I_GetTime() + 2;		}		else if (ev->data2 == 1)		{			ch = KEY_RIGHTARROW;			joywait = I_GetTime() + 2;		}				if (ev->data1&1)		{			ch = KEY_ENTER;			joywait = I_GetTime() + 5;		}		if (ev->data1&2)		{			ch = KEY_BACKSPACE;			joywait = I_GetTime() + 5;		}	}	else 	if (ev->type == ev_mouse && mousewait < I_GetTime())	{		mousey += ev->data3;		if (mousey < lasty-30)		{			ch = KEY_DOWNARROW;			mousewait = I_GetTime() + 5;			mousey = lasty -= 30;		}		else if (mousey > lasty+30)		{			ch = KEY_UPARROW;			mousewait = I_GetTime() + 5;			mousey = lasty += 30;		}				mousex += ev->data2;		if (mousex < lastx-30)		{			ch = KEY_LEFTARROW;			mousewait = I_GetTime() + 5;			mousex = lastx -= 30;		}		else if (mousex > lastx+30)		{			ch = KEY_RIGHTARROW;			mousewait = I_GetTime() + 5;			mousex = lastx += 30;		}				if (ev->data1&1)		{			ch = KEY_ENTER;			mousewait = I_GetTime() + 15;		}					if (ev->data1&2)		{			ch = KEY_BACKSPACE;			mousewait = I_GetTime() + 15;		}	}	else 	if (ev->type == ev_keydown)	{		ch = ev->data1;	}		if (ch == -1)		return false;				//	//      Save Game string input 	//	if (saveStringEnter)	{		switch(ch)		{			case KEY_BACKSPACE:				if (saveCharIndex > 0)				{					saveCharIndex--;					savegamestrings[saveSlot][saveCharIndex] = 0;				}				break;							case KEY_ESCAPE:				saveStringEnter = 0;				strcpy(&savegamestrings[saveSlot][0],saveOldString);				break;							case KEY_ENTER:				saveStringEnter = 0;				if (savegamestrings[saveSlot][0])					M_DoSave(saveSlot);				break;							default:				ch = toupper(ch);				if (ch != 32)					if (ch-HU_FONTSTART < 0 || ch-HU_FONTSTART >= HU_FONTSIZE)						break;				if (ch >= 32 && ch <= 127 &&					saveCharIndex < SAVESTRINGSIZE-1 &&				  M_StringWidth(savegamestrings[saveSlot]) <					(SAVESTRINGSIZE-2)*8)				{					savegamestrings[saveSlot][saveCharIndex++] = ch;					savegamestrings[saveSlot][saveCharIndex] = 0;				}				break;		}		return true;	}		//	//      Take care of any messages that need input 	//	if (messageToPrint)	{		if (messageNeedsInput == true &&		   !(ch == ' ' || ch == 'n' || ch == 'y' || ch == KEY_ESCAPE))		   return false;				menuactive = messageLastMenuActive;		messageToPrint = 0;		if (messageRoutine)			messageRoutine(ch);		gOneTimeFullUpdate = 1;					menuactive = false;		S_StartSound(NULL,sfx_swtchx);		return true;	}		if (devparm && ch == KEY_F1)	{		G_ScreenShot ();		return true;	}			//	// F-Keys 	//	if (!menuactive)		switch(ch)		{			case KEY_MINUS:         // Screen size down 				if (automapactive || chat_on)					return false;				M_SizeDisplay(0);				S_StartSound(NULL,sfx_stnmov);				return true;							case KEY_EQUALS:        // Screen size up 				if (automapactive || chat_on)					return false;				M_SizeDisplay(1);				S_StartSound(NULL,sfx_stnmov);				return true;							case KEY_F1:            // Help key			/*			#ifdef SPECIAL				M_StartControlPanel ();				currentMenu = &ReadDef2;				itemOn = 0;				S_StartSound(NULL,sfx_swtchn);				return true;			#else			*/								S_StartSound(NULL,sfx_swtchn);				HelpScreen();				return true;			/*			#endif			*/						case KEY_F2:            // Save As				gGameLoaded = false;			// Prompt user				sendsave = true;/*				gDoSaveAs = 1;				M_StartControlPanel();				S_StartSound(NULL,sfx_swtchn);				M_SaveGame(0);*/				return true;							case KEY_F3:            // Load 				M_StartControlPanel();				S_StartSound(NULL,sfx_swtchn);				M_LoadGame(0);				return true;							case KEY_F4:            // Sound Volume 				M_StartControlPanel ();				currentMenu = &SoundDef;				itemOn = sfx_vol;				S_StartSound(NULL,sfx_swtchn);				return true;							case KEY_F5:            // Detail toggle 				M_ChangeDetail(0);				S_StartSound(NULL,sfx_swtchn);				return true;							case KEY_F6:            // Quicksave 				sendsave = true;				S_StartSound(NULL,sfx_swtchn);				M_QuickSave();				return true;							case KEY_F7:            // End game 				S_StartSound(NULL,sfx_swtchn);				M_EndGame(0);				return true;							case KEY_F8:            // Toggle messages 				M_ChangeMessages(0);				S_StartSound(NULL,sfx_swtchn);				return true;							case KEY_F9:            // Quickload 				S_StartSound(NULL,sfx_swtchn);				M_QuickLoad();				return true;							case KEY_F10:           // Quit DOOM 				S_StartSound(NULL,sfx_swtchn);				M_QuitDOOM(0);				return true;						case KEY_F11:           // gamma toggle 				usegamma++;				if (usegamma > 4)					usegamma = 0;				players[consoleplayer].message = gammamsg[usegamma];				I_SetPalette (W_CacheLumpName ("PLAYPAL", PU_CACHE));				return true;		}	//	// Pop-up menu?	//	if (!menuactive)	{		if (ch == KEY_ESCAPE)		{			M_StartControlPanel ();			S_StartSound(NULL,sfx_swtchn);			return true;		}		return false;	}	//	// Keys usable within menu 	//	switch (ch)	{	case KEY_DOWNARROW:		do 		{			if (itemOn+1 > currentMenu->numitems-1)				itemOn = 0;			else itemOn++;			S_StartSound(NULL,sfx_pstop);		} while(currentMenu->menuitems[itemOn].status==-1);		return true;			case KEY_UPARROW:		do 		{			if (!itemOn)				itemOn = currentMenu->numitems-1;			else itemOn--;			S_StartSound(NULL,sfx_pstop);		} while(currentMenu->menuitems[itemOn].status==-1);		return true;	case KEY_LEFTARROW:		if (currentMenu->menuitems[itemOn].routine &&			currentMenu->menuitems[itemOn].status == 2)		{			S_StartSound(NULL,sfx_stnmov);			currentMenu->menuitems[itemOn].routine(0);		}		return true;			case KEY_RIGHTARROW:		if (currentMenu->menuitems[itemOn].routine &&			currentMenu->menuitems[itemOn].status == 2)		{			S_StartSound(NULL,sfx_stnmov);			currentMenu->menuitems[itemOn].routine(1);		}		return true;	case KEY_ENTER:		if (currentMenu->menuitems[itemOn].routine &&			currentMenu->menuitems[itemOn].status)		{			currentMenu->lastOn = itemOn;			if (currentMenu->menuitems[itemOn].status == 2)			{				currentMenu->menuitems[itemOn].routine(1);      // right arrow 				S_StartSound(NULL,sfx_stnmov);			}			else 			{				currentMenu->menuitems[itemOn].routine(itemOn);				S_StartSound(NULL,sfx_pistol);			}		}		return true;			case KEY_ESCAPE:		currentMenu->lastOn = itemOn;		M_ClearMenus ();		S_StartSound(NULL,sfx_swtchx);		return true;			case KEY_BACKSPACE:		currentMenu->lastOn = itemOn;		if (currentMenu->prevMenu)		{			currentMenu = currentMenu->prevMenu;			itemOn = currentMenu->lastOn;			S_StartSound(NULL,sfx_swtchn);		}		return true;		default:		for (i = itemOn+1;i < currentMenu->numitems;i++)			if (currentMenu->menuitems[i].alphaKey == ch)			{				itemOn = i;				S_StartSound(NULL,sfx_pstop);				return true;			}		for (i = 0;i <= itemOn;i++)			if (currentMenu->menuitems[i].alphaKey == ch)			{				itemOn = i;				S_StartSound(NULL,sfx_pstop);				return true;			}		break;		}	return false;}/*======================= M_StartControlPanel =======================*/ void M_StartControlPanel (void){	if (menuactive)		return;                 // intro might call this repeatedly	menuactive = 1;	currentMenu = &MainDef;         // JDC	itemOn = currentMenu->lastOn;   // JDC}/*================================================================================ M_Drawer == Called after the view has been rendered, but before it has been blitted.===============================================================================*/ void M_Drawer (void){	static          short   x,y;	short           i,max;	char            string[40];	int                     start;	inhelpscreens = false;	//	//      Horiz. & Vertically center string and print it.	//	if (messageToPrint)	{		start = 0;		y = 100 - M_StringHeight(messageString)/2;		while(*(messageString+start))		{			for (i = 0;i < strlen(messageString+start);i++)				if (*(messageString+start+i) == '\n')				{					memset(string,0,40);					strncpy(string,messageString+start,i);					start += i+1;					break;				}							if (i == strlen(messageString+start))			{				strcpy(string,messageString+start);				start += i;			}							x = 160 - M_StringWidth(string)/2;			M_WriteText(x,y,string);			y += SHORT(hu_font[0]->height);		}		return;	}	if (!menuactive)		return;	if (currentMenu->routine)		currentMenu->routine();         // call Draw routine 	//	// DRAW MENU 	//	x = currentMenu->x;	y = currentMenu->y;	max = currentMenu->numitems;	for (i = 0; i < max; i++)	{		if (currentMenu->menuitems[i].name[0])			V_DrawPatchLRes (x, y, 0, W_CacheLumpName(currentMenu->menuitems[i].name ,PU_CACHE));		y += LINEHEIGHT;	}	//	// DRAW SKULL 	//	V_DrawPatchLRes(x + SKULLXOFF,currentMenu->y - 5 + itemOn*LINEHEIGHT, 0,				W_CacheLumpName(skullName[whichSkull],PU_CACHE));	//I_FinishUpdate();	// ¥¥ Added by DG.}/*======================= M_ClearMenus =======================*/ void M_ClearMenus (void){	menuactive = 0;//      if (!netgame && usergame && paused)//              sendpause = true;	gOneTimeFullUpdate = 1;	if (gBackscreenFilled && gamestate != GS_FINALE)		R_DrawViewBorder();}//=============================================//// M_SetupNextMenu ////============================================= void M_SetupNextMenu(menu_t *menudef){	currentMenu = menudef;	itemOn = currentMenu->lastOn;}/*======================= M_Ticker =======================*/ void M_Ticker (void){	if (--skullAnimCounter <= 0)	{		whichSkull ^= 1;		skullAnimCounter = 8;	}}/*======================= M_Init =======================*/ void M_Init (void){	currentMenu = &MainDef;	menuactive = 0;	itemOn = currentMenu->lastOn;	whichSkull = 0;	skullAnimCounter = 10;	screenSize = screenblocks - 3;	messageToPrint = 0;	messageString = NULL;	messageLastMenuActive = menuactive;	// quickSaveSlot = -1;	gOneTimeFullUpdate = 1;		if (commercial)	{		// MainMenu[readthis] = MainMenu[quitdoom];		MainDef.numitems--;		MainDef.y += 8;				NewDef.prevMenu = &MainDef;		ReadDef1.routine = M_DrawReadThisRetail;		ReadDef1.x = 330;		ReadDef1.y = 165;		ReadMenu1[0].routine = M_FinishReadThis;	}}