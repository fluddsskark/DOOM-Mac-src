#define global#ifndef __MPW_VERSION__	#if defined(powerc) || defined(__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#else	#include <Fonts.h>	#include <Resources.h>	#include <SegLoad.h>#endif#include "LionDoom.h"#include <Lion.h>#include <AppleEvents.h>#include <GestaltEqu.h>#include <Menus.h>#include <Movies.h>#include <OSUtils.h>#include <Palettes.h>#include <QuickDraw.h>#include <Sound.h>#include <StandardFile.h>#include <ToolUtils.h>#include <Windows.h>#include "DoomResources.h"#include "CTBNet.h"#include "NetDialogs.h"#define	kOptionKey			0x3A#include "CTBNet.h"#define	kOptionKey			0x3A#define kEscKey					0x35#define kMyDelayTicks		2#define IsKeyPressed(a) ((gKeyState[ a >> 3 ] >> (a & 0x07)) & 0x01)#ifdef __MPW_VERSION__	#if defined(powerc) || defined (__powerc)		QDGlobals		qd;	#endif#endif#include "Offscreen.h"#include "doomdef.h"#include "DoomResources.h"#include "I_MAIN.PROTO.H"#include "MACALLOCA.PROTO.H"#include "r_local.h"#include "MacPCSwitches.h"#include "DebugSwitches.h"#include <ctype.h>#define MAXWADFILES             8CTabHandle		gClut;extern int							usejoystick;extern skill_t					startskill;extern int							sfxVolume;							// has default 0 - 15 extern int							musicVolume;						// has default 0 - 15 extern FSSpec						gWadFiles[MAXWADFILES];extern int							gNumWads;extern int							useMouse;extern int							startmap;extern Boolean					gMusicOff;extern Boolean					gFrameRateOn;extern Boolean					gOneTimeFullUpdate;extern Boolean					gInForeground;extern unsigned char 		gKeyState[16];extern int							gSndSfxVolume,												gSndMusicVolume;#define kMaxMacChannels			4extern short						gNumPlayersOnNet;extern SndChannelPtr		gMacSndChannels[kMaxMacChannels];extern drawseg_t	drawsegs[MAXDRAWSEGS];extern lighttable_t	*scalelight[LIGHTLEVELS][MAXLIGHTSCALE];extern lighttable_t	*scalelightfixed[MAXLIGHTSCALE];extern lighttable_t	*zlight[LIGHTLEVELS][MAXLIGHTZ];#if (__DEBUG_FILE__)FILE	*debugfile;#endifextern channel_t					*gDoomSndChannels;		// the set of channels availableextern musicinfo_t				*gCurrSongPlaying;		// music currently being playedextern boolean						gMusicPaused;						// whether songs are pausedextern void KeyboardPrefsDialog (Boolean inInitial);extern void EditChatMacros (Boolean inInitial);extern Boolean gLargeGraphics;Str255					gStr1;Boolean							gLoadGamePending = FALSE;FSSpec							gPendingGame = {0,0,"\p"};Boolean							gInitialLoadGame = TRUE;PaletteHandle				gThePalette;short								gAppVRefNum = 0;long								gAppDirId = 0;int									gMacStartTicks = 0;WindowPtr						gDoomWindow = NULL;CGrafPtr						gOffPort = NULL;GDHandle						gOffDevice = NULL;CGrafPtr						gOffSmallPort = NULL;GDHandle						gOffSmallDevice = NULL;GDHandle						gMainDevice = NULL;Rect								gDrawRect = { 0, 0, 0, 0 };Boolean							gPlayAlone = 0;Boolean							gKillFinder = 0;Boolean							gQuickTimeInstalled;Boolean							gQuickTimeLoaded;Boolean							gHasHelpManager = FALSE;short								gCursID = -2;long								gCursChange = 0L;int									turboparm = 0;boolean							nomonsters = 0;			// checkparm of -nomonstersboolean							respawnparm = 0;		// checkparm of -respawnboolean							fastparm = 0;			// checkparm of -fastModalFilterUPP			gInitialFilterProc;ModalFilterUPP			gOptionsFilterProc;FileFilterUPP				gWadFilterUPP;AEEventHandlerUPP		gOAPPHandlerProc;AEEventHandlerUPP		gODOCHandlerProc;AEEventHandlerUPP		gPDOCHandlerProc;AEEventHandlerUPP		gQUITHandlerProc;/* * *	Prototypes * */extern I_StartupSound (void);extern I_ShutdownSound (void);extern tLong GetGestaltResult (OSType gestaltSelector);extern void HideMenuBar ( void );extern void ShowMenuBar (void);extern void GetPlayMode (void);extern void M_LoadDefaults (void);extern void DrawPicOffscreen (PicHandle pic, GrafPtr gPtr, Rect *destRect);extern void S_Init (int sfxVolume, int musicVolume);extern void I_PlaySoundResource (int mchan, int id);extern int I_SoundIsPlaying (int handle);extern void I_StopSound (int handle);extern void AboutBox (void);extern void G_DoLoadGame (FSSpec *fSpec);void RestoreScreenDepth( void );Boolean ChangeScreenDepth ( short screenBitDepth, GDHandle screenDevice );Boolean CheckForEscBail (void);Boolean CheckForBail (void);Boolean TrackOffscreenRect (Rect *normR, Rect *hiliteR, Rect *dstR, Point where,	GrafPtr offBuff);void LionSplash (void);void CloseStatusDialog (void);void StatusDialog (tLong total, tLong current);void DrawStatusDialog (Boolean forUpdate);short InitialDialog (void);pascal Boolean InitialDialogFilter (DialogPtr dlg, EventRecord *evt, tWord *itm);short OptionsDialog (Boolean inInitial);pascal Boolean OptionsDialogFilter (DialogPtr dlg, EventRecord *evt, tWord *itm);Boolean GetWadFile (FSSpec *fsSpec);pascal Boolean WADFilter (CInfoPBPtr pb);void CopyPStr (void *src, void *dst);void AppendPStr (void *src, void *endstr);void MySetCursor (short cursID);void SpinCursor (void);void MyInitCursor (void);Boolean CompPStr (void *strA, void *strB);void StatusParamText(char *one, char *two, char *three, char *four);void BlackScreen(void);pascal OSErr HandleOAPPEvent (AppleEvent *aevt, AEDescList reply, tLong refCon);pascal OSErr HandleODOCEvent (AppleEvent *aevt, AEDescList reply, tLong refCon);pascal OSErr HandlePDOCEvent (AppleEvent *aevt, AEDescList reply, tLong refCon);pascal OSErr HandleQUITEvent (AppleEvent *aevt, AEDescList reply, tLong refCon);OSErr GotRequiredParams (AppleEvent *theAEvent);/******************************************************** *	KillEverybody.																			* *																											* *	Kills all running applications, including the				* *	Macintosh Finder. Requires System 7 or greater.			* ********************************************************/void KillEverybody (void){	ProcessSerialNumber		myProc, processSN;	ProcessSerialNumber		finderPSN;	ProcessInfoRec				infoRec;	Str31									processName;	FSSpec								procSpec;	OSErr									myErr = noErr, otherError;	AppleEvent						theEvent;	AEDesc								theAddress;	Boolean								ourFlag, notFinder, finderFound = false;	short										i;	GetCurrentProcess(&myProc);	// Preset the PSN to no PSN, see IM VI, the Process Manager		processSN.lowLongOfPSN = kNoProcess;	processSN.highLongOfPSN = kNoProcess;	finderPSN.lowLongOfPSN = 0L;	finderPSN.highLongOfPSN = 0L;    	do	{		myErr = GetNextProcess(&processSN);				SameProcess(&myProc, &processSN, &ourFlag);		if (!ourFlag && !finderFound)		{			// See if it's the Finder, we have to kill the finder LAST      // or else non-sys 7 apps won't get killed since the Finder       // must be there to convert the AppleEvent to Puppet Strings      // if the app is not AppleEvent aware.     				infoRec.processInfoLength = sizeof(ProcessInfoRec);			infoRec.processName = processName;			infoRec.processAppSpec = &procSpec;						GetProcessInformation(&processSN, &infoRec);						if ((infoRec.processSignature == 'MACS') && (infoRec.processType == 'FNDR'))			{				// save this number for later				finderPSN = processSN;				notFinder = false;				finderFound = true;			}			else			{				notFinder = true;				//finderFound = true;		Marci changed to above 01/24			}		}		else			notFinder = true;	//Marci added		if (!myErr && !ourFlag && notFinder)		{			otherError = AECreateDesc(typeProcessSerialNumber, (Ptr)&processSN, sizeof(processSN), &theAddress);						if (!otherError)				otherError = AECreateAppleEvent(kCoreEventClass, kAEQuitApplication, &theAddress, kAutoGenerateReturnID,					kAnyTransactionID, &theEvent);						if (!otherError)				AEDisposeDesc(&theAddress);            			// Again, the Finder will convert the AppleEvent to puppetstrings if			// the application is a System 6 or non-AE aware app.  This ONLY			// happens for the 4 required (oapp,odoc,pdoc, and quit) AppleEvents			// and ONLY if you use the PSN for the address			if (!otherError)				AESend(&theEvent, NULL, kAENoReply + kAEAlwaysInteract + kAECanSwitchLayer, 					kAENormalPriority, kAEDefaultTimeout, NULL, NULL);						AEDisposeDesc(&theEvent);		}	}	while (!myErr);		// Now, if the finder was running, it's safe to kill it	if (finderPSN.lowLongOfPSN || finderPSN.highLongOfPSN)	{		otherError = AECreateDesc(typeProcessSerialNumber, (Ptr)&finderPSN, sizeof(processSN), &theAddress);		if (!otherError)			otherError = AECreateAppleEvent(kCoreEventClass, kAEQuitApplication, &theAddress, 				kAutoGenerateReturnID, kAnyTransactionID, &theEvent);				if (!otherError)			AEDisposeDesc(&theAddress);		if (!otherError)			AESend(&theEvent, NULL, kAENoReply + kAEAlwaysInteract + kAECanSwitchLayer, 				kAENormalPriority, kAEDefaultTimeout, NULL, NULL);				AEDisposeDesc(&theEvent);	}		for (i = 0; i < 3; i++)		SystemTask();}/******************************************************** *	MakeDoomOffport.																		* *																											* *	Create the offscreen graf port.											* ********************************************************/void MakeDoomOffport (void){	Rect					r, r2;	CTabHandle		ctab;	GrafPtr				oldPort;		GetPort(&oldPort);		gOffPort = NULL;	gOffDevice = NULL;		SetRect(&r2, 0, 0, kHiResRowBytes, 410);		// "Seed" color table.		ctab = GetCTable( 128 );	DetachResource( (Handle)ctab );		if (CreateOffScreen(&r2, 8, ctab, &gOffPort, &gOffDevice) != noErr)	{	ShowCAndBail :		SysBeep(1);		ShowCursor();		ExitToShell();	}		SetRect(&r, 0, 0, 320, 200);		if (CreateOffScreen(&r, 8, ctab, &gOffSmallPort, &gOffSmallDevice) != noErr)		goto ShowCAndBail;			DisposeHandle((Handle)ctab);		// The "baseAddr" of both ports are NULL. V_Init will allocate the	// screen memory.		V_Init ();		// Set the two color graphics ports to point at same memory, whether	// we're in low resolution or high resolution.		(**(*gOffPort).portPixMap).baseAddr = (Ptr) screens[0];	(**(*gOffSmallPort).portPixMap).baseAddr = (Ptr) screens[0];} /******************************************************** *	CenterRect.																					* *																											* *	Centers rectangle "a" within rectangle "b".					* ********************************************************/void CenterRect (Rect *a, Rect *b){ 	short		hor; 	short		ver; 	 	hor = b->left + ((b->right - b->left) >> 1) - ((a->right - a->left) >> 1); 	ver = b->top + ((b->bottom - b->top) >> 1) - ((a->bottom - a->top) >> 1); 	SetRect(a, hor, ver, hor + a->right - a->left, ver + a->bottom - a->top);}/****************************************************** *	GotRequiredParams.																* *																										* *	Returns an OSErr if the required parameters have	* *	not been extracted from the specified AppleEvent.	* ******************************************************/OSErr GotRequiredParams (AppleEvent *theAEvent){	DescType		returnedType;	Size				actualSize;	OSErr				myErr;		myErr = AEGetAttributePtr(theAEvent, keyMissedKeywordAttr, typeWildCard,		&returnedType, NULL, 0, &actualSize);	if (myErr == errAEDescNotFound)		return (noErr);	else if (myErr == noErr)		return (errAEEventNotHandled);	else		return (myErr);}/****************************************************** *	HandleODOCEvent.																	* *																										* *	Handle an apple event of type 'odoc'. Open a			* *	document.																					* ******************************************************/pascal OSErr HandleODOCEvent (AppleEvent *aevt, AEDescList reply, tLong refCon)//pascal OSErr HandleODOCEvent (AEDescList aevt, AEDescList reply, tLong refCon){	AEDescList			docList;	OSErr						err, err2;	tLong						i, numItems;	Size						actualSize;	DescType				theType;	AEKeyword				keywd;	FSSpec					myFSS;	FInfo						fndrInfo;	Str255					str;		// Get the direct parameter, a descriptor list, and put it into docList.	err = AEGetParamDesc(aevt, keyDirectObject, typeAEList, &docList);	if (err != noErr)		return (err);			err = GotRequiredParams(aevt);	if (err != noErr)	{		err2 = AEDisposeDesc(&docList);		return (err);	}			// Count the number of descriptor records in the list.	err = AECountItems(&docList, &numItems);	if (err != noErr)	{		err2 = AEDisposeDesc(&docList);		return (err);	}		// Now get each descriptor record from the list and coerce to a FSSpec.	for (i = 1L; i <= numItems; i++)	{		// Get the Nth file spec.		err = AEGetNthPtr(&docList, i, typeFSS, &keywd, &theType, (Ptr)&myFSS, 			sizeof(FSSpec), &actualSize);				if (err != noErr)		{			sprintf((char *)str, "Doom II could not obtain the file spec record from the AppleEvent descriptor list ( %ld of %ld ). The error number was %d. (Type was 0x%08X)",				(long)i, (long)numItems, (short)err, (long)theType);			c2pstr((char *)str);			ParamText(str, "\p", "\p", "\p");			InitCursor();			gCursID = -2;			(void) Alert(rAlertErrGeneral, NULL);			if (useMouse || usejoystick)				HideCursor();			err2 = AEDisposeDesc(&docList);			return (err);		}				err = FSpGetFInfo(&myFSS, &fndrInfo);				if (fndrInfo.fdType == '.WAD')		{		HandleWad :			if (CompPStr(myFSS.name, gWadFiles[0].name))				gWadFiles[0] = myFSS;			else if (gNumWads < MAXWADFILES)			{				short		ndx;								gWadFiles[gNumWads] = myFSS;								// Don't add one twice!				for (ndx = gNumWads - 1; ndx >= 0; ndx--)				{					if ((gWadFiles[ndx].vRefNum == gWadFiles[gNumWads].vRefNum) &&							(gWadFiles[ndx].parID == gWadFiles[gNumWads].parID) &&							CompPStr(gWadFiles[ndx].name, gWadFiles[gNumWads].name))						goto DontAdd;				}								gNumWads++;			DontAdd :				;			}			else			{				ParamText("\pThe maximum number of WAD files has already been added.", "\p", "\p", "\p");				InitCursor();				gCursID = -2;				(void) Alert(rAlertErrGeneral, NULL);				if (useMouse || usejoystick)					HideCursor();			}						err2 = AEDisposeDesc(&docList);		}		else if ((commercial && fndrInfo.fdType == 'D2sg') || (!commercial &&  fndrInfo.fdType == 'D1sg'))		{			if (gLoadGamePending == FALSE)			{				gLoadGamePending = TRUE;				gPendingGame = myFSS;			}			else			{				p2cstr(myFSS.name);				sprintf((char *)str, "There is already a saved game pending. The file named “%s” will not be loaded.",					(char *)myFSS.name);				c2pstr((char *)str);				ParamText(str, "\p", "\p", "\p");				InitCursor();				gCursID = -2;				(void) Alert(rAlertErrGeneral, NULL);				if (useMouse || usejoystick)					HideCursor();			}		}		// Not a save game		else if ((fndrInfo.fdType != 'D2sg') && (fndrInfo.fdType != 'D1sg'))		{			short			ndx;						for (ndx = 1; ndx < myFSS.name[0]; ndx++)				myFSS.name[ndx] = toupper(myFSS.name[ndx]);			if (memcmp(".WAD", &myFSS.name[ myFSS.name[0] - 3 ], 4) == 0)				goto HandleWad;		}	}		err2 = AEDisposeDesc(&docList);		return(noErr);}/******************************************************** *	HandlePDOCEvent.																		* *																											* *	Handles PDOC apple events.													* ********************************************************/pascal OSErr HandlePDOCEvent (AppleEvent *aevt, AEDescList reply, long refCon){	OSErr				err;	AEDescList	docList;	err = AEGetParamDesc(aevt, keyDirectObject, typeAEList, &docList);	if (err != noErr)		return (err);		// Check for missing required parameters.	err = GotRequiredParams(aevt);	if (err != noErr)		return (err);		ParamText("\pDoom II cannot print that file. Sorry!", "\p", "\p", "\p");	InitCursor();	gCursID = -2;	(void) Alert(rAlertErrGeneral, NULL);		HideCursor();	I_Quit();		return (noErr);}/******************************************************** *	HandleOAPPEvent.																		* *																											* *	Handles OAPP apple events.													* ********************************************************/pascal OSErr HandleOAPPEvent (AppleEvent *aevt, AEDescList reply, long refCon){	OSErr				err;	err = GotRequiredParams(aevt);	if (err != noErr)		return(err);	else		return(noErr);}/******************************************************** *	HandleQUITEvent.																		* *																											* *	Handles apple events.																* ********************************************************/pascal OSErr HandleQUITEvent (AppleEvent *aevt, AEDescList reply, long refCon){	OSErr				err;	err = GotRequiredParams(aevt);	if (err != noErr)		return (err);	else		I_Quit();		// Doesn't return.		return (noErr);}/******************************************************** *	InitSystemSeven.																		* *																											* *	Performs System 7-specific initialization.					* ********************************************************/void InitSystemSeven (void){	OSErr		err;	long		result;	Boolean		hasAppleEvents;		hasAppleEvents = (Gestalt(gestaltAppleEventsAttr, &result) ? kFalse : result != 0);		if (hasAppleEvents)	{		gOAPPHandlerProc = NewAEEventHandlerProc(HandleOAPPEvent);		gODOCHandlerProc = NewAEEventHandlerProc(HandleODOCEvent);		gPDOCHandlerProc = NewAEEventHandlerProc(HandlePDOCEvent);		gQUITHandlerProc = NewAEEventHandlerProc(HandleQUITEvent);				err = AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, 			gOAPPHandlerProc, 0, kFalse);		if (err)			return;				err = AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,			gODOCHandlerProc, 0, kFalse);		if (err)			return;			err = AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments,			gPDOCHandlerProc, 0, kFalse);		if (err)			return;			err = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication,			gQUITHandlerProc, 0, kFalse);		if (err)			return;	}}/******************************************************** *	GetGestaltResult.									* *														* *	Returns the result of Gestalt, or 0 if an error		* *	occurs.												* ********************************************************/tLong GetGestaltResult (OSType gestaltSelector){	tLong	gestaltResult;		if (Gestalt(gestaltSelector, &gestaltResult) == noErr)		return(gestaltResult);	else		return(0);}/****************************************************** *	MyInitCursor.																			* *																										* *	Initializes the cursor.														* ******************************************************/void MyInitCursor (void){	if (useMouse)		return;		if (gCursID != 0)		InitCursor();	gCursID = 0;}/****************************************************** *	SpinCursor.																				* *																										* *	Spins the "beach ball" cursor. No initialization	* *	is necessary. This is most effective when called	* *	from within loops.																* ******************************************************/void SpinCursor (void){	short		newID;		if ((TickCount() - gCursChange) < 4L)		return;		newID = gCursID + 1;		if ((newID < 280) || (newID > 283))		newID = 280;		MySetCursor(newID);}/****************************************************** *	MySetCursor.																			* *																										* *	Sets the cursor to the specified cursor ID. If		* *	a color cursor is available, it is used, other-		* *	wise, a black & white cursor is used.							* ******************************************************/void MySetCursor (short cursID){	CCrsrHandle		clrCurs;	CursHandle		curs;		if (cursID == gCursID)		return;			if (cursID == -1)	{		if (gCursID != -1)		{			gCursID = -1;			HideCursor();		}	}	else if (gCursID == -1)		MyInitCursor();			clrCurs = NULL;	clrCurs = GetCCursor(cursID);	if ((clrCurs == NULL) || (ResError()))	{		curs = GetCursor(cursID);		if ((curs) && (!ResError()))		{			SetCursor(*curs);			gCursID = cursID;			gCursChange = TickCount();		}	}	else	{		SetCCursor(clrCurs);		gCursID = cursID;		gCursChange = TickCount();	}}/****************************************************** *	GetWadFile.																				* *																										* *	Allow the user to select a file using the					* *	standard "GetFile" dialog.												* ******************************************************/Boolean GetWadFile (FSSpec *fsSpec){	StandardFileReply		reply;		StandardGetFile(gWadFilterUPP, -1, NULL, &reply);	MyInitCursor();		if (reply.sfGood == kTrue)		*fsSpec = reply.sfFile;	else		return FALSE;		return TRUE;}/******************************************************** *	WADFilter.																					* *																											* *	Filters all files except those ending with ".WAD"		* *	or with type ".WAD".																* ********************************************************/pascal Boolean WADFilter (CInfoPBPtr pb){	tULong			tempL;	tUWord			len, i;	Str255			fileName;		// Directories are OK.	if (pb->hFileInfo.ioFlAttrib & 0x0010)		return FALSE;	if (pb->hFileInfo.ioFlFndrInfo.fdType == '.WAD')		return kFalse;	else	{		CopyPStr(pb->hFileInfo.ioNamePtr, fileName);		len = (tUByte)fileName[0];		for (i = 1; i < len; i++)			fileName[i] = toupper(fileName[i]);				if (len >= 4)		{			BlockMoveData( &fileName[len - 3], &tempL, 4L );			if (tempL == '.WAD')				return kFalse;		}	}		return kTrue;} // For readability of "CompPStr" #define MY_ASTR		((tUByte *)strA) #define MY_BSTR		((tUByte *)strB)/****************************************************** *	CompPStr.																					* *																										* *	Compares two Pascal-type strings and returns			* *	TRUE if the strings are equal.										* ******************************************************/Boolean CompPStr (void *strA, void *strB){	tWord				i;		if ( MY_ASTR[0] != MY_BSTR[0] )		return FALSE;		for (i = 1; i <= MY_ASTR[0]; i++)		if ( MY_ASTR[i] != MY_BSTR[i] )			return FALSE;		return TRUE;}/****************************************************** *	CopyPStr.																					* *																										* *	Copies a Pascal-type string into a destination		* *	string.																						* ******************************************************/void CopyPStr (void *src, void *dst){	BlockMove(src, dst, 1L + (tULong)*((tUByte *)src));}/****************************************************** *	AppendPStr.																				* *																										* *	Appends "endstr" onto the end of "src". Both			* *	strings should be Pascal-type strings.						* ******************************************************/void AppendPStr (void *src, void *endstr){	tWord		moveamt;	tWord		length;		if ((moveamt = (length = (tWord)*((tUByte *)src) + (tWord)*((tUByte *)endstr)) > 255 ? (255 - (tWord)*((tUByte *)src)) : (tWord)*((tUByte *)endstr)) > 0)	{		BlockMove( ((tUByte *)endstr) + 1L, ((tUByte *)src) + 1L + (*((tUByte *)src)), (tLong)moveamt);		*((tUByte *)src) = (tUByte)length;	}}pascal Boolean FilterInDoom(CInfoPBPtr pb){	Str255 doom2	= "\pDOOM2.WAD";	Str255 doom1	= "\pDOOM1.WAD";	Str255 doom 	= "\pDOOM.WAD";		if (pb->hFileInfo.ioFlAttrib & 0x0010)	{		return false;						// Show all directories	}	else	{		if (CompPStr(doom2, pb->hFileInfo.ioNamePtr))			return false;		else if (CompPStr(doom, pb->hFileInfo.ioNamePtr))			return false;		else if (CompPStr(doom1, pb->hFileInfo.ioNamePtr))			return false;		else			return true;	}}/******************************************************** *	InitManagers.																				* *																											* *	Initializes the Macintosh Toolbox managers.					* ********************************************************/void InitManagers (void){ 	tWord						i, err; 	MenuHandle			menu; 	long						result; 	NumVersion			vers;	FileFilterUPP		doomFileFilterProc;		InitGraf((Ptr) &qd.thePort);	InitFonts();	InitWindows();	InitMenus();	InitCursor();	TEInit();	InitDialogs(0L);	MaxApplZone();		for (i = 0; i < 4; i++)		MoreMasters();		// We're in big trouble if this fails!	if (InitAllocA(32767L) == FALSE)	{	ShowAndBail :		ShowCursor();		ExitToShell();	}		gOptionsFilterProc = NewModalFilterProc(OptionsDialogFilter);	gWadFilterUPP = NewFileFilterProc(WADFilter);	InitSystemSeven();		#if (__DEBUG_FILE__)		debugfile = fopen ("debugfile","w");#endif	for (i = 0; i < kNumMenus; i++)	{		menu = GetMenu(i + mAppleMenu);		InsertMenu(menu, 0);		if (i == 0)			AddResMenu(menu, 'DRVR');	}		DrawMenuBar();		err = HGetVol( NULL, &gAppVRefNum, &gAppDirId );		err = FSMakeFSSpec(gAppVRefNum, gAppDirId, "\pDOOM2.WAD", &gWadFiles[0]);	if (err != noErr)	{		err = FSMakeFSSpec(0, 0, "\pDoom II:DOOM2.WAD", &gWadFiles[0]);		if (err != noErr)		{			err = FSMakeFSSpec(gAppVRefNum, gAppDirId, "\pDOOM.WAD", &gWadFiles[0]);			if (err != noErr)			{				err = FSMakeFSSpec(gAppVRefNum, gAppDirId, "\pDOOM1.WAD", &gWadFiles[0]);				if (err != noErr)				{					StandardFileReply reply;										InitCursor();					// •• Ask to locate, get name and compare. If DOOM2, DOOM, or DOOM1, then					// adjust variables, otherwise say appropriate file needs to be available.							ParamText("\pThe WAD file could not be found. Would you like to look for it?", "\p", "\p", "\p");							if (Alert(600, NULL) == 1)					{						BlackScreen();																		doomFileFilterProc = NewFileFilterProc((ProcPtr) FilterInDoom);						StandardGetFile(doomFileFilterProc, -1, NULL, &reply);												BlackScreen();												if (reply.sfGood)						{							Str255 doom2	= "\pDOOM2.WAD";							Str255 doom1	= "\pDOOM1.WAD";							Str255 doom 	= "\pDOOM.WAD";														gWadFiles[0] = reply.sfFile;														if (CompPStr(doom2, reply.sfFile.name))								commercial = true;							else if (CompPStr(doom, reply.sfFile.name))								registered = true;							else if (CompPStr(doom1, reply.sfFile.name))								shareware = true;						}						else							goto BailNow;					}					else					{					BailNow :						I_Shutdown();						RestoreScreenDepth();						ExitToShell();					}				}				else					shareware = true;			}			else				registered = true;		}		else			commercial = true;	}	else		commercial = true;		gNumWads = 1;		if (GetMMUMode() == false32b)	{		ParamText("\pDoom II requires that 32-bit addressing be turned on (use the Memory Control Panel to do so). Exiting to Finder.", "\p", "\p", "\p");		goto DisplayAndBail;	}		result = GetGestaltResult(gestaltNativeCPUtype);	if (result < gestaltCPU68030)	// •• Fix me, you queer boys at Apple!	{		ParamText("\pDoom II requires a 68040 processor or better in order to run. Exiting to Finder.", "\p", "\p", "\p");	DisplayAndBail :		InitCursor();		Alert(rAlertErrGeneral, NULL);		goto ShowAndBail;	}		if ((GetGestaltResult(gestaltSystemVersion) & 0xFF00) < 0x0700)	{		ParamText("\pDoom II requires System 7.0 or later to run. Exiting to Finder.", "\p", "\p", "\p");		goto DisplayAndBail;	}		vers = SndSoundManagerVersion();	if (vers.majorRev < 3)	{		ParamText("\pDoom II requires Sound Manager 3.0 or later in order to run. Exiting to Finder.", "\p", "\p", "\p");		InitCursor();		Alert(rAlertErrGeneral, NULL);		goto ShowAndBail;	}	if (Gestalt(gestaltQuickTime, &result) != noErr)	{	NoQuickTime :		ParamText("\pDoom II requires QuickTime™ 2.0 be installed for music. Music will be turned off...", "\p", "\p", "\p");		InitCursor();		Alert(rAlertErrGeneral, NULL);		gQuickTimeInstalled = FALSE;		HideCursor();	}	else	{		if ( result < 0x02000000L )		{			goto NoQuickTime;		}		else			gQuickTimeInstalled = 1;	}		if (gQuickTimeInstalled == FALSE)	{		SetItemMark(GetMenu(mOptionsMenu), 11, noMark); // Music On/Off		DisableItem(GetMenu(mOptionsMenu), 11);	}}static Boolean		gColorScreenMode;						// True if application was launched in color mode (vs. a grayscale mode)static Boolean		gChangedScreenDepth;				// True if user asked application to change the screen depth.static short			gPreviousScreenMode;				// Previous screen depth before user asked application to change it./******************************************************** *	ChangeScreenDepth.																	* *																											* *	Changes the screen depth if necessary after					* *	confirming with user.																* ********************************************************/Boolean ChangeScreenDepth ( short screenBitDepth, GDHandle screenDevice ){	short			err;		gChangedScreenDepth = FALSE;						// Default no depth change.	gPreviousScreenMode = screenBitDepth;		// Remember the current bit depth.		if ( screenBitDepth == 8 )		return( TRUE );		if ( TestDeviceAttribute( screenDevice, gdDevType ) )		// Were we in color or grayscale mode?		gColorScreenMode = TRUE;															// Remember this for restoring mode at exit.	else		gColorScreenMode = FALSE;		ParamText("\pDoom II requires that your main monitor be set to 256 colors. Would you like to reset it?", "\p", "\p", "\p");		if ( screenBitDepth < 8 )			// We're in 2-bit or 4-bit mode.	{		if ( HasDepth( screenDevice, 8, 1 << gdDevType, 1 ) )		{			InitCursor();						if ( Alert(600, NULL) == 1 )			{				err = SetDepth( screenDevice, 8, 1 << gdDevType, 1 );				gChangedScreenDepth = TRUE;			}						gCursID = -2;			HideCursor();						return( gChangedScreenDepth );		}		else		// If they can't handle 8-bit mode.		{			ParamText("\pDoom II requires that you have a monitor that supports 256 colors. Sorry!", "\p", "\p", "\p");			InitCursor();			(void) Alert(rAlertErrGeneral, NULL);		}	}		if ( screenBitDepth > 8 )		// We're in Thousands or Millions modes (16-bit or 24-bit)	{		InitCursor();				if ( Alert(600, NULL) == 1 )		{			err = SetDepth( screenDevice, 8, 1 << gdDevType, 1 );			gChangedScreenDepth = TRUE;		}				gCursID = -2;		HideCursor();				return( gChangedScreenDepth );	}	Error:	return FALSE;}/*=======================================================================================	Function: RestoreScreenDepth		Description: This function ask the user if they'd like to change the display back to the way they had it before	running the game (if they chose to change the display mode at startup). It uses the static variables setup by	ChangeScreenDepth().		Side Effects/Comments:=======================================================================================*/void RestoreScreenDepth( void ){	short			err;		if ( gChangedScreenDepth )	{		ParamText("\pWould you like to reset your monitor to its previous setting before quitting?", "\p", "\p", "\p");		InitCursor();		ShowCursor();				if ( Alert(600, NULL) == 1 )		{			err = SetDepth( gMainDevice, gPreviousScreenMode, 1 << gdDevType, gColorScreenMode );		}	}	Error:	;}	// RestoreScreenDepth/******************************************************** *	MakeDoomWindow.																			* *																											* *	Allocate and show the Doom II window.								* ********************************************************/void MakeDoomWindow (void){	Rect		r;	CTabHandle	clut;	short		pixelSize;	gMainDevice = GetMainDevice();	if (gMainDevice)		pixelSize = (**(**gMainDevice).gdPMap).pixelSize;	else		pixelSize = 0;	SetRect(&r, 0, 0, 320, 200);	OffsetRect(&r, 10, 40);		r = (**gMainDevice).gdRect;		if (pixelSize != 8)	{		if (!ChangeScreenDepth ( pixelSize, gMainDevice ))		{		ShowAndBail :			InitCursor();			ExitToShell();		}	}		gDoomWindow = NewCWindow( NULL, &r, "\pDoom II", TRUE, noGrowDocProc, (WindowPtr) -1L, 		FALSE, 0L);		if ( gDoomWindow == NULL )	{		SysBeep(1);		goto ShowAndBail;	}		if(gLargeGraphics)	{		SetRect(&gDrawRect, 0, 0, 640, 400);	}	else	{			SetRect(&gDrawRect, 0, 0, 320, 200);	}		CenterRect(&gDrawRect, &gDoomWindow->portRect);	if (gDrawRect.left & 0x03)		OffsetRect(&gDrawRect, -(4 - (gDrawRect.left & 0x03)), 0);		ShowWindow( gDoomWindow );	SelectWindow( gDoomWindow );	SetPort( gDoomWindow );	BackPat( &qd.black );		ClipRect(&gDoomWindow->portRect);	PaintRect(&gDoomWindow->portRect);		clut = GetCTable(128);	if (clut)	{		gThePalette = NewPalette(256, clut, pmExplicit + pmTolerant, 0);			if (gThePalette)		{			SetPalette((WindowPtr)-1, gThePalette, TRUE);			SetPalette(gDoomWindow, gThePalette, TRUE);			ActivatePalette(gDoomWindow);		}	}}/******************************************************** *	OptionsDialogFilter.																* *																											* *	Filter proc for the options dialog.									* ********************************************************/ pascal Boolean OptionsDialogFilter (DialogPtr dlg, EventRecord *evt, tWord *itm){	tWord			kind;	Handle		h;	Rect			r;		S_ServiceMusic();	if ((evt->what == keyDown) || (evt->what == autoKey))	{		if (evt->modifiers & cmdKey)		{			if ((evt->message & charCodeMask) == '.')				goto DoCancel;		}		else		{			switch (evt->message & charCodeMask)			{				case 0x0D :				case 0x03 :					*itm = 1;					GetDItem(dlg, 1, &kind, &h, &r);					HiliteControl((ControlHandle)h, 1);					return(TRUE);					break;									case 0x1B :				DoCancel :					*itm = 2;					GetDItem(dlg, 2, &kind, &h, &r);					HiliteControl((ControlHandle)h, 1);					return(TRUE);					break;			}		}	}	else if (evt->what == updateEvt)	{		BeginUpdate(dlg);		DrawDialog(dlg);				// Outline the "OK" button.		GetDItem(dlg, 1, &kind, &h, &r);		InsetRect(&r, -4, -4);		PenSize(3, 3);		FrameRoundRect(&r, 15, 15);		PenNormal();				// Draw our little line.		GetDItem(dlg, 3, NULL, NULL, &r);		PenPat(&qd.gray);		MoveTo(r.left, r.top);		LineTo(r.right - 1, r.top);		PenPat(&qd.black);		EndUpdate(dlg);	}	return(FALSE);}DialogPtr			gStatusDialog;DialogRecord	gStatusDialogRec;long					gStatusTotal;long					gStatusCurrent;/****************************************************** *	CloseStatusDialog.																* *																										* *	Close the status dialog.													* ******************************************************/void CloseStatusDialog (void){	if (gStatusDialog != NULL)	{		HideWindow(gStatusDialog);		CloseDialog(gStatusDialog);		gStatusDialog = NULL;				ReleaseResource(GetResource('DLOG', 132));		ReleaseResource(GetResource('DITL', 132));	}}void StatusParamText(char *one, char *two, char *three, char *four){	Str255 numStr;		// single player	if(gPlayAlone)	{		ParamText(one, "\pSingle Player", "\p", "\p");	}	else if (gNetType == kSerialNet || gNetType == kCTBNet)	{		ParamText(one, "\p2", "\pPlayers", "\p");	}	else	{		if (gNumPlayersOnNet)		{			numStr[0] = 1;			numStr[1] = gNumPlayersOnNet + 1 + '0';			ParamText(one, numStr, "\pPlayers", "\p");		}		else		{			ParamText(one, "\p", "\p", "\p");		}	}}/****************************************************** *	StatusDialog.																			* *																										* *	Open and display the status dialog.								* ******************************************************/void StatusDialog (tLong total, tLong current){	if (gStatusDialog == NULL)	{		// Load the dialog		if(!gPlayNetGame)		{			if (commercial)				gStatusDialog = GetNewDialog(132, &gStatusDialogRec, (WindowPtr)-1L);			else				gStatusDialog = GetNewDialog(152, &gStatusDialogRec, (WindowPtr)-1L);					}		else		{			if (commercial)				gStatusDialog = GetNewDialog(142, &gStatusDialogRec, (WindowPtr)-1L);			else				gStatusDialog = GetNewDialog(162, &gStatusDialogRec, (WindowPtr)-1L);		}				if (gStatusDialog == NULL)			return;				SelectWindow(gStatusDialog);		SetPort(gStatusDialog);		ShowWindow(gStatusDialog);				if (total > 0)		{			gStatusTotal = total;			gStatusCurrent = current;		}		else			gStatusTotal = gStatusCurrent = -1L;	}	else if (gStatusDialog != NULL)	{		gStatusTotal = total;		gStatusCurrent = current;		DrawStatusDialog(kFalse);	}}/****************************************************** *	DrawStatusDialog.																	* *																										* *	Draws the status dialog.													* ******************************************************/ void DrawStatusDialog (Boolean forUpdate){	Rect				r, saveR;	tLong				temp;	GrafPtr			oldPort;		if (gStatusDialog != NULL)	{		GetPort(&oldPort);		SetPort(gStatusDialog);				if (forUpdate)		{			DrawDialog(gStatusDialog);						// Draw our little line.			GetDItem(gStatusDialog, 3, NULL, NULL, &r);			PenPat(&qd.gray);			MoveTo(r.left, r.top);			LineTo(r.right - 1, r.top);			PenPat(&qd.black);		}			if (gStatusTotal > 0)		{			GetDItem(gStatusDialog, 4, NULL, NULL, &r);			FrameRect(&r);			InsetRect(&r, 1, 1);						saveR = r;						if (gStatusCurrent >= gStatusTotal)			{				PaintRect(&r);			}			else if (gStatusCurrent > 0)			{				temp = r.right - r.left;				temp = (((100L * gStatusCurrent) * temp) / gStatusTotal) / 100L;				r.right = temp + r.left;				PaintRect(&r);								saveR.left = r.right;				EraseRect(&saveR);			}		}		SetPort(oldPort);	}}/******************************************************** *	OptionsDialog.																			* *																											* *	The options dialog.																	* ********************************************************/ short OptionsDialog (Boolean inInitial){	DialogPtr					dlg;	tWord							itm, i;	Boolean						done;	GrafPtr						oldPort;	Handle						h;	long							tempL;	Rect							sr, r;		dlg = GetNewDialog(131, NULL, (WindowPtr)-1L);	if (dlg == NULL)		return 2;		GetPort(&oldPort);	SelectWindow(dlg);	SetPort(dlg);	ShowWindow(dlg);	InitCursor();	gCursID = -2;			if (!nomonsters)	{		GetDItem(dlg, iOptionsMonster, NULL, &h, NULL);		SetCtlValue((ControlHandle)h, 1);	}		if (gKillFinder)	{		GetDItem(dlg, iOptionsKill, NULL, &h, NULL);		SetCtlValue((ControlHandle)h, 1);	}		if (respawnparm)	{		GetDItem(dlg, iOptionsRespawn, NULL, &h, NULL);		SetCtlValue((ControlHandle)h, 1);	}		// autostart == Warp		if (autostart)	// Had to have been in Options dialog before.	{		GetDItem(dlg, iOptionsWarp, NULL, &h, NULL);		SetCtlValue((ControlHandle)h, 1);				NumToString(startmap, gStr1);		GetDItem(dlg, iOptionsWarpNum, NULL, &h, NULL);		SetIText(h, gStr1);				for (i = iOptionsLev1; i <= iOptionsLev5; i++)		{			if (startskill + iOptionsLev1 == i)			{				GetDItem(dlg, i, NULL, &h, NULL);				SetCtlValue((ControlHandle)h, 1);			}		}	}	else	{		for (i = iOptionsLev1; i <= iOptionsLev5; i++)		{			GetDItem(dlg, i, NULL, &h, NULL);			HiliteControl((ControlHandle)h, 255);			if (startskill + iOptionsLev1 == i)				SetCtlValue((ControlHandle)h, 1);		}				HideDItem(dlg, iOptionsWarpNum);	}		SelIText(dlg, iOptionsWarpNum, 0, 100);		done = kFalse;	do	{		ModalDialog(gOptionsFilterProc, &itm);				switch (itm)		{			case iOptionsOK :				done = TRUE;								GetDItem(dlg, iOptionsKill, NULL, &h, NULL);				if (GetCtlValue((ControlHandle)h))					gKillFinder = TRUE;				else					gKillFinder = FALSE;								GetDItem(dlg, iOptionsMonster, NULL, &h, NULL);				if (GetCtlValue((ControlHandle)h))					nomonsters = 0;				else					nomonsters = 1;								GetDItem(dlg, iOptionsRespawn, NULL, &h, NULL);				if (GetCtlValue((ControlHandle)h))					respawnparm = 1;				else					respawnparm = 0;								GetDItem(dlg, iOptionsWarp, NULL, &h, NULL);				if (GetCtlValue((ControlHandle)h))				{					GetDItem(dlg, iOptionsWarpNum, NULL, &h, NULL);					GetIText(h, gStr1);					StringToNum(gStr1, &tempL);										if (tempL < 0)					{						SysBeep(1);						SelIText(dlg, iOptionsWarpNum, 0, 100);					}					else					{						startmap = tempL;						autostart = true;					}				}				break;							case iOptionsCancel :				done = TRUE;				break;						case iOptionsTitle :				GetDItem(dlg, itm, NULL, &h, NULL);				if (GetCtlValue((ControlHandle)h))					SetCtlValue((ControlHandle)h, 0);				else					SetCtlValue((ControlHandle)h, 1);				break;							case iOptionsKill :			case iOptionsMonster :			case iOptionsRespawn :				GetDItem(dlg, itm, NULL, &h, NULL);				if (GetCtlValue((ControlHandle)h))					SetCtlValue((ControlHandle)h, 0);				else					SetCtlValue((ControlHandle)h, 1);				break;							case iOptionsWarp :				GetDItem(dlg, itm, NULL, &h, NULL);				if (GetCtlValue((ControlHandle)h))				{					SetCtlValue((ControlHandle)h, 0);					for (i = iOptionsLev1; i <= iOptionsLev5; i++)					{						GetDItem(dlg, i, NULL, &h, NULL);						HiliteControl((ControlHandle)h, 255);					}					HideDItem(dlg, iOptionsWarpNum);				}				else				{					SetCtlValue((ControlHandle)h, 1);					for (i = iOptionsLev1; i <= iOptionsLev5; i++)					{						GetDItem(dlg, i, NULL, &h, NULL);						HiliteControl((ControlHandle)h, 0);					}					GetDItem(dlg, iOptionsWarpNum, NULL, &h, NULL);					SetIText(h, "\p0");					ShowDItem(dlg, iOptionsWarpNum);					SelIText(dlg, iOptionsWarpNum, 0, 2);				}				break;							case iOptionsLev1 :			case iOptionsLev2 :			case iOptionsLev3 :			case iOptionsLev4 :			case iOptionsLev5 :				startskill = itm - 11;				for (i = iOptionsLev1; i <= iOptionsLev5; i++)				{					GetDItem(dlg, i, NULL, &h, NULL);					if (itm == i)						SetCtlValue((ControlHandle)h, 1);					else if (GetCtlValue((ControlHandle)h))						SetCtlValue((ControlHandle)h, 0);				}				break;/*			case iOptionsLoad :				// Select a wad file.				if (gNumWads < MAXWADFILES)				{						if (GetWadFile(&gWadFiles[gNumWads]))					{											// Redraw splash screen						SetPort(gDoomWindow);						PaintRect(&gDoomWindow->portRect);									SetRect(&sr, 0, 0, 480, 360);						r = sr;						CenterRect(&r, &gDoomWindow->portRect);											SetPort(gDoomWindow);						(**gClut).ctSeed = (**(**(**gMainDevice).gdPMap).pmTable).ctSeed;						CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);												SelectWindow(dlg);						SetPort(dlg);						ShowWindow(dlg);						// End Redraw splash screen									// Don't add one twice!						for (i = gNumWads - 1; i >= 0; i--)						{							if ((gWadFiles[i].vRefNum == gWadFiles[gNumWads].vRefNum) &&									(gWadFiles[i].parID == gWadFiles[gNumWads].parID) &&									CompPStr(gWadFiles[i].name, gWadFiles[gNumWads].name))							{								ParamText("\pThat WAD file has already been selected. It will not be added twice.", "\p", "\p", "\p");								Alert(rAlertErrGeneral, NULL);								goto DontAdd;							}						}						gNumWads++;					DontAdd :						;					}				}				// Redraw splash screen					SetPort(gDoomWindow);				PaintRect(&gDoomWindow->portRect);					SetRect(&sr, 0, 0, 480, 360);				r = sr;				CenterRect(&r, &gDoomWindow->portRect);							SetPort(gDoomWindow);				(**gClut).ctSeed = (**(**(**gMainDevice).gdPMap).pmTable).ctSeed;				CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);								SelectWindow(dlg);				SetPort(dlg);				ShowWindow(dlg);			//	ShowWindow(oldPort);				// End Redraw splash screen			break;*/		}	}	while (!done);		HideWindow(dlg);	DisposDialog(dlg);	SetPort(oldPort);		ReleaseResource(GetResource('DLOG', 131));	ReleaseResource(GetResource('DITL', 131));		return itm;}void BlackScreen(void){	GrafPtr						oldPort;	if(gDoomWindow)	{		GetPort(&oldPort);		SetPort(gDoomWindow);		PaintRect(&gDoomWindow->portRect);	// Clear the dialog area		ValidRect(&gDoomWindow->portRect);		SetPort(oldPort);	}}/****************************************************** *	TrackOffscreenRect.																* *																										* *	Track a rectangle in the current port, using			* *	graphics offscreen as the "normal" and "hilited"	* *	version. Returns kTrue if the mouse is released		* *	inside the rectangle, kFalse otherwise.						* ******************************************************/Boolean TrackOffscreenRect (Rect *normR, Rect *hiliteR, Rect *dstR, Point where,	GrafPtr offBuff){	Point				currPt;	Boolean			on;	GrafPtr			currPort;		GetPort(&currPort);		CopyBits(&offBuff->portBits, &currPort->portBits, hiliteR, dstR, srcCopy, NULL);	on = kTrue;	currPt = where;		do	{		GetMouse(&currPt);				if ((!PtInRect(currPt, dstR)) && (on == kTrue))		{			CopyBits(&offBuff->portBits, &currPort->portBits, normR, dstR, srcCopy, NULL);			on = kFalse;		}		else if ((PtInRect(currPt, dstR)) && (on == kFalse))		{			CopyBits(&offBuff->portBits, &currPort->portBits, hiliteR, dstR, srcCopy, NULL);			on = kTrue;		}	}	while (StillDown());		CopyBits(&offBuff->portBits, &currPort->portBits, normR, dstR, srcCopy, NULL);		return on;}/******************************************************** *	CheckForEscBail.																		* *																											* *	Return TRUE if a key or the mouse button is down.		* ********************************************************/ Boolean CheckForEscBail (void){	if (Button())		return TRUE;		GetKeys((long *)gKeyState);		if (IsKeyPressed(kEscKey))		return TRUE;		return FALSE;}/******************************************************** *	CheckForBail.																				* *																											* *	Return TRUE if a key or the mouse button is down.		* ********************************************************/ Boolean CheckForBail (void){	long		*longChecker;		if (Button())		return TRUE;		GetKeys((long *)gKeyState);		longChecker = (long *)gKeyState;	if (longChecker[0] || longChecker[1] || longChecker[2] || longChecker[3])		return TRUE;		return FALSE;}/******************************************************** *	PreAboutBox.																				* *																											* *	About box which is used before game starts.					* ********************************************************/PreAboutBox(){		Rect							sr, r;	if (commercial)		ParamText("\pDoom II: Hell on Earth", "\p", "\p", "\p");	else		ParamText("\pDoom", "\p", "\p", "\p");			Alert(128, NULL);	while(!CheckForBail())	{;}	// Redraw splash screen	SetPort(gDoomWindow);	PaintRect(&gDoomWindow->portRect);	SetRect(&sr, 0, 0, 480, 360);	r = sr;	CenterRect(&r, &gDoomWindow->portRect);	SetPort(gDoomWindow);	(**gClut).ctSeed = (**(**(**gMainDevice).gdPMap).pmTable).ctSeed;	CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);	// End Redraw splash screen		Alert(129, NULL);	while(!CheckForBail())	{;}}/******************************************************** *	OpenWadFile.																				* *																											* *	Open Wad item of file menu.													* ********************************************************/static void OpenWadFile(){	Rect r, sr;	int	i;		// Select a wad file.	if (gNumWads < MAXWADFILES)	{			if (GetWadFile(&gWadFiles[gNumWads]))		{								// Redraw splash screen			SetPort(gDoomWindow);			PaintRect(&gDoomWindow->portRect);				SetRect(&sr, 0, 0, 480, 360);			r = sr;			CenterRect(&r, &gDoomWindow->portRect);					SetPort(gDoomWindow);			(**gClut).ctSeed = (**(**(**gMainDevice).gdPMap).pmTable).ctSeed;			CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);			// End Redraw splash screen				// Don't add one twice!			for (i = gNumWads - 1; i >= 0; i--)			{				if ((gWadFiles[i].vRefNum == gWadFiles[gNumWads].vRefNum) &&						(gWadFiles[i].parID == gWadFiles[gNumWads].parID) &&						CompPStr(gWadFiles[i].name, gWadFiles[gNumWads].name))				{					ParamText("\pThat WAD file has already been selected. It will not be added twice.", "\p", "\p", "\p");					Alert(rAlertErrGeneral, NULL);					goto DontAdd;				}			}			gNumWads++;		DontAdd :			;		}	}}/********************************************************** *	HandleInitialMenu.																		* *																												* *	Handle menu selection in initial dialog.							* *	Returns whether a termination selection has been made * **********************************************************/static Boolean HandleInitialMenu(short menuID, short menuItem){	MenuHandle			theMenu;	Str255					daName;	short					drvrRefNum;	Boolean					done = false;	StandardFileReply	reply;	SFTypeList			typeList;						theMenu = GetMHandle(menuID);								switch (menuID)	{		case mAppleMenu :	// Apple Menu			if (menuItem == 1)				;//PreAboutBox();			else			{				GetItem(theMenu, menuItem, daName);				drvrRefNum = OpenDeskAcc(daName);			}			break;					case mFileMenu :	// File Menu			switch (menuItem)			{				case iFileOpen :									if (commercial)						typeList[0] = 'D2sg';					else						typeList[0] = 'D1sg';										StandardGetFile(NULL, 1, typeList, &reply);					if (reply.sfGood == true)					{						gLoadGamePending = true;						gPendingGame = reply.sfFile;					}					break;					case iFileLoadWAD :					OpenWadFile();					break;									case iFileStartGame :					done = TRUE;					gPlayAlone = TRUE;					break;								case iFileMulti :					// Find out what type of multiplayer game.					GetPlayMode();					if(gPlayNetGame)						done = TRUE;					break;									case iFileSetup :					OptionsDialog(true);					ShowMenuBar();					break;									case iFileQuit :					HideWindow(gDoomWindow);					ShowMenuBar();					RestoreScreenDepth();					ExitToShell();					break;			}			break;							case mControlMenu : // Control menu			switch (menuItem)			{				case iControlSet : // Set Controls					KeyboardPrefsDialog(true);					ShowMenuBar();				break;								case iControlChat : // Edit chat macros					EditChatMacros(true);					ShowMenuBar();				break;			}			break;	}	return (done);}/******************************************************** *	InitialDialog.																			* *																											* *	The initial "splash" dialog.												* ********************************************************/short InitialDialog (void){	PicHandle			pic;	CTabHandle		clutCopy, temp;	GrafPtr				oldPort;	Rect					sr, r, r2;	short					vIndex, part;	int						i, j;	byte					*dPtr;	PaletteHandle	pal;	Boolean				done;	EventRecord		macEvent;	OSErr					err;	WindowPtr			wind;	char					c;	long					tempL;	short 				menuIndex;			// FlushEvents( keyDownMask | keyUpMask | mDownMask | mUpMask | autoKeyMask, 0);		// Fill with color #255.	dPtr = (byte *)screens[0];	for (i = 0; i < 640 * 400; i++)		*dPtr++ = 0xFF;			if(commercial)	{		pic = GetPicture(128);		gClut = GetCTable(128);	}	else	{		pic = GetPicture(150);		gClut = GetCTable(150);	}		pal = GetPalette( gDoomWindow );		GetPort(&oldPort);		r.left = 0;	r.right = 640;	r.top = 0;	r.bottom = 400;	r2 = (**pic).picFrame;	OffsetRect(&r2, -r2.left, -r2.top);		clutCopy = (CTabHandle) NewHandle(GetHandleSize((Handle)gClut));	BlockMoveData(*gClut, *clutCopy, GetHandleSize((Handle)gClut));		for (i = 0; i < 256; i++)	{		(**clutCopy).ctTable[i].rgb.red = 0;		(**clutCopy).ctTable[i].rgb.green = 0;		(**clutCopy).ctTable[i].rgb.blue = 0;	}			SetPort((GrafPtr)gOffPort);	SetGDevice(gOffDevice);	temp = (**(*gOffPort).portPixMap).pmTable;	(**(*gOffPort).portPixMap).pmTable = gClut;	DrawPicOffscreen(pic, (GrafPtr)gOffPort, &r2);	ReleaseResource((Handle)pic);		gPlayAlone = FALSE;	SetPort(gDoomWindow);	gCursID = -2;		SetGDevice(gMainDevice);	SetPort(gDoomWindow);		SetRect(&sr, 0, 0, 480, 360);	r = sr;	CenterRect(&r, &gDoomWindow->portRect);		// Set the palette	for (i = 0; i < 256; i++)		SetEntryColor(pal, (**gClut).ctTable[i].value, &(**gClut).ctTable[i].rgb);	ActivatePalette(gDoomWindow);		SetEntries(0, 255, (**clutCopy).ctTable);	(**gClut).ctSeed = (**(**(**gMainDevice).gdPMap).pmTable).ctSeed;	CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);		// Fade in	for (j = 16; j >= 0; j--)	{		for (i = 0; i < 256; i++)		{			vIndex = (**gClut).ctTable[i].value;			(**clutCopy).ctTable[vIndex].rgb.red = (**gClut).ctTable[i].rgb.red >> j;			(**clutCopy).ctTable[vIndex].rgb.green = (**gClut).ctTable[i].rgb.green >> j;			(**clutCopy).ctTable[vIndex].rgb.blue = (**gClut).ctTable[i].rgb.blue >> j;		}		SetEntries(0, 255, (**clutCopy).ctTable);		Delay(kMyDelayTicks, NULL);	}		// Make damn sure it's showing!	InitCursor();	ShowCursor();	ShowCursor();	ValidRect(&gDoomWindow->portRect);		ShowMenuBar();	done = FALSE;	while (!done)	{		S_ServiceMusic();		if (WaitNextEvent(everyEvent | osEvt, &macEvent, 0L, NULL))		{			switch (macEvent.what)			{				case osEvt :					switch( (macEvent.message >> 24) & 0xFF )					{						case mouseMovedMessage:							break;													case suspendResumeMessage:							if ( macEvent.message & resumeFlag )							{								gInForeground = TRUE;							HideMenuBar();				PaintRect(&gDoomWindow->portRect);	// Clear white bar at top.							}							else							{								gInForeground = FALSE;								ShowMenuBar();							}							break;					}					break;									case mouseDown :					part = FindWindow(macEvent.where, &wind);										if (part == inMenuBar)					{								tempL = MenuSelect(macEvent.where);						done = HandleInitialMenu( HiWord(tempL), LoWord(tempL) );					}					break;	// mousedown event									case kHighLevelEvent :					err = AEProcessAppleEvent(&macEvent);					break;								case mouseUp :					break;													case keyDown :					if (macEvent.modifiers & cmdKey)					{						// Macintosh menu.						tempL = MenuKey( macEvent.message & charCodeMask );												done = HandleInitialMenu( HiWord(tempL), LoWord(tempL) );					}					break;				case updateEvt :					if (gDoomWindow == (WindowPtr)macEvent.message)					{						BeginUpdate((WindowPtr)macEvent.message);						PaintRect(&gDoomWindow->portRect);						SetRect(&sr, 0, 0, 480, 360);						r = sr;						CenterRect(&r, &gDoomWindow->portRect);												(**gClut).ctSeed = (**(**(**gMainDevice).gdPMap).pmTable).ctSeed;						CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);												EndUpdate((WindowPtr)macEvent.message);												ShowMenuBar();					}					break;				}			}		}OuttaHere :		S_StopMusic();	(**(*gOffPort).portPixMap).pmTable = temp;	DisposeHandle((Handle)clutCopy);	ReleaseResource((Handle)gClut);		HideMenuBar();	SetPort(gDoomWindow);	PaintRect(&gDoomWindow->portRect);	ValidRect(&gDoomWindow->portRect);		return 1;}/******************************************************** *	LionSplash.																					* *																											* *	Show the Lion logo splash screen.										* ********************************************************/ void LionSplash (void){	PicHandle			pic;	CTabHandle		clut, clutCopy, temp;	GrafPtr				oldPort;	Rect					r, r2, sr;	short					vIndex;	int						i, j;	byte					*dPtr;	PaletteHandle	pal;	Boolean				bailed = FALSE;	int						prevMusicVol;		// Start some music	prevMusicVol = gSndMusicVolume;	gSndMusicVolume = 128;	S_ChangeMusic(mus_evil, TRUE);	gSndMusicVolume = prevMusicVol;	// Fill with color #255.	dPtr = (byte *)screens[0];	for (i = 0; i < 640 * 400; i++)		*dPtr++ = 0xFF;			pic = GetPicture(132);	clut = GetCTable(132);		pal = GetPalette( gDoomWindow );	GetPort(&oldPort);		r.left = 0;	r.right = 640;	r.top = 0;	r.bottom = 400;	r2 = (**pic).picFrame;	CenterRect(&r2, &r);		clutCopy = (CTabHandle) NewHandle(GetHandleSize((Handle)clut));	BlockMoveData(*clut, *clutCopy, GetHandleSize((Handle)clut));		for (i = 0; i < 256; i++)		SetEntryColor(pal, (**clut).ctTable[i].value, &(**clut).ctTable[i].rgb);	ActivatePalette(gDoomWindow);	for (i = 0; i < 256; i++)	{		(**clutCopy).ctTable[i].rgb.red = 0;		(**clutCopy).ctTable[i].rgb.green = 0;		(**clutCopy).ctTable[i].rgb.blue = 0;	}		SetPort((GrafPtr)gOffPort);	SetGDevice(gOffDevice);	temp = (**(*gOffPort).portPixMap).pmTable;	(**(*gOffPort).portPixMap).pmTable = clut;	DrawPicOffscreen(pic, (GrafPtr)gOffPort, &r2);	ReleaseResource((Handle)pic);			r2 = r;	CenterRect(&r2, &gDoomWindow->portRect);			SetGDevice(gMainDevice);	SetPort(gDoomWindow);	SetEntries(0, 255, (**clutCopy).ctTable);		gFrameRateOn = 0;	gHiRes = 2;	gOneTimeFullUpdate = 1;	gInForeground = 1;	I_FinishUpdate();	HideCursor();		for (j = 16; j >= 0; j--)	{		for (i = 0; i < 256; i++)		{			vIndex = (**clut).ctTable[i].value;			(**clutCopy).ctTable[vIndex].rgb.red = (**clut).ctTable[i].rgb.red >> j;			(**clutCopy).ctTable[vIndex].rgb.green = (**clut).ctTable[i].rgb.green >> j;			(**clutCopy).ctTable[vIndex].rgb.blue = (**clut).ctTable[i].rgb.blue >> j;		}		SetEntries(0, 255, (**clutCopy).ctTable);		Delay(kMyDelayTicks, NULL);	}		for (j = 0; j < 90; j++)	{		Delay(1, NULL);		if (CheckForEscBail())		{			bailed = TRUE;			goto DidBail1;		}	}		for (j = 0; j <= 16; j++)	{		for (i = 0; i < 256; i++)		{			vIndex = (**clut).ctTable[i].value;			(**clutCopy).ctTable[vIndex].rgb.red = (**clut).ctTable[i].rgb.red >> j;			(**clutCopy).ctTable[vIndex].rgb.green = (**clut).ctTable[i].rgb.green >> j;			(**clutCopy).ctTable[vIndex].rgb.blue = (**clut).ctTable[i].rgb.blue >> j;		}		SetEntries(0, 255, (**clutCopy).ctTable);		Delay(kMyDelayTicks, NULL);	}DidBail1 :	(**(*gOffPort).portPixMap).pmTable = temp;	PaintRect(&gDoomWindow->portRect);	ReleaseResource((Handle)clut);	if (bailed)		goto DidBail2;	// Show the "id" logo		pic = GetPicture(133);	clut = GetCTable(133);		r.left = 0;	r.right = 640;	r.top = 0;	r.bottom = 400;	r2 = (**pic).picFrame;	CenterRect(&r2, &r);		BlockMoveData(*clut, *clutCopy, GetHandleSize((Handle)clut));		for (i = 0; i < 256; i++)	{		(**clutCopy).ctTable[i].rgb.red = 0;		(**clutCopy).ctTable[i].rgb.green = 0;		(**clutCopy).ctTable[i].rgb.blue = 0;	}		SetPort((GrafPtr)gOffPort);	SetGDevice(gOffDevice);	(**(*gOffPort).portPixMap).pmTable = clut;	DrawPicOffscreen(pic, (GrafPtr)gOffPort, &r2);	ReleaseResource((Handle)pic);		r2 = r;	CenterRect(&r2, &gDoomWindow->portRect);		for (i = 0; i < 256; i++)		SetEntryColor(pal, (**clutCopy).ctTable[i].value, &(**clutCopy).ctTable[i].rgb);	ActivatePalette(gDoomWindow);		SetGDevice(gMainDevice);	SetPort(gDoomWindow);	SetEntries(0, 255, (**clutCopy).ctTable);		gFrameRateOn = 0;	gHiRes = 2;	gOneTimeFullUpdate = 1;	gInForeground = 1;	I_FinishUpdate();	HideCursor();		for (j = 16; j >= 0; j--)	{		for (i = 0; i < 256; i++)		{			vIndex = (**clut).ctTable[i].value;			(**clutCopy).ctTable[vIndex].rgb.red = (**clut).ctTable[i].rgb.red >> j;			(**clutCopy).ctTable[vIndex].rgb.green = (**clut).ctTable[i].rgb.green >> j;			(**clutCopy).ctTable[vIndex].rgb.blue = (**clut).ctTable[i].rgb.blue >> j;		}		SetEntries(0, 255, (**clutCopy).ctTable);		Delay(kMyDelayTicks, NULL);	}		for (j = 0; j < 90; j++)	{		Delay(1, NULL);		if (CheckForEscBail())		{			bailed = TRUE;			goto DidBail3;		}	}		for (j = 0; j <= 16; j++)	{		for (i = 0; i < 256; i++)		{			vIndex = (**clut).ctTable[i].value;			(**clutCopy).ctTable[vIndex].rgb.red = (**clut).ctTable[i].rgb.red >> j;			(**clutCopy).ctTable[vIndex].rgb.green = (**clut).ctTable[i].rgb.green >> j;			(**clutCopy).ctTable[vIndex].rgb.blue = (**clut).ctTable[i].rgb.blue >> j;		}		SetEntries(0, 255, (**clutCopy).ctTable);		Delay(kMyDelayTicks, NULL);	}DidBail3 :	PaintRect(&gDoomWindow->portRect);	ReleaseResource((Handle)clut);	// #133 - id Logo	// Do the "present" thing	if (!bailed)	{		clut = GetCTable(128);				for (i = 0; i < 256; i++)			SetEntryColor(pal, (**clutCopy).ctTable[i].value, &(**clutCopy).ctTable[i].rgb);		ActivatePalette(gDoomWindow);				for (i = 0; i < 256; i++)		{			vIndex = (**clut).ctTable[i].value;			(**clutCopy).ctTable[vIndex].rgb.red = (**clut).ctTable[i].rgb.red;			(**clutCopy).ctTable[vIndex].rgb.green = (**clut).ctTable[i].rgb.green;			(**clutCopy).ctTable[vIndex].rgb.blue = (**clut).ctTable[i].rgb.blue;		}		SetEntries(0, 255, (**clutCopy).ctTable);				(**clut).ctSeed = (**(**(**gMainDevice).gdPMap).pmTable).ctSeed;				pic = GetPicture(134);				r = (**pic).picFrame;		OffsetRect(&r, -r.left, -r.top);		r2 = r;		CenterRect(&r2, &gDoomWindow->portRect);				SetPort((GrafPtr)gOffPort);		SetGDevice(gOffDevice);		(**(*gOffPort).portPixMap).pmTable = clut;		(**(**gOffDevice).gdPMap).pmTable = clut;		DrawPicOffscreen(pic, (GrafPtr)gOffPort, &r);		ReleaseResource((Handle)pic);				SetPort(gDoomWindow);		SetGDevice(gMainDevice);				// P		I_PlaySoundResource(0, 128);		SetRect(&sr, 0, 0, 16, 14);		r = sr;		OffsetRect(&r, r2.left, r2.top);		CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);		Delay(14, NULL);				// R		I_PlaySoundResource(1, 128);		SetRect(&sr, 16, 0, 32, 14);		r = sr;		OffsetRect(&r, r2.left, r2.top);		CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);		Delay(24, NULL);				// E		I_PlaySoundResource(2, 128);		SetRect(&sr, 32, 0, 48, 14);		r = sr;		OffsetRect(&r, r2.left, r2.top);		CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);		Delay(18, NULL);		// S		I_PlaySoundResource(3, 128);		SetRect(&sr, 48, 0, 62, 14);		r = sr;		OffsetRect(&r, r2.left, r2.top);		CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);		Delay(12, NULL);				// E		I_PlaySoundResource(0, 128);		SetRect(&sr, 62, 0, 78, 14);		r = sr;		OffsetRect(&r, r2.left, r2.top);		CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);		Delay(16, NULL);				// N		I_PlaySoundResource(1, 128);		SetRect(&sr, 78, 0, 94, 14);		r = sr;		OffsetRect(&r, r2.left, r2.top);		CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);		Delay(10, NULL);				// T		I_PlaySoundResource(2, 128);		SetRect(&sr, 94, 0, 110, 14);		r = sr;		OffsetRect(&r, r2.left, r2.top);		CopyBits(&((GrafPtr)gOffPort)->portBits, &gDoomWindow->portBits, &sr, &r, srcCopy, NULL);		Delay(40, NULL);		while (I_SoundIsPlaying((int)gMacSndChannels[0]))			;		I_StopSound((int)gMacSndChannels[0]);		while (I_SoundIsPlaying((int)gMacSndChannels[1]))			;		I_StopSound((int)gMacSndChannels[1]);		while (I_SoundIsPlaying((int)gMacSndChannels[2]))			;		I_StopSound((int)gMacSndChannels[2]);		while (I_SoundIsPlaying((int)gMacSndChannels[3]))			;		I_StopSound((int)gMacSndChannels[3]);				ReleaseResource((Handle)clut);		(**(*gOffPort).portPixMap).pmTable = temp;		DisposeHandle((Handle)clutCopy);				SetPort(oldPort);		ShowCursor();				Delay(45, NULL);		return;	}// Restore the paletteDidBail2 :	(**(*gOffPort).portPixMap).pmTable = temp;	DisposeHandle((Handle)clutCopy);	clut = GetCTable(128);	pal = GetPalette( gDoomWindow );	for (i = 0; i < 256; i++)		SetEntryColor(pal, (**clut).ctTable[i].value, &(**clut).ctTable[i].rgb);	ActivatePalette(gDoomWindow);	SetEntries(0, 255, (**clut).ctTable);	ReleaseResource((Handle)clut);		SetPort(gDoomWindow);	PaintRect(&gDoomWindow->portRect);		SetPort(oldPort);}/******************************************************** *	main.																								* *																											* *	The main program.																		* ********************************************************/void main (void){	long	result;	Boolean saveLargeGraphics;		memset(&drawsegs[0], 0, sizeof(drawseg_t) * MAXDRAWSEGS);	memset(&scalelight[0][0], 0, LIGHTLEVELS * MAXLIGHTSCALE * 4);	memset(&scalelightfixed[0], 0, MAXLIGHTSCALE * 4);	memset(&zlight[0][0], 0, LIGHTLEVELS * MAXLIGHTZ * 4);		InitManagers();		// LoadFixedMath();		HideCursor();	Z_Init ();	M_LoadDefaults ();              		// load before initing other systems		MakeDoomWindow();	MakeDoomOffport();		HideMenuBar();						// Hide the menu bar.	PaintRect(&gDoomWindow->portRect);	// Clear white bar at top.			// Load QuickTime if it is installed AND the user doesn't have music	// turned off in preferences. Having it off adds 1 frame/sec.		if (gQuickTimeInstalled && !gMusicOff)	{		EnterMovies();		gQuickTimeLoaded = TRUE;	}	else	{		gQuickTimeLoaded = FALSE;		if (gMusicOff)			SetItemMark(GetMenu(mOptionsMenu), 11, noMark); // Music On/Off	}	S_Init (sfxVolume * 8, musicVolume * 8);	I_StartupSound ();		// Splash Screen must be in large graphics mode, set back to default if needed	if(!gLargeGraphics)	{		SetRect(&gDrawRect, 0, 0, 640, 400);		CenterRect(&gDrawRect, &gDoomWindow->portRect);		if (gDrawRect.left & 0x03)			OffsetRect(&gDrawRect, -(4 - (gDrawRect.left & 0x03)), 0);	}	saveLargeGraphics = gLargeGraphics;	gLargeGraphics = TRUE;	LionSplash();	gLargeGraphics = saveLargeGraphics;	if(!gLargeGraphics)	{			SetRect(&gDrawRect, 0, 0, 320, 200);		CenterRect(&gDrawRect, &gDoomWindow->portRect);		if (gDrawRect.left & 0x03)			OffsetRect(&gDrawRect, -(4 - (gDrawRect.left & 0x03)), 0);	}		// Do initial splash & options dialog. Kill Finder if desired.				SetPort(gDoomWindow);		PaintRect(&gDoomWindow->portRect);		ValidRect(&gDoomWindow->portRect);				// Disable options menu		DisableItem(GetMHandle(mOptionsMenu), 0);		// Control Menu Set Controls		EnableItem(GetMHandle(mControlMenu), 0);		DisableItem(GetMHandle(mControlMenu), iControlHelp);		DisableItem(GetMHandle(mControlMenu), iControlSound);		DisableItem(GetMHandle(mControlMenu), iControlGraphic);		DisableItem(GetMHandle(mControlMenu), iControlMessages);		DisableItem(GetMHandle(mControlMenu), iControlGamma);		DisableItem(GetMHandle(mControlMenu), iControlView);		DisableItem(GetMHandle(mControlMenu), iControlPause);			// File menu		EnableItem(GetMHandle(mFileMenu), 0);				//DisableItem(GetMHandle(mFileMenu), iFileOpen);		DisableItem(GetMHandle(mFileMenu), iFileClose);		DisableItem(GetMHandle(mFileMenu), iFileSave);		DisableItem(GetMHandle(mFileMenu), iFileSaveAs);			// Make changes for registered and shareware		if (shareware || registered)		{			// Don't allow to load WAD files			DisableItem(GetMHandle(mFileMenu), iFileLoadWAD);						// Rename about item			SetItem(GetMHandle(mAppleMenu), 1, "\pAbout Doom...");		}			if (( Gestalt( gestaltHelpMgrAttr, &result )) == noErr ) // Is the Help manager here?	{		if ( result & ( 1 << gestaltHelpMgrPresent ) )			gHasHelpManager = TRUE;	}	do	{		InitialDialog();		if (turboparm)			SetItemMark(GetMHandle(mOptionsMenu), 8, checkMark); // Turbo			if (!gLargeGraphics)		{			SetItemMark(GetMHandle(mOptionsMenu), 6, checkMark);	// Set small graphics			SetItemMark(GetMHandle(mOptionsMenu), 5, 0); 					// Clear large graphics		}				if (gPlayAlone)		{			if (gKillFinder)				KillEverybody();			I_InitNetwork ();			break;		}			if (gPlayNetGame)		{			if (gKillFinder)				KillEverybody();						break;		}	}	while (TRUE);		// Reset menus	EnableItem(GetMHandle(mFileMenu), 0);	EnableItem(GetMHandle(mOptionsMenu), 0);	EnableItem(GetMHandle(mControlMenu), 0);	EnableItem(GetMHandle(mControlMenu), iControlHelp);	EnableItem(GetMHandle(mControlMenu), iControlSound);	EnableItem(GetMHandle(mControlMenu), iControlGraphic);	EnableItem(GetMHandle(mControlMenu), iControlMessages);	EnableItem(GetMHandle(mControlMenu), iControlGamma);	EnableItem(GetMHandle(mControlMenu), iControlView);	EnableItem(GetMHandle(mControlMenu), iControlPause);	EnableItem(GetMHandle(mFileMenu), iFileQuickLoad);	EnableItem(GetMHandle(mFileMenu), iFileStart);	DisableItem(GetMHandle(mFileMenu), iFileLoadWAD);	DisableItem(GetMHandle(mFileMenu), iFileStartGame);	DisableItem(GetMHandle(mFileMenu), iFileMulti);	DisableItem(GetMHandle(mFileMenu), iFileSetup);	if (gPlayAlone || deathmatch)		DisableItem(GetMHandle(mControlMenu), iControlView);	// Next Viewpoint			#if __profile__	if (!ProfilerInit(collectSummary, microsecondsTimeBase, 500, 32))	{		ProfilerSetStatus(0);#endif		ParamText("\p", "\p", "\p", "\p");		// Clear these handles. Probably a waste of time.				// SetRect for small screen				SetPort(gDoomWindow);		HideMenuBar();						// Hide the menu bar.		PaintRect(&gDoomWindow->portRect);	// Clear white bar at top.		ValidRect(&gDoomWindow->portRect);				D_DoomMain();	#if __profile__		ProfilerDump("\pExample.prof");		ProfilerTerm();	}#endif}