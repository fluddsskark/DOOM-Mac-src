#ifndef __MPW_VERSION__	#if defined(powerc) || defined (__powerc)		/* Pre-compiled Mac header */		#include <DGMacHeadersPPC>	#else		#include <DGMacHeaders68K>	#endif#endif#include "LionDoom.h"#include <Lion.h>#include "Doomdef.h"#include <CTBUtilities.h>#include <CommResources.h>#include <Connections.h>#include "CTBBuffer.h"#include "NetBuffer.h"#include "MacPCSwitches.h"#include "DebugSwitches.h"#if __DEBUG_FILE__	#include <stdio.h>#endifextern ConnHandle	gConn;#define kHeaderSize (sizeof(tDoomDataHeader))#define kReadTimeout		-1 //(60 * 30)#define kWriteTimeout	kReadTimeoutConnectionCompletionUPP gReadCTBCompletionProc;ConnectionCompletionUPP gWriteCTBEOMCompletionProc;static tMessageBufArr	*gMsgBufPtr;					// Global pointer to message bufferstatic long 						gSizeToWrite;/*___________________________________________________________________________________	WriteEOMCompletion		This routine only gets called if the command message is full and there is no room 	to tag it on to the end.		___________________________________________________________________________________*/pascal void WriteEOMCompletion(ConnHandle hConn){	tMessageBuf			*theMessPtr;	OSErr						status;	tMessageBufArr	*theMsgBufPtr;	char						data[2] = {FRAMECHAR1, FRAMECHAR2};	#if !defined(powerc) && !defined (__powerc)	unsigned long		prevA5;	unsigned long		valA5;#endif#if !defined(powerc) && !defined (__powerc)	valA5 = CMGetRefCon(hConn);	prevA5 = SetA5(valA5);#endif			gSizeToWrite = 2;		status = CMWrite(gConn, data, &gSizeToWrite, cmData, true, NULL, -1, gMsgBufPtr->cmWFlags);	if (status != cmNoErr)	{		I_Error("Error in calling CMWrite %hd", status);	}	#if !defined(powerc) && !defined (__powerc)		valA5 = SetA5(prevA5);	#endif}/*___________________________________________________________________________________	ReadCompletionRoutine		On entry , theMessPtr->bufStat should always be kHeadWaiting.  There should have been	an asynchronous call to read the header with this Proc as the completion routine.		On exit, the state should always be kDataWaiting and this routine should have made an	asynch call with no completion routine to read the data.	___________________________________________________________________________________*/pascal void ReadCompletion(ConnHandle hConn){	tMessageBuf		*theMessPtr;	OSErr					status;	tMessageBufArr	*theMsgBufPtr;	CMStatFlags		statusFlags;	CMBufferSizes	sizes;#if !defined(powerc) && !defined (__powerc)		unsigned long		prevA5;		unsigned long		valA5;#endif#if !defined(powerc) && !defined (__powerc)		valA5 = CMGetRefCon(hConn);		prevA5 = SetA5(valA5);#endif		status = CMStatus(hConn, sizes, &statusFlags);		theMsgBufPtr = (tMessageBufArr *) CMGetUserData(hConn); 	//¥¥JDM WARNING get rid of this cookie crap	if (theMsgBufPtr->cookie != 123456)	{			I_Error("Asynchronous routine received bad data");	}		theMessPtr = &(theMsgBufPtr->bufs[theMsgBufPtr->bufPend]);//DebugStr("\pPointers Set");		// Find out what was read and check if all data read	if (theMessPtr->bufStat == kHeadWaiting)	{			if ((**hConn).asyncCount[cmDataIn] == theMsgBufPtr->readSize)		{						theMessPtr->bufStat				= kDataWaiting;			theMsgBufPtr->sizeToRead 	= theMessPtr->headMsg.numtics * sizeof(ticcmd_t);	#if __MESSAGE_EOM__			// Reading data+EOM and able to fit into buffer			if (theMsgBufPtr->sizeToRead <= sizeof(doomdata_t) + 2)	// Read the message along with eom bytes			{				theMsgBufPtr->sizeToRead += 2;					theMsgBufPtr->readSize		= theMsgBufPtr->sizeToRead;					// Read data+EOM				status = CMRead(gConn, (Ptr) &(theMessPtr->dataMsg), &theMsgBufPtr->sizeToRead, cmData, true, NULL, kReadTimeout, &theMsgBufPtr->cmRFlags);				#if __ASYNCH_DEBUG__				fprintf(debugfile,"Read eom data\n");#endif	//__ASYNCH_DEBUG__			}			// Reading EOM and not able to fit into buffer			else			{				char	eomBuffer[2];								theMsgBufPtr->readSize		= theMsgBufPtr->sizeToRead;						// Read data				if (theMsgBufPtr->sizeToRead > 0)				{					status = CMRead(gConn, (Ptr) &(theMessPtr->dataMsg), &theMsgBufPtr->sizeToRead, cmData, false, NULL, kReadTimeout, &theMsgBufPtr->cmRFlags);				}				#if __ASYNCH_DEBUG__				fprintf(debugfile,"Read data\n");#endif //__ASYNCH_DEBUG__						theMsgBufPtr->sizeToRead	= 2;				theMsgBufPtr->readSize		= 2;				// Read EOM				status = CMRead(gConn, (Ptr) eomBuffer, &theMsgBufPtr->sizeToRead, cmData, true, NULL, kReadTimeout, &theMsgBufPtr->cmRFlags);#if __ASYNCH_DEBUG__				fprintf(debugfile,"Read seperate eom data\n");#endif //__ASYNCH_DEBUG__				}			#else //__MESSAGE_EOM__			// Not reading EOM, read data			theMsgBufPtr->readSize 		= theMsgBufPtr->sizeToRead;			if (theMsgBufPtr->readSize > 0)			{				status = CMRead(hConn, (Ptr) &(theMessPtr->dataMsg), &theMsgBufPtr->sizeToRead, cmData, true, NULL, kReadTimeout, &theMsgBufPtr->cmRFlags);			}			#endif //__MESSAGE_EOM__		}		else			// Header was not completely read		{				I_Error("Asynchronous read of header did not complete, error %d",(**hConn).errCode);	/*		theMsgBufPtr->sizeToRead = theMsgBufPtr->readSize - (**hConn).asyncCount[cmDataIn];				status = CMRead(hConn, (Ptr) (&(theMessPtr->headMsg) + (**hConn).asyncCount[cmDataIn]), &theMsgBufPtr->sizeToRead, cmData, true, NULL, -1, &theMsgBufPtr->cmRFlags);	*/}		}	else			// Somehow we got into here in the wrong state	{			I_Error("This should never happen");	}#if !defined(powerc) && !defined (__powerc)	SetA5(prevA5);#endif}/*___________________________________________________________________________________	___________________________________________________________________________________*//*___________________________________________________________________________________	InitCTBBuffer		Initializes the message buffer.	___________________________________________________________________________________*/void	InitCTBBuffer(void){	short	numBufs;	#if !defined(powerc) && !defined (__powerc)			unsigned long	valA5;	#endif		// Allocate buffer	gMsgBufPtr = (tMessageBufArr *) NewPtrClear(sizeof(tMessageBufArr));	if (gMsgBufPtr == NULL)	{		I_Error("Error in allocating message buffer");	}		//Set default values	gMsgBufPtr->bufPend 		= 0;											// Fill first buffer	gMsgBufPtr->nextMsg			= 0;											// The next message to pass on	gMsgBufPtr->readSize		= 0;											// Size of the current read	gMsgBufPtr->cmRFlags		= 0;	for (numBufs = 0; numBufs < kNumMessageBufs; numBufs++)	{		gMsgBufPtr->bufs[numBufs].bufStat = kHeadFree;		// All free	}		gReadCTBCompletionProc = NewConnectionCompletionProc((ProcPtr) ReadCompletion);	if (gReadCTBCompletionProc == NULL)	{		I_Error("Error in allocating Read completion routine");	}	gWriteCTBEOMCompletionProc = NewConnectionCompletionProc((ProcPtr) WriteEOMCompletion);	if (gWriteCTBEOMCompletionProc == NULL)	{		I_Error("Error in allocating Write eom completion routine");	}			#if !defined(powerc) && !defined (__powerc)		valA5 = SetCurrentA5();			CMSetRefCon(gConn, valA5);	#endif	CMSetUserData(gConn, (unsigned long)gMsgBufPtr);		gMsgBufPtr->cookie = kCookie;#if __ASYNCH_DEBUG__	fprintf(debugfile,"CTBBuffer initialised\n");#endif}/*___________________________________________________________________________________	TerminateCTBBuffer		Terminates the message buffer.	___________________________________________________________________________________*/void	TerminateCTBBuffer(void){	// Deallocate buffer	DisposePtr((Ptr)gMsgBufPtr);	//¥¥ JDM WARNING dispose of completion routine UPPs?}/*___________________________________________________________________________________	ServiceWrite		___________________________________________________________________________________*/OSErr ServiceWrite(UInt16 sendTo, Ptr data, Size length){	CMFlags				cmFlags = 0;	CMBufferSizes	sizes;	CMStatFlags		statusFlags;	OSErr					status;		status = CMStatus(gConn, sizes, &statusFlags);	while (statusFlags & cmStatusDWPend)	{#if __SYSBEEPS__		SysBeep(5);#endif		status = CMStatus(gConn, sizes, &statusFlags);	}			// Add eom to message#if __MESSAGE_EOM__	if (length <= sizeof(doomdata_t) + 2)	// Add eom to command if there is room	{		*(data + length) 			= FRAMECHAR1;		*(data + length + 1)	= FRAMECHAR2;		length += 2;				gSizeToWrite = length;#if __ASYNCH_DEBUG__fprintf(debugfile,"Writing length<");#endif		#if __COMPLETE_ASYNCH__		status = CMWrite(gConn, data, &gSizeToWrite, cmData, true, NULL, kWriteTimeout, gMsgBufPtr->cmWFlags);#else		status = CMWrite(gConn, data, &gSizeToWrite, cmData, false, NULL, kWriteTimeout, gMsgBufPtr->cmWFlags);		if (status != cmNoErr)		{			I_Error("Error in calling CMWrite %hd", status);			goto ErrorDone;		}#endif //__COMPLETE_ASYNCH__	}	else				// Otherwise, send it as a seperate message	{		char					data2[2] = {FRAMECHAR1, FRAMECHAR2};#if __ASYNCH_DEBUG__		fprintf(debugfile,"Writing length>");#endif		gSizeToWrite = length;		status = CMWrite(gConn, data, &gSizeToWrite, cmData, false, NULL, kWriteTimeout, gMsgBufPtr->cmWFlags);		if (status != cmNoErr)		{			I_Error("Error in calling CMWrite %hd", status);			goto ErrorDone;		}				gSizeToWrite = 2;#if __ASYNCH_DEBUG__		fprintf(debugfile,"Writing length > ,eom");#endif		status = CMWrite(gConn, data2, &gSizeToWrite, cmData, __COMPLETE_ASYNCH__, NULL, kWriteTimeout, gMsgBufPtr->cmWFlags);		if (status != cmNoErr)		{			I_Error("Error in calling CMWrite %hd", status);			goto ErrorDone;		}	}			#else // not __MESSAGE_EOM__	gSizeToWrite = length;	status = CMWrite(gConn, data, &gSizeToWrite, cmData, __COMPLETE_ASYNCH__, NULL, kWriteTimeout, gMsgBufPtr->cmWFlags);	if (status != cmNoErr)	{		I_Error("Error in calling CMWrite %hd", status);		goto ErrorDone;	}#endif // __MESSAGE_EOM__ErrorDone:	return(status);}/*___________________________________________________________________________________	ServiceRead		-BEHAVIOR-	If there is a full message in a buffer, passes on that data,	initiaites the next read and returns true.		If there is not a full message, initiates the next read and returns	false.		-INITIATING A READ-	If a read is pending, do nothing.	If we don't have a free buffer, do nothing.	If we do have a free buffer,		If there is a header which does not have its accompanying data, read the data		 and mark that buffer as read requested.		Otherwise, read the next header and mark that buffer as read requested			-PASSING ON THE DATA-	Copy data to location specified by caller and invalidate the data in buffer.		---COMPLETION ROUTINE---	Marks the current buffer as read.		---BUFFERS---	BufPend is the index of the buffer which is currently being read into	NextBuf is the index of the next buffer to be sent back to caller 			___________________________________________________________________________________*/			//¥¥ JDM Warning - would better to have a specified timeout and a 			//								completion routine that checks if all read and gives error if not			Boolean ServiceRead(Ptr data, Size	*length){	Boolean				doRead;	Boolean				gotData;	long					msgSize;	long 					size;	Ptr						src, dst;	tMessageBuf		*theMessPtr;	CMStatFlags		statusFlags;	CMBufferSizes	sizes;	OSErr					status;	#if __ASYNCH_DEBUG__		fprintf(debugfile,"Pending buffer index = %i\n",gMsgBufPtr->bufPend);	#endif	theMessPtr = &(gMsgBufPtr->bufs[gMsgBufPtr->bufPend]);		//________________________________________________________________		//____________ Update the state for the previous read ____________	//________________________________________________________________		// If read is not pending, advance to next state	status = CMStatus(gConn, sizes, &statusFlags);	if (statusFlags & cmStatusDRPend)	{#if __ASYNCH_DEBUG__		fprintf(debugfile,"Read is pending...\n");#endif	}	// There is no read pending	// The header has just been read	else if (theMessPtr->bufStat == kHeadWaiting)	{		if ((**gConn).asyncCount[cmDataIn] == gMsgBufPtr->readSize)		{			theMessPtr->bufStat = kDataFree;#if __ASYNCH_DEBUG__			fprintf(debugfile,"kHeadWaiting -> kDataFree\n");#endif		}		else			// Asynchronous read of header did not complete		{			I_Error("Read of header did not complete");		}	}		// The data has just been read	else if (theMessPtr->bufStat == kDataWaiting)	{		if (((**gConn).asyncCount[cmDataIn] == gMsgBufPtr->readSize) || (gMsgBufPtr->readSize == 0))		// ¥¥JDM With serial tool, if you requested 0 read, asyncCount has value from last read		{			theMessPtr->bufStat = kDataFull;			// Advance pending buffer pointer			gMsgBufPtr->bufPend = (gMsgBufPtr->bufPend +1 ) % kNumMessageBufs;#if __ASYNCH_DEBUG__			fprintf(debugfile,"kDataWaiting -> kDataFull\n");#endif		}		else			// complete data was not read		{			status = CMStatus(gConn, sizes, &statusFlags);			I_Error("Read of data did not complete %d,",(**gConn).errCode);		}	}	//________________________________________________________________________________________		//____________ At this point, we have updated the state for the previous read ____________	//________________________________________________________________________________________		#if __ASYNCH_DEBUG__		fprintf(debugfile,"Next message index = %i\n",gMsgBufPtr->nextMsg);	#endif	theMessPtr = &(gMsgBufPtr->bufs[gMsgBufPtr->nextMsg]);	// If the data is ready, pass it on to caller	if (theMessPtr->bufStat == kDataFull)	{		// Copy the data		src = (Ptr) &(theMessPtr->headMsg);		dst	= data;		size = kHeaderSize;		while(size > 0)		{			*dst++ = *src++;			size--;		}				// Get size of message		msgSize = theMessPtr->headMsg.numtics * sizeof(ticcmd_t);				src = (Ptr) &(theMessPtr->dataMsg);		size = msgSize;		while(size > 0)		{			*dst++ = *src++;			size--;		}		#if __ASYNCH_DEBUG__		fprintf(debugfile,"Data ready and copied to caller\n");#endif		// Assign length		*length = msgSize + kHeaderSize;				// Reset flags		theMessPtr->bufStat = kHeadFree;		#if __ASYNCH_DEBUG__		fprintf(debugfile,"kDataFull -> kHeadFree\n");#endif		gotData = true;				gMsgBufPtr->nextMsg = (gMsgBufPtr->nextMsg + 1) % kNumMessageBufs;			}	else	{		*length = 0;		gotData = false;	}		theMessPtr = &(gMsgBufPtr->bufs[gMsgBufPtr->bufPend]);		//________________________________________________________________		//____________ If possible, initiate next  read ____________	//________________________________________________________________		// Dont read if there is a read pending	status = CMStatus(gConn, sizes, &statusFlags);	if (statusFlags & cmStatusDRPend)	{#if __ASYNCH_DEBUG__		fprintf(debugfile,"Read is pending...\n");#endif	}		// Read header	else if (theMessPtr->bufStat == kHeadFree)	{		theMessPtr->bufStat			= kHeadWaiting;		gMsgBufPtr->sizeToRead	= kHeaderSize;		gMsgBufPtr->readSize		= gMsgBufPtr->sizeToRead;#if __COMPLETE_ASYNCH__#if __READ_HDR_COMPLETION__		status = CMRead(gConn, (Ptr) &(theMessPtr->headMsg), &gMsgBufPtr->sizeToRead, cmData, true, gReadCTBCompletionProc, -1, &gMsgBufPtr->cmRFlags);#else		status = CMRead(gConn, (Ptr) &(theMessPtr->headMsg), &gMsgBufPtr->sizeToRead, cmData, true, NULL, kReadTimeout, &gMsgBufPtr->cmRFlags);#endif	// __READ_HDR_COMPLETION__#else	// not __COMPLETE_ASYNCH__				// Only read header if there is data available		status = CMStatus(gConn, sizes, &statusFlags);		if (sizes[cmDataIn] >= kHeaderSize)		{			status = CMRead(gConn, (Ptr) &(theMessPtr->headMsg), &gMsgBufPtr->sizeToRead, cmData, false, NULL, 0, &gMsgBufPtr->cmRFlags);			if (status == noErr)			{	// if called asynchronously, change to kHeadWaiting				theMessPtr->bufStat			= kDataFree;			}			else			{				theMessPtr->bufStat = kHeadFree;			}		}		else		{				theMessPtr->bufStat = kHeadFree;				}		#endif //__COMPLETE_ASYNCH__#if __ASYNCH_DEBUG__		fprintf(debugfile,"Read header\n");#endif	}		// Read data (header has already been read)	else if (theMessPtr->bufStat == kDataFree)	{				theMessPtr->bufStat			= kDataWaiting;				if ((gMsgBufPtr->sizeToRead	= theMessPtr->headMsg.numtics * sizeof(ticcmd_t)) <= sizeof (tDoomDataData))		{		}		else		{			I_Error("Attempting to read too much data");		}#if __MESSAGE_EOM__		if (gMsgBufPtr->sizeToRead <= sizeof(doomdata_t) + 2)	// Read the eom bytes		{			gMsgBufPtr->sizeToRead += 2;					gMsgBufPtr->readSize		= gMsgBufPtr->sizeToRead;		// Read data#if __COMPLETE_ASYNCH__			status = CMRead(gConn, (Ptr) &(theMessPtr->dataMsg), &gMsgBufPtr->sizeToRead, cmData, true, NULL, -1, &gMsgBufPtr->cmRFlags);#else			status = CMRead(gConn, (Ptr) &(theMessPtr->dataMsg), &gMsgBufPtr->sizeToRead, cmData, false, NULL, kReadTimeout, &gMsgBufPtr->cmRFlags);			if (gMsgBufPtr->sizeToRead != gMsgBufPtr->readSize)			{				I_Error("Read of data did not complete");			}#endif //__COMPLETE_ASYNCH__#if __ASYNCH_DEBUG__			fprintf(debugfile,"Read data\n");#endif		}		else	// Read data and EOM seperately		{			char	eomBuffer[2];						gMsgBufPtr->readSize		= gMsgBufPtr->sizeToRead;			// Read data			status = CMRead(gConn, (Ptr) &(theMessPtr->dataMsg), &gMsgBufPtr->sizeToRead, cmData, false, NULL, kReadTimeout, &gMsgBufPtr->cmRFlags);			if (gMsgBufPtr->sizeToRead != gMsgBufPtr->readSize)			{				I_Error("Read of data (eom to follow) did not complete");			}#if __ASYNCH_DEBUG__			fprintf(debugfile,"Read data\n");#endif			gMsgBufPtr->sizeToRead	= 2;			gMsgBufPtr->readSize		= 2;			// Read eom#if __COMPLETE_ASYNCH__			status = CMRead(gConn, (Ptr) eomBuffer, &gMsgBufPtr->sizeToRead, cmData, true, NULL, -1, &gMsgBufPtr->cmRFlags);#else			status = CMRead(gConn, (Ptr) eomBuffer, &gMsgBufPtr->sizeToRead, cmData, false, NULL, kReadTimeout, &gMsgBufPtr->cmRFlags);			if (gMsgBufPtr->sizeToRead != gMsgBufPtr->readSize)			{				I_Error("Read of eom did not complete");			}#endif	// __COMPLETE_ASYNCH__	#if __ASYNCH_DEBUG__			fprintf(debugfile,"Read seperate eom data\n");#endif	}	#else // not __MESSAGE_EOM__		gMsgBufPtr->readSize		= gMsgBufPtr->sizeToRead;#if __COMPLETE_ASYNCH__		status = CMRead(gConn, (Ptr) &(theMessPtr->dataMsg), &gMsgBufPtr->sizeToRead, cmData, true, NULL, kReadTimeout, &gMsgBufPtr->cmRFlags);#else		status = CMRead(gConn, (Ptr) &(theMessPtr->dataMsg), &gMsgBufPtr->sizeToRead, cmData, false, NULL, kReadTimeout, &gMsgBufPtr->cmRFlags);			if (gMsgBufPtr->sizeToRead != gMsgBufPtr->readSize)			{				I_Error("Read of data (no eom) did not complete");			}#endif	// __COMPLETE_ASYNCH__#endif //__MESSAGE_EOM__#if __ASYNCH_DEBUG__		fprintf(debugfile,"Read data\n");#endif	}		return (gotData);}